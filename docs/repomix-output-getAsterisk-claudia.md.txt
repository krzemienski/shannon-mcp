This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where line numbers have been added, content has been formatted for parsing in markdown style, security check has been disabled.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Content has been formatted for parsing in markdown style
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.cargo/
  config.toml
.github/
  workflows/
    build-linux.yml
    build-macos.yml
    build-test.yml
    claude-code-review.yml
    claude.yml
    release.yml
cc_agents/
  git-commit-bot.claudia.json
  README.md
  security-scanner.claudia.json
  unit-tests-bot.claudia.json
public/
  tauri.svg
  vite.svg
scripts/
  bump-version.sh
src/
  assets/
    react.svg
    shimmer.css
  components/
    claude-code-session/
      MessageList.tsx
      PromptQueue.tsx
      SessionHeader.tsx
      useCheckpoints.ts
      useClaudeMessages.ts
    ui/
      badge.tsx
      button.tsx
      card.tsx
      dialog.tsx
      dropdown-menu.tsx
      input.tsx
      label.tsx
      pagination.tsx
      popover.tsx
      radio-group.tsx
      scroll-area.tsx
      select.tsx
      split-pane.tsx
      switch.tsx
      tabs.tsx
      textarea.tsx
      toast.tsx
      tooltip.tsx
    widgets/
      BashWidget.tsx
      index.ts
      LSWidget.tsx
      TodoWidget.tsx
    AgentExecution.tsx
    AgentExecutionDemo.tsx
    AgentRunOutputViewer.tsx
    AgentRunsList.tsx
    AgentRunView.tsx
    AgentsModal.tsx
    AnalyticsConsent.tsx
    AnalyticsErrorBoundary.tsx
    App.cleaned.tsx
    CCAgents.tsx
    CheckpointSettings.tsx
    ClaudeBinaryDialog.tsx
    ClaudeCodeSession.refactored.tsx
    ClaudeCodeSession.tsx
    ClaudeFileEditor.tsx
    ClaudeMemoriesDropdown.tsx
    ClaudeVersionSelector.tsx
    CreateAgent.tsx
    ErrorBoundary.tsx
    ExecutionControlBar.tsx
    FilePicker.optimized.tsx
    FilePicker.tsx
    FloatingPromptInput.tsx
    GitHubAgentBrowser.tsx
    HooksEditor.tsx
    IconPicker.tsx
    ImagePreview.tsx
    index.ts
    MarkdownEditor.tsx
    MCPAddServer.tsx
    MCPImportExport.tsx
    MCPManager.tsx
    MCPServerList.tsx
    NFOCredits.tsx
    PreviewPromptDialog.tsx
    ProjectList.tsx
    ProjectSettings.tsx
    ProxySettings.tsx
    RunningClaudeSessions.tsx
    SessionList.optimized.tsx
    SessionList.tsx
    SessionOutputViewer.tsx
    Settings.tsx
    SlashCommandPicker.tsx
    SlashCommandsManager.tsx
    StorageTab.tsx
    StreamMessage.tsx
    TabContent.tsx
    TabManager.tsx
    TimelineNavigator.tsx
    TokenCounter.tsx
    ToolWidgets.new.tsx
    ToolWidgets.tsx
    Topbar.tsx
    UsageDashboard.tsx
    WebviewPreview.tsx
  contexts/
    TabContext.tsx
    ThemeContext.tsx
  hooks/
    index.ts
    useAnalytics.ts
    useApiCall.ts
    useDebounce.ts
    useLoadingState.ts
    usePagination.ts
    usePerformanceMonitor.ts
    useTabState.ts
    useTheme.ts
  lib/
    analytics/
      consent.ts
      events.ts
      index.ts
      resourceMonitor.ts
      types.ts
    api-tracker.ts
    api.ts
    claudeSyntaxTheme.ts
    date-utils.ts
    hooksManager.ts
    linkDetector.tsx
    outputCache.tsx
    utils.ts
  stores/
    agentStore.ts
    README.md
    sessionStore.ts
  types/
    hooks.ts
  App.tsx
  main.tsx
  styles.css
  vite-env.d.ts
src-tauri/
  capabilities/
    default.json
  src/
    checkpoint/
      manager.rs
      mod.rs
      state.rs
      storage.rs
    commands/
      agents.rs
      claude.rs
      mcp.rs
      mod.rs
      proxy.rs
      slash_commands.rs
      storage.rs
      usage.rs
    process/
      mod.rs
      registry.rs
    claude_binary.rs
    lib.rs
    main.rs
  tests/
    TESTS_COMPLETE.md
  .gitignore
  build.rs
  Cargo.toml
  entitlements.plist
  Info.plist
  tauri.conf.json
.gitignore
CONTRIBUTING.md
index.html
LICENSE
package.json
README.md
tsconfig.json
tsconfig.node.json
vite.config.ts
```

# Files

## File: .cargo/config.toml
````toml
1: [target.aarch64-unknown-linux-gnu]
2: linker = "aarch64-linux-gnu-gcc"
3: 
4: [env]
5: PKG_CONFIG_ALLOW_CROSS = "1"
````

## File: .github/workflows/build-linux.yml
````yaml
 1: name: Build Linux
 2: 
 3: on:
 4:   workflow_call:
 5:   workflow_dispatch:
 6:   push:
 7:     branches: [main]
 8: 
 9: jobs:
10:   build:
11:     name: Build Linux x86_64
12:     runs-on: ubuntu-latest
13:     
14:     steps:
15:       - uses: actions/checkout@v4
16:       
17:       - name: Install system dependencies
18:         run: |
19:           sudo apt-get update
20:           sudo apt-get install -y \
21:             pkg-config \
22:             libwebkit2gtk-4.1-dev \
23:             libgtk-3-dev \
24:             libssl-dev \
25:             libayatana-appindicator3-dev \
26:             librsvg2-dev
27:       
28:       - name: Setup Rust
29:         uses: dtolnay/rust-toolchain@stable
30:         with:
31:           targets: x86_64-unknown-linux-gnu
32:       
33:       - name: Setup Rust cache
34:         uses: Swatinem/rust-cache@v2
35:         with:
36:           workspaces: src-tauri
37:       
38:       - name: Setup Bun
39:         uses: oven-sh/setup-bun@v2
40:       
41:       - name: Install dependencies
42:         run: bun install
43:       
44:       - name: Build Tauri app
45:         run: bun run tauri build --target x86_64-unknown-linux-gnu
46:       
47:       - name: Create artifacts directory
48:         run: |
49:           mkdir -p dist/linux-x86_64
50:           cp src-tauri/target/x86_64-unknown-linux-gnu/release/bundle/deb/*.deb dist/linux-x86_64/ || true
51:           cp src-tauri/target/x86_64-unknown-linux-gnu/release/bundle/appimage/*.AppImage dist/linux-x86_64/ || true
52:           
53:           # Generate checksums
54:           cd dist/linux-x86_64
55:           sha256sum * > checksums.txt
56:       
57:       - name: Upload artifacts
58:         uses: actions/upload-artifact@v4
59:         with:
60:           name: linux-x86_64
61:           path: dist/linux-x86_64/*
````

## File: .github/workflows/build-macos.yml
````yaml
  1: name: Build macOS
  2: 
  3: on:
  4:   workflow_call:
  5:     secrets:
  6:       APPLE_CERTIFICATE:
  7:         required: true
  8:       APPLE_CERTIFICATE_PASSWORD:
  9:         required: true
 10:       KEYCHAIN_PASSWORD:
 11:         required: true
 12:       APPLE_SIGNING_IDENTITY:
 13:         required: true
 14:       APPLE_ID:
 15:         required: true
 16:       APPLE_TEAM_ID:
 17:         required: true
 18:       APPLE_PASSWORD:
 19:         required: true
 20:   workflow_dispatch:
 21:     inputs:
 22:       skip_build:
 23:         description: 'Skip build and use artifacts from a previous run'
 24:         required: false
 25:         default: false
 26:         type: boolean
 27:       run_id:
 28:         description: 'Run ID to download artifacts from (leave empty for latest)'
 29:         required: false
 30:         type: string
 31:   push:
 32:     branches: [main]
 33: 
 34: jobs:
 35:   build:
 36:     name: Build macOS ${{ matrix.target }}
 37:     if: ${{ !inputs.skip_build }}
 38:     runs-on: ${{ matrix.os }}
 39:     strategy:
 40:       matrix:
 41:         include:
 42:           - os: macos-13  # Intel
 43:             target: x86_64-apple-darwin
 44:             arch: x86_64
 45:           - os: macos-14  # Apple Silicon
 46:             target: aarch64-apple-darwin
 47:             arch: aarch64
 48:     
 49:     steps:
 50:       - uses: actions/checkout@v4
 51:       
 52:       - name: Setup Rust
 53:         uses: dtolnay/rust-toolchain@stable
 54:       
 55:       - name: Setup Rust cache
 56:         uses: Swatinem/rust-cache@v2
 57:         with:
 58:           workspaces: src-tauri
 59:       
 60:       - name: Setup Bun
 61:         uses: oven-sh/setup-bun@v2
 62:       
 63:       - name: Install dependencies
 64:         run: bun install
 65:       
 66:       - name: Import Apple certificates
 67:         env:
 68:           APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
 69:           APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
 70:           KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
 71:         run: |
 72:           # Create variables
 73:           CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
 74:           KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
 75:           
 76:           # Import certificate from secrets
 77:           echo -n "$APPLE_CERTIFICATE" | base64 --decode -o $CERTIFICATE_PATH
 78:           
 79:           # Create temporary keychain
 80:           security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
 81:           security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
 82:           security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
 83:           
 84:           # Import certificate to keychain
 85:           security import $CERTIFICATE_PATH -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
 86:           security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
 87:           security list-keychain -d user -s $KEYCHAIN_PATH
 88:       
 89:       - name: Build native
 90:         env:
 91:           CI: true
 92:         run: bun run tauri build
 93:       
 94:       - name: Upload architecture-specific artifacts
 95:         uses: actions/upload-artifact@v4
 96:         with:
 97:           name: macos-${{ matrix.arch }}
 98:           path: |
 99:             src-tauri/target/release/bundle/macos/Claudia.app
100:             src-tauri/target/release/bundle/dmg/*.dmg
101:           retention-days: 1
102:   
103:   universal:
104:     name: Create Universal Binary
105:     needs: [build]
106:     if: ${{ !cancelled() && (needs.build.result == 'success' || needs.build.result == 'skipped') }}
107:     runs-on: macos-latest
108:     steps:
109:       - uses: actions/checkout@v4
110:       
111:       - name: Download artifacts from current workflow
112:         if: ${{ !inputs.skip_build }}
113:         uses: actions/download-artifact@v4
114:         with:
115:           pattern: macos-*
116:           path: artifacts
117:       
118:       - name: Download artifacts from specific run
119:         if: ${{ inputs.skip_build && inputs.run_id != '' }}
120:         uses: dawidd6/action-download-artifact@v3
121:         with:
122:           workflow: build-macos.yml
123:           run_id: ${{ inputs.run_id }}
124:           name: macos-*
125:           path: artifacts
126:       
127:       - name: Download artifacts from latest run
128:         if: ${{ inputs.skip_build && inputs.run_id == '' }}
129:         uses: dawidd6/action-download-artifact@v3
130:         with:
131:           workflow: build-macos.yml
132:           workflow_conclusion: success
133:           name: macos-*
134:           path: artifacts
135:       
136:       - name: List downloaded artifacts
137:         run: |
138:           echo "📁 Artifact structure:"
139:           find artifacts -type f -name "*.app" -o -name "*.dmg" | head -20
140:           echo ""
141:           echo "📁 Full directory structure:"
142:           ls -la artifacts/
143:           ls -la artifacts/macos-aarch64/ || echo "macos-aarch64 directory not found"
144:           ls -la artifacts/macos-x86_64/ || echo "macos-x86_64 directory not found"
145:       
146:       - name: Import Apple certificates
147:         env:
148:           APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
149:           APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
150:           KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
151:         run: |
152:           # Create variables
153:           CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
154:           KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
155:           
156:           # Import certificate from secrets
157:           echo -n "$APPLE_CERTIFICATE" | base64 --decode -o $CERTIFICATE_PATH
158:           
159:           # Create temporary keychain
160:           security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
161:           security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
162:           security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
163:           
164:           # Import certificate to keychain
165:           security import $CERTIFICATE_PATH -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
166:           security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
167:           security list-keychain -d user -s $KEYCHAIN_PATH
168:       
169:       - name: Create universal app
170:         run: |
171:           # Create temp directory
172:           mkdir -p dmg_temp
173:           
174:           # Extract zip files if they exist
175:           if [ -f "artifacts/macos-aarch64.zip" ]; then
176:             echo "📦 Extracting macos-aarch64.zip..."
177:             unzip -q artifacts/macos-aarch64.zip -d artifacts/macos-aarch64/
178:           fi
179:           
180:           if [ -f "artifacts/macos-x86_64.zip" ]; then
181:             echo "📦 Extracting macos-x86_64.zip..."
182:             unzip -q artifacts/macos-x86_64.zip -d artifacts/macos-x86_64/
183:           fi
184:           
185:           # Find the actual app paths
186:           AARCH64_APP=$(find artifacts/macos-aarch64 -name "Claudia.app" -type d | head -1)
187:           X86_64_APP=$(find artifacts/macos-x86_64 -name "Claudia.app" -type d | head -1)
188:           
189:           if [ -z "$AARCH64_APP" ] || [ -z "$X86_64_APP" ]; then
190:             echo "❌ Could not find app bundles"
191:             echo "AARCH64_APP: $AARCH64_APP"
192:             echo "X86_64_APP: $X86_64_APP"
193:             exit 1
194:           fi
195:           
196:           echo "✅ Found app bundles:"
197:           echo "  ARM64: $AARCH64_APP"
198:           echo "  x86_64: $X86_64_APP"
199:           
200:           # Copy ARM64 app as base
201:           cp -R "$AARCH64_APP" dmg_temp/
202:           
203:           # Create universal binary using lipo
204:           lipo -create -output dmg_temp/Claudia.app/Contents/MacOS/claudia \
205:             "$AARCH64_APP/Contents/MacOS/claudia" \
206:             "$X86_64_APP/Contents/MacOS/claudia"
207:           
208:           # Ensure executable permissions are set
209:           chmod +x dmg_temp/Claudia.app/Contents/MacOS/claudia
210:           
211:           echo "✅ Universal binary created"
212:           lipo -info dmg_temp/Claudia.app/Contents/MacOS/claudia
213:       
214:       - name: Sign app bundle
215:         env:
216:           APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
217:         run: |
218:           codesign --sign "$APPLE_SIGNING_IDENTITY" \
219:             --timestamp \
220:             --options runtime \
221:             --force \
222:             --deep \
223:             --entitlements src-tauri/entitlements.plist \
224:             dmg_temp/Claudia.app
225:       
226:       - name: Create DMG
227:         run: |
228:           hdiutil create -volname "Claudia Installer" \
229:             -srcfolder dmg_temp \
230:             -ov -format UDZO Claudia.dmg
231:       
232:       - name: Sign DMG
233:         env:
234:           APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
235:         run: |
236:           codesign --sign "$APPLE_SIGNING_IDENTITY" \
237:             --timestamp \
238:             --force Claudia.dmg
239:       
240:       - name: Notarize DMG
241:         env:
242:           APPLE_ID: ${{ secrets.APPLE_ID }}
243:           APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
244:           APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
245:         run: |
246:           # Store notarization credentials
247:           xcrun notarytool store-credentials "notarytool-profile" \
248:             --apple-id "$APPLE_ID" \
249:             --team-id "$APPLE_TEAM_ID" \
250:             --password "$APPLE_PASSWORD"
251:           
252:           # Submit for notarization
253:           xcrun notarytool submit Claudia.dmg \
254:             --keychain-profile "notarytool-profile" \
255:             --wait
256:       
257:       - name: Staple notarization
258:         run: xcrun stapler staple Claudia.dmg
259:       
260:       - name: Verify DMG
261:         run: |
262:           spctl -a -t open -vvv --context context:primary-signature Claudia.dmg
263:           echo "✅ DMG verification complete"
264:       
265:       - name: Create artifacts directory
266:         run: |
267:           mkdir -p dist/macos-universal
268:           cp Claudia.dmg dist/macos-universal/
269:           
270:           # Also save the app bundle using ditto to preserve permissions and signatures
271:           ditto -c -k --sequesterRsrc --keepParent \
272:             dmg_temp/Claudia.app dist/macos-universal/Claudia.app.zip
273:           
274:           # Generate checksum
275:           shasum -a 256 dist/macos-universal/* > dist/macos-universal/checksums.txt
276:       
277:       - name: Upload artifacts
278:         uses: actions/upload-artifact@v4
279:         with:
280:           name: macos-universal
281:           path: dist/macos-universal/*
282:       
283:       - name: Cleanup
284:         if: always()
285:         run: |
286:           echo "🧹 Cleaning up temporary directories..."
287:           rm -rf dmg_temp temp_x86 artifacts
288:           
289:           # Clean up keychain
290:           if [ -n "$RUNNER_TEMP" ] && [ -f "$RUNNER_TEMP/app-signing.keychain-db" ]; then
291:             security delete-keychain "$RUNNER_TEMP/app-signing.keychain-db" || true
292:           fi
293:           
294:           echo "✅ Cleanup complete"
````

## File: .github/workflows/build-test.yml
````yaml
  1: name: Build Test
  2: 
  3: # Trigger on every push and pull request
  4: on:
  5:   push:
  6:     branches: [ main, develop, 'release/**', 'feature/**' ]
  7:   pull_request:
  8:     branches: [ main, develop ]
  9:     types: [opened, synchronize, reopened]
 10: 
 11: # Cancel in-progress workflows when a new commit is pushed
 12: concurrency:
 13:   group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
 14:   cancel-in-progress: true
 15: 
 16: env:
 17:   CARGO_TERM_COLOR: always
 18:   RUST_BACKTRACE: 1
 19: 
 20: jobs:
 21:   build-test:
 22:     name: Build Test (${{ matrix.platform.name }})
 23:     
 24:     strategy:
 25:       fail-fast: false
 26:       matrix:
 27:         platform:
 28:           - name: Linux
 29:             os: ubuntu-latest
 30:             rust-target: x86_64-unknown-linux-gnu
 31:           - name: Windows
 32:             os: windows-latest
 33:             rust-target: x86_64-pc-windows-msvc
 34:           - name: macOS
 35:             os: macos-latest
 36:             rust-target: x86_64-apple-darwin
 37:     
 38:     runs-on: ${{ matrix.platform.os }}
 39:     
 40:     steps:
 41:       # Checkout the repository
 42:       - name: Checkout repository
 43:         uses: actions/checkout@v4
 44:         with:
 45:           fetch-depth: 0
 46: 
 47:       # Install system dependencies for Linux
 48:       - name: Install Linux dependencies
 49:         if: matrix.platform.os == 'ubuntu-latest'
 50:         run: |
 51:           sudo apt-get update
 52:           sudo apt-get install -y \
 53:             libwebkit2gtk-4.1-dev \
 54:             libgtk-3-dev \
 55:             libayatana-appindicator3-dev \
 56:             librsvg2-dev \
 57:             libssl-dev \
 58:             libglib2.0-dev \
 59:             libjavascriptcoregtk-4.1-dev \
 60:             libsoup-3.0-dev \
 61:             libxdo-dev \
 62:             libxcb-shape0-dev \
 63:             libxcb-xfixes0-dev
 64: 
 65:       # Setup Rust with caching
 66:       - name: Setup Rust
 67:         uses: dtolnay/rust-toolchain@stable
 68:         with:
 69:           targets: ${{ matrix.platform.rust-target }}
 70: 
 71:       # Cache Rust dependencies
 72:       - name: Cache Rust dependencies
 73:         uses: Swatinem/rust-cache@v2
 74:         with:
 75:           workspaces: './src-tauri -> target'
 76:           key: ${{ matrix.platform.os }}-rust-${{ hashFiles('**/Cargo.lock') }}
 77:           
 78:       # Setup Bun
 79:       - name: Setup Bun
 80:         uses: oven-sh/setup-bun@v2
 81:         with:
 82:           bun-version: latest
 83: 
 84:       # Cache Bun dependencies
 85:       - name: Cache Bun dependencies
 86:         uses: actions/cache@v4
 87:         with:
 88:           path: |
 89:             ~/.bun
 90:             node_modules
 91:           key: ${{ matrix.platform.os }}-bun-${{ hashFiles('bun.lockb', 'package.json') }}
 92:           restore-keys: |
 93:             ${{ matrix.platform.os }}-bun-
 94:       
 95:       # Install frontend dependencies
 96:       - name: Install frontend dependencies
 97:         run: bun install --frozen-lockfile
 98: 
 99:       # Build frontend
100:       - name: Build frontend
101:         run: bun run build
102: 
103:       # Build Tauri application
104:       - name: Build Tauri application
105:         run: bun run tauri build --no-bundle -d
106:         env:
107:           TAURI_SIGNING_PRIVATE_KEY: ""
108:           TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ""
109: 
110:       # Upload build artifacts for debugging (optional)
111:       - name: Upload build logs on failure
112:         if: failure()
113:         uses: actions/upload-artifact@v4
114:         with:
115:           name: build-logs-${{ matrix.platform.name }}
116:           path: |
117:             src-tauri/target/release/build/*/output
118:             src-tauri/target/debug/build/*/output
119:           retention-days: 3
120: 
121:   # Summary job to ensure all builds pass
122:   build-test-summary:
123:     name: Build Test Summary
124:     runs-on: ubuntu-latest
125:     needs: [build-test]
126:     if: always()
127:     
128:     steps:
129:       - name: Check build results
130:         run: |
131:           if [[ "${{ needs.build-test.result }}" == "failure" ]]; then
132:             echo "❌ One or more build tests failed"
133:             exit 1
134:           elif [[ "${{ needs.build-test.result }}" == "cancelled" ]]; then
135:             echo "⚠️ Build tests were cancelled"
136:             exit 1
137:           else
138:             echo "✅ All build tests passed successfully"
139:           fi
140: 
141:       - name: Create status comment (PR only)
142:         if: github.event_name == 'pull_request'
143:         uses: actions/github-script@v7
144:         with:
145:           script: |
146:             const result = '${{ needs.build-test.result }}';
147:             const emoji = result === 'success' ? '✅' : '❌';
148:             const status = result === 'success' ? 'All build tests passed!' : 'Build tests failed';
149:             
150:             // Create a comment summarizing the build status
151:             const comment = `## ${emoji} Build Test Results
152:             
153:             **Status**: ${status}
154:             **Commit**: ${{ github.event.pull_request.head.sha || github.sha }}
155:             
156:             | Platform | Status |
157:             |----------|--------|
158:             | Linux    | ${{ contains(needs.build-test.result, 'success') && '✅' || '❌' }} |
159:             | Windows  | ${{ contains(needs.build-test.result, 'success') && '✅' || '❌' }} |
160:             | macOS    | ${{ contains(needs.build-test.result, 'success') && '✅' || '❌' }} |
161:             
162:             [View full workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;
163:             
164:             // Only post comment if it's a PR
165:             if (context.eventName === 'pull_request') {
166:               await github.rest.issues.createComment({
167:                 owner: context.repo.owner,
168:                 repo: context.repo.repo,
169:                 issue_number: context.issue.number,
170:                 body: comment
171:               });
172:             }
````

## File: .github/workflows/claude-code-review.yml
````yaml
 1: name: Claude Code Review
 2: 
 3: on:
 4:   pull_request:
 5:     types: [opened, synchronize]
 6:     # Optional: Only run on specific file changes
 7:     # paths:
 8:     #   - "src/**/*.ts"
 9:     #   - "src/**/*.tsx"
10:     #   - "src/**/*.js"
11:     #   - "src/**/*.jsx"
12: 
13: jobs:
14:   claude-review:
15:     # Optional: Filter by PR author
16:     # if: |
17:     #   github.event.pull_request.user.login == 'external-contributor' ||
18:     #   github.event.pull_request.user.login == 'new-developer' ||
19:     #   github.event.pull_request.author_association == 'FIRST_TIME_CONTRIBUTOR'
20:     
21:     runs-on: ubuntu-latest
22:     permissions:
23:       contents: read
24:       pull-requests: read
25:       issues: read
26:       id-token: write
27:     
28:     steps:
29:       - name: Checkout repository
30:         uses: actions/checkout@v4
31:         with:
32:           fetch-depth: 1
33: 
34:       - name: Run Claude Code Review
35:         id: claude-review
36:         uses: anthropics/claude-code-action@beta
37:         with:
38:           anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
39:           
40:           # Optional: Specify model (defaults to Claude Sonnet 4, uncomment for Claude Opus 4)
41:           # model: "claude-opus-4-20250514"
42:           
43:           # Direct prompt for automated review (no @claude mention needed)
44:           direct_prompt: |
45:             Please review this pull request and provide feedback on:
46:             - Code quality and best practices
47:             - Potential bugs or issues
48:             - Performance considerations
49:             - Security concerns
50:             - Test coverage
51:             
52:             Be constructive and helpful in your feedback.
53:           
54:           # Optional: Customize review based on file types
55:           # direct_prompt: |
56:           #   Review this PR focusing on:
57:           #   - For TypeScript files: Type safety and proper interface usage
58:           #   - For API endpoints: Security, input validation, and error handling
59:           #   - For React components: Performance, accessibility, and best practices
60:           #   - For tests: Coverage, edge cases, and test quality
61:           
62:           # Optional: Different prompts for different authors
63:           # direct_prompt: |
64:           #   ${{ github.event.pull_request.author_association == 'FIRST_TIME_CONTRIBUTOR' && 
65:           #   'Welcome! Please review this PR from a first-time contributor. Be encouraging and provide detailed explanations for any suggestions.' ||
66:           #   'Please provide a thorough code review focusing on our coding standards and best practices.' }}
67:           
68:           # Optional: Add specific tools for running tests or linting
69:           # allowed_tools: "Bash(npm run test),Bash(npm run lint),Bash(npm run typecheck)"
70:           
71:           # Optional: Skip review for certain conditions
72:           # if: |
73:           #   !contains(github.event.pull_request.title, '[skip-review]') &&
74:           #   !contains(github.event.pull_request.title, '[WIP]')
````

## File: .github/workflows/claude.yml
````yaml
 1: name: Claude Code
 2: 
 3: on:
 4:   issue_comment:
 5:     types: [created]
 6:   pull_request_review_comment:
 7:     types: [created]
 8:   issues:
 9:     types: [opened, assigned]
10:   pull_request_review:
11:     types: [submitted]
12: 
13: jobs:
14:   claude:
15:     if: |
16:       (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
17:       (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
18:       (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
19:       (github.event_name == 'issues' && (contains(github.event.issue.body, '@claude') || contains(github.event.issue.title, '@claude')))
20:     runs-on: ubuntu-latest
21:     permissions:
22:       contents: read
23:       pull-requests: read
24:       issues: read
25:       id-token: write
26:     steps:
27:       - name: Checkout repository
28:         uses: actions/checkout@v4
29:         with:
30:           fetch-depth: 1
31: 
32:       - name: Run Claude Code
33:         id: claude
34:         uses: anthropics/claude-code-action@beta
35:         with:
36:           anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
37:           
38:           # Optional: Specify model (defaults to Claude Sonnet 4, uncomment for Claude Opus 4)
39:           model: "claude-opus-4-20250514"
40:           
41:           # Optional: Customize the trigger phrase (default: @claude)
42:           # trigger_phrase: "/claude"
43:           
44:           # Optional: Trigger when specific user is assigned to an issue
45:           # assignee_trigger: "claude-bot"
46:           
47:           # Optional: Allow Claude to run specific commands
48:           # allowed_tools: "Bash(npm install),Bash(npm run build),Bash(npm run test:*),Bash(npm run lint:*)"
49:           
50:           # Optional: Add custom instructions for Claude to customize its behavior for your project
51:           # custom_instructions: |
52:           #   Follow our coding standards
53:           #   Ensure all new code has tests
54:           #   Use TypeScript for new files
55:           
56:           # Optional: Custom environment variables for Claude
57:           # claude_env: |
58:           #   NODE_ENV: test
````

## File: .github/workflows/release.yml
````yaml
  1: name: Release
  2: 
  3: on:
  4:   push:
  5:     tags:
  6:       - 'v*'
  7:   workflow_dispatch:
  8:     inputs:
  9:       version:
 10:         description: 'Version to release (e.g., v1.0.0)'
 11:         required: true
 12:         type: string
 13: 
 14: permissions:
 15:   contents: write
 16: 
 17: jobs:
 18:   # Build jobs for each platform
 19:   build-linux:
 20:     uses: ./.github/workflows/build-linux.yml
 21:     secrets: inherit
 22:   
 23:   build-macos:
 24:     uses: ./.github/workflows/build-macos.yml
 25:     secrets: inherit
 26:   
 27: 
 28:   # Create release after all builds complete
 29:   create-release:
 30:     name: Create Release
 31:     needs: [build-linux, build-macos]
 32:     runs-on: ubuntu-latest
 33:     
 34:     steps:
 35:       - uses: actions/checkout@v4
 36:       
 37:       - name: Determine version
 38:         id: version
 39:         run: |
 40:           if [ "${{ github.event_name }}" = "push" ]; then
 41:             VERSION="${GITHUB_REF#refs/tags/}"
 42:           else
 43:             VERSION="${{ inputs.version }}"
 44:           fi
 45:           echo "version=$VERSION" >> $GITHUB_OUTPUT
 46:           echo "Version: $VERSION"
 47:       
 48:       - name: Download all artifacts
 49:         uses: actions/download-artifact@v4
 50:         with:
 51:           path: artifacts
 52:       
 53:       - name: Prepare release assets
 54:         run: |
 55:           mkdir -p release-assets
 56:           
 57:           # Linux artifacts
 58:           if [ -d "artifacts/linux-x86_64" ]; then
 59:             cp artifacts/linux-x86_64/*.deb release-assets/Claudia_${{ steps.version.outputs.version }}_linux_x86_64.deb || true
 60:             cp artifacts/linux-x86_64/*.AppImage release-assets/Claudia_${{ steps.version.outputs.version }}_linux_x86_64.AppImage || true
 61:           fi
 62:           
 63:           # macOS artifacts
 64:           if [ -d "artifacts/macos-universal" ]; then
 65:             cp artifacts/macos-universal/Claudia.dmg release-assets/Claudia_${{ steps.version.outputs.version }}_macos_universal.dmg || true
 66:             cp artifacts/macos-universal/Claudia.app.zip release-assets/Claudia_${{ steps.version.outputs.version }}_macos_universal.app.tar.gz || true
 67:           fi
 68:           
 69:           # Create source code archives
 70:           # Clean version without 'v' prefix for archive names
 71:           CLEAN_VERSION="${{ steps.version.outputs.version }}"
 72:           CLEAN_VERSION="${CLEAN_VERSION#v}"
 73:           
 74:           # Create source code archives (excluding .git and other unnecessary files)
 75:           echo "Creating source code archives..."
 76:           
 77:           # Create a clean export of the repository
 78:           git archive --format=tar.gz --prefix=claudia-${CLEAN_VERSION}/ -o release-assets/claudia-${CLEAN_VERSION}.tar.gz HEAD
 79:           git archive --format=zip --prefix=claudia-${CLEAN_VERSION}/ -o release-assets/claudia-${CLEAN_VERSION}.zip HEAD
 80: 
 81:           # Generate signatures for all files
 82:           cd release-assets
 83:           for file in *; do
 84:             if [ -f "$file" ]; then
 85:               sha256sum "$file" > "$file.sha256"
 86:             fi
 87:           done
 88:           cd ..
 89:       
 90:       - name: Create Release
 91:         uses: softprops/action-gh-release@v1
 92:         with:
 93:           tag_name: ${{ steps.version.outputs.version }}
 94:           name: Claudia ${{ steps.version.outputs.version }}
 95:           draft: true
 96:           prerelease: false
 97:           generate_release_notes: true
 98:           files: release-assets/*
 99:           body: |
100:             <div align="center">
101:               <img src="https://raw.githubusercontent.com/${{ github.repository }}/${{ steps.version.outputs.version }}/src-tauri/icons/icon.png" alt="Claudia Logo" width="128" height="128">
102:               
103:               # Claudia ${{ steps.version.outputs.version }}
104:               
105:               🎉 **First Release!** 🎉
106:             
107:             ### 🚀 What's New in This First Release
108:             
109:             - **AI-Powered Coding**: Seamless integration with Claude for intelligent code assistance
110:             - **Cross-Platform Support**: Available for macOS and Linux
111:             - **Modern UI**: Clean, intuitive interface built with React and Tauri
112:             - **MCP Support**: Model Context Protocol integration for enhanced capabilities
113:             - **Session Management**: Save and restore your coding sessions
114:             - **And much more!**
115:             
116:             ### Downloads
117:             
118:             #### macOS
119:             - Universal binary (Intel + Apple Silicon)
120:             - `.dmg` - Disk image installer (recommended)
121:             - `.app.tar.gz` - Application bundle
122:             
123: 
124:             #### Linux
125:             - `.AppImage` - Universal Linux package (recommended)
126:             - `.deb` - Debian/Ubuntu package
127:             
128:             #### Source Code
129:             - `claudia-{version}.tar.gz` - Source code (tar.gz)
130:             - `claudia-{version}.zip` - Source code (zip)
131:             
132:             ### Installation
133:             
134:             **macOS**: Download the `.dmg` file, open it, and drag Claudia to your Applications folder.
135:             
136: 
137:             **Linux**: Download the `.AppImage` file, make it executable (`chmod +x`), and run it. For Debian/Ubuntu, use the `.deb` file.
138:             
139:             ### Verification
140:             
141:             All files include `.sha256` signature files for verification.
````

## File: cc_agents/git-commit-bot.claudia.json
````json
 1: {
 2:   "agent": {
 3:     "default_task": "Push all changes.",
 4:     "icon": "bot",
 5:     "model": "sonnet",
 6:     "name": "Git Commit Bot",
 7:     "system_prompt": "<task>\nYou are a Git Commit Push bot. Your task is to analyze changes in a git repository, write a detailed commit message following the Conventional Commits specification, and push the changes to git.\n</task>\n\n# Instructions\n\n<instructions>\nFirst, check if there are commits in the remote repository that have not been synced locally:\n1. Run `git fetch` to update remote tracking branches\n2. Check if the local branch is behind the remote using `git status` or `git log`\n3. If there are unsynced commits from the remote:\n   - Perform a `git pull` to merge remote changes\n   - If merge conflicts occur:\n     a. Carefully analyze the conflicting changes\n     b. Resolve conflicts by keeping the appropriate changes from both versions\n     c. Mark conflicts as resolved using `git add`\n     d. Complete the merge\n4. Only proceed with the following steps after ensuring the local repository is up-to-date\n\nAnalyze the changes shown in the git diff and status outputs. Pay attention to:\n1. Which files were modified, added, or deleted\n2. The nature of the changes (e.g., bug fixes, new features, refactoring)\n3. The scope of the changes (which part of the project was affected)\n\nBased on your analysis, write a commit message following the Conventional Commits specification:\n1. Use one of the following types: feat, fix, docs, style, refactor, perf, test, or chore\n2. Include a scope in parentheses if applicable\n3. Write a concise description in the present tense\n4. If necessary, add a longer description after a blank line\n5. Include any breaking changes or issues closed\n\nThen finally push the changes to git.\n</instructions>\n\n# Notes\n\n<notes>\n- Replace [branch_name] with the appropriate branch name based on the information in the git log. If you cannot determine the branch name, use \"main\" as the default.\n- Remember to think carefully about the changes and their impact on the project when crafting your commit message. Your goal is to provide a clear and informative record of the changes made to the repository.\n- When resolving merge conflicts, prioritize maintaining functionality and avoiding breaking changes. If unsure about a conflict resolution, prefer a conservative approach that preserves existing behavior.\n</notes>"
 8:   },
 9:   "exported_at": "2025-06-23T14:29:58.156063+00:00",
10:   "version": 1
11: }
````

## File: cc_agents/README.md
````markdown
  1: # 🤖 Claudia CC Agents
  2: 
  3: <div align="center">
  4:   <p>
  5:     <strong>Pre-built AI agents for Claudia powered by Claude Code</strong>
  6:   </p>
  7:   <p>
  8:     <a href="#available-agents">Browse Agents</a> •
  9:     <a href="#importing-agents">Import Guide</a> •
 10:     <a href="#exporting-agents">Export Guide</a> •
 11:     <a href="#contributing">Contribute</a>
 12:   </p>
 13: </div>
 14: 
 15: ---
 16: 
 17: ## 📦 Available Agents
 18: 
 19: | Agent | Model | Description | Default Task |
 20: |-------|-------|-------------|--------------|
 21: | **🎯 Git Commit Bot**<br/>🤖 `bot` | <img src="https://img.shields.io/badge/Sonnet-blue?style=flat-square" alt="Sonnet"> | **Automate your Git workflow with intelligent commit messages**<br/><br/>Analyzes Git repository changes, generates detailed commit messages following Conventional Commits specification, and pushes changes to remote repository. | "Push all changes." |
 22: | **🛡️ Security Scanner**<br/>🛡️ `shield` | <img src="https://img.shields.io/badge/Opus-purple?style=flat-square" alt="Opus"> | **Advanced AI-powered Static Application Security Testing (SAST)**<br/><br/>Performs comprehensive security audits by spawning specialized sub-agents for: codebase intelligence gathering, threat modeling (STRIDE), vulnerability scanning (OWASP Top 10, CWE), exploit validation, remediation design, and professional report generation. | "Review the codebase for security issues." |
 23: | **🧪 Unit Tests Bot**<br/>💻 `code` | <img src="https://img.shields.io/badge/Opus-purple?style=flat-square" alt="Opus"> | **Automated comprehensive unit test generation for any codebase**<br/><br/>Analyzes codebase and generates comprehensive unit tests by: analyzing code structure, creating test plans, writing tests matching your style, verifying execution, optimizing coverage (>80% overall, 100% critical paths), and generating documentation. | "Generate unit tests for this codebase." |
 24: 
 25: ### Available Icons
 26: 
 27: Choose from these icon options when creating agents:
 28: - `bot` - 🤖 General purpose
 29: - `shield` - 🛡️ Security related
 30: - `code` - 💻 Development
 31: - `terminal` - 🖥️ System/CLI
 32: - `database` - 🗄️ Data operations
 33: - `globe` - 🌐 Network/Web
 34: - `file-text` - 📄 Documentation
 35: - `git-branch` - 🌿 Version control
 36: 
 37: ---
 38: 
 39: ## 📥 Importing Agents
 40: 
 41: ### Method 1: Import from GitHub (Recommended)
 42: 
 43: 1. In Claudia, navigate to **CC Agents**
 44: 2. Click the **Import** dropdown button
 45: 3. Select **From GitHub**
 46: 4. Browse available agents from the official repository
 47: 5. Preview agent details and click **Import Agent**
 48: 
 49: ### Method 2: Import from Local File
 50: 
 51: 1. Download a `.claudia.json` file from this repository
 52: 2. In Claudia, navigate to **CC Agents**
 53: 3. Click the **Import** dropdown button
 54: 4. Select **From File**
 55: 5. Choose the downloaded `.claudia.json` file
 56: 
 57: ## 📤 Exporting Agents
 58: 
 59: ### Export Your Custom Agents
 60: 
 61: 1. In Claudia, navigate to **CC Agents**
 62: 2. Find your agent in the grid
 63: 3. Click the **Export** button
 64: 4. Choose where to save the `.claudia.json` file
 65: 
 66: ### Agent File Format
 67: 
 68: All agents are stored in `.claudia.json` format with the following structure:
 69: 
 70: ```json
 71: {
 72:   "version": 1,
 73:   "exported_at": "2025-01-23T14:29:58.156063+00:00",
 74:   "agent": {
 75:     "name": "Your Agent Name",
 76:     "icon": "bot",
 77:     "model": "opus|sonnet|haiku",
 78:     "system_prompt": "Your agent's instructions...",
 79:     "default_task": "Default task description"
 80:   }
 81: }
 82: ```
 83: 
 84: ## 🔧 Technical Implementation
 85: 
 86: ### How Import/Export Works
 87: 
 88: The agent import/export system is built on a robust architecture:
 89: 
 90: #### Backend (Rust/Tauri)
 91: - **Storage**: SQLite database stores agent configurations
 92: - **Export**: Serializes agent data to JSON with version control
 93: - **Import**: Validates and deduplicates agents on import
 94: - **GitHub Integration**: Fetches agents via GitHub API
 95: 
 96: #### Frontend (React/TypeScript)
 97: - **UI Components**: 
 98:   - `CCAgents.tsx` - Main agent management interface
 99:   - `GitHubAgentBrowser.tsx` - GitHub repository browser
100:   - `CreateAgent.tsx` - Agent creation/editing form
101: - **File Operations**: Native file dialogs for import/export
102: - **Real-time Updates**: Live agent status and execution monitoring
103: 
104: ### Key Features
105: 
106: 1. **Version Control**: Each agent export includes version metadata
107: 2. **Duplicate Prevention**: Automatic naming conflict resolution
108: 3. **Model Selection**: Choose between Opus, Sonnet, and Haiku models
109: 4. **GitHub Integration**: Direct import from the official repository
110: 
111: ## 🤝 Contributing
112: 
113: We welcome agent contributions! Here's how to add your agent:
114: 
115: ### 1. Create Your Agent
116: Design and test your agent in Claudia with a clear, focused purpose.
117: 
118: ### 2. Export Your Agent
119: Export your agent to a `.claudia.json` file with a descriptive name.
120: 
121: ### 3. Submit a Pull Request
122: 1. Fork this repository
123: 2. Add your `.claudia.json` file to the `cc_agents` directory
124: 3. Update this README with your agent's details
125: 4. Submit a PR with a description of what your agent does
126: 
127: ### Agent Guidelines
128: 
129: - **Single Purpose**: Each agent should excel at one specific task
130: - **Clear Documentation**: Write comprehensive system prompts
131: - **Model Choice**: Use Haiku for simple tasks, Sonnet for general purpose, Opus for complex reasoning
132: - **Naming**: Use descriptive names that clearly indicate the agent's function
133: 
134: ## 📜 License
135: 
136: These agents are provided under the same license as the Claudia project. See the main LICENSE file for details.
137: 
138: ---
139: 
140: <div align="center">
141:   <strong>Built with ❤️ by the Claudia community</strong>
142: </div>
````

## File: cc_agents/security-scanner.claudia.json
````json
 1: {
 2:   "agent": {
 3:     "default_task": "Review the codebase for security issues.",
 4:     "icon": "shield",
 5:     "model": "opus",
 6:     "name": "Security Scanner",
 7:     "system_prompt": "# AI SAST Agent - System Prompt\n\n<role>\nYou are an advanced AI-powered Static Application Security Testing (SAST) agent specialized in performing deep, comprehensive security audits of codebases. You identify vulnerabilities with high precision, analyze attack vectors, and produce professional security reports following industry standards. You operate by orchestrating specialized sub-agents for each phase of the security assessment.\n</role>\n\n<primary_objectives>\n1. Perform thorough static analysis to identify security vulnerabilities\n2. Minimize false positives through contextual analysis and validation\n3. Provide actionable remediation guidance with code examples\n4. Generate professional security reports suitable for development and security teams\n5. Prioritize findings based on exploitability and business impact\n</primary_objectives>\n\n<methodology>\nApply a systematic approach combining:\n- **OWASP Top 10** vulnerability patterns\n- **CWE (Common Weakness Enumeration)** classification\n- **STRIDE** threat modeling\n- **Data Flow Analysis** for taint tracking\n- **Control Flow Analysis** for logic vulnerabilities\n</methodology>\n\n<workflow>\n\n## Phase 1: Codebase Intelligence Gathering\n<task_spawn>\nSpawn a **Codebase Intelligence Analyzer** sub-agent using the `Task` tool with the following instruction:\n\n```\nPerform deep codebase analysis to extract:\n\n<analysis_targets>\n- Language(s), frameworks, and libraries with versions\n- Architecture patterns (MVC, microservices, serverless, etc.)\n- Authentication and authorization mechanisms\n- Data storage systems and ORM usage\n- External integrations and API endpoints\n- Input validation and sanitization practices\n- Cryptographic implementations\n- Session management approach\n- File and resource handling\n- Third-party dependencies and known CVEs\n</analysis_targets>\n```\n</task_spawn>\n\n## Phase 2: Threat Modeling\n<task_spawn>\nSpawn a **Threat Modeling Specialist** sub-agent using the `Task` tool with the following instruction:\n\n```\nCreate a comprehensive threat model based on the codebase intelligence:\n\n<threat_model_components>\n1. Asset Identification:\n   - Sensitive data (PII, credentials, financial)\n   - Critical business logic\n   - Infrastructure components\n   \n2. Trust Boundaries:\n   - User-to-application boundaries\n   - Service-to-service boundaries\n   - Network segmentation points\n   \n3. Entry Points:\n   - API endpoints\n   - User interfaces\n   - File upload mechanisms\n   - Background job processors\n   - WebSocket connections\n   \n4. STRIDE Analysis per component:\n   - Spoofing threats\n   - Tampering threats\n   - Repudiation threats\n   - Information disclosure threats\n   - Denial of service threats\n   - Elevation of privilege threats\n</threat_model_components>\n```\n</task_spawn>\n\n## Phase 3: Vulnerability Scanning\n<task_spawn>\nFor each identified entry point and component, spawn a **Vulnerability Scanner** sub-agent using the `Task` tool:\n\n```\nScan for vulnerabilities in component: [COMPONENT_NAME]\n\n<scanning_checklist>\nINJECTION VULNERABILITIES:\n- SQL Injection (including blind, time-based, union-based)\n- NoSQL Injection\n- LDAP Injection\n- OS Command Injection\n- Code Injection (eval, dynamic execution)\n- XML/XXE Injection\n- Template Injection\n- Header Injection\n\nAUTHENTICATION & SESSION:\n- Broken authentication flows\n- Weak password policies\n- Session fixation\n- Insufficient session expiration\n- Predictable tokens\n- Missing MFA enforcement\n\nACCESS CONTROL:\n- Horizontal privilege escalation\n- Vertical privilege escalation\n- IDOR (Insecure Direct Object References)\n- Missing function-level access control\n- Path traversal\n- Forced browsing\n\nDATA EXPOSURE:\n- Sensitive data in logs\n- Unencrypted sensitive data\n- Information leakage in errors\n- Directory listing\n- Source code disclosure\n- API information disclosure\n\nCRYPTOGRAPHIC ISSUES:\n- Weak algorithms\n- Hardcoded keys/secrets\n- Insufficient key length\n- Improper IV usage\n- Insecure random number generation\n\nBUSINESS LOGIC:\n- Race conditions\n- Time-of-check time-of-use (TOCTOU)\n- Workflow bypass\n- Price manipulation\n- Insufficient rate limiting\n\nCONFIGURATION:\n- Security misconfiguration\n- Default credentials\n- Unnecessary services\n- Verbose error messages\n- Missing security headers\n</scanning_checklist>\n\n<analysis_requirements>\nFor each potential vulnerability:\n1. Trace complete data flow from source to sink\n2. Identify all transformations applied\n3. Check for existing mitigations\n4. Verify exploitability conditions\n5. Map to CWE identifier\n</analysis_requirements>\n\nReturn findings in structured format with full context.\n```\n</task_spawn>\n\n## Phase 4: Exploit Development & Validation\n<task_spawn>\nSpawn an **Exploit Developer** sub-agent using the `Task` tool with the following instruction:\n\n```\nFor each identified vulnerability, develop proof-of-concept exploits:\n\n<exploit_requirements>\n1. Create minimal, working PoC code\n2. Document exact preconditions\n3. Show full attack chain\n4. Demonstrate impact clearly\n5. Avoid destructive payloads\n6. Include both manual and automated versions\n</exploit_requirements>\n\n<poc_template>\nFor each vulnerability provide:\n- Setup requirements\n- Step-by-step exploitation\n- Expected vs actual behavior\n- Screenshot/output evidence\n- Automation script (curl/python/etc)\n</poc_template>\n\nValidate each finding to ensure:\n- Reproducibility\n- Real-world exploitability\n- No false positives\n```\n</task_spawn>\n\n## Phase 5: Remediation Design\n<task_spawn>\nSpawn a **Security Architect** sub-agent using the `Task` tool with the following instruction:\n\n```\nDesign comprehensive remediation strategies:\n\n<remediation_components>\n1. Immediate Fixes:\n   - Code patches with examples\n   - Configuration changes\n   - Quick mitigations\n\n2. Long-term Solutions:\n   - Architectural improvements\n   - Security control implementations\n   - Process enhancements\n\n3. Defense in Depth:\n   - Primary fix\n   - Compensating controls\n   - Detection mechanisms\n   - Incident response procedures\n</remediation_components>\n\nInclude:\n- Specific code examples in the target language\n- Library recommendations with versions\n- Testing strategies for fixes\n- Regression prevention measures\n```\n</task_spawn>\n\n## Phase 6: Report Generation\n<task_spawn>\nSpawn a **Security Report Writer** sub-agent using the `Task` tool with the following instruction:\n\n```\nGenerate a professional security assessment report:\n\n<report_sections>\n1. Executive Summary\n   - Key findings overview\n   - Risk summary\n   - Business impact analysis\n   - Prioritized recommendations\n\n2. Technical Summary\n   - Vulnerability statistics\n   - Severity distribution\n   - Attack vector analysis\n   - Affected components\n\n3. Detailed Findings\n   [Use HackerOne format for each]\n\n4. Remediation Roadmap\n   - Quick wins (< 1 day)\n   - Short-term (1-7 days)\n   - Long-term (> 7 days)\n\n5. Appendices\n   - Methodology\n   - Tools used\n   - References\n</report_sections>\n```\n</task_spawn>\n\n</workflow>\n\n<vulnerability_report_format>\n## [CWE-XXX] Vulnerability Title\n\n### Summary\n**Severity**: Critical | High | Medium | Low | Informational\n**CVSS Score**: X.X (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H)\n**CWE**: CWE-XXX\n**OWASP**: A0X:2021 – Category Name\n\n### Description\n[Concise explanation of the vulnerability and its potential impact]\n\n### Technical Details\n<details>\n<summary>Affected Component</summary>\n\n```\nFile: /path/to/vulnerable/file.ext\nFunction: vulnerableFunction()\nLines: 42-58\n```\n</details>\n\n<details>\n<summary>Data Flow Analysis</summary>\n\n```\n1. User input received at: controller.getUserInput() [line 42]\n   ↓ (no sanitization)\n2. Passed to: service.processData(input) [line 45]\n   ↓ (string concatenation)\n3. Used in: database.query(sql + input) [line 58]\n   ↓ (direct execution)\n4. SINK: SQL query execution with untrusted data\n```\n</details>\n\n### Proof of Concept\n\n```bash\n# Manual exploitation\ncurl -X POST https://target.com/api/users \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\": \"admin\\\"; DROP TABLE users; --\"}'\n\n# Automated PoC\npython3 exploit_sqli.py --target https://target.com --payload \"' OR '1'='1\"\n```\n\n**Expected Result**: Error or filtered input\n**Actual Result**: SQL query executed, data exposed\n\n### Impact\n- **Confidentiality**: High - Full database access possible\n- **Integrity**: High - Data manipulation possible\n- **Availability**: Medium - DoS via resource exhaustion\n\n### Remediation\n\n#### Immediate Fix\n```[language]\n// Vulnerable code\nconst query = `SELECT * FROM users WHERE id = ${userId}`;\n\n// Secure code\nconst query = 'SELECT * FROM users WHERE id = ?';\ndb.query(query, [userId]);\n```\n\n#### Long-term Solution\n1. Implement parameterized queries throughout\n2. Add input validation layer\n3. Deploy WAF rules for SQL injection patterns\n4. Enable database query logging and monitoring\n\n### References\n- [CWE-89: SQL Injection](https://cwe.mitre.org/data/definitions/89.html)\n- [OWASP SQL Injection Prevention](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n\n---\n</vulnerability_report_format>\n\n<severity_classification>\n**Critical**: \n- Remote code execution\n- Authentication bypass\n- Full data breach potential\n- Complete system compromise\n\n**High**:\n- SQL/NoSQL injection\n- Privilege escalation\n- Sensitive data exposure\n- Critical business logic flaws\n\n**Medium**:\n- XSS (stored/reflected)\n- CSRF on sensitive actions\n- Session management issues\n- Information disclosure\n\n**Low**:\n- Missing security headers\n- Weak configurations\n- Information leakage\n- Minor logic flaws\n\n**Informational**:\n- Best practice violations\n- Defense-in-depth opportunities\n- Future-proofing recommendations\n</severity_classification>\n\n<quality_assurance>\nBefore finalizing any finding:\n1. ✓ Verified exploitability (not just theoretical)\n2. ✓ Confirmed source-to-sink flow\n3. ✓ Tested proposed fix\n4. ✓ No false positives\n5. ✓ Business context considered\n6. ✓ CWE/OWASP mapping accurate\n</quality_assurance>\n\n<communication_guidelines>\n- Use clear, non-technical language in summaries\n- Provide technical depth in detailed sections\n- Include visual diagrams where helpful\n- Reference industry standards\n- Maintain professional, constructive tone\n- Focus on solutions, not just problems\n</communication_guidelines>\n\n<continuous_improvement>\nAfter each phase:\n- Log any false positives encountered\n- Document new vulnerability patterns discovered\n- Update scanning rules based on findings\n- Refine severity ratings based on context\n- Enhance PoC templates for efficiency\n</continuous_improvement>"
 8:   },
 9:   "exported_at": "2025-06-23T14:29:55.510402+00:00",
10:   "version": 1
11: }
````

## File: cc_agents/unit-tests-bot.claudia.json
````json
 1: {
 2:   "agent": {
 3:     "default_task": "Generate unit tests for this codebase.",
 4:     "icon": "code",
 5:     "model": "opus",
 6:     "name": "Unit Tests Bot",
 7:     "system_prompt": "# Unit Tests Generation Agent\n\n<role>\nYou are an autonomous Unit Test Generation Agent specialized in analyzing codebases, writing comprehensive unit tests, verifying test coverage, and documenting the testing process. You work by spawning specialized sub-agents for each phase of the testing workflow.\n</role>\n\n<primary_objectives>\n1. Analyze the existing codebase structure and coding patterns\n2. Generate comprehensive unit tests that match the codebase style\n3. Execute and verify all generated tests\n4. Create detailed documentation of the testing process and coverage\n5. Ensure 100% critical path coverage and >80% overall code coverage\n</primary_objectives>\n\n<workflow>\n\n## Phase 1: Codebase Analysis\n<task_spawn>\nSpawn a **Codebase Analyzer** sub-agent using the `Task` tool with the following instruction:\n\n```\nAnalyze the codebase structure and extract:\n- Programming language(s) and frameworks\n- Existing test framework and patterns\n- Code style conventions (naming, formatting, structure)\n- Directory structure and test file locations\n- Dependencies and testing utilities\n- Coverage requirements and existing coverage reports\n```\n</task_spawn>\n\n## Phase 2: Test Planning\n<task_spawn>\nSpawn a **Test Planner** sub-agent using the `Task` tool with the following instruction:\n\n```\nBased on the codebase analysis, create a comprehensive test plan:\n- Identify all testable modules/classes/functions\n- Categorize by priority (critical, high, medium, low)\n- Define test scenarios for each component\n- Specify edge cases and error conditions\n- Plan integration test requirements\n- Estimate coverage targets per module\n```\n</task_spawn>\n\n## Phase 3: Test Generation\n<task_spawn>\nFor each module identified in the test plan, spawn a **Test Writer** sub-agent using the `Task` tool:\n\n```\nGenerate unit tests for module: [MODULE_NAME]\nRequirements:\n- Follow existing test patterns and conventions\n- Use the same testing framework as the codebase\n- Include positive, negative, and edge case scenarios\n- Add descriptive test names and comments\n- Mock external dependencies appropriately\n- Ensure tests are isolated and repeatable\nReturn the complete test file(s) with proper imports and setup.\n```\n</task_spawn>\n\n## Phase 4: Test Verification\n<task_spawn>\nSpawn a **Test Verifier** sub-agent using the `Task` tool with the following instruction:\n```\nExecute and verify all generated tests:\n- Run the test suite and capture results\n- Identify any failing tests\n- Check for flaky or non-deterministic tests\n- Measure code coverage metrics\n- Validate test isolation and independence\n- Ensure no test pollution or side effects\nReturn a verification report with any necessary fixes.\n```\n</task_spawn>\n\n## Phase 5: Coverage Optimization\n<task_spawn>\nIf coverage targets are not met, spawn a **Coverage Optimizer** sub-agent using the `Task` tool:\n\n```\nAnalyze coverage gaps and generate additional tests:\n- Identify uncovered code paths\n- Generate tests for missed branches\n- Add tests for error handling paths\n- Cover edge cases in complex logic\n- Ensure mutation testing resistance\nReturn additional tests to meet coverage targets.\n```\n</task_spawn>\n\n## Phase 6: Documentation Generation\n<task_spawn>\nSpawn a **Documentation Writer** sub-agent using the `Task` tool with the following instruction:\n\n```\nCreate comprehensive testing documentation:\n- Overview of test suite structure\n- Test coverage summary and metrics\n- Guide for running and maintaining tests\n- Description of key test scenarios\n- Known limitations and future improvements\n- CI/CD integration instructions\nReturn documentation in Markdown format.\n```\n</task_spawn>\n\n</workflow>\n\n<style_consistency_rules>\n- **Naming Conventions**: Match the existing codebase patterns (camelCase, snake_case, PascalCase)\n- **Test Structure**: Follow the Arrange-Act-Assert or Given-When-Then pattern consistently\n- **File Organization**: Place tests in the same structure as source files\n- **Import Style**: Use the same import conventions as the main codebase\n- **Assertion Style**: Use the project's preferred assertion library and patterns\n- **Comment Style**: Match the documentation style (JSDoc, docstrings, etc.)\n</style_consistency_rules>\n\n<test_quality_criteria>\n- Each test should have a single, clear purpose\n- Test names must describe what is being tested and expected outcome\n- Tests must be independent and can run in any order\n- Use appropriate mocking for external dependencies\n- Include both happy path and error scenarios\n- Ensure tests fail meaningfully when code is broken\n- Avoid testing implementation details, focus on behavior\n</test_quality_criteria>\n\n<error_handling>\nIf any phase encounters errors:\n1. Log the error with context\n2. Attempt automatic resolution\n3. If resolution fails, document the issue\n4. Continue with remaining modules\n5. Report unresolvable issues in final documentation\n</error_handling>\n\n<verification_steps>\n1. **Syntax Verification**: Ensure all tests compile/parse correctly\n2. **Execution Verification**: Run each test in isolation and as a suite\n3. **Coverage Verification**: Confirm coverage meets targets\n4. **Performance Verification**: Ensure tests complete in reasonable time\n5. **Determinism Verification**: Run tests multiple times to check consistency\n</verification_steps>\n\n<best_practices>\n- **DRY Principle**: Extract common test utilities and helpers\n- **Clear Assertions**: Use descriptive matchers and error messages\n- **Test Data**: Use factories or builders for complex test data\n- **Async Testing**: Properly handle promises and async operations\n- **Resource Cleanup**: Always clean up after tests (files, connections, etc.)\n- **Meaningful Variables**: Use descriptive names for test data and results\n</best_practices>\n\n<communication_protocol>\n- Report progress after each major phase\n- Log detailed information for debugging\n- Summarize results at each stage\n- Provide actionable feedback for failures\n- Include time estimates for long-running operations\n</communication_protocol>\n\n<final_checklist>\nBefore completing the task, verify:\n- [ ] All source files have corresponding test files\n- [ ] Coverage targets are met (>80% overall, 100% critical)\n- [ ] All tests pass consistently\n- [ ] No hardcoded values or environment dependencies\n- [ ] Tests follow codebase conventions\n- [ ] Documentation is complete and accurate\n- [ ] CI/CD integration is configured\n</final_checklist>"
 8:   },
 9:   "exported_at": "2025-06-23T14:29:51.009370+00:00",
10:   "version": 1
11: }
````

## File: public/tauri.svg
````
1: <svg width="206" height="231" viewBox="0 0 206 231" fill="none" xmlns="http://www.w3.org/2000/svg">
2: <path d="M143.143 84C143.143 96.1503 133.293 106 121.143 106C108.992 106 99.1426 96.1503 99.1426 84C99.1426 71.8497 108.992 62 121.143 62C133.293 62 143.143 71.8497 143.143 84Z" fill="#FFC131"/>
3: <ellipse cx="84.1426" cy="147" rx="22" ry="22" transform="rotate(180 84.1426 147)" fill="#24C8DB"/>
4: <path fill-rule="evenodd" clip-rule="evenodd" d="M166.738 154.548C157.86 160.286 148.023 164.269 137.757 166.341C139.858 160.282 141 153.774 141 147C141 144.543 140.85 142.121 140.558 139.743C144.975 138.204 149.215 136.139 153.183 133.575C162.73 127.404 170.292 118.608 174.961 108.244C179.63 97.8797 181.207 86.3876 179.502 75.1487C177.798 63.9098 172.884 53.4021 165.352 44.8883C157.82 36.3744 147.99 30.2165 137.042 27.1546C126.095 24.0926 114.496 24.2568 103.64 27.6274C92.7839 30.998 83.1319 37.4317 75.8437 46.1553C74.9102 47.2727 74.0206 48.4216 73.176 49.5993C61.9292 50.8488 51.0363 54.0318 40.9629 58.9556C44.2417 48.4586 49.5653 38.6591 56.679 30.1442C67.0505 17.7298 80.7861 8.57426 96.2354 3.77762C111.685 -1.01901 128.19 -1.25267 143.769 3.10474C159.348 7.46215 173.337 16.2252 184.056 28.3411C194.775 40.457 201.767 55.4101 204.193 71.404C206.619 87.3978 204.374 103.752 197.73 118.501C191.086 133.25 180.324 145.767 166.738 154.548ZM41.9631 74.275L62.5557 76.8042C63.0459 72.813 63.9401 68.9018 65.2138 65.1274C57.0465 67.0016 49.2088 70.087 41.9631 74.275Z" fill="#FFC131"/>
5: <path fill-rule="evenodd" clip-rule="evenodd" d="M38.4045 76.4519C47.3493 70.6709 57.2677 66.6712 67.6171 64.6132C65.2774 70.9669 64 77.8343 64 85.0001C64 87.1434 64.1143 89.26 64.3371 91.3442C60.0093 92.8732 55.8533 94.9092 51.9599 97.4256C42.4128 103.596 34.8505 112.392 30.1816 122.756C25.5126 133.12 23.9357 144.612 25.6403 155.851C27.3449 167.09 32.2584 177.598 39.7906 186.112C47.3227 194.626 57.153 200.784 68.1003 203.846C79.0476 206.907 90.6462 206.743 101.502 203.373C112.359 200.002 122.011 193.568 129.299 184.845C130.237 183.722 131.131 182.567 131.979 181.383C143.235 180.114 154.132 176.91 164.205 171.962C160.929 182.49 155.596 192.319 148.464 200.856C138.092 213.27 124.357 222.426 108.907 227.222C93.458 232.019 76.9524 232.253 61.3736 227.895C45.7948 223.538 31.8055 214.775 21.0867 202.659C10.3679 190.543 3.37557 175.59 0.949823 159.596C-1.47592 143.602 0.768139 127.248 7.41237 112.499C14.0566 97.7497 24.8183 85.2327 38.4045 76.4519ZM163.062 156.711L163.062 156.711C162.954 156.773 162.846 156.835 162.738 156.897C162.846 156.835 162.954 156.773 163.062 156.711Z" fill="#24C8DB"/>
6: </svg>
````

## File: public/vite.svg
````
1: <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
````

## File: scripts/bump-version.sh
````bash
 1: #!/bin/bash
 2: 
 3: # Script to bump version across all files
 4: # Usage: ./scripts/bump-version.sh 1.0.0
 5: 
 6: set -e
 7: 
 8: if [ -z "$1" ]; then
 9:     echo "Usage: $0 <version>"
10:     echo "Example: $0 1.0.0"
11:     exit 1
12: fi
13: 
14: VERSION=$1
15: 
16: echo "Bumping version to $VERSION..."
17: 
18: # Update package.json
19: sed -i.bak "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json && rm package.json.bak
20: 
21: # Update Cargo.toml
22: sed -i.bak "s/^version = \".*\"/version = \"$VERSION\"/" src-tauri/Cargo.toml && rm src-tauri/Cargo.toml.bak
23: 
24: # Update tauri.conf.json
25: sed -i.bak "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json && rm src-tauri/tauri.conf.json.bak
26: 
27: # Update Info.plist
28: sed -i.bak "s/<string>.*<\/string><!-- VERSION -->/<string>$VERSION<\/string><!-- VERSION -->/" src-tauri/Info.plist && rm src-tauri/Info.plist.bak
29: 
30: echo "✅ Version bumped to $VERSION in all files"
31: echo ""
32: echo "Next steps:"
33: echo "1. Review the changes: git diff"
34: echo "2. Commit: git commit -am \"chore: bump version to v$VERSION\""
35: echo "3. Tag: git tag -a v$VERSION -m \"Release v$VERSION\""
36: echo "4. Push: git push && git push --tags"
````

## File: src/assets/react.svg
````
1: <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
````

## File: src/assets/shimmer.css
````css
  1: /**
  2:  * Shimmer animation styles
  3:  * Provides a sword-like shimmer effect for elements
  4:  */
  5: 
  6: @keyframes shimmer {
  7:   0% {
  8:     transform: translateX(-100%);
  9:     opacity: 0;
 10:   }
 11:   20% {
 12:     opacity: 1;
 13:   }
 14:   40% {
 15:     transform: translateX(100%);
 16:     opacity: 0;
 17:   }
 18:   50% {
 19:     transform: translateX(-100%);
 20:     opacity: 0;
 21:   }
 22:   70% {
 23:     opacity: 1;
 24:   }
 25:   90% {
 26:     transform: translateX(100%);
 27:     opacity: 0;
 28:   }
 29:   100% {
 30:     transform: translateX(100%);
 31:     opacity: 0;
 32:   }
 33: }
 34: 
 35: @keyframes shimmer-text {
 36:   0% {
 37:     background-position: -200% center;
 38:   }
 39:   45% {
 40:     background-position: 200% center;
 41:   }
 42:   50% {
 43:     background-position: -200% center;
 44:   }
 45:   95% {
 46:     background-position: 200% center;
 47:   }
 48:   96%, 100% {
 49:     background-position: 200% center;
 50:     -webkit-text-fill-color: currentColor;
 51:     background: none;
 52:   }
 53: }
 54: 
 55: @keyframes symbol-rotate {
 56:   0% {
 57:     content: '◐';
 58:     opacity: 1;
 59:     transform: translateY(0) scale(1);
 60:   }
 61:   25% {
 62:     content: '◓';
 63:     opacity: 1;
 64:     transform: translateY(0) scale(1);
 65:   }
 66:   50% {
 67:     content: '◑';
 68:     opacity: 1;
 69:     transform: translateY(0) scale(1);
 70:   }
 71:   75% {
 72:     content: '◒';
 73:     opacity: 1;
 74:     transform: translateY(0) scale(1);
 75:   }
 76:   100% {
 77:     content: '◐';
 78:     opacity: 1;
 79:     transform: translateY(0) scale(1);
 80:   }
 81: }
 82: 
 83: .shimmer-once {
 84:   position: relative;
 85:   display: inline-block;
 86:   background: linear-gradient(
 87:     105deg,
 88:     currentColor 0%,
 89:     currentColor 40%,
 90:     #d97757 50%,
 91:     currentColor 60%,
 92:     currentColor 100%
 93:   );
 94:   background-size: 200% auto;
 95:   background-position: -200% center;
 96:   -webkit-background-clip: text;
 97:   -webkit-text-fill-color: transparent;
 98:   background-clip: text;
 99:   animation: shimmer-text 1s ease-out forwards;
100: }
101: 
102: .rotating-symbol {
103:   display: inline-block;
104:   color: #d97757;
105:   font-size: 1.5rem; /* Make it bigger! */
106:   margin-right: 0.5rem;
107:   font-weight: bold;
108:   vertical-align: middle;
109:   position: relative;
110:   line-height: 1;
111:   top: -2px;
112: }
113: 
114: .rotating-symbol::before {
115:   content: '◐';
116:   display: inline-block;
117:   animation: symbol-rotate 2s linear infinite;
118:   font-size: inherit;
119:   line-height: inherit;
120:   vertical-align: baseline;
121: }
122: 
123: .shimmer-hover {
124:   position: relative;
125:   overflow: hidden;
126: }
127: 
128: .shimmer-hover::before {
129:   content: '';
130:   position: absolute;
131:   top: -50%;
132:   left: 0;
133:   width: 100%;
134:   height: 200%;
135:   background: linear-gradient(
136:     105deg,
137:     transparent 0%,
138:     transparent 40%,
139:     rgba(217, 119, 87, 0.4) 50%,
140:     transparent 60%,
141:     transparent 100%
142:   );
143:   transform: translateX(-100%) rotate(-10deg);
144:   opacity: 0;
145:   pointer-events: none;
146:   z-index: 1;
147: }
148: 
149: .shimmer-hover > * {
150:   position: relative;
151:   z-index: 2;
152: }
153: 
154: .shimmer-hover:hover::before {
155:   animation: shimmer 1s ease-out;
156: }
````

## File: src/components/claude-code-session/MessageList.tsx
````typescript
  1: import React, { useRef, useEffect } from 'react';
  2: import { motion, AnimatePresence } from 'framer-motion';
  3: import { useVirtualizer } from '@tanstack/react-virtual';
  4: import { StreamMessage } from '../StreamMessage';
  5: import { Terminal } from 'lucide-react';
  6: import { cn } from '@/lib/utils';
  7: import type { ClaudeStreamMessage } from '../AgentExecution';
  8: 
  9: interface MessageListProps {
 10:   messages: ClaudeStreamMessage[];
 11:   projectPath: string;
 12:   isStreaming: boolean;
 13:   onLinkDetected?: (url: string) => void;
 14:   className?: string;
 15: }
 16: 
 17: export const MessageList: React.FC<MessageListProps> = React.memo(({
 18:   messages,
 19:   projectPath,
 20:   isStreaming,
 21:   onLinkDetected,
 22:   className
 23: }) => {
 24:   const scrollContainerRef = useRef<HTMLDivElement>(null);
 25:   const shouldAutoScrollRef = useRef(true);
 26:   const userHasScrolledRef = useRef(false);
 27: 
 28:   // Virtual scrolling setup
 29:   const virtualizer = useVirtualizer({
 30:     count: messages.length,
 31:     getScrollElement: () => scrollContainerRef.current,
 32:     estimateSize: () => 100, // Estimated height of each message
 33:     overscan: 5,
 34:   });
 35: 
 36:   // Auto-scroll to bottom when new messages arrive
 37:   useEffect(() => {
 38:     if (shouldAutoScrollRef.current && scrollContainerRef.current) {
 39:       const scrollElement = scrollContainerRef.current;
 40:       scrollElement.scrollTop = scrollElement.scrollHeight;
 41:     }
 42:   }, [messages]);
 43: 
 44:   // Handle scroll events to detect user scrolling
 45:   const handleScroll = () => {
 46:     if (!scrollContainerRef.current) return;
 47:     
 48:     const scrollElement = scrollContainerRef.current;
 49:     const isAtBottom = 
 50:       Math.abs(scrollElement.scrollHeight - scrollElement.scrollTop - scrollElement.clientHeight) < 50;
 51:     
 52:     if (!isAtBottom) {
 53:       userHasScrolledRef.current = true;
 54:       shouldAutoScrollRef.current = false;
 55:     } else if (userHasScrolledRef.current) {
 56:       shouldAutoScrollRef.current = true;
 57:       userHasScrolledRef.current = false;
 58:     }
 59:   };
 60: 
 61:   // Reset auto-scroll when streaming stops
 62:   useEffect(() => {
 63:     if (!isStreaming) {
 64:       shouldAutoScrollRef.current = true;
 65:       userHasScrolledRef.current = false;
 66:     }
 67:   }, [isStreaming]);
 68: 
 69:   if (messages.length === 0) {
 70:     return (
 71:       <div className={cn("flex-1 flex items-center justify-center", className)}>
 72:         <motion.div
 73:           initial={{ opacity: 0, scale: 0.95 }}
 74:           animate={{ opacity: 1, scale: 1 }}
 75:           className="text-center space-y-4 max-w-md"
 76:         >
 77:           <div className="h-16 w-16 bg-primary/10 rounded-full flex items-center justify-center mx-auto">
 78:             <Terminal className="h-8 w-8 text-primary" />
 79:           </div>
 80:           <div>
 81:             <h3 className="text-lg font-semibold mb-2">Ready to start coding</h3>
 82:             <p className="text-sm text-muted-foreground">
 83:               {projectPath 
 84:                 ? "Enter a prompt below to begin your Claude Code session"
 85:                 : "Select a project folder to begin"}
 86:             </p>
 87:           </div>
 88:         </motion.div>
 89:       </div>
 90:     );
 91:   }
 92: 
 93:   return (
 94:     <div
 95:       ref={scrollContainerRef}
 96:       onScroll={handleScroll}
 97:       className={cn("flex-1 overflow-y-auto scroll-smooth", className)}
 98:     >
 99:       <div
100:         style={{
101:           height: `${virtualizer.getTotalSize()}px`,
102:           width: '100%',
103:           position: 'relative',
104:         }}
105:       >
106:         <AnimatePresence mode="popLayout">
107:           {virtualizer.getVirtualItems().map((virtualItem) => {
108:             const message = messages[virtualItem.index];
109:             const key = `msg-${virtualItem.index}-${message.type}`;
110:             
111:             return (
112:               <motion.div
113:                 key={key}
114:                 initial={{ opacity: 0, y: 10 }}
115:                 animate={{ opacity: 1, y: 0 }}
116:                 exit={{ opacity: 0, scale: 0.95 }}
117:                 transition={{ duration: 0.2 }}
118:                 style={{
119:                   position: 'absolute',
120:                   top: 0,
121:                   left: 0,
122:                   width: '100%',
123:                   transform: `translateY(${virtualItem.start}px)`,
124:                 }}
125:               >
126:                 <div className="px-4 py-2">
127:                   <StreamMessage 
128:                     message={message}
129:                     streamMessages={messages}
130:                     onLinkDetected={onLinkDetected}
131:                   />
132:                 </div>
133:               </motion.div>
134:             );
135:           })}
136:         </AnimatePresence>
137:       </div>
138: 
139:       {/* Streaming indicator */}
140:       {isStreaming && (
141:         <motion.div
142:           initial={{ opacity: 0 }}
143:           animate={{ opacity: 1 }}
144:           exit={{ opacity: 0 }}
145:           className="sticky bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-background to-transparent"
146:         >
147:           <div className="flex items-center gap-2 text-sm text-muted-foreground">
148:             <div className="h-2 w-2 bg-primary rounded-full animate-pulse" />
149:             <span>Claude is thinking...</span>
150:           </div>
151:         </motion.div>
152:       )}
153:     </div>
154:   );
155: });
````

## File: src/components/claude-code-session/PromptQueue.tsx
````typescript
 1: import React from 'react';
 2: import { motion, AnimatePresence } from 'framer-motion';
 3: import { X, Clock, Sparkles, Zap } from 'lucide-react';
 4: import { Button } from '@/components/ui/button';
 5: import { Badge } from '@/components/ui/badge';
 6: import { cn } from '@/lib/utils';
 7: 
 8: interface QueuedPrompt {
 9:   id: string;
10:   prompt: string;
11:   model: "sonnet" | "opus";
12: }
13: 
14: interface PromptQueueProps {
15:   queuedPrompts: QueuedPrompt[];
16:   onRemove: (id: string) => void;
17:   className?: string;
18: }
19: 
20: export const PromptQueue: React.FC<PromptQueueProps> = React.memo(({
21:   queuedPrompts,
22:   onRemove,
23:   className
24: }) => {
25:   if (queuedPrompts.length === 0) return null;
26: 
27:   return (
28:     <motion.div
29:       initial={{ opacity: 0, height: 0 }}
30:       animate={{ opacity: 1, height: 'auto' }}
31:       exit={{ opacity: 0, height: 0 }}
32:       className={cn("border-t bg-muted/20", className)}
33:     >
34:       <div className="px-4 py-3">
35:         <div className="flex items-center gap-2 mb-2">
36:           <Clock className="h-4 w-4 text-muted-foreground" />
37:           <span className="text-sm font-medium">Queued Prompts</span>
38:           <Badge variant="secondary" className="text-xs">
39:             {queuedPrompts.length}
40:           </Badge>
41:         </div>
42:         
43:         <div className="space-y-2 max-h-32 overflow-y-auto">
44:           <AnimatePresence mode="popLayout">
45:             {queuedPrompts.map((queuedPrompt, index) => (
46:               <motion.div
47:                 key={queuedPrompt.id}
48:                 initial={{ opacity: 0, x: -20 }}
49:                 animate={{ opacity: 1, x: 0 }}
50:                 exit={{ opacity: 0, x: 20 }}
51:                 transition={{ delay: index * 0.05 }}
52:                 className="flex items-start gap-2 p-2 rounded-md bg-background/50"
53:               >
54:                 <div className="flex-shrink-0 mt-0.5">
55:                   {queuedPrompt.model === "opus" ? (
56:                     <Sparkles className="h-3.5 w-3.5 text-purple-500" />
57:                   ) : (
58:                     <Zap className="h-3.5 w-3.5 text-amber-500" />
59:                   )}
60:                 </div>
61:                 
62:                 <div className="flex-1 min-w-0">
63:                   <p className="text-sm truncate">{queuedPrompt.prompt}</p>
64:                   <span className="text-xs text-muted-foreground">
65:                     {queuedPrompt.model === "opus" ? "Opus" : "Sonnet"}
66:                   </span>
67:                 </div>
68:                 
69:                 <Button
70:                   variant="ghost"
71:                   size="icon"
72:                   className="h-6 w-6 flex-shrink-0"
73:                   onClick={() => onRemove(queuedPrompt.id)}
74:                 >
75:                   <X className="h-3 w-3" />
76:                 </Button>
77:               </motion.div>
78:             ))}
79:           </AnimatePresence>
80:         </div>
81:       </div>
82:     </motion.div>
83:   );
84: });
````

## File: src/components/claude-code-session/SessionHeader.tsx
````typescript
  1: import React from 'react';
  2: import { motion } from 'framer-motion';
  3: import { 
  4:   ArrowLeft, 
  5:   Terminal, 
  6:   FolderOpen, 
  7:   Copy, 
  8:   GitBranch,
  9:   Settings,
 10:   Hash,
 11:   Command
 12: } from 'lucide-react';
 13: import { Button } from '@/components/ui/button';
 14: import { Popover } from '@/components/ui/popover';
 15: import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
 16: import { Badge } from '@/components/ui/badge';
 17: import { cn } from '@/lib/utils';
 18: 
 19: interface SessionHeaderProps {
 20:   projectPath: string;
 21:   claudeSessionId: string | null;
 22:   totalTokens: number;
 23:   isStreaming: boolean;
 24:   hasMessages: boolean;
 25:   showTimeline: boolean;
 26:   copyPopoverOpen: boolean;
 27:   onBack: () => void;
 28:   onSelectPath: () => void;
 29:   onCopyAsJsonl: () => void;
 30:   onCopyAsMarkdown: () => void;
 31:   onToggleTimeline: () => void;
 32:   onProjectSettings?: () => void;
 33:   onSlashCommandsSettings?: () => void;
 34:   setCopyPopoverOpen: (open: boolean) => void;
 35: }
 36: 
 37: export const SessionHeader: React.FC<SessionHeaderProps> = React.memo(({
 38:   projectPath,
 39:   claudeSessionId,
 40:   totalTokens,
 41:   isStreaming,
 42:   hasMessages,
 43:   showTimeline,
 44:   copyPopoverOpen,
 45:   onBack,
 46:   onSelectPath,
 47:   onCopyAsJsonl,
 48:   onCopyAsMarkdown,
 49:   onToggleTimeline,
 50:   onProjectSettings,
 51:   onSlashCommandsSettings,
 52:   setCopyPopoverOpen
 53: }) => {
 54:   return (
 55:     <motion.div 
 56:       initial={{ opacity: 0, y: -20 }}
 57:       animate={{ opacity: 1, y: 0 }}
 58:       className="bg-background/95 backdrop-blur-sm border-b px-4 py-3 sticky top-0 z-40"
 59:     >
 60:       <div className="flex items-center justify-between">
 61:         <div className="flex items-center gap-3">
 62:           <Button
 63:             variant="ghost"
 64:             size="icon"
 65:             onClick={onBack}
 66:             className="h-8 w-8"
 67:           >
 68:             <ArrowLeft className="h-4 w-4" />
 69:           </Button>
 70:           
 71:           <div className="flex items-center gap-2">
 72:             <Terminal className="h-5 w-5 text-primary" />
 73:             <span className="font-semibold">Claude Code Session</span>
 74:           </div>
 75: 
 76:           {projectPath && (
 77:             <div className="flex items-center gap-2 text-sm text-muted-foreground">
 78:               <FolderOpen className="h-4 w-4" />
 79:               <span className="font-mono max-w-md truncate">{projectPath}</span>
 80:             </div>
 81:           )}
 82:           
 83:           {!projectPath && (
 84:             <Button
 85:               variant="outline"
 86:               size="sm"
 87:               onClick={onSelectPath}
 88:               className="flex items-center gap-2"
 89:             >
 90:               <FolderOpen className="h-4 w-4" />
 91:               Select Project
 92:             </Button>
 93:           )}
 94:         </div>
 95: 
 96:         <div className="flex items-center gap-2">
 97:           {claudeSessionId && (
 98:             <div className="flex items-center gap-2">
 99:               <Badge variant="outline" className="text-xs">
100:                 <Hash className="h-3 w-3 mr-1" />
101:                 {claudeSessionId.slice(0, 8)}
102:               </Badge>
103:               {totalTokens > 0 && (
104:                 <Badge variant="secondary" className="text-xs">
105:                   {totalTokens.toLocaleString()} tokens
106:                 </Badge>
107:               )}
108:             </div>
109:           )}
110: 
111:           {hasMessages && !isStreaming && (
112:             <Popover
113:               open={copyPopoverOpen}
114:               onOpenChange={setCopyPopoverOpen}
115:               trigger={
116:                 <Button variant="ghost" size="icon" className="h-8 w-8">
117:                   <Copy className="h-4 w-4" />
118:                 </Button>
119:               }
120:               content={
121:                 <div className="space-y-1">
122:                   <Button
123:                     variant="ghost"
124:                     size="sm"
125:                     className="w-full justify-start"
126:                     onClick={onCopyAsJsonl}
127:                   >
128:                     Copy as JSONL
129:                   </Button>
130:                   <Button
131:                     variant="ghost"
132:                     size="sm"
133:                     className="w-full justify-start"
134:                     onClick={onCopyAsMarkdown}
135:                   >
136:                     Copy as Markdown
137:                   </Button>
138:                 </div>
139:               }
140:               className="w-48 p-2"
141:             />
142:           )}
143: 
144:           <Button
145:             variant="ghost"
146:             size="icon"
147:             onClick={onToggleTimeline}
148:             className={cn(
149:               "h-8 w-8 transition-colors",
150:               showTimeline && "bg-accent text-accent-foreground"
151:             )}
152:           >
153:             <GitBranch className="h-4 w-4" />
154:           </Button>
155: 
156:           <DropdownMenu>
157:             <DropdownMenuTrigger asChild>
158:               <Button variant="ghost" size="icon" className="h-8 w-8">
159:                 <Settings className="h-4 w-4" />
160:               </Button>
161:             </DropdownMenuTrigger>
162:             <DropdownMenuContent align="end" className="w-48">
163:               {onProjectSettings && projectPath && (
164:                 <DropdownMenuItem onClick={onProjectSettings}>
165:                   <Settings className="h-4 w-4 mr-2" />
166:                   Project Settings
167:                 </DropdownMenuItem>
168:               )}
169:               {onSlashCommandsSettings && projectPath && (
170:                 <DropdownMenuItem onClick={onSlashCommandsSettings}>
171:                   <Command className="h-4 w-4 mr-2" />
172:                   Slash Commands
173:                 </DropdownMenuItem>
174:               )}
175:             </DropdownMenuContent>
176:           </DropdownMenu>
177:         </div>
178:       </div>
179:     </motion.div>
180:   );
181: });
````

## File: src/components/claude-code-session/useCheckpoints.ts
````typescript
  1: import { useState, useCallback } from 'react';
  2: import { api } from '@/lib/api';
  3: 
  4: // Local checkpoint format for UI display
  5: interface Checkpoint {
  6:   id: string;
  7:   sessionId: string;
  8:   name: string;
  9:   createdAt: string;
 10:   messageCount: number;
 11: }
 12: 
 13: interface UseCheckpointsOptions {
 14:   sessionId: string | null;
 15:   projectId: string;
 16:   projectPath: string;
 17:   onToast?: (message: string, type: 'success' | 'error') => void;
 18: }
 19: 
 20: export function useCheckpoints({ sessionId, projectId, projectPath, onToast }: UseCheckpointsOptions) {
 21:   const [checkpoints, setCheckpoints] = useState<Checkpoint[]>([]);
 22:   const [isLoadingCheckpoints, setIsLoadingCheckpoints] = useState(false);
 23:   const [timelineVersion, setTimelineVersion] = useState(0);
 24:   
 25:   const showToast = useCallback((message: string, type: 'success' | 'error' = 'success') => {
 26:     if (onToast) {
 27:       onToast(message, type);
 28:     }
 29:   }, [onToast]);
 30: 
 31:   const loadCheckpoints = useCallback(async () => {
 32:     if (!sessionId) return;
 33:     
 34:     setIsLoadingCheckpoints(true);
 35:     try {
 36:       const result = await api.listCheckpoints(sessionId, projectId, projectPath);
 37:       // Map API Checkpoint type to local format if needed
 38:       const mappedCheckpoints = result.map(cp => ({
 39:         id: cp.id,
 40:         sessionId: cp.sessionId,
 41:         name: cp.description || `Checkpoint at ${cp.timestamp}`,
 42:         createdAt: cp.timestamp,
 43:         messageCount: cp.metadata.totalTokens
 44:       }));
 45:       setCheckpoints(mappedCheckpoints);
 46:       setTimelineVersion(prev => prev + 1);
 47:     } catch (error) {
 48:       console.error("Failed to load checkpoints:", error);
 49:       showToast("Failed to load checkpoints", 'error');
 50:     } finally {
 51:       setIsLoadingCheckpoints(false);
 52:     }
 53:   }, [sessionId, projectId, projectPath, showToast]);
 54: 
 55:   const createCheckpoint = useCallback(async (name: string) => {
 56:     if (!sessionId) return;
 57:     
 58:     try {
 59:       await api.createCheckpoint(sessionId, projectId, projectPath, undefined, name);
 60:       await loadCheckpoints();
 61:       showToast("Checkpoint created successfully", 'success');
 62:     } catch (error) {
 63:       console.error("Failed to create checkpoint:", error);
 64:       showToast("Failed to create checkpoint", 'error');
 65:       throw error;
 66:     }
 67:   }, [sessionId, projectId, projectPath, loadCheckpoints, showToast]);
 68: 
 69:   const restoreCheckpoint = useCallback(async (checkpointId: string) => {
 70:     if (!sessionId) return;
 71:     
 72:     try {
 73:       await api.restoreCheckpoint(checkpointId, sessionId, projectId, projectPath);
 74:       showToast("Checkpoint restored successfully", 'success');
 75:       // Return true to indicate success
 76:       return true;
 77:     } catch (error) {
 78:       console.error("Failed to restore checkpoint:", error);
 79:       showToast("Failed to restore checkpoint", 'error');
 80:       return false;
 81:     }
 82:   }, [sessionId, projectId, projectPath, showToast]);
 83: 
 84:   const deleteCheckpoint = useCallback(async (_checkpointId: string) => {
 85:     if (!sessionId) return;
 86:     
 87:     try {
 88:       // API doesn't have deleteCheckpoint, using a placeholder
 89:       console.warn('deleteCheckpoint not implemented in API');
 90:       await loadCheckpoints();
 91:       showToast("Checkpoint deleted successfully", 'success');
 92:     } catch (error) {
 93:       console.error("Failed to delete checkpoint:", error);
 94:       showToast("Failed to delete checkpoint", 'error');
 95:     }
 96:   }, [sessionId, loadCheckpoints, showToast]);
 97: 
 98:   const forkCheckpoint = useCallback(async (checkpointId: string, newSessionName: string) => {
 99:     if (!sessionId) return null;
100:     
101:     try {
102:       const forkedSession = await api.forkFromCheckpoint(checkpointId, sessionId, projectId, projectPath, newSessionName, 'Forked from checkpoint');
103:       showToast("Session forked successfully", 'success');
104:       return forkedSession;
105:     } catch (error) {
106:       console.error("Failed to fork checkpoint:", error);
107:       showToast("Failed to fork session", 'error');
108:       return null;
109:     }
110:   }, [sessionId, projectId, projectPath, showToast]);
111: 
112:   return {
113:     checkpoints,
114:     isLoadingCheckpoints,
115:     timelineVersion,
116:     loadCheckpoints,
117:     createCheckpoint,
118:     restoreCheckpoint,
119:     deleteCheckpoint,
120:     forkCheckpoint
121:   };
122: }
````

## File: src/components/claude-code-session/useClaudeMessages.ts
````typescript
  1: import { useState, useCallback, useRef, useEffect } from 'react';
  2: import { listen, type UnlistenFn } from '@tauri-apps/api/event';
  3: import { api } from '@/lib/api';
  4: import type { ClaudeStreamMessage } from '../AgentExecution';
  5: 
  6: interface UseClaudeMessagesOptions {
  7:   onSessionInfo?: (info: { sessionId: string; projectId: string }) => void;
  8:   onTokenUpdate?: (tokens: number) => void;
  9:   onStreamingChange?: (isStreaming: boolean, sessionId: string | null) => void;
 10: }
 11: 
 12: export function useClaudeMessages(options: UseClaudeMessagesOptions = {}) {
 13:   const [messages, setMessages] = useState<ClaudeStreamMessage[]>([]);
 14:   const [rawJsonlOutput, setRawJsonlOutput] = useState<string[]>([]);
 15:   const [isStreaming, setIsStreaming] = useState(false);
 16:   const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);
 17:   
 18:   const eventListenerRef = useRef<UnlistenFn | null>(null);
 19:   const accumulatedContentRef = useRef<{ [key: string]: string }>({});
 20: 
 21:   const handleMessage = useCallback((message: ClaudeStreamMessage) => {
 22:     if ((message as any).type === "start") {
 23:       // Clear accumulated content for new stream
 24:       accumulatedContentRef.current = {};
 25:       setIsStreaming(true);
 26:       options.onStreamingChange?.(true, currentSessionId);
 27:     } else if ((message as any).type === "partial") {
 28:       if (message.tool_calls && message.tool_calls.length > 0) {
 29:         message.tool_calls.forEach((toolCall: any) => {
 30:           if (toolCall.content && toolCall.partial_tool_call_index !== undefined) {
 31:             const key = `tool-${toolCall.partial_tool_call_index}`;
 32:             if (!accumulatedContentRef.current[key]) {
 33:               accumulatedContentRef.current[key] = "";
 34:             }
 35:             accumulatedContentRef.current[key] += toolCall.content;
 36:             toolCall.accumulated_content = accumulatedContentRef.current[key];
 37:           }
 38:         });
 39:       }
 40:     } else if ((message as any).type === "response" && message.message?.usage) {
 41:       const totalTokens = (message.message.usage.input_tokens || 0) + 
 42:                          (message.message.usage.output_tokens || 0);
 43:       options.onTokenUpdate?.(totalTokens);
 44:     } else if ((message as any).type === "error" || (message as any).type === "response") {
 45:       setIsStreaming(false);
 46:       options.onStreamingChange?.(false, currentSessionId);
 47:     }
 48: 
 49:     setMessages(prev => [...prev, message]);
 50:     setRawJsonlOutput(prev => [...prev, JSON.stringify(message)]);
 51: 
 52:     // Extract session info
 53:     if ((message as any).type === "session_info" && (message as any).session_id && (message as any).project_id) {
 54:       options.onSessionInfo?.({
 55:         sessionId: (message as any).session_id,
 56:         projectId: (message as any).project_id
 57:       });
 58:       setCurrentSessionId((message as any).session_id);
 59:     }
 60:   }, [currentSessionId, options]);
 61: 
 62:   const clearMessages = useCallback(() => {
 63:     setMessages([]);
 64:     setRawJsonlOutput([]);
 65:     accumulatedContentRef.current = {};
 66:   }, []);
 67: 
 68:   const loadMessages = useCallback(async (sessionId: string) => {
 69:     try {
 70:       const output = await api.getSessionOutput(parseInt(sessionId));
 71:       // Note: API returns a string, not an array of outputs
 72:       const outputs = [{ jsonl: output }];
 73:       const loadedMessages: ClaudeStreamMessage[] = [];
 74:       const loadedRawJsonl: string[] = [];
 75:       
 76:       outputs.forEach(output => {
 77:         if (output.jsonl) {
 78:           const lines = output.jsonl.split('\n').filter(line => line.trim());
 79:           lines.forEach(line => {
 80:             try {
 81:               const msg = JSON.parse(line);
 82:               loadedMessages.push(msg);
 83:               loadedRawJsonl.push(line);
 84:             } catch (e) {
 85:               console.error("Failed to parse JSONL:", e);
 86:             }
 87:           });
 88:         }
 89:       });
 90:       
 91:       setMessages(loadedMessages);
 92:       setRawJsonlOutput(loadedRawJsonl);
 93:     } catch (error) {
 94:       console.error("Failed to load session outputs:", error);
 95:       throw error;
 96:     }
 97:   }, []);
 98: 
 99:   // Set up event listener
100:   useEffect(() => {
101:     const setupListener = async () => {
102:       if (eventListenerRef.current) {
103:         eventListenerRef.current();
104:       }
105:       
106:       eventListenerRef.current = await listen<string>("claude-stream", (event) => {
107:         try {
108:           const message = JSON.parse(event.payload) as ClaudeStreamMessage;
109:           handleMessage(message);
110:         } catch (error) {
111:           console.error("Failed to parse Claude stream message:", error);
112:         }
113:       });
114:     };
115: 
116:     setupListener();
117: 
118:     return () => {
119:       if (eventListenerRef.current) {
120:         eventListenerRef.current();
121:       }
122:     };
123:   }, [handleMessage]);
124: 
125:   return {
126:     messages,
127:     rawJsonlOutput,
128:     isStreaming,
129:     currentSessionId,
130:     clearMessages,
131:     loadMessages,
132:     handleMessage
133:   };
134: }
````

## File: src/components/ui/badge.tsx
````typescript
 1: import * as React from "react"
 2: import { cva, type VariantProps } from "class-variance-authority"
 3: 
 4: import { cn } from "@/lib/utils"
 5: 
 6: const badgeVariants = cva(
 7:   "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors",
 8:   {
 9:     variants: {
10:       variant: {
11:         default:
12:           "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
13:         secondary:
14:           "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
15:         destructive:
16:           "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
17:         outline: "text-foreground",
18:       },
19:     },
20:     defaultVariants: {
21:       variant: "default",
22:     },
23:   }
24: )
25: 
26: export interface BadgeProps
27:   extends React.HTMLAttributes<HTMLDivElement>,
28:     VariantProps<typeof badgeVariants> {}
29: 
30: function Badge({ className, variant, ...props }: BadgeProps) {
31:   return (
32:     <div className={cn(badgeVariants({ variant }), className)} {...props} />
33:   )
34: }
35: 
36: export { Badge, badgeVariants }
````

## File: src/components/ui/button.tsx
````typescript
 1: import * as React from "react";
 2: import { cva, type VariantProps } from "class-variance-authority";
 3: import { cn } from "@/lib/utils";
 4: 
 5: /**
 6:  * Button variants configuration using class-variance-authority
 7:  */
 8: const buttonVariants = cva(
 9:   "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors disabled:pointer-events-none disabled:opacity-50",
10:   {
11:     variants: {
12:       variant: {
13:         default:
14:           "bg-primary text-primary-foreground shadow hover:bg-primary/90",
15:         destructive:
16:           "bg-destructive text-destructive-foreground shadow-xs hover:bg-destructive/90",
17:         outline:
18:           "border border-input bg-background shadow-xs hover:bg-accent hover:text-accent-foreground",
19:         secondary:
20:           "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
21:         ghost: "hover:bg-accent hover:text-accent-foreground",
22:         link: "text-primary underline-offset-4 hover:underline",
23:       },
24:       size: {
25:         default: "h-9 px-4 py-2",
26:         sm: "h-8 rounded-md px-3 text-xs",
27:         lg: "h-10 rounded-md px-8",
28:         icon: "h-9 w-9",
29:       },
30:     },
31:     defaultVariants: {
32:       variant: "default",
33:       size: "default",
34:     },
35:   }
36: );
37: 
38: export interface ButtonProps
39:   extends React.ButtonHTMLAttributes<HTMLButtonElement>,
40:     VariantProps<typeof buttonVariants> {
41:   asChild?: boolean;
42: }
43: 
44: /**
45:  * Button component with multiple variants and sizes
46:  * 
47:  * @example
48:  * <Button variant="outline" size="lg" onClick={() => console.log('clicked')}>
49:  *   Click me
50:  * </Button>
51:  */
52: const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
53:   ({ className, variant, size, ...props }, ref) => {
54:     return (
55:       <button
56:         className={cn(buttonVariants({ variant, size, className }))}
57:         ref={ref}
58:         {...props}
59:       />
60:     );
61:   }
62: );
63: Button.displayName = "Button";
64: 
65: export { Button, buttonVariants };
````

## File: src/components/ui/card.tsx
````typescript
  1: import * as React from "react";
  2: import { cn } from "@/lib/utils";
  3: 
  4: /**
  5:  * Card component - A container with consistent styling and sections
  6:  * 
  7:  * @example
  8:  * <Card>
  9:  *   <CardHeader>
 10:  *     <CardTitle>Card Title</CardTitle>
 11:  *     <CardDescription>Card description</CardDescription>
 12:  *   </CardHeader>
 13:  *   <CardContent>
 14:  *     Content goes here
 15:  *   </CardContent>
 16:  *   <CardFooter>
 17:  *     Footer content
 18:  *   </CardFooter>
 19:  * </Card>
 20:  */
 21: const Card = React.forwardRef<
 22:   HTMLDivElement,
 23:   React.HTMLAttributes<HTMLDivElement>
 24: >(({ className, ...props }, ref) => (
 25:   <div
 26:     ref={ref}
 27:     className={cn(
 28:       "rounded-lg border shadow-xs",
 29:       className
 30:     )}
 31:     style={{
 32:       borderColor: "var(--color-border)",
 33:       backgroundColor: "var(--color-card)",
 34:       color: "var(--color-card-foreground)"
 35:     }}
 36:     {...props}
 37:   />
 38: ));
 39: Card.displayName = "Card";
 40: 
 41: /**
 42:  * CardHeader component - Top section of a card
 43:  */
 44: const CardHeader = React.forwardRef<
 45:   HTMLDivElement,
 46:   React.HTMLAttributes<HTMLDivElement>
 47: >(({ className, ...props }, ref) => (
 48:   <div
 49:     ref={ref}
 50:     className={cn("flex flex-col space-y-1.5 p-6", className)}
 51:     {...props}
 52:   />
 53: ));
 54: CardHeader.displayName = "CardHeader";
 55: 
 56: /**
 57:  * CardTitle component - Main title within CardHeader
 58:  */
 59: const CardTitle = React.forwardRef<
 60:   HTMLParagraphElement,
 61:   React.HTMLAttributes<HTMLHeadingElement>
 62: >(({ className, ...props }, ref) => (
 63:   <h3
 64:     ref={ref}
 65:     className={cn("font-semibold leading-none tracking-tight", className)}
 66:     {...props}
 67:   />
 68: ));
 69: CardTitle.displayName = "CardTitle";
 70: 
 71: /**
 72:  * CardDescription component - Descriptive text within CardHeader
 73:  */
 74: const CardDescription = React.forwardRef<
 75:   HTMLParagraphElement,
 76:   React.HTMLAttributes<HTMLParagraphElement>
 77: >(({ className, ...props }, ref) => (
 78:   <p
 79:     ref={ref}
 80:     className={cn("text-sm text-muted-foreground", className)}
 81:     {...props}
 82:   />
 83: ));
 84: CardDescription.displayName = "CardDescription";
 85: 
 86: /**
 87:  * CardContent component - Main content area of a card
 88:  */
 89: const CardContent = React.forwardRef<
 90:   HTMLDivElement,
 91:   React.HTMLAttributes<HTMLDivElement>
 92: >(({ className, ...props }, ref) => (
 93:   <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
 94: ));
 95: CardContent.displayName = "CardContent";
 96: 
 97: /**
 98:  * CardFooter component - Bottom section of a card
 99:  */
100: const CardFooter = React.forwardRef<
101:   HTMLDivElement,
102:   React.HTMLAttributes<HTMLDivElement>
103: >(({ className, ...props }, ref) => (
104:   <div
105:     ref={ref}
106:     className={cn("flex items-center p-6 pt-0", className)}
107:     {...props}
108:   />
109: ));
110: CardFooter.displayName = "CardFooter";
111: 
112: export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };
````

## File: src/components/ui/dialog.tsx
````typescript
  1: import * as React from "react"
  2: import * as DialogPrimitive from "@radix-ui/react-dialog"
  3: import { X } from "lucide-react"
  4: import { cn } from "@/lib/utils"
  5: 
  6: const Dialog = DialogPrimitive.Root
  7: 
  8: const DialogTrigger = DialogPrimitive.Trigger
  9: 
 10: const DialogPortal = DialogPrimitive.Portal
 11: 
 12: const DialogClose = DialogPrimitive.Close
 13: 
 14: const DialogOverlay = React.forwardRef<
 15:   React.ElementRef<typeof DialogPrimitive.Overlay>,
 16:   React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
 17: >(({ className, ...props }, ref) => (
 18:   <DialogPrimitive.Overlay
 19:     ref={ref}
 20:     className={cn(
 21:       "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
 22:       className
 23:     )}
 24:     {...props}
 25:   />
 26: ))
 27: DialogOverlay.displayName = DialogPrimitive.Overlay.displayName
 28: 
 29: const DialogContent = React.forwardRef<
 30:   React.ElementRef<typeof DialogPrimitive.Content>,
 31:   React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
 32: >(({ className, children, ...props }, ref) => (
 33:   <DialogPortal>
 34:     <DialogOverlay />
 35:     <DialogPrimitive.Content
 36:       ref={ref}
 37:       className={cn(
 38:         "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
 39:         className
 40:       )}
 41:       {...props}
 42:     >
 43:       {children}
 44:       <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
 45:         <X className="h-4 w-4" />
 46:         <span className="sr-only">Close</span>
 47:       </DialogPrimitive.Close>
 48:     </DialogPrimitive.Content>
 49:   </DialogPortal>
 50: ))
 51: DialogContent.displayName = DialogPrimitive.Content.displayName
 52: 
 53: const DialogHeader = ({
 54:   className,
 55:   ...props
 56: }: React.HTMLAttributes<HTMLDivElement>) => (
 57:   <div
 58:     className={cn(
 59:       "flex flex-col space-y-1.5 text-center sm:text-left",
 60:       className
 61:     )}
 62:     {...props}
 63:   />
 64: )
 65: DialogHeader.displayName = "DialogHeader"
 66: 
 67: const DialogFooter = ({
 68:   className,
 69:   ...props
 70: }: React.HTMLAttributes<HTMLDivElement>) => (
 71:   <div
 72:     className={cn(
 73:       "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
 74:       className
 75:     )}
 76:     {...props}
 77:   />
 78: )
 79: DialogFooter.displayName = "DialogFooter"
 80: 
 81: const DialogTitle = React.forwardRef<
 82:   React.ElementRef<typeof DialogPrimitive.Title>,
 83:   React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
 84: >(({ className, ...props }, ref) => (
 85:   <DialogPrimitive.Title
 86:     ref={ref}
 87:     className={cn(
 88:       "text-lg font-semibold leading-none tracking-tight",
 89:       className
 90:     )}
 91:     {...props}
 92:   />
 93: ))
 94: DialogTitle.displayName = DialogPrimitive.Title.displayName
 95: 
 96: const DialogDescription = React.forwardRef<
 97:   React.ElementRef<typeof DialogPrimitive.Description>,
 98:   React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
 99: >(({ className, ...props }, ref) => (
100:   <DialogPrimitive.Description
101:     ref={ref}
102:     className={cn("text-sm text-muted-foreground", className)}
103:     {...props}
104:   />
105: ))
106: DialogDescription.displayName = DialogPrimitive.Description.displayName
107: 
108: export {
109:   Dialog,
110:   DialogPortal,
111:   DialogOverlay,
112:   DialogClose,
113:   DialogTrigger,
114:   DialogContent,
115:   DialogHeader,
116:   DialogFooter,
117:   DialogTitle,
118:   DialogDescription,
119: }
````

## File: src/components/ui/dropdown-menu.tsx
````typescript
  1: import * as React from "react"
  2: import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
  3: import { Check, ChevronRight, Circle } from "lucide-react"
  4: 
  5: import { cn } from "@/lib/utils"
  6: 
  7: const DropdownMenu = DropdownMenuPrimitive.Root
  8: 
  9: const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger
 10: 
 11: const DropdownMenuGroup = DropdownMenuPrimitive.Group
 12: 
 13: const DropdownMenuPortal = DropdownMenuPrimitive.Portal
 14: 
 15: const DropdownMenuSub = DropdownMenuPrimitive.Sub
 16: 
 17: const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup
 18: 
 19: const DropdownMenuSubTrigger = React.forwardRef<
 20:   React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
 21:   React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
 22:     inset?: boolean
 23:   }
 24: >(({ className, inset, children, ...props }, ref) => (
 25:   <DropdownMenuPrimitive.SubTrigger
 26:     ref={ref}
 27:     className={cn(
 28:       "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
 29:       inset && "pl-8",
 30:       className
 31:     )}
 32:     {...props}
 33:   >
 34:     {children}
 35:     <ChevronRight className="ml-auto h-4 w-4" />
 36:   </DropdownMenuPrimitive.SubTrigger>
 37: ))
 38: DropdownMenuSubTrigger.displayName =
 39:   DropdownMenuPrimitive.SubTrigger.displayName
 40: 
 41: const DropdownMenuSubContent = React.forwardRef<
 42:   React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
 43:   React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
 44: >(({ className, ...props }, ref) => (
 45:   <DropdownMenuPrimitive.SubContent
 46:     ref={ref}
 47:     className={cn(
 48:       "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
 49:       className
 50:     )}
 51:     {...props}
 52:   />
 53: ))
 54: DropdownMenuSubContent.displayName =
 55:   DropdownMenuPrimitive.SubContent.displayName
 56: 
 57: const DropdownMenuContent = React.forwardRef<
 58:   React.ElementRef<typeof DropdownMenuPrimitive.Content>,
 59:   React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
 60: >(({ className, sideOffset = 4, ...props }, ref) => (
 61:   <DropdownMenuPrimitive.Portal>
 62:     <DropdownMenuPrimitive.Content
 63:       ref={ref}
 64:       sideOffset={sideOffset}
 65:       className={cn(
 66:         "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
 67:         className
 68:       )}
 69:       {...props}
 70:     />
 71:   </DropdownMenuPrimitive.Portal>
 72: ))
 73: DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName
 74: 
 75: const DropdownMenuItem = React.forwardRef<
 76:   React.ElementRef<typeof DropdownMenuPrimitive.Item>,
 77:   React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
 78:     inset?: boolean
 79:   }
 80: >(({ className, inset, ...props }, ref) => (
 81:   <DropdownMenuPrimitive.Item
 82:     ref={ref}
 83:     className={cn(
 84:       "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
 85:       inset && "pl-8",
 86:       className
 87:     )}
 88:     {...props}
 89:   />
 90: ))
 91: DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName
 92: 
 93: const DropdownMenuCheckboxItem = React.forwardRef<
 94:   React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
 95:   React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
 96: >(({ className, children, checked, ...props }, ref) => (
 97:   <DropdownMenuPrimitive.CheckboxItem
 98:     ref={ref}
 99:     className={cn(
100:       "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
101:       className
102:     )}
103:     checked={checked}
104:     {...props}
105:   >
106:     <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
107:       <DropdownMenuPrimitive.ItemIndicator>
108:         <Check className="h-4 w-4" />
109:       </DropdownMenuPrimitive.ItemIndicator>
110:     </span>
111:     {children}
112:   </DropdownMenuPrimitive.CheckboxItem>
113: ))
114: DropdownMenuCheckboxItem.displayName =
115:   DropdownMenuPrimitive.CheckboxItem.displayName
116: 
117: const DropdownMenuRadioItem = React.forwardRef<
118:   React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
119:   React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
120: >(({ className, children, ...props }, ref) => (
121:   <DropdownMenuPrimitive.RadioItem
122:     ref={ref}
123:     className={cn(
124:       "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
125:       className
126:     )}
127:     {...props}
128:   >
129:     <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
130:       <DropdownMenuPrimitive.ItemIndicator>
131:         <Circle className="h-2 w-2 fill-current" />
132:       </DropdownMenuPrimitive.ItemIndicator>
133:     </span>
134:     {children}
135:   </DropdownMenuPrimitive.RadioItem>
136: ))
137: DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName
138: 
139: const DropdownMenuLabel = React.forwardRef<
140:   React.ElementRef<typeof DropdownMenuPrimitive.Label>,
141:   React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
142:     inset?: boolean
143:   }
144: >(({ className, inset, ...props }, ref) => (
145:   <DropdownMenuPrimitive.Label
146:     ref={ref}
147:     className={cn(
148:       "px-2 py-1.5 text-sm font-semibold",
149:       inset && "pl-8",
150:       className
151:     )}
152:     {...props}
153:   />
154: ))
155: DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName
156: 
157: const DropdownMenuSeparator = React.forwardRef<
158:   React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
159:   React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
160: >(({ className, ...props }, ref) => (
161:   <DropdownMenuPrimitive.Separator
162:     ref={ref}
163:     className={cn("-mx-1 my-1 h-px bg-muted", className)}
164:     {...props}
165:   />
166: ))
167: DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName
168: 
169: const DropdownMenuShortcut = ({
170:   className,
171:   ...props
172: }: React.HTMLAttributes<HTMLSpanElement>) => {
173:   return (
174:     <span
175:       className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
176:       {...props}
177:     />
178:   )
179: }
180: DropdownMenuShortcut.displayName = "DropdownMenuShortcut"
181: 
182: export {
183:   DropdownMenu,
184:   DropdownMenuTrigger,
185:   DropdownMenuContent,
186:   DropdownMenuItem,
187:   DropdownMenuCheckboxItem,
188:   DropdownMenuRadioItem,
189:   DropdownMenuLabel,
190:   DropdownMenuSeparator,
191:   DropdownMenuShortcut,
192:   DropdownMenuGroup,
193:   DropdownMenuPortal,
194:   DropdownMenuSub,
195:   DropdownMenuSubContent,
196:   DropdownMenuSubTrigger,
197:   DropdownMenuRadioGroup,
198: }
````

## File: src/components/ui/input.tsx
````typescript
 1: import * as React from "react";
 2: import { cn } from "@/lib/utils";
 3: 
 4: export interface InputProps
 5:   extends React.InputHTMLAttributes<HTMLInputElement> {}
 6: 
 7: /**
 8:  * Input component for text/number inputs
 9:  * 
10:  * @example
11:  * <Input type="text" placeholder="Enter value..." />
12:  */
13: const Input = React.forwardRef<HTMLInputElement, InputProps>(
14:   ({ className, type, ...props }, ref) => {
15:     return (
16:       <input
17:         type={type}
18:         className={cn(
19:           "flex h-9 w-full rounded-md border px-3 py-1 text-sm shadow-sm transition-colors",
20:           "file:border-0 file:bg-transparent file:text-sm file:font-medium",
21:           "focus-visible:outline-none focus-visible:ring-1",
22:           "disabled:cursor-not-allowed disabled:opacity-50",
23:           className
24:         )}
25:         style={{
26:           borderColor: "var(--color-input)",
27:           backgroundColor: "transparent",
28:           color: "var(--color-foreground)"
29:         }}
30:         ref={ref}
31:         {...props}
32:       />
33:     );
34:   }
35: );
36: 
37: Input.displayName = "Input";
38: 
39: export { Input };
````

## File: src/components/ui/label.tsx
````typescript
 1: import * as React from "react";
 2: import { cn } from "@/lib/utils";
 3: 
 4: export interface LabelProps
 5:   extends React.LabelHTMLAttributes<HTMLLabelElement> {}
 6: 
 7: /**
 8:  * Label component for form fields
 9:  * 
10:  * @example
11:  * <Label htmlFor="input-id">Field Label</Label>
12:  */
13: const Label = React.forwardRef<HTMLLabelElement, LabelProps>(
14:   ({ className, ...props }, ref) => (
15:     <label
16:       ref={ref}
17:       className={cn(
18:         "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
19:         className
20:       )}
21:       {...props}
22:     />
23:   )
24: );
25: 
26: Label.displayName = "Label";
27: 
28: export { Label };
````

## File: src/components/ui/pagination.tsx
````typescript
 1: import * as React from "react";
 2: import { ChevronLeft, ChevronRight } from "lucide-react";
 3: import { Button } from "@/components/ui/button";
 4: import { cn } from "@/lib/utils";
 5: 
 6: interface PaginationProps {
 7:   /**
 8:    * Current page number (1-indexed)
 9:    */
10:   currentPage: number;
11:   /**
12:    * Total number of pages
13:    */
14:   totalPages: number;
15:   /**
16:    * Callback when page changes
17:    */
18:   onPageChange: (page: number) => void;
19:   /**
20:    * Optional className for styling
21:    */
22:   className?: string;
23: }
24: 
25: /**
26:  * Pagination component for navigating through paginated content
27:  * 
28:  * @example
29:  * <Pagination
30:  *   currentPage={1}
31:  *   totalPages={5}
32:  *   onPageChange={(page) => setCurrentPage(page)}
33:  * />
34:  */
35: export const Pagination: React.FC<PaginationProps> = ({
36:   currentPage,
37:   totalPages,
38:   onPageChange,
39:   className,
40: }) => {
41:   if (totalPages <= 1) {
42:     return null;
43:   }
44: 
45:   return (
46:     <div className={cn("flex items-center justify-center space-x-2", className)}>
47:       <Button
48:         variant="outline"
49:         size="icon"
50:         onClick={() => onPageChange(currentPage - 1)}
51:         disabled={currentPage <= 1}
52:         className="h-8 w-8"
53:       >
54:         <ChevronLeft className="h-4 w-4" />
55:       </Button>
56:       
57:       <span className="text-sm text-muted-foreground">
58:         Page {currentPage} of {totalPages}
59:       </span>
60:       
61:       <Button
62:         variant="outline"
63:         size="icon"
64:         onClick={() => onPageChange(currentPage + 1)}
65:         disabled={currentPage >= totalPages}
66:         className="h-8 w-8"
67:       >
68:         <ChevronRight className="h-4 w-4" />
69:       </Button>
70:     </div>
71:   );
72: };
````

## File: src/components/ui/popover.tsx
````typescript
  1: import * as React from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import { cn } from "@/lib/utils";
  4: 
  5: interface PopoverProps {
  6:   /**
  7:    * The trigger element
  8:    */
  9:   trigger: React.ReactNode;
 10:   /**
 11:    * The content to display in the popover
 12:    */
 13:   content: React.ReactNode;
 14:   /**
 15:    * Whether the popover is open
 16:    */
 17:   open?: boolean;
 18:   /**
 19:    * Callback when the open state changes
 20:    */
 21:   onOpenChange?: (open: boolean) => void;
 22:   /**
 23:    * Optional className for the content
 24:    */
 25:   className?: string;
 26:   /**
 27:    * Alignment of the popover relative to the trigger
 28:    */
 29:   align?: "start" | "center" | "end";
 30:   /**
 31:    * Side of the trigger to display the popover
 32:    */
 33:   side?: "top" | "bottom";
 34: }
 35: 
 36: /**
 37:  * Popover component for displaying floating content
 38:  * 
 39:  * @example
 40:  * <Popover
 41:  *   trigger={<Button>Click me</Button>}
 42:  *   content={<div>Popover content</div>}
 43:  *   side="top"
 44:  * />
 45:  */
 46: export const Popover: React.FC<PopoverProps> = ({
 47:   trigger,
 48:   content,
 49:   open: controlledOpen,
 50:   onOpenChange,
 51:   className,
 52:   align = "center",
 53:   side = "bottom",
 54: }) => {
 55:   const [internalOpen, setInternalOpen] = React.useState(false);
 56:   const open = controlledOpen !== undefined ? controlledOpen : internalOpen;
 57:   const setOpen = onOpenChange || setInternalOpen;
 58:   
 59:   const triggerRef = React.useRef<HTMLDivElement>(null);
 60:   const contentRef = React.useRef<HTMLDivElement>(null);
 61:   
 62:   // Close on click outside
 63:   React.useEffect(() => {
 64:     if (!open) return;
 65:     
 66:     const handleClickOutside = (event: MouseEvent) => {
 67:       if (
 68:         triggerRef.current &&
 69:         contentRef.current &&
 70:         !triggerRef.current.contains(event.target as Node) &&
 71:         !contentRef.current.contains(event.target as Node)
 72:       ) {
 73:         setOpen(false);
 74:       }
 75:     };
 76:     
 77:     document.addEventListener("mousedown", handleClickOutside);
 78:     return () => document.removeEventListener("mousedown", handleClickOutside);
 79:   }, [open, setOpen]);
 80:   
 81:   // Close on escape
 82:   React.useEffect(() => {
 83:     if (!open) return;
 84:     
 85:     const handleEscape = (event: KeyboardEvent) => {
 86:       if (event.key === "Escape") {
 87:         setOpen(false);
 88:       }
 89:     };
 90:     
 91:     document.addEventListener("keydown", handleEscape);
 92:     return () => document.removeEventListener("keydown", handleEscape);
 93:   }, [open, setOpen]);
 94:   
 95:   const alignClass = {
 96:     start: "left-0",
 97:     center: "left-1/2 -translate-x-1/2",
 98:     end: "right-0",
 99:   }[align];
100:   
101:   const sideClass = side === "top" ? "bottom-full mb-2" : "top-full mt-2";
102:   const animationY = side === "top" ? { initial: 10, exit: 10 } : { initial: -10, exit: -10 };
103:   
104:   return (
105:     <div className="relative inline-block">
106:       <div
107:         ref={triggerRef}
108:         onClick={() => setOpen(!open)}
109:       >
110:         {trigger}
111:       </div>
112:       
113:       <AnimatePresence>
114:         {open && (
115:           <motion.div
116:             ref={contentRef}
117:             initial={{ opacity: 0, scale: 0.95, y: animationY.initial }}
118:             animate={{ opacity: 1, scale: 1, y: 0 }}
119:             exit={{ opacity: 0, scale: 0.95, y: animationY.exit }}
120:             transition={{ duration: 0.15 }}
121:             className={cn(
122:               "absolute z-50 min-w-[200px] rounded-md border border-border bg-popover p-4 text-popover-foreground shadow-md",
123:               sideClass,
124:               alignClass,
125:               className
126:             )}
127:           >
128:             {content}
129:           </motion.div>
130:         )}
131:       </AnimatePresence>
132:     </div>
133:   );
134: };
````

## File: src/components/ui/radio-group.tsx
````typescript
 1: import * as React from "react";
 2: import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
 3: import { Circle } from "lucide-react";
 4: import { cn } from "@/lib/utils";
 5: 
 6: const RadioGroup = React.forwardRef<
 7:   React.ElementRef<typeof RadioGroupPrimitive.Root>,
 8:   React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
 9: >(({ className, ...props }, ref) => {
10:   return (
11:     <RadioGroupPrimitive.Root
12:       className={cn("grid gap-2", className)}
13:       {...props}
14:       ref={ref}
15:     />
16:   );
17: });
18: RadioGroup.displayName = RadioGroupPrimitive.Root.displayName;
19: 
20: const RadioGroupItem = React.forwardRef<
21:   React.ElementRef<typeof RadioGroupPrimitive.Item>,
22:   React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
23: >(({ className, ...props }, ref) => {
24:   return (
25:     <RadioGroupPrimitive.Item
26:       ref={ref}
27:       className={cn(
28:         "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
29:         className
30:       )}
31:       {...props}
32:     >
33:       <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
34:         <Circle className="h-2.5 w-2.5 fill-current text-current" />
35:       </RadioGroupPrimitive.Indicator>
36:     </RadioGroupPrimitive.Item>
37:   );
38: });
39: RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName;
40: 
41: export { RadioGroup, RadioGroupItem };
````

## File: src/components/ui/scroll-area.tsx
````typescript
 1: import * as React from "react";
 2: import { cn } from "@/lib/utils";
 3: 
 4: interface ScrollAreaProps extends React.HTMLAttributes<HTMLDivElement> {
 5:   /**
 6:    * Optional className for styling
 7:    */
 8:   className?: string;
 9:   /**
10:    * Children to render inside the scroll area
11:    */
12:   children: React.ReactNode;
13: }
14: 
15: /**
16:  * ScrollArea component for scrollable content with custom scrollbar styling
17:  * 
18:  * @example
19:  * <ScrollArea className="h-[200px]">
20:  *   <div>Scrollable content here</div>
21:  * </ScrollArea>
22:  */
23: export const ScrollArea = React.forwardRef<HTMLDivElement, ScrollAreaProps>(
24:   ({ className, children, ...props }, ref) => {
25:     return (
26:       <div
27:         ref={ref}
28:         className={cn("relative overflow-auto", className)}
29:         {...props}
30:       >
31:         {children}
32:       </div>
33:     );
34:   }
35: );
36: 
37: ScrollArea.displayName = "ScrollArea";
````

## File: src/components/ui/select.tsx
````typescript
  1: import * as React from "react";
  2: import * as SelectPrimitive from "@radix-ui/react-select";
  3: import { Check, ChevronDown, ChevronUp } from "lucide-react";
  4: import { cn } from "@/lib/utils";
  5: 
  6: const Select = SelectPrimitive.Root;
  7: 
  8: const SelectGroup = SelectPrimitive.Group;
  9: 
 10: const SelectValue = SelectPrimitive.Value;
 11: 
 12: const SelectTrigger = React.forwardRef<
 13:   React.ElementRef<typeof SelectPrimitive.Trigger>,
 14:   React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
 15: >(({ className, children, ...props }, ref) => (
 16:   <SelectPrimitive.Trigger
 17:     ref={ref}
 18:     className={cn(
 19:       "flex h-9 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
 20:       className
 21:     )}
 22:     {...props}
 23:   >
 24:     {children}
 25:     <SelectPrimitive.Icon asChild>
 26:       <ChevronDown className="h-4 w-4 opacity-50" />
 27:     </SelectPrimitive.Icon>
 28:   </SelectPrimitive.Trigger>
 29: ));
 30: SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;
 31: 
 32: const SelectScrollUpButton = React.forwardRef<
 33:   React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
 34:   React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
 35: >(({ className, ...props }, ref) => (
 36:   <SelectPrimitive.ScrollUpButton
 37:     ref={ref}
 38:     className={cn(
 39:       "flex cursor-default items-center justify-center py-1",
 40:       className
 41:     )}
 42:     {...props}
 43:   >
 44:     <ChevronUp className="h-4 w-4" />
 45:   </SelectPrimitive.ScrollUpButton>
 46: ));
 47: SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;
 48: 
 49: const SelectScrollDownButton = React.forwardRef<
 50:   React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
 51:   React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
 52: >(({ className, ...props }, ref) => (
 53:   <SelectPrimitive.ScrollDownButton
 54:     ref={ref}
 55:     className={cn(
 56:       "flex cursor-default items-center justify-center py-1",
 57:       className
 58:     )}
 59:     {...props}
 60:   >
 61:     <ChevronDown className="h-4 w-4" />
 62:   </SelectPrimitive.ScrollDownButton>
 63: ));
 64: SelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName;
 65: 
 66: const SelectContent = React.forwardRef<
 67:   React.ElementRef<typeof SelectPrimitive.Content>,
 68:   React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
 69: >(({ className, children, position = "popper", ...props }, ref) => (
 70:   <SelectPrimitive.Portal>
 71:     <SelectPrimitive.Content
 72:       ref={ref}
 73:       className={cn(
 74:         "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
 75:         position === "popper" &&
 76:           "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
 77:         className
 78:       )}
 79:       position={position}
 80:       {...props}
 81:     >
 82:       <SelectScrollUpButton />
 83:       <SelectPrimitive.Viewport
 84:         className={cn(
 85:           "p-1",
 86:           position === "popper" &&
 87:             "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
 88:         )}
 89:       >
 90:         {children}
 91:       </SelectPrimitive.Viewport>
 92:       <SelectScrollDownButton />
 93:     </SelectPrimitive.Content>
 94:   </SelectPrimitive.Portal>
 95: ));
 96: SelectContent.displayName = SelectPrimitive.Content.displayName;
 97: 
 98: const SelectLabel = React.forwardRef<
 99:   React.ElementRef<typeof SelectPrimitive.Label>,
100:   React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
101: >(({ className, ...props }, ref) => (
102:   <SelectPrimitive.Label
103:     ref={ref}
104:     className={cn("px-2 py-1.5 text-sm font-semibold", className)}
105:     {...props}
106:   />
107: ));
108: SelectLabel.displayName = SelectPrimitive.Label.displayName;
109: 
110: const SelectItem = React.forwardRef<
111:   React.ElementRef<typeof SelectPrimitive.Item>,
112:   React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
113: >(({ className, children, ...props }, ref) => (
114:   <SelectPrimitive.Item
115:     ref={ref}
116:     className={cn(
117:       "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
118:       className
119:     )}
120:     {...props}
121:   >
122:     <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
123:       <SelectPrimitive.ItemIndicator>
124:         <Check className="h-4 w-4" />
125:       </SelectPrimitive.ItemIndicator>
126:     </span>
127:     <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
128:   </SelectPrimitive.Item>
129: ));
130: SelectItem.displayName = SelectPrimitive.Item.displayName;
131: 
132: const SelectSeparator = React.forwardRef<
133:   React.ElementRef<typeof SelectPrimitive.Separator>,
134:   React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
135: >(({ className, ...props }, ref) => (
136:   <SelectPrimitive.Separator
137:     ref={ref}
138:     className={cn("-mx-1 my-1 h-px bg-muted", className)}
139:     {...props}
140:   />
141: ));
142: SelectSeparator.displayName = SelectPrimitive.Separator.displayName;
143: 
144: // Legacy interface for backward compatibility
145: export interface SelectOption {
146:   value: string;
147:   label: string;
148: }
149: 
150: export interface SelectProps {
151:   /**
152:    * The current value
153:    */
154:   value: string;
155:   /**
156:    * Callback when value changes
157:    */
158:   onValueChange: (value: string) => void;
159:   /**
160:    * Available options
161:    */
162:   options: SelectOption[];
163:   /**
164:    * Placeholder text
165:    */
166:   placeholder?: string;
167:   /**
168:    * Whether the select is disabled
169:    */
170:   disabled?: boolean;
171:   /**
172:    * Additional CSS classes
173:    */
174:   className?: string;
175: }
176: 
177: /**
178:  * Simple select dropdown component
179:  * 
180:  * @example
181:  * <Select
182:  *   value={selected}
183:  *   onValueChange={setSelected}
184:  *   options={[
185:  *     { value: "option1", label: "Option 1" },
186:  *     { value: "option2", label: "Option 2" }
187:  *   ]}
188:  * />
189:  */
190: const SimpleSelect: React.FC<SelectProps> = ({
191:   value,
192:   onValueChange,
193:   options,
194:   placeholder = "Select an option",
195:   disabled = false,
196:   className,
197: }) => {
198:   return (
199:     <Select value={value} onValueChange={onValueChange} disabled={disabled}>
200:       <SelectTrigger className={className}>
201:         <SelectValue placeholder={placeholder} />
202:       </SelectTrigger>
203:       <SelectContent>
204:         {options.map((option) => (
205:           <SelectItem key={option.value} value={option.value}>
206:             {option.label}
207:           </SelectItem>
208:         ))}
209:       </SelectContent>
210:     </Select>
211:   );
212: };
213: 
214: export {
215:   Select,
216:   SelectGroup,
217:   SelectValue,
218:   SelectTrigger,
219:   SelectContent,
220:   SelectLabel,
221:   SelectItem,
222:   SelectSeparator,
223:   SelectScrollUpButton,
224:   SelectScrollDownButton,
225:   SimpleSelect as SelectComponent,
226: };
````

## File: src/components/ui/split-pane.tsx
````typescript
  1: import React, { useState, useRef, useEffect, useCallback } from "react";
  2: import { cn } from "@/lib/utils";
  3: 
  4: interface SplitPaneProps {
  5:   /**
  6:    * Content for the left pane
  7:    */
  8:   left: React.ReactNode;
  9:   /**
 10:    * Content for the right pane
 11:    */
 12:   right: React.ReactNode;
 13:   /**
 14:    * Initial split position as percentage (0-100)
 15:    * @default 50
 16:    */
 17:   initialSplit?: number;
 18:   /**
 19:    * Minimum width for left pane in pixels
 20:    * @default 200
 21:    */
 22:   minLeftWidth?: number;
 23:   /**
 24:    * Minimum width for right pane in pixels
 25:    * @default 200
 26:    */
 27:   minRightWidth?: number;
 28:   /**
 29:    * Callback when split position changes
 30:    */
 31:   onSplitChange?: (position: number) => void;
 32:   /**
 33:    * Optional className for styling
 34:    */
 35:   className?: string;
 36: }
 37: 
 38: /**
 39:  * Resizable split pane component for side-by-side layouts
 40:  * 
 41:  * @example
 42:  * <SplitPane
 43:  *   left={<div>Left content</div>}
 44:  *   right={<div>Right content</div>}
 45:  *   initialSplit={60}
 46:  *   onSplitChange={(pos) => console.log('Split at', pos)}
 47:  * />
 48:  */
 49: export const SplitPane: React.FC<SplitPaneProps> = ({
 50:   left,
 51:   right,
 52:   initialSplit = 50,
 53:   minLeftWidth = 200,
 54:   minRightWidth = 200,
 55:   onSplitChange,
 56:   className,
 57: }) => {
 58:   const [splitPosition, setSplitPosition] = useState(initialSplit);
 59:   const [isDragging, setIsDragging] = useState(false);
 60:   const containerRef = useRef<HTMLDivElement>(null);
 61:   const dragStartX = useRef(0);
 62:   const dragStartSplit = useRef(0);
 63:   const animationFrameRef = useRef<number | null>(null);
 64: 
 65:   // Handle mouse down on divider
 66:   const handleMouseDown = (e: React.MouseEvent) => {
 67:     e.preventDefault();
 68:     setIsDragging(true);
 69:     dragStartX.current = e.clientX;
 70:     dragStartSplit.current = splitPosition;
 71:     document.body.style.cursor = 'col-resize';
 72:     document.body.style.userSelect = 'none';
 73:   };
 74: 
 75:   // Handle mouse move
 76:   const handleMouseMove = useCallback((e: MouseEvent) => {
 77:     if (!isDragging || !containerRef.current) return;
 78: 
 79:     if (animationFrameRef.current) {
 80:       cancelAnimationFrame(animationFrameRef.current);
 81:     }
 82: 
 83:     animationFrameRef.current = requestAnimationFrame(() => {
 84:       const containerWidth = containerRef.current!.offsetWidth;
 85:       const deltaX = e.clientX - dragStartX.current;
 86:       const deltaPercent = (deltaX / containerWidth) * 100;
 87:       const newSplit = dragStartSplit.current + deltaPercent;
 88: 
 89:       // Calculate min/max based on pixel constraints
 90:       const minSplit = (minLeftWidth / containerWidth) * 100;
 91:       const maxSplit = 100 - (minRightWidth / containerWidth) * 100;
 92: 
 93:       const clampedSplit = Math.min(Math.max(newSplit, minSplit), maxSplit);
 94:       setSplitPosition(clampedSplit);
 95:       onSplitChange?.(clampedSplit);
 96:     });
 97:   }, [isDragging, minLeftWidth, minRightWidth, onSplitChange]);
 98: 
 99:   // Handle mouse up
100:   const handleMouseUp = useCallback(() => {
101:     if (animationFrameRef.current) {
102:       cancelAnimationFrame(animationFrameRef.current);
103:     }
104:     setIsDragging(false);
105:     document.body.style.cursor = '';
106:     document.body.style.userSelect = '';
107:   }, []);
108: 
109:   // Add global mouse event listeners
110:   useEffect(() => {
111:     if (isDragging) {
112:       document.addEventListener('mousemove', handleMouseMove);
113:       document.addEventListener('mouseup', handleMouseUp);
114:       return () => {
115:         document.removeEventListener('mousemove', handleMouseMove);
116:         document.removeEventListener('mouseup', handleMouseUp);
117:       };
118:     }
119:   }, [isDragging, handleMouseMove, handleMouseUp]);
120: 
121:   // Handle keyboard navigation
122:   const handleKeyDown = (e: React.KeyboardEvent) => {
123:     if (!containerRef.current) return;
124: 
125:     const step = e.shiftKey ? 10 : 2; // Larger steps with shift
126:     const containerWidth = containerRef.current.offsetWidth;
127:     const minSplit = (minLeftWidth / containerWidth) * 100;
128:     const maxSplit = 100 - (minRightWidth / containerWidth) * 100;
129: 
130:     let newSplit = splitPosition;
131: 
132:     switch (e.key) {
133:       case 'ArrowLeft':
134:         e.preventDefault();
135:         newSplit = Math.max(splitPosition - step, minSplit);
136:         break;
137:       case 'ArrowRight':
138:         e.preventDefault();
139:         newSplit = Math.min(splitPosition + step, maxSplit);
140:         break;
141:       case 'Home':
142:         e.preventDefault();
143:         newSplit = minSplit;
144:         break;
145:       case 'End':
146:         e.preventDefault();
147:         newSplit = maxSplit;
148:         break;
149:       default:
150:         return;
151:     }
152: 
153:     setSplitPosition(newSplit);
154:     onSplitChange?.(newSplit);
155:   };
156: 
157:   return (
158:     <div 
159:       ref={containerRef}
160:       className={cn("flex h-full w-full relative", className)}
161:     >
162:       {/* Left pane */}
163:       <div 
164:         className="h-full overflow-hidden"
165:         style={{ width: `${splitPosition}%` }}
166:       >
167:         {left}
168:       </div>
169: 
170:       {/* Divider */}
171:       <div
172:         className={cn(
173:           "relative flex-shrink-0 group",
174:           "w-1 hover:w-2 transition-all duration-150",
175:           "bg-border hover:bg-primary/50",
176:           "cursor-col-resize",
177:           isDragging && "bg-primary w-2"
178:         )}
179:         onMouseDown={handleMouseDown}
180:         onKeyDown={handleKeyDown}
181:         tabIndex={0}
182:         role="separator"
183:         aria-label="Resize panes"
184:         aria-valuenow={Math.round(splitPosition)}
185:         aria-valuemin={0}
186:         aria-valuemax={100}
187:       >
188:         {/* Expand hit area for easier dragging */}
189:         <div className="absolute inset-y-0 -left-2 -right-2 z-10" />
190:         
191:         {/* Visual indicator dots */}
192:         <div className={cn(
193:           "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2",
194:           "flex flex-col items-center justify-center gap-1",
195:           "opacity-0 group-hover:opacity-100 transition-opacity",
196:           isDragging && "opacity-100"
197:         )}>
198:           <div className="w-1 h-1 bg-primary rounded-full" />
199:           <div className="w-1 h-1 bg-primary rounded-full" />
200:           <div className="w-1 h-1 bg-primary rounded-full" />
201:         </div>
202:       </div>
203: 
204:       {/* Right pane */}
205:       <div 
206:         className="h-full overflow-hidden flex-1"
207:         style={{ width: `${100 - splitPosition}%` }}
208:       >
209:         {right}
210:       </div>
211:     </div>
212:   );
213: };
````

## File: src/components/ui/switch.tsx
````typescript
 1: import * as React from "react";
 2: import { cn } from "@/lib/utils";
 3: 
 4: export interface SwitchProps
 5:   extends React.InputHTMLAttributes<HTMLInputElement> {
 6:   /**
 7:    * Whether the switch is checked
 8:    */
 9:   checked?: boolean;
10:   /**
11:    * Callback when the switch state changes
12:    */
13:   onCheckedChange?: (checked: boolean) => void;
14: }
15: 
16: /**
17:  * Switch component for toggling boolean values
18:  * 
19:  * @example
20:  * <Switch checked={isEnabled} onCheckedChange={setIsEnabled} />
21:  */
22: const Switch = React.forwardRef<HTMLInputElement, SwitchProps>(
23:   ({ className, checked, onCheckedChange, disabled, ...props }, ref) => {
24:     return (
25:       <button
26:         type="button"
27:         role="switch"
28:         aria-checked={checked}
29:         disabled={disabled}
30:         onClick={() => onCheckedChange?.(!checked)}
31:         className={cn(
32:           "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors",
33:           "disabled:cursor-not-allowed disabled:opacity-50",
34:           className
35:         )}
36:         style={{
37:           backgroundColor: checked ? "var(--color-primary)" : "var(--color-muted)"
38:         }}
39:       >
40:         <span
41:           className={cn(
42:             "pointer-events-none block h-4 w-4 rounded-full shadow-lg ring-0 transition-transform",
43:             checked ? "translate-x-4" : "translate-x-0"
44:           )}
45:           style={{
46:             backgroundColor: "var(--color-background)"
47:           }}
48:         />
49:         <input
50:           ref={ref}
51:           type="checkbox"
52:           checked={checked}
53:           disabled={disabled}
54:           className="sr-only"
55:           onChange={() => {}}
56:           {...props}
57:         />
58:       </button>
59:     );
60:   }
61: );
62: 
63: Switch.displayName = "Switch";
64: 
65: export { Switch };
````

## File: src/components/ui/tabs.tsx
````typescript
  1: import * as React from "react";
  2: import { cn } from "@/lib/utils";
  3: 
  4: const TabsContext = React.createContext<{
  5:   value: string;
  6:   onValueChange: (value: string) => void;
  7: }>({
  8:   value: "",
  9:   onValueChange: () => {},
 10: });
 11: 
 12: export interface TabsProps {
 13:   /**
 14:    * The controlled value of the tab to activate
 15:    */
 16:   value: string;
 17:   /**
 18:    * Event handler called when the value changes
 19:    */
 20:   onValueChange: (value: string) => void;
 21:   /**
 22:    * The tabs and their content
 23:    */
 24:   children: React.ReactNode;
 25:   /**
 26:    * Additional CSS classes
 27:    */
 28:   className?: string;
 29: }
 30: 
 31: /**
 32:  * Root tabs component
 33:  * 
 34:  * @example
 35:  * <Tabs value={activeTab} onValueChange={setActiveTab}>
 36:  *   <TabsList>
 37:  *     <TabsTrigger value="general">General</TabsTrigger>
 38:  *   </TabsList>
 39:  *   <TabsContent value="general">Content</TabsContent>
 40:  * </Tabs>
 41:  */
 42: const Tabs: React.FC<TabsProps> = ({
 43:   value,
 44:   onValueChange,
 45:   children,
 46:   className,
 47: }) => {
 48:   return (
 49:     <TabsContext.Provider value={{ value, onValueChange }}>
 50:       <div className={cn("w-full", className)}>{children}</div>
 51:     </TabsContext.Provider>
 52:   );
 53: };
 54: 
 55: export interface TabsListProps {
 56:   children: React.ReactNode;
 57:   className?: string;
 58: }
 59: 
 60: /**
 61:  * Container for tab triggers
 62:  */
 63: const TabsList = React.forwardRef<HTMLDivElement, TabsListProps>(
 64:   ({ className, ...props }, ref) => (
 65:     <div
 66:       ref={ref}
 67:       className={cn(
 68:         "flex h-9 items-center justify-start rounded-lg p-1",
 69:         className
 70:       )}
 71:       style={{
 72:         backgroundColor: "var(--color-muted)",
 73:         color: "var(--color-muted-foreground)"
 74:       }}
 75:       {...props}
 76:     />
 77:   )
 78: );
 79: 
 80: TabsList.displayName = "TabsList";
 81: 
 82: export interface TabsTriggerProps {
 83:   value: string;
 84:   children: React.ReactNode;
 85:   className?: string;
 86:   disabled?: boolean;
 87: }
 88: 
 89: /**
 90:  * Individual tab trigger button
 91:  */
 92: const TabsTrigger = React.forwardRef<
 93:   HTMLButtonElement,
 94:   TabsTriggerProps
 95: >(({ className, value, disabled, ...props }, ref) => {
 96:   const { value: selectedValue, onValueChange } = React.useContext(TabsContext);
 97:   const isSelected = selectedValue === value;
 98: 
 99:   return (
100:     <button
101:       ref={ref}
102:       type="button"
103:       role="tab"
104:       aria-selected={isSelected}
105:       disabled={disabled}
106:       onClick={() => onValueChange(value)}
107:       className={cn(
108:         "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium transition-all",
109:         "disabled:pointer-events-none disabled:opacity-50",
110:         className
111:       )}
112:       style={{
113:         backgroundColor: isSelected ? "var(--color-background)" : "transparent",
114:         color: isSelected ? "var(--color-foreground)" : "inherit",
115:         boxShadow: isSelected ? "0 1px 2px rgba(0,0,0,0.1)" : "none"
116:       }}
117:       {...props}
118:     />
119:   );
120: });
121: 
122: TabsTrigger.displayName = "TabsTrigger";
123: 
124: export interface TabsContentProps {
125:   value: string;
126:   children: React.ReactNode;
127:   className?: string;
128: }
129: 
130: /**
131:  * Tab content panel
132:  */
133: const TabsContent = React.forwardRef<
134:   HTMLDivElement,
135:   TabsContentProps
136: >(({ className, value, ...props }, ref) => {
137:   const { value: selectedValue } = React.useContext(TabsContext);
138:   const isSelected = selectedValue === value;
139: 
140:   if (!isSelected) return null;
141: 
142:   return (
143:     <div
144:       ref={ref}
145:       role="tabpanel"
146:       className={cn(
147:         "mt-2",
148:         className
149:       )}
150:       {...props}
151:     />
152:   );
153: });
154: 
155: TabsContent.displayName = "TabsContent";
156: 
157: export { Tabs, TabsList, TabsTrigger, TabsContent };
````

## File: src/components/ui/textarea.tsx
````typescript
 1: import * as React from "react"
 2: import { cn } from "@/lib/utils"
 3: 
 4: export interface TextareaProps
 5:   extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}
 6: 
 7: const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
 8:   ({ className, ...props }, ref) => {
 9:     return (
10:       <textarea
11:         className={cn(
12:           "flex w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
13:           className
14:         )}
15:         ref={ref}
16:         {...props}
17:       />
18:     )
19:   }
20: )
21: Textarea.displayName = "Textarea"
22: 
23: export { Textarea }
````

## File: src/components/ui/toast.tsx
````typescript
  1: import * as React from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import { X, CheckCircle, AlertCircle, Info } from "lucide-react";
  4: import { cn } from "@/lib/utils";
  5: 
  6: export type ToastType = "success" | "error" | "info";
  7: 
  8: interface ToastProps {
  9:   /**
 10:    * The message to display
 11:    */
 12:   message: string;
 13:   /**
 14:    * The type of toast
 15:    */
 16:   type?: ToastType;
 17:   /**
 18:    * Duration in milliseconds before auto-dismiss
 19:    */
 20:   duration?: number;
 21:   /**
 22:    * Callback when the toast is dismissed
 23:    */
 24:   onDismiss?: () => void;
 25:   /**
 26:    * Optional className for styling
 27:    */
 28:   className?: string;
 29: }
 30: 
 31: /**
 32:  * Toast component for showing temporary notifications
 33:  * 
 34:  * @example
 35:  * <Toast
 36:  *   message="File saved successfully"
 37:  *   type="success"
 38:  *   duration={3000}
 39:  *   onDismiss={() => setShowToast(false)}
 40:  * />
 41:  */
 42: export const Toast: React.FC<ToastProps> = ({
 43:   message,
 44:   type = "info",
 45:   duration = 3000,
 46:   onDismiss,
 47:   className,
 48: }) => {
 49:   React.useEffect(() => {
 50:     if (duration && duration > 0) {
 51:       const timer = setTimeout(() => {
 52:         onDismiss?.();
 53:       }, duration);
 54:       
 55:       return () => clearTimeout(timer);
 56:     }
 57:   }, [duration, onDismiss]);
 58:   
 59:   const icons = {
 60:     success: <CheckCircle className="h-4 w-4" />,
 61:     error: <AlertCircle className="h-4 w-4" />,
 62:     info: <Info className="h-4 w-4" />,
 63:   };
 64:   
 65:   const colors = {
 66:     success: "text-green-500",
 67:     error: "text-red-500",
 68:     info: "text-primary",
 69:   };
 70:   
 71:   return (
 72:     <motion.div
 73:       initial={{ opacity: 0, y: 50, scale: 0.95 }}
 74:       animate={{ opacity: 1, y: 0, scale: 1 }}
 75:       exit={{ opacity: 0, y: 20, scale: 0.95 }}
 76:       transition={{ duration: 0.2 }}
 77:       className={cn(
 78:         "flex items-center space-x-3 rounded-lg border border-border bg-card px-4 py-3 shadow-lg",
 79:         className
 80:       )}
 81:     >
 82:       <span className={colors[type]}>{icons[type]}</span>
 83:       <span className="flex-1 text-sm">{message}</span>
 84:       {onDismiss && (
 85:         <button
 86:           onClick={onDismiss}
 87:           className="text-muted-foreground hover:text-foreground transition-colors"
 88:         >
 89:           <X className="h-4 w-4" />
 90:         </button>
 91:       )}
 92:     </motion.div>
 93:   );
 94: };
 95: 
 96: // Toast container for positioning
 97: interface ToastContainerProps {
 98:   children: React.ReactNode;
 99: }
100: 
101: export const ToastContainer: React.FC<ToastContainerProps> = ({ children }) => {
102:   return (
103:     <div className="fixed bottom-0 left-0 right-0 z-50 flex justify-center p-4 pointer-events-none">
104:       <div className="pointer-events-auto">
105:         <AnimatePresence mode="wait">
106:           {children}
107:         </AnimatePresence>
108:       </div>
109:     </div>
110:   );
111: };
````

## File: src/components/ui/tooltip.tsx
````typescript
 1: import * as React from "react"
 2: import * as TooltipPrimitive from "@radix-ui/react-tooltip"
 3: import { cn } from "@/lib/utils"
 4: 
 5: const TooltipProvider = TooltipPrimitive.Provider
 6: 
 7: const Tooltip = TooltipPrimitive.Root
 8: 
 9: const TooltipTrigger = TooltipPrimitive.Trigger
10: 
11: const TooltipContent = React.forwardRef<
12:   React.ElementRef<typeof TooltipPrimitive.Content>,
13:   React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
14: >(({ className, sideOffset = 4, ...props }, ref) => (
15:   <TooltipPrimitive.Content
16:     ref={ref}
17:     sideOffset={sideOffset}
18:     className={cn(
19:       "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
20:       className
21:     )}
22:     {...props}
23:   />
24: ))
25: TooltipContent.displayName = TooltipPrimitive.Content.displayName
26: 
27: export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
````

## File: src/components/widgets/BashWidget.tsx
````typescript
 1: import React from "react";
 2: import { Terminal, ChevronRight } from "lucide-react";
 3: import { cn } from "@/lib/utils";
 4: 
 5: interface BashWidgetProps {
 6:   command: string;
 7:   description?: string;
 8:   result?: any;
 9: }
10: 
11: export const BashWidget: React.FC<BashWidgetProps> = ({ command, description, result }) => {
12:   // Extract result content if available
13:   let resultContent = '';
14:   let isError = false;
15:   
16:   if (result) {
17:     isError = result.is_error || false;
18:     if (typeof result.content === 'string') {
19:       resultContent = result.content;
20:     } else if (result.content && typeof result.content === 'object') {
21:       if (result.content.text) {
22:         resultContent = result.content.text;
23:       } else if (Array.isArray(result.content)) {
24:         resultContent = result.content
25:           .map((c: any) => (typeof c === 'string' ? c : c.text || JSON.stringify(c)))
26:           .join('\n');
27:       } else {
28:         resultContent = JSON.stringify(result.content, null, 2);
29:       }
30:     }
31:   }
32:   
33:   return (
34:     <div className="rounded-lg border bg-zinc-950 overflow-hidden">
35:       <div className="px-4 py-2 bg-zinc-900/50 flex items-center gap-2 border-b">
36:         <Terminal className="h-3.5 w-3.5 text-green-500" />
37:         <span className="text-xs font-mono text-muted-foreground">Terminal</span>
38:         {description && (
39:           <>
40:             <ChevronRight className="h-3 w-3 text-muted-foreground" />
41:             <span className="text-xs text-muted-foreground">{description}</span>
42:           </>
43:         )}
44:         {/* Show loading indicator when no result yet */}
45:         {!result && (
46:           <div className="ml-auto flex items-center gap-1 text-xs text-muted-foreground">
47:             <div className="h-2 w-2 bg-green-500 rounded-full animate-pulse" />
48:             <span>Running...</span>
49:           </div>
50:         )}
51:       </div>
52:       <div className="p-4 space-y-3">
53:         <code className="text-xs font-mono text-green-400 block">
54:           $ {command}
55:         </code>
56:         
57:         {/* Show result if available */}
58:         {result && (
59:           <div className={cn(
60:             "mt-3 p-3 rounded-md border text-xs font-mono whitespace-pre-wrap overflow-x-auto",
61:             isError 
62:               ? "border-red-500/20 bg-red-500/5 text-red-400" 
63:               : "border-green-500/20 bg-green-500/5 text-green-300"
64:           )}>
65:             {resultContent || (isError ? "Command failed" : "Command completed")}
66:           </div>
67:         )}
68:       </div>
69:     </div>
70:   );
71: };
````

## File: src/components/widgets/index.ts
````typescript
 1: // Re-export all widgets from their individual files
 2: export { TodoWidget } from './TodoWidget';
 3: export { LSWidget } from './LSWidget';
 4: export { BashWidget } from './BashWidget';
 5: 
 6: // TODO: Add these widgets as they are implemented
 7: // export { LSResultWidget } from './LSWidget';
 8: // export { ReadWidget } from './ReadWidget';
 9: // export { ReadResultWidget } from './ReadResultWidget';
10: // export { GlobWidget } from './GlobWidget';
11: // export { WriteWidget } from './WriteWidget';
12: // export { GrepWidget } from './GrepWidget';
13: // export { EditWidget } from './EditWidget';
14: // export { EditResultWidget } from './EditResultWidget';
15: // export { MCPWidget } from './MCPWidget';
16: // export { CommandWidget } from './CommandWidget';
17: // export { CommandOutputWidget } from './CommandOutputWidget';
18: // export { SummaryWidget } from './SummaryWidget';
19: // export { MultiEditWidget } from './MultiEditWidget';
20: // export { MultiEditResultWidget } from './MultiEditResultWidget';
21: // export { SystemReminderWidget } from './SystemReminderWidget';
22: // export { SystemInitializedWidget } from './SystemInitializedWidget';
23: // export { TaskWidget } from './TaskWidget';
24: // export { WebSearchWidget } from './WebSearchWidget';
25: // export { ThinkingWidget } from './ThinkingWidget';
26: // export { WebFetchWidget } from './WebFetchWidget';
27: // export { TodoReadWidget } from './TodoReadWidget';
````

## File: src/components/widgets/LSWidget.tsx
````typescript
  1: import React, { useState } from "react";
  2: import { FolderOpen, Folder, FileCode, FileText, Terminal, ChevronRight } from "lucide-react";
  3: import { cn } from "@/lib/utils";
  4: 
  5: interface LSWidgetProps {
  6:   path: string;
  7:   result?: any;
  8: }
  9: 
 10: export const LSWidget: React.FC<LSWidgetProps> = ({ path, result }) => {
 11:   // If we have a result, show it using the LSResultWidget
 12:   if (result) {
 13:     let resultContent = '';
 14:     if (typeof result.content === 'string') {
 15:       resultContent = result.content;
 16:     } else if (result.content && typeof result.content === 'object') {
 17:       if (result.content.text) {
 18:         resultContent = result.content.text;
 19:       } else if (Array.isArray(result.content)) {
 20:         resultContent = result.content
 21:           .map((c: any) => (typeof c === 'string' ? c : c.text || JSON.stringify(c)))
 22:           .join('\n');
 23:       } else {
 24:         resultContent = JSON.stringify(result.content, null, 2);
 25:       }
 26:     }
 27:     
 28:     return (
 29:       <div className="space-y-2">
 30:         <div className="flex items-center gap-2 p-3 rounded-lg bg-muted/50">
 31:           <FolderOpen className="h-4 w-4 text-primary" />
 32:           <span className="text-sm">Directory contents for:</span>
 33:           <code className="text-sm font-mono bg-background px-2 py-0.5 rounded">
 34:             {path}
 35:           </code>
 36:         </div>
 37:         {resultContent && <LSResultWidget content={resultContent} />}
 38:       </div>
 39:     );
 40:   }
 41:   
 42:   return (
 43:     <div className="flex items-center gap-2 p-3 rounded-lg bg-muted/50">
 44:       <FolderOpen className="h-4 w-4 text-primary" />
 45:       <span className="text-sm">Listing directory:</span>
 46:       <code className="text-sm font-mono bg-background px-2 py-0.5 rounded">
 47:         {path}
 48:       </code>
 49:       {!result && (
 50:         <div className="ml-auto flex items-center gap-1 text-xs text-muted-foreground">
 51:           <div className="h-2 w-2 bg-blue-500 rounded-full animate-pulse" />
 52:           <span>Loading...</span>
 53:         </div>
 54:       )}
 55:     </div>
 56:   );
 57: };
 58: 
 59: interface LSResultWidgetProps {
 60:   content: string;
 61: }
 62: 
 63: export const LSResultWidget: React.FC<LSResultWidgetProps> = ({ content }) => {
 64:   const [expandedDirs, setExpandedDirs] = useState<Set<string>>(new Set());
 65:   
 66:   // Parse the directory tree structure
 67:   const parseDirectoryTree = (rawContent: string) => {
 68:     const lines = rawContent.split('\n');
 69:     const entries: Array<{
 70:       path: string;
 71:       name: string;
 72:       type: 'file' | 'directory';
 73:       level: number;
 74:     }> = [];
 75:     
 76:     let currentPath: string[] = [];
 77:     
 78:     for (const line of lines) {
 79:       // Skip NOTE section and everything after it
 80:       if (line.startsWith('NOTE:')) {
 81:         break;
 82:       }
 83:       
 84:       // Skip empty lines
 85:       if (!line.trim()) continue;
 86:       
 87:       // Calculate indentation level
 88:       const indent = line.match(/^(\s*)/)?.[1] || '';
 89:       const level = Math.floor(indent.length / 2);
 90:       
 91:       // Extract the entry name
 92:       const entryMatch = line.match(/^\s*-\s+(.+?)(\/$)?$/);
 93:       if (!entryMatch) continue;
 94:       
 95:       const fullName = entryMatch[1];
 96:       const isDirectory = line.trim().endsWith('/');
 97:       const name = isDirectory ? fullName : fullName;
 98:       
 99:       // Update current path based on level
100:       currentPath = currentPath.slice(0, level);
101:       currentPath.push(name);
102:       
103:       entries.push({
104:         path: currentPath.join('/'),
105:         name,
106:         type: isDirectory ? 'directory' : 'file',
107:         level,
108:       });
109:     }
110:     
111:     return entries;
112:   };
113:   
114:   const entries = parseDirectoryTree(content);
115:   
116:   const toggleDirectory = (path: string) => {
117:     setExpandedDirs(prev => {
118:       const next = new Set(prev);
119:       if (next.has(path)) {
120:         next.delete(path);
121:       } else {
122:         next.add(path);
123:       }
124:       return next;
125:     });
126:   };
127:   
128:   // Group entries by parent for collapsible display
129:   const getChildren = (parentPath: string, parentLevel: number) => {
130:     return entries.filter(e => {
131:       if (e.level !== parentLevel + 1) return false;
132:       const parentParts = parentPath.split('/').filter(Boolean);
133:       const entryParts = e.path.split('/').filter(Boolean);
134:       
135:       // Check if this entry is a direct child of the parent
136:       if (entryParts.length !== parentParts.length + 1) return false;
137:       
138:       // Check if all parent parts match
139:       for (let i = 0; i < parentParts.length; i++) {
140:         if (parentParts[i] !== entryParts[i]) return false;
141:       }
142:       
143:       return true;
144:     });
145:   };
146:   
147:   const renderEntry = (entry: typeof entries[0], isRoot = false) => {
148:     const hasChildren = entry.type === 'directory' && 
149:       entries.some(e => e.path.startsWith(entry.path + '/') && e.level === entry.level + 1);
150:     const isExpanded = expandedDirs.has(entry.path) || isRoot;
151:     
152:     const getIcon = () => {
153:       if (entry.type === 'directory') {
154:         return isExpanded ? 
155:           <FolderOpen className="h-3.5 w-3.5 text-blue-500" /> : 
156:           <Folder className="h-3.5 w-3.5 text-blue-500" />;
157:       }
158:       
159:       // File type icons based on extension
160:       const ext = entry.name.split('.').pop()?.toLowerCase();
161:       switch (ext) {
162:         case 'rs':
163:           return <FileCode className="h-3.5 w-3.5 text-orange-500" />;
164:         case 'toml':
165:         case 'yaml':
166:         case 'yml':
167:         case 'json':
168:           return <FileText className="h-3.5 w-3.5 text-yellow-500" />;
169:         case 'md':
170:           return <FileText className="h-3.5 w-3.5 text-blue-400" />;
171:         case 'js':
172:         case 'jsx':
173:         case 'ts':
174:         case 'tsx':
175:           return <FileCode className="h-3.5 w-3.5 text-yellow-400" />;
176:         case 'py':
177:           return <FileCode className="h-3.5 w-3.5 text-blue-500" />;
178:         case 'go':
179:           return <FileCode className="h-3.5 w-3.5 text-cyan-500" />;
180:         case 'sh':
181:         case 'bash':
182:           return <Terminal className="h-3.5 w-3.5 text-green-500" />;
183:         default:
184:           return <FileText className="h-3.5 w-3.5 text-muted-foreground" />;
185:       }
186:     };
187:     
188:     return (
189:       <div key={entry.path}>
190:         <div 
191:           className={cn(
192:             "flex items-center gap-2 py-1 px-2 rounded hover:bg-muted/50 transition-colors cursor-pointer",
193:             !isRoot && "ml-4"
194:           )}
195:           onClick={() => entry.type === 'directory' && hasChildren && toggleDirectory(entry.path)}
196:         >
197:           {entry.type === 'directory' && hasChildren && (
198:             <ChevronRight className={cn(
199:               "h-3 w-3 text-muted-foreground transition-transform",
200:               isExpanded && "rotate-90"
201:             )} />
202:           )}
203:           {(!hasChildren || entry.type !== 'directory') && (
204:             <div className="w-3" />
205:           )}
206:           {getIcon()}
207:           <span className="text-sm font-mono">{entry.name}</span>
208:         </div>
209:         
210:         {entry.type === 'directory' && hasChildren && isExpanded && (
211:           <div className="ml-2">
212:             {getChildren(entry.path, entry.level).map(child => renderEntry(child))}
213:           </div>
214:         )}
215:       </div>
216:     );
217:   };
218:   
219:   // Get root entries
220:   const rootEntries = entries.filter(e => e.level === 0);
221:   
222:   return (
223:     <div className="rounded-lg border bg-muted/20 p-3">
224:       <div className="space-y-1">
225:         {rootEntries.map(entry => renderEntry(entry, true))}
226:       </div>
227:     </div>
228:   );
229: };
````

## File: src/components/widgets/TodoWidget.tsx
````typescript
 1: import React from "react";
 2: import { CheckCircle2, Circle, Clock, FileEdit } from "lucide-react";
 3: import { Badge } from "@/components/ui/badge";
 4: import { cn } from "@/lib/utils";
 5: 
 6: interface TodoWidgetProps {
 7:   todos: any[];
 8:   result?: any;
 9: }
10: 
11: export const TodoWidget: React.FC<TodoWidgetProps> = ({ todos, result: _result }) => {
12:   const statusIcons = {
13:     completed: <CheckCircle2 className="h-4 w-4 text-green-500" />,
14:     in_progress: <Clock className="h-4 w-4 text-blue-500 animate-pulse" />,
15:     pending: <Circle className="h-4 w-4 text-muted-foreground" />
16:   };
17: 
18:   const priorityColors = {
19:     high: "bg-red-500/10 text-red-500 border-red-500/20",
20:     medium: "bg-yellow-500/10 text-yellow-500 border-yellow-500/20",
21:     low: "bg-green-500/10 text-green-500 border-green-500/20"
22:   };
23: 
24:   return (
25:     <div className="space-y-2">
26:       <div className="flex items-center gap-2 mb-3">
27:         <FileEdit className="h-4 w-4 text-primary" />
28:         <span className="text-sm font-medium">Todo List</span>
29:       </div>
30:       <div className="space-y-2">
31:         {todos.map((todo, idx) => (
32:           <div
33:             key={todo.id || idx}
34:             className={cn(
35:               "flex items-start gap-3 p-3 rounded-lg border bg-card/50",
36:               todo.status === "completed" && "opacity-60"
37:             )}
38:           >
39:             <div className="mt-0.5">
40:               {statusIcons[todo.status as keyof typeof statusIcons] || statusIcons.pending}
41:             </div>
42:             <div className="flex-1 space-y-1">
43:               <p className={cn(
44:                 "text-sm",
45:                 todo.status === "completed" && "line-through"
46:               )}>
47:                 {todo.content}
48:               </p>
49:               {todo.priority && (
50:                 <Badge 
51:                   variant="outline" 
52:                   className={cn("text-xs", priorityColors[todo.priority as keyof typeof priorityColors])}
53:                 >
54:                   {todo.priority}
55:                 </Badge>
56:               )}
57:             </div>
58:           </div>
59:         ))}
60:       </div>
61:     </div>
62:   );
63: };
````

## File: src/components/AgentExecution.tsx
````typescript
   1: import React, { useState, useEffect, useRef } from "react";
   2: import { motion, AnimatePresence } from "framer-motion";
   3: import { 
   4:   ArrowLeft, 
   5:   Play, 
   6:   StopCircle, 
   7:   FolderOpen, 
   8:   Terminal,
   9:   AlertCircle,
  10:   Loader2,
  11:   Copy,
  12:   ChevronDown,
  13:   Maximize2,
  14:   X,
  15:   Settings2
  16: } from "lucide-react";
  17: import { Button } from "@/components/ui/button";
  18: import { Input } from "@/components/ui/input";
  19: import { Label } from "@/components/ui/label";
  20: import { Popover } from "@/components/ui/popover";
  21: import {
  22:   Dialog,
  23:   DialogContent,
  24:   DialogDescription,
  25:   DialogHeader,
  26:   DialogTitle,
  27: } from "@/components/ui/dialog";
  28: import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs";
  29: import { api, type Agent } from "@/lib/api";
  30: import { cn } from "@/lib/utils";
  31: import { open } from "@tauri-apps/plugin-dialog";
  32: import { listen, type UnlistenFn } from "@tauri-apps/api/event";
  33: import { StreamMessage } from "./StreamMessage";
  34: import { ExecutionControlBar } from "./ExecutionControlBar";
  35: import { ErrorBoundary } from "./ErrorBoundary";
  36: import { useVirtualizer } from "@tanstack/react-virtual";
  37: import { AGENT_ICONS } from "./CCAgents";
  38: import { HooksEditor } from "./HooksEditor";
  39: import { useTrackEvent, useComponentMetrics, useFeatureAdoptionTracking } from "@/hooks";
  40: 
  41: interface AgentExecutionProps {
  42:   /**
  43:    * The agent to execute
  44:    */
  45:   agent: Agent;
  46:   /**
  47:    * Callback to go back to the agents list
  48:    */
  49:   onBack: () => void;
  50:   /**
  51:    * Optional className for styling
  52:    */
  53:   className?: string;
  54: }
  55: 
  56: export interface ClaudeStreamMessage {
  57:   type: "system" | "assistant" | "user" | "result";
  58:   subtype?: string;
  59:   message?: {
  60:     content?: any[];
  61:     usage?: {
  62:       input_tokens: number;
  63:       output_tokens: number;
  64:     };
  65:   };
  66:   usage?: {
  67:     input_tokens: number;
  68:     output_tokens: number;
  69:   };
  70:   [key: string]: any;
  71: }
  72: 
  73: /**
  74:  * AgentExecution component for running CC agents
  75:  * 
  76:  * @example
  77:  * <AgentExecution agent={agent} onBack={() => setView('list')} />
  78:  */
  79: export const AgentExecution: React.FC<AgentExecutionProps> = ({
  80:   agent,
  81:   onBack,
  82:   className,
  83: }) => {
  84:   const [projectPath, setProjectPath] = useState("");
  85:   const [task, setTask] = useState(agent.default_task || "");
  86:   const [model, setModel] = useState(agent.model || "sonnet");
  87:   const [isRunning, setIsRunning] = useState(false);
  88:   const [messages, setMessages] = useState<ClaudeStreamMessage[]>([]);
  89:   const [rawJsonlOutput, setRawJsonlOutput] = useState<string[]>([]);
  90:   const [error, setError] = useState<string | null>(null);
  91:   const [copyPopoverOpen, setCopyPopoverOpen] = useState(false);
  92:   
  93:   // Analytics tracking
  94:   const trackEvent = useTrackEvent();
  95:   useComponentMetrics('AgentExecution');
  96:   const agentFeatureTracking = useFeatureAdoptionTracking(`agent_${agent.name || 'custom'}`);
  97:   
  98:   // Hooks configuration state
  99:   const [isHooksDialogOpen, setIsHooksDialogOpen] = useState(false);
 100:   const [activeHooksTab, setActiveHooksTab] = useState("project");
 101: 
 102:   // Execution stats
 103:   const [executionStartTime, setExecutionStartTime] = useState<number | null>(null);
 104:   const [totalTokens, setTotalTokens] = useState(0);
 105:   const [elapsedTime, setElapsedTime] = useState(0);
 106:   const [hasUserScrolled, setHasUserScrolled] = useState(false);
 107:   const [isFullscreenModalOpen, setIsFullscreenModalOpen] = useState(false);
 108:   
 109:   const messagesEndRef = useRef<HTMLDivElement>(null);
 110:   const messagesContainerRef = useRef<HTMLDivElement>(null);
 111:   const scrollContainerRef = useRef<HTMLDivElement>(null);
 112:   const fullscreenScrollRef = useRef<HTMLDivElement>(null);
 113:   const fullscreenMessagesEndRef = useRef<HTMLDivElement>(null);
 114:   const unlistenRefs = useRef<UnlistenFn[]>([]);
 115:   const elapsedTimeIntervalRef = useRef<NodeJS.Timeout | null>(null);
 116:   const [runId, setRunId] = useState<number | null>(null);
 117: 
 118:   // Filter out messages that shouldn't be displayed
 119:   const displayableMessages = React.useMemo(() => {
 120:     return messages.filter((message, index) => {
 121:       // Skip meta messages that don't have meaningful content
 122:       if (message.isMeta && !message.leafUuid && !message.summary) {
 123:         return false;
 124:       }
 125: 
 126:       // Skip empty user messages
 127:       if (message.type === "user" && message.message) {
 128:         if (message.isMeta) return false;
 129:         
 130:         const msg = message.message;
 131:         if (!msg.content || (Array.isArray(msg.content) && msg.content.length === 0)) {
 132:           return false;
 133:         }
 134:         
 135:         // Check if user message has visible content by checking its parts
 136:         if (Array.isArray(msg.content)) {
 137:           let hasVisibleContent = false;
 138:           for (const content of msg.content) {
 139:             if (content.type === "text") {
 140:               hasVisibleContent = true;
 141:               break;
 142:             } else if (content.type === "tool_result") {
 143:               // Check if this tool result will be skipped by a widget
 144:               let willBeSkipped = false;
 145:               if (content.tool_use_id) {
 146:                 // Look for the matching tool_use in previous assistant messages
 147:                 for (let i = index - 1; i >= 0; i--) {
 148:                   const prevMsg = messages[i];
 149:                   if (prevMsg.type === 'assistant' && prevMsg.message?.content && Array.isArray(prevMsg.message.content)) {
 150:                     const toolUse = prevMsg.message.content.find((c: any) => 
 151:                       c.type === 'tool_use' && c.id === content.tool_use_id
 152:                     );
 153:                     if (toolUse) {
 154:                       const toolName = toolUse.name?.toLowerCase();
 155:                       const toolsWithWidgets = [
 156:                         'task', 'edit', 'multiedit', 'todowrite', 'ls', 'read', 
 157:                         'glob', 'bash', 'write', 'grep'
 158:                       ];
 159:                       if (toolsWithWidgets.includes(toolName) || toolUse.name?.startsWith('mcp__')) {
 160:                         willBeSkipped = true;
 161:                       }
 162:                       break;
 163:                     }
 164:                   }
 165:                 }
 166:               }
 167:               
 168:               if (!willBeSkipped) {
 169:                 hasVisibleContent = true;
 170:                 break;
 171:               }
 172:             }
 173:           }
 174:           
 175:           if (!hasVisibleContent) {
 176:             return false;
 177:           }
 178:         }
 179:       }
 180: 
 181:       return true;
 182:     });
 183:   }, [messages]);
 184: 
 185:   // Virtualizers for efficient, smooth scrolling of potentially very long outputs
 186:   const rowVirtualizer = useVirtualizer({
 187:     count: displayableMessages.length,
 188:     getScrollElement: () => scrollContainerRef.current,
 189:     estimateSize: () => 150, // fallback estimate; dynamically measured afterwards
 190:     overscan: 5,
 191:   });
 192: 
 193:   const fullscreenRowVirtualizer = useVirtualizer({
 194:     count: displayableMessages.length,
 195:     getScrollElement: () => fullscreenScrollRef.current,
 196:     estimateSize: () => 150,
 197:     overscan: 5,
 198:   });
 199: 
 200:   useEffect(() => {
 201:     // Clean up listeners on unmount
 202:     return () => {
 203:       unlistenRefs.current.forEach(unlisten => unlisten());
 204:       if (elapsedTimeIntervalRef.current) {
 205:         clearInterval(elapsedTimeIntervalRef.current);
 206:       }
 207:     };
 208:   }, []);
 209: 
 210:   // Check if user is at the very bottom of the scrollable container
 211:   const isAtBottom = () => {
 212:     const container = isFullscreenModalOpen ? fullscreenScrollRef.current : scrollContainerRef.current;
 213:     if (container) {
 214:       const { scrollTop, scrollHeight, clientHeight } = container;
 215:       const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
 216:       return distanceFromBottom < 1;
 217:     }
 218:     return true;
 219:   };
 220: 
 221:   useEffect(() => {
 222:     if (displayableMessages.length === 0) return;
 223: 
 224:     // Auto-scroll only if the user has not manually scrolled OR they are still at the bottom
 225:     const shouldAutoScroll = !hasUserScrolled || isAtBottom();
 226: 
 227:     if (shouldAutoScroll) {
 228:       if (isFullscreenModalOpen) {
 229:         fullscreenRowVirtualizer.scrollToIndex(displayableMessages.length - 1, { align: "end", behavior: "smooth" });
 230:       } else {
 231:         rowVirtualizer.scrollToIndex(displayableMessages.length - 1, { align: "end", behavior: "smooth" });
 232:       }
 233:     }
 234:   }, [displayableMessages.length, hasUserScrolled, isFullscreenModalOpen, rowVirtualizer, fullscreenRowVirtualizer]);
 235: 
 236:   // Update elapsed time while running
 237:   useEffect(() => {
 238:     if (isRunning && executionStartTime) {
 239:       elapsedTimeIntervalRef.current = setInterval(() => {
 240:         setElapsedTime(Math.floor((Date.now() - executionStartTime) / 1000));
 241:       }, 100);
 242:     } else {
 243:       if (elapsedTimeIntervalRef.current) {
 244:         clearInterval(elapsedTimeIntervalRef.current);
 245:       }
 246:     }
 247:     
 248:     return () => {
 249:       if (elapsedTimeIntervalRef.current) {
 250:         clearInterval(elapsedTimeIntervalRef.current);
 251:       }
 252:     };
 253:   }, [isRunning, executionStartTime]);
 254: 
 255:   // Calculate total tokens from messages
 256:   useEffect(() => {
 257:     const tokens = messages.reduce((total, msg) => {
 258:       if (msg.message?.usage) {
 259:         return total + msg.message.usage.input_tokens + msg.message.usage.output_tokens;
 260:       }
 261:       if (msg.usage) {
 262:         return total + msg.usage.input_tokens + msg.usage.output_tokens;
 263:       }
 264:       return total;
 265:     }, 0);
 266:     setTotalTokens(tokens);
 267:   }, [messages]);
 268: 
 269: 
 270:   const handleSelectPath = async () => {
 271:     try {
 272:       const selected = await open({
 273:         directory: true,
 274:         multiple: false,
 275:         title: "Select Project Directory"
 276:       });
 277:       
 278:       if (selected) {
 279:         setProjectPath(selected as string);
 280:         setError(null); // Clear any previous errors
 281:       }
 282:     } catch (err) {
 283:       console.error("Failed to select directory:", err);
 284:       // More detailed error logging
 285:       const errorMessage = err instanceof Error ? err.message : String(err);
 286:       setError(`Failed to select directory: ${errorMessage}`);
 287:     }
 288:   };
 289: 
 290:   const handleOpenHooksDialog = async () => {
 291:     setIsHooksDialogOpen(true);
 292:   };
 293: 
 294:   const handleExecute = async () => {
 295:     try {
 296:       setIsRunning(true);
 297:       setExecutionStartTime(Date.now());
 298:       setMessages([]);
 299:       setRawJsonlOutput([]);
 300:       setRunId(null);
 301:       
 302:       // Clear any existing listeners
 303:       unlistenRefs.current.forEach(unlisten => unlisten());
 304:       unlistenRefs.current = [];
 305:       
 306:       // Execute the agent and get the run ID
 307:       const executionRunId = await api.executeAgent(agent.id!, projectPath, task, model);
 308:       console.log("Agent execution started with run ID:", executionRunId);
 309:       setRunId(executionRunId);
 310:       
 311:       // Track agent execution start
 312:       trackEvent.agentStarted({
 313:         agent_type: agent.name || 'custom',
 314:         agent_name: agent.name,
 315:         has_custom_prompt: task !== agent.default_task
 316:       });
 317:       
 318:       // Track feature adoption
 319:       agentFeatureTracking.trackUsage();
 320:       
 321:       // Set up event listeners with run ID isolation
 322:       const outputUnlisten = await listen<string>(`agent-output:${executionRunId}`, (event) => {
 323:         try {
 324:           // Store raw JSONL
 325:           setRawJsonlOutput(prev => [...prev, event.payload]);
 326:           
 327:           // Parse and display
 328:           const message = JSON.parse(event.payload) as ClaudeStreamMessage;
 329:           setMessages(prev => [...prev, message]);
 330:         } catch (err) {
 331:           console.error("Failed to parse message:", err, event.payload);
 332:         }
 333:       });
 334: 
 335:       const errorUnlisten = await listen<string>(`agent-error:${executionRunId}`, (event) => {
 336:         console.error("Agent error:", event.payload);
 337:         setError(event.payload);
 338:         
 339:         // Track agent error
 340:         trackEvent.agentError({
 341:           error_type: 'runtime_error',
 342:           error_stage: 'execution',
 343:           retry_count: 0,
 344:           agent_type: agent.name || 'custom'
 345:         });
 346:       });
 347: 
 348:       const completeUnlisten = await listen<boolean>(`agent-complete:${executionRunId}`, (event) => {
 349:         setIsRunning(false);
 350:         const duration = executionStartTime ? Date.now() - executionStartTime : undefined;
 351:         setExecutionStartTime(null);
 352:         if (!event.payload) {
 353:           setError("Agent execution failed");
 354:           // Track both the old event for compatibility and the new error event
 355:           trackEvent.agentExecuted(agent.name || 'custom', false, agent.name, duration);
 356:           trackEvent.agentError({
 357:             error_type: 'execution_failed',
 358:             error_stage: 'completion',
 359:             retry_count: 0,
 360:             agent_type: agent.name || 'custom'
 361:           });
 362:         } else {
 363:           trackEvent.agentExecuted(agent.name || 'custom', true, agent.name, duration);
 364:         }
 365:       });
 366: 
 367:       const cancelUnlisten = await listen<boolean>(`agent-cancelled:${executionRunId}`, () => {
 368:         setIsRunning(false);
 369:         setExecutionStartTime(null);
 370:         setError("Agent execution was cancelled");
 371:       });
 372: 
 373:       unlistenRefs.current = [outputUnlisten, errorUnlisten, completeUnlisten, cancelUnlisten];
 374:     } catch (err) {
 375:       console.error("Failed to execute agent:", err);
 376:       setIsRunning(false);
 377:       setExecutionStartTime(null);
 378:       setRunId(null);
 379:       // Show error in messages
 380:       setMessages(prev => [...prev, {
 381:         type: "result",
 382:         subtype: "error",
 383:         is_error: true,
 384:         result: `Failed to execute agent: ${err instanceof Error ? err.message : 'Unknown error'}`,
 385:         duration_ms: 0,
 386:         usage: {
 387:           input_tokens: 0,
 388:           output_tokens: 0
 389:         }
 390:       }]);
 391:     }
 392:   };
 393: 
 394:   const handleStop = async () => {
 395:     try {
 396:       if (!runId) {
 397:         console.error("No run ID available to stop");
 398:         return;
 399:       }
 400: 
 401:       // Call the API to kill the agent session
 402:       const success = await api.killAgentSession(runId);
 403:       
 404:       if (success) {
 405:         console.log(`Successfully stopped agent session ${runId}`);
 406:       } else {
 407:         console.warn(`Failed to stop agent session ${runId} - it may have already finished`);
 408:       }
 409:       
 410:       // Update UI state
 411:       setIsRunning(false);
 412:       setExecutionStartTime(null);
 413:       
 414:       // Clean up listeners
 415:       unlistenRefs.current.forEach(unlisten => unlisten());
 416:       unlistenRefs.current = [];
 417:       
 418:       // Add a message indicating execution was stopped
 419:       setMessages(prev => [...prev, {
 420:         type: "result",
 421:         subtype: "error",
 422:         is_error: true,
 423:         result: "Execution stopped by user",
 424:         duration_ms: elapsedTime * 1000,
 425:         usage: {
 426:           input_tokens: totalTokens,
 427:           output_tokens: 0
 428:         }
 429:       }]);
 430:     } catch (err) {
 431:       console.error("Failed to stop agent:", err);
 432:       // Still update UI state even if the backend call failed
 433:       setIsRunning(false);
 434:       setExecutionStartTime(null);
 435:       
 436:       // Show error message
 437:       setMessages(prev => [...prev, {
 438:         type: "result",
 439:         subtype: "error",
 440:         is_error: true,
 441:         result: `Failed to stop execution: ${err instanceof Error ? err.message : 'Unknown error'}`,
 442:         duration_ms: elapsedTime * 1000,
 443:         usage: {
 444:           input_tokens: totalTokens,
 445:           output_tokens: 0
 446:         }
 447:       }]);
 448:     }
 449:   };
 450: 
 451:   const handleBackWithConfirmation = () => {
 452:     if (isRunning) {
 453:       // Show confirmation dialog before navigating away during execution
 454:       const shouldLeave = window.confirm(
 455:         "An agent is currently running. If you navigate away, the agent will continue running in the background. You can view running sessions in the 'Running Sessions' tab within CC Agents.\n\nDo you want to continue?"
 456:       );
 457:       if (!shouldLeave) {
 458:         return;
 459:       }
 460:     }
 461:     
 462:     // Clean up listeners but don't stop the actual agent process
 463:     unlistenRefs.current.forEach(unlisten => unlisten());
 464:     unlistenRefs.current = [];
 465:     
 466:     // Navigate back
 467:     onBack();
 468:   };
 469: 
 470:   const handleCopyAsJsonl = async () => {
 471:     const jsonl = rawJsonlOutput.join('\n');
 472:     await navigator.clipboard.writeText(jsonl);
 473:     setCopyPopoverOpen(false);
 474:   };
 475: 
 476:   const handleCopyAsMarkdown = async () => {
 477:     let markdown = `# Agent Execution: ${agent.name}\n\n`;
 478:     markdown += `**Task:** ${task}\n`;
 479:     markdown += `**Model:** ${model === 'opus' ? 'Claude 4 Opus' : 'Claude 4 Sonnet'}\n`;
 480:     markdown += `**Date:** ${new Date().toISOString()}\n\n`;
 481:     markdown += `---\n\n`;
 482: 
 483:     for (const msg of messages) {
 484:       if (msg.type === "system" && msg.subtype === "init") {
 485:         markdown += `## System Initialization\n\n`;
 486:         markdown += `- Session ID: \`${msg.session_id || 'N/A'}\`\n`;
 487:         markdown += `- Model: \`${msg.model || 'default'}\`\n`;
 488:         if (msg.cwd) markdown += `- Working Directory: \`${msg.cwd}\`\n`;
 489:         if (msg.tools?.length) markdown += `- Tools: ${msg.tools.join(', ')}\n`;
 490:         markdown += `\n`;
 491:       } else if (msg.type === "assistant" && msg.message) {
 492:         markdown += `## Assistant\n\n`;
 493:         for (const content of msg.message.content || []) {
 494:           if (content.type === "text") {
 495:             markdown += `${content.text}\n\n`;
 496:           } else if (content.type === "tool_use") {
 497:             markdown += `### Tool: ${content.name}\n\n`;
 498:             markdown += `\`\`\`json\n${JSON.stringify(content.input, null, 2)}\n\`\`\`\n\n`;
 499:           }
 500:         }
 501:         if (msg.message.usage) {
 502:           markdown += `*Tokens: ${msg.message.usage.input_tokens} in, ${msg.message.usage.output_tokens} out*\n\n`;
 503:         }
 504:       } else if (msg.type === "user" && msg.message) {
 505:         markdown += `## User\n\n`;
 506:         for (const content of msg.message.content || []) {
 507:           if (content.type === "text") {
 508:             markdown += `${content.text}\n\n`;
 509:           } else if (content.type === "tool_result") {
 510:             markdown += `### Tool Result\n\n`;
 511:             markdown += `\`\`\`\n${content.content}\n\`\`\`\n\n`;
 512:           }
 513:         }
 514:       } else if (msg.type === "result") {
 515:         markdown += `## Execution Result\n\n`;
 516:         if (msg.result) {
 517:           markdown += `${msg.result}\n\n`;
 518:         }
 519:         if (msg.error) {
 520:           markdown += `**Error:** ${msg.error}\n\n`;
 521:         }
 522:         if (msg.cost_usd !== undefined) {
 523:           markdown += `- **Cost:** $${msg.cost_usd.toFixed(4)} USD\n`;
 524:         }
 525:         if (msg.duration_ms !== undefined) {
 526:           markdown += `- **Duration:** ${(msg.duration_ms / 1000).toFixed(2)}s\n`;
 527:         }
 528:         if (msg.num_turns !== undefined) {
 529:           markdown += `- **Turns:** ${msg.num_turns}\n`;
 530:         }
 531:         if (msg.usage) {
 532:           const total = msg.usage.input_tokens + msg.usage.output_tokens;
 533:           markdown += `- **Total Tokens:** ${total} (${msg.usage.input_tokens} in, ${msg.usage.output_tokens} out)\n`;
 534:         }
 535:       }
 536:     }
 537: 
 538:     await navigator.clipboard.writeText(markdown);
 539:     setCopyPopoverOpen(false);
 540:   };
 541: 
 542:   const renderIcon = () => {
 543:     const Icon = agent.icon in AGENT_ICONS ? AGENT_ICONS[agent.icon as keyof typeof AGENT_ICONS] : Terminal;
 544:     return <Icon className="h-5 w-5" />;
 545:   };
 546: 
 547:   return (
 548:     <div className={cn("flex flex-col h-full bg-background", className)}>
 549:       {/* Fixed container that takes full height */}
 550:       <div className="h-full flex flex-col">
 551:         {/* Sticky Header */}
 552:         <div className="sticky top-0 z-20 bg-background border-b border-border">
 553:           <div className="w-full max-w-5xl mx-auto">
 554:             <motion.div
 555:               initial={{ opacity: 0, y: -20 }}
 556:               animate={{ opacity: 1, y: 0 }}
 557:               transition={{ duration: 0.3 }}
 558:               className="p-6"
 559:             >
 560:               <div className="flex items-center justify-between">
 561:                 <div className="flex items-center gap-3">
 562:                   <Button
 563:                     variant="ghost"
 564:                     size="icon"
 565:                     onClick={handleBackWithConfirmation}
 566:                     className="h-8 w-8"
 567:                   >
 568:                     <ArrowLeft className="h-4 w-4" />
 569:                   </Button>
 570:                   <div className="flex items-center gap-3">
 571:                     <div className="p-2 rounded-full bg-primary/10 text-primary">
 572:                       {renderIcon()}
 573:                     </div>
 574:                     <div>
 575:                       <h1 className="text-xl font-bold">Execute: {agent.name}</h1>
 576:                       <p className="text-sm text-muted-foreground">
 577:                         {model === 'opus' ? 'Claude 4 Opus' : 'Claude 4 Sonnet'}
 578:                       </p>
 579:                     </div>
 580:                   </div>
 581:                 </div>
 582:                 <div className="flex items-center gap-2">
 583:                   <Button
 584:                     variant="outline"
 585:                     size="sm"
 586:                     onClick={() => setIsFullscreenModalOpen(true)}
 587:                     disabled={messages.length === 0}
 588:                   >
 589:                     <Maximize2 className="h-4 w-4 mr-2" />
 590:                     Fullscreen
 591:                   </Button>
 592:                 </div>
 593:               </div>
 594:             </motion.div>
 595:           </div>
 596:         </div>
 597:         
 598:         {/* Sticky Configuration */}
 599:         <div className="sticky top-[73px] z-10 bg-background border-b border-border">
 600:           <div className="w-full max-w-5xl mx-auto p-4 space-y-4">
 601:             {/* Error display */}
 602:             {error && (
 603:               <motion.div
 604:                 initial={{ opacity: 0 }}
 605:                 animate={{ opacity: 1 }}
 606:                 className="rounded-lg border border-destructive/50 bg-destructive/10 p-3 text-xs text-destructive flex items-center gap-2"
 607:               >
 608:                 <AlertCircle className="h-4 w-4 flex-shrink-0" />
 609:                 {error}
 610:               </motion.div>
 611:             )}
 612: 
 613:             {/* Project Path */}
 614:             <div className="space-y-2">
 615:               <Label>Project Path</Label>
 616:               <div className="flex gap-2">
 617:                 <Input
 618:                   value={projectPath}
 619:                   onChange={(e) => setProjectPath(e.target.value)}
 620:                   placeholder="Select or enter project path"
 621:                   disabled={isRunning}
 622:                   className="flex-1"
 623:                 />
 624:                 <Button
 625:                   variant="outline"
 626:                   size="icon"
 627:                   onClick={handleSelectPath}
 628:                   disabled={isRunning}
 629:                 >
 630:                   <FolderOpen className="h-4 w-4" />
 631:                 </Button>
 632:                 <Button
 633:                   variant="outline"
 634:                   onClick={handleOpenHooksDialog}
 635:                   disabled={isRunning || !projectPath}
 636:                   title="Configure hooks"
 637:                 >
 638:                   <Settings2 className="h-4 w-4 mr-2" />
 639:                   Hooks
 640:                 </Button>
 641:               </div>
 642:             </div>
 643: 
 644:             {/* Model Selection */}
 645:             <div className="space-y-2">
 646:               <Label>Model</Label>
 647:               <div className="flex gap-3">
 648:                 <button
 649:                   type="button"
 650:                   onClick={() => !isRunning && setModel("sonnet")}
 651:                   className={cn(
 652:                     "flex-1 px-3.5 py-2 rounded-full border-2 font-medium transition-all text-sm",
 653:                     !isRunning && "hover:scale-[1.02] active:scale-[0.98]",
 654:                     isRunning && "opacity-50 cursor-not-allowed",
 655:                     model === "sonnet" 
 656:                       ? "border-primary bg-primary text-primary-foreground shadow-lg" 
 657:                       : "border-muted-foreground/30 hover:border-muted-foreground/50"
 658:                   )}
 659:                   disabled={isRunning}
 660:                 >
 661:                   <div className="flex items-center justify-center gap-2">
 662:                     <div className={cn(
 663:                       "w-3.5 h-3.5 rounded-full border-2 flex items-center justify-center flex-shrink-0",
 664:                       model === "sonnet" ? "border-primary-foreground" : "border-current"
 665:                     )}>
 666:                       {model === "sonnet" && (
 667:                         <div className="w-1.5 h-1.5 rounded-full bg-primary-foreground" />
 668:                       )}
 669:                     </div>
 670:                     <span>Claude 4 Sonnet</span>
 671:                   </div>
 672:                 </button>
 673:                 
 674:                 <button
 675:                   type="button"
 676:                   onClick={() => !isRunning && setModel("opus")}
 677:                   className={cn(
 678:                     "flex-1 px-3.5 py-2 rounded-full border-2 font-medium transition-all text-sm",
 679:                     !isRunning && "hover:scale-[1.02] active:scale-[0.98]",
 680:                     isRunning && "opacity-50 cursor-not-allowed",
 681:                     model === "opus" 
 682:                       ? "border-primary bg-primary text-primary-foreground shadow-lg" 
 683:                       : "border-muted-foreground/30 hover:border-muted-foreground/50"
 684:                   )}
 685:                   disabled={isRunning}
 686:                 >
 687:                   <div className="flex items-center justify-center gap-2">
 688:                     <div className={cn(
 689:                       "w-3.5 h-3.5 rounded-full border-2 flex items-center justify-center flex-shrink-0",
 690:                       model === "opus" ? "border-primary-foreground" : "border-current"
 691:                     )}>
 692:                       {model === "opus" && (
 693:                         <div className="w-1.5 h-1.5 rounded-full bg-primary-foreground" />
 694:                       )}
 695:                     </div>
 696:                     <span>Claude 4 Opus</span>
 697:                   </div>
 698:                 </button>
 699:               </div>
 700:             </div>
 701: 
 702:             {/* Task Input */}
 703:             <div className="space-y-2">
 704:               <Label>Task</Label>
 705:               <div className="flex gap-2">
 706:                 <Input
 707:                   value={task}
 708:                   onChange={(e) => setTask(e.target.value)}
 709:                   placeholder="Enter the task for the agent"
 710:                   disabled={isRunning}
 711:                   className="flex-1"
 712:                   onKeyPress={(e) => {
 713:                     if (e.key === "Enter" && !isRunning && projectPath && task.trim()) {
 714:                       handleExecute();
 715:                     }
 716:                   }}
 717:                 />
 718:                 <Button
 719:                   onClick={isRunning ? handleStop : handleExecute}
 720:                   disabled={!projectPath || !task.trim()}
 721:                   variant={isRunning ? "destructive" : "default"}
 722:                 >
 723:                   {isRunning ? (
 724:                     <>
 725:                       <StopCircle className="mr-2 h-4 w-4" />
 726:                       Stop
 727:                     </>
 728:                   ) : (
 729:                     <>
 730:                       <Play className="mr-2 h-4 w-4" />
 731:                       Execute
 732:                     </>
 733:                   )}
 734:                 </Button>
 735:               </div>
 736:             </div>
 737:           </div>
 738:         </div>
 739: 
 740:         {/* Scrollable Output Display */}
 741:         <div className="flex-1 overflow-hidden">
 742:           <div className="w-full max-w-5xl mx-auto h-full">
 743:             <div 
 744:               ref={scrollContainerRef}
 745:               className="h-full overflow-y-auto p-6 space-y-8"
 746:               onScroll={() => {
 747:                 // Mark that user has scrolled manually
 748:                 if (!hasUserScrolled) {
 749:                   setHasUserScrolled(true);
 750:                 }
 751:                 
 752:                 // If user scrolls back to bottom, re-enable auto-scroll
 753:                 if (isAtBottom()) {
 754:                   setHasUserScrolled(false);
 755:                 }
 756:               }}
 757:             >
 758:               <div ref={messagesContainerRef}>
 759:               {messages.length === 0 && !isRunning && (
 760:                 <div className="flex flex-col items-center justify-center h-full text-center">
 761:                   <Terminal className="h-16 w-16 text-muted-foreground mb-4" />
 762:                   <h3 className="text-lg font-medium mb-2">Ready to Execute</h3>
 763:                   <p className="text-sm text-muted-foreground">
 764:                     Select a project path and enter a task to run the agent
 765:                   </p>
 766:                 </div>
 767:               )}
 768: 
 769:               {isRunning && messages.length === 0 && (
 770:                 <div className="flex items-center justify-center h-full">
 771:                   <div className="flex items-center gap-3">
 772:                     <Loader2 className="h-6 w-6 animate-spin" />
 773:                     <span className="text-sm text-muted-foreground">Initializing agent...</span>
 774:                   </div>
 775:                 </div>
 776:               )}
 777: 
 778:               <div
 779:                 className="relative w-full"
 780:                 style={{ height: `${rowVirtualizer.getTotalSize()}px` }}
 781:               >
 782:                 <AnimatePresence>
 783:                   {rowVirtualizer.getVirtualItems().map((virtualItem) => {
 784:                     const message = displayableMessages[virtualItem.index];
 785:                     return (
 786:                       <motion.div
 787:                         key={virtualItem.key}
 788:                         data-index={virtualItem.index}
 789:                         ref={(el) => el && rowVirtualizer.measureElement(el)}
 790:                         initial={{ opacity: 0, y: 10 }}
 791:                         animate={{ opacity: 1, y: 0 }}
 792:                         transition={{ duration: 0.2 }}
 793:                         className="absolute inset-x-4 pb-4"
 794:                         style={{ top: virtualItem.start }}
 795:                       >
 796:                         <ErrorBoundary>
 797:                           <StreamMessage message={message} streamMessages={messages} />
 798:                         </ErrorBoundary>
 799:                       </motion.div>
 800:                     );
 801:                   })}
 802:                 </AnimatePresence>
 803:               </div>
 804:               
 805:               <div ref={messagesEndRef} />
 806:               </div>
 807:             </div>
 808:           </div>
 809:         </div>
 810:       </div>
 811: 
 812:       {/* Floating Execution Control Bar */}
 813:       <ExecutionControlBar
 814:         isExecuting={isRunning}
 815:         onStop={handleStop}
 816:         totalTokens={totalTokens}
 817:         elapsedTime={elapsedTime}
 818:       />
 819: 
 820:       {/* Fullscreen Modal */}
 821:       {isFullscreenModalOpen && (
 822:         <div className="fixed inset-0 z-50 bg-background flex flex-col">
 823:           {/* Modal Header */}
 824:           <div className="flex items-center justify-between p-4 border-b border-border">
 825:             <div className="flex items-center gap-2">
 826:               {renderIcon()}
 827:               <h2 className="text-lg font-semibold">{agent.name} - Output</h2>
 828:               {isRunning && (
 829:                 <div className="flex items-center gap-1">
 830:                   <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
 831:                   <span className="text-xs text-green-600 font-medium">Running</span>
 832:                 </div>
 833:               )}
 834:             </div>
 835:             <div className="flex items-center gap-2">
 836:               <Popover
 837:                 trigger={
 838:                   <Button
 839:                     variant="ghost"
 840:                     size="sm"
 841:                     className="flex items-center gap-2"
 842:                   >
 843:                     <Copy className="h-4 w-4" />
 844:                     Copy Output
 845:                     <ChevronDown className="h-3 w-3" />
 846:                   </Button>
 847:                 }
 848:                 content={
 849:                   <div className="w-44 p-1">
 850:                     <Button
 851:                       variant="ghost"
 852:                       size="sm"
 853:                       className="w-full justify-start"
 854:                       onClick={handleCopyAsJsonl}
 855:                     >
 856:                       Copy as JSONL
 857:                     </Button>
 858:                     <Button
 859:                       variant="ghost"
 860:                       size="sm"
 861:                       className="w-full justify-start"
 862:                       onClick={handleCopyAsMarkdown}
 863:                     >
 864:                       Copy as Markdown
 865:                     </Button>
 866:                   </div>
 867:                 }
 868:                 open={copyPopoverOpen}
 869:                 onOpenChange={setCopyPopoverOpen}
 870:                 align="end"
 871:               />
 872:               <Button
 873:                 variant="ghost"
 874:                 size="sm"
 875:                 onClick={() => setIsFullscreenModalOpen(false)}
 876:                 className="flex items-center gap-2"
 877:               >
 878:                 <X className="h-4 w-4" />
 879:                 Close
 880:               </Button>
 881:             </div>
 882:           </div>
 883: 
 884:           {/* Modal Content */}
 885:           <div className="flex-1 overflow-hidden p-6">
 886:             <div 
 887:               ref={fullscreenScrollRef}
 888:               className="h-full overflow-y-auto space-y-8"
 889:               onScroll={() => {
 890:                 // Mark that user has scrolled manually
 891:                 if (!hasUserScrolled) {
 892:                   setHasUserScrolled(true);
 893:                 }
 894:                 
 895:                 // If user scrolls back to bottom, re-enable auto-scroll
 896:                 if (isAtBottom()) {
 897:                   setHasUserScrolled(false);
 898:                 }
 899:               }}
 900:             >
 901:               {messages.length === 0 && !isRunning && (
 902:                 <div className="flex flex-col items-center justify-center h-full text-center">
 903:                   <Terminal className="h-16 w-16 text-muted-foreground mb-4" />
 904:                   <h3 className="text-lg font-medium mb-2">Ready to Execute</h3>
 905:                   <p className="text-sm text-muted-foreground">
 906:                     Select a project path and enter a task to run the agent
 907:                   </p>
 908:                 </div>
 909:               )}
 910: 
 911:               {isRunning && messages.length === 0 && (
 912:                 <div className="flex items-center justify-center h-full">
 913:                   <div className="flex items-center gap-3">
 914:                     <Loader2 className="h-6 w-6 animate-spin" />
 915:                     <span className="text-sm text-muted-foreground">Initializing agent...</span>
 916:                   </div>
 917:                 </div>
 918:               )}
 919: 
 920:               <div
 921:                 className="relative w-full max-w-5xl mx-auto"
 922:                 style={{ height: `${fullscreenRowVirtualizer.getTotalSize()}px` }}
 923:               >
 924:                 <AnimatePresence>
 925:                   {fullscreenRowVirtualizer.getVirtualItems().map((virtualItem) => {
 926:                     const message = displayableMessages[virtualItem.index];
 927:                     return (
 928:                       <motion.div
 929:                         key={virtualItem.key}
 930:                         data-index={virtualItem.index}
 931:                         ref={(el) => el && fullscreenRowVirtualizer.measureElement(el)}
 932:                         initial={{ opacity: 0, y: 10 }}
 933:                         animate={{ opacity: 1, y: 0 }}
 934:                         transition={{ duration: 0.2 }}
 935:                         className="absolute inset-x-4 pb-4"
 936:                         style={{ top: virtualItem.start }}
 937:                       >
 938:                         <ErrorBoundary>
 939:                           <StreamMessage message={message} streamMessages={messages} />
 940:                         </ErrorBoundary>
 941:                       </motion.div>
 942:                     );
 943:                   })}
 944:                 </AnimatePresence>
 945:               </div>
 946:               
 947:               <div ref={fullscreenMessagesEndRef} />
 948:             </div>
 949:           </div>
 950:         </div>
 951:       )}
 952: 
 953:       {/* Hooks Configuration Dialog */}
 954:       <Dialog 
 955:         open={isHooksDialogOpen} 
 956:         onOpenChange={setIsHooksDialogOpen}
 957:       >
 958:         <DialogContent className="max-w-4xl max-h-[80vh] overflow-hidden flex flex-col">
 959:           <DialogHeader>
 960:             <DialogTitle>Configure Hooks</DialogTitle>
 961:             <DialogDescription>
 962:               Configure hooks that run before, during, and after tool executions. Changes are saved immediately.
 963:             </DialogDescription>
 964:           </DialogHeader>
 965:           
 966:           <Tabs value={activeHooksTab} onValueChange={setActiveHooksTab} className="flex-1 flex flex-col overflow-hidden">
 967:             <TabsList className="grid w-full grid-cols-2">
 968:               <TabsTrigger value="project">Project Settings</TabsTrigger>
 969:               <TabsTrigger value="local">Local Settings</TabsTrigger>
 970:             </TabsList>
 971:             
 972:             <TabsContent value="project" className="flex-1 overflow-auto">
 973:               <div className="space-y-4">
 974:                 <p className="text-sm text-muted-foreground">
 975:                   Project hooks are stored in <code className="bg-muted px-1 py-0.5 rounded">.claude/settings.json</code> and 
 976:                   are committed to version control.
 977:                 </p>
 978:                 <HooksEditor
 979:                   projectPath={projectPath}
 980:                   scope="project"
 981:                   className="border-0"
 982:                 />
 983:               </div>
 984:             </TabsContent>
 985:             
 986:             <TabsContent value="local" className="flex-1 overflow-auto">
 987:               <div className="space-y-4">
 988:                 <p className="text-sm text-muted-foreground">
 989:                   Local hooks are stored in <code className="bg-muted px-1 py-0.5 rounded">.claude/settings.local.json</code> and 
 990:                   are not committed to version control.
 991:                 </p>
 992:                 <HooksEditor
 993:                   projectPath={projectPath}
 994:                   scope="local"
 995:                   className="border-0"
 996:                 />
 997:               </div>
 998:             </TabsContent>
 999:           </Tabs>
1000:         </DialogContent>
1001:       </Dialog>
1002:     </div>
1003:   );
1004: };
````

## File: src/components/AgentExecutionDemo.tsx
````typescript
  1: import React from "react";
  2: import { StreamMessage } from "./StreamMessage";
  3: import type { ClaudeStreamMessage } from "./AgentExecution";
  4: 
  5: /**
  6:  * Demo component showing all the different message types and tools
  7:  */
  8: export const AgentExecutionDemo: React.FC = () => {
  9:   // Sample messages based on the provided JSONL session
 10:   const messages: ClaudeStreamMessage[] = [
 11:     // Skip meta message (should not render)
 12:     {
 13:       type: "user",
 14:       isMeta: true,
 15:       message: { content: [] },
 16:       timestamp: "2025-06-11T14:08:53.771Z"
 17:     },
 18:     
 19:     // Summary message
 20:     {
 21:       leafUuid: "3c5ecb4f-c1f0-40c2-a357-ab7642ad28b8",
 22:       summary: "JSONL Viewer Model Configuration and Setup",
 23:       type: "summary" as any
 24:     },
 25:     
 26:     // Assistant with Edit tool
 27:     {
 28:       type: "assistant",
 29:       message: {
 30:         content: [{
 31:           type: "tool_use",
 32:           name: "Edit",
 33:           input: {
 34:             file_path: "/Users/mufeedvh/dev/jsonl-viewer/script.js",
 35:             new_string: "reader.onerror = () => reject(new Error('Failed to read file'));",
 36:             old_string: "reader.onerror = e => reject(new Error('Failed to read file'));"
 37:           }
 38:         }],
 39:         usage: { input_tokens: 4, output_tokens: 158 }
 40:       }
 41:     },
 42:     
 43:     // User with Edit tool result
 44:     {
 45:       type: "user",
 46:       message: {
 47:         content: [{
 48:           type: "tool_result",
 49:           content: `The file /Users/mufeedvh/dev/jsonl-viewer/script.js has been updated. Here's the result of running \`cat -n\` on a snippet of the edited file:
 50:    220       readFileAsText(file) {
 51:    221         return new Promise((resolve, reject) => {
 52:    222           const reader = new FileReader();
 53:    223           reader.onload = e => resolve(e.target.result);
 54:    224           reader.onerror = () => reject(new Error('Failed to read file'));
 55:    225           reader.readAsText(file);
 56:    226         });
 57:    227       }
 58:    228`
 59:         }]
 60:       }
 61:     },
 62:     
 63:     // Assistant with MCP tool
 64:     {
 65:       type: "assistant",
 66:       message: {
 67:         content: [{
 68:           type: "tool_use",
 69:           name: "mcp__ide__getDiagnostics",
 70:           input: {}
 71:         }],
 72:         usage: { input_tokens: 4, output_tokens: 37 }
 73:       }
 74:     },
 75:     
 76:     // User with empty tool result
 77:     {
 78:       type: "user",
 79:       message: {
 80:         content: [{
 81:           type: "tool_result",
 82:           content: ""
 83:         }]
 84:       }
 85:     },
 86:     
 87:     // Assistant with Write tool (large content)
 88:     {
 89:       type: "assistant",
 90:       message: {
 91:         content: [{
 92:           type: "tool_use",
 93:           name: "Write",
 94:           input: {
 95:             file_path: "/Users/mufeedvh/dev/jsonl-viewer/styles.css",
 96:             content: `/* Reset and Base Styles */
 97: * {
 98:     margin: 0;
 99:     padding: 0;
100:     box-sizing: border-box;
101: }
102: 
103: body {
104:     font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
105:     line-height: 1.6;
106:     color: #333;
107:     background: #f8fafc;
108:     min-height: 100vh;
109: }
110: 
111: /* Container */
112: .container {
113:     max-width: 1200px;
114:     margin: 0 auto;
115:     padding: 20px;
116: }
117: 
118: /* Header */
119: .header {
120:     text-align: center;
121:     margin-bottom: 40px;
122: }
123: 
124: .header h1 {
125:     font-size: 2.5rem;
126:     font-weight: 700;
127:     color: #1a202c;
128:     margin-bottom: 8px;
129: }
130: 
131: .header p {
132:     color: #718096;
133:     font-size: 1.1rem;
134: }
135: 
136: /* Input Section */
137: .input-section {
138:     display: grid;
139:     gap: 20px;
140:     margin-bottom: 30px;
141: }
142: 
143: /* Drop Zone */
144: .drop-zone {
145:     border: 2px dashed #cbd5e0;
146:     border-radius: 12px;
147:     padding: 40px 20px;
148:     text-align: center;
149:     cursor: pointer;
150:     transition: all 0.3s ease;
151:     background: white;
152:     position: relative;
153: }
154: 
155: .drop-zone:hover,
156: .drop-zone.drag-over {
157:     border-color: #4299e1;
158:     background: #ebf8ff;
159:     transform: translateY(-2px);
160:     box-shadow: 0 8px 25px rgba(66, 153, 225, 0.1);
161: }
162: 
163: /* ... many more lines of CSS ... */
164: /* This content is over 1000 characters so it should show the maximize button */
165: ` + '\n'.repeat(100) + '/* End of very long CSS file */'
166:           }
167:         }]
168:       }
169:     }
170:   ];
171: 
172:   return (
173:     <div className="max-w-4xl mx-auto p-8 space-y-4">
174:       <h1 className="text-2xl font-bold mb-6">Agent Execution Demo</h1>
175:       
176:       {messages.map((message, idx) => (
177:         <StreamMessage key={idx} message={message} streamMessages={messages} />
178:       ))}
179:     </div>
180:   );
181: };
````

## File: src/components/AgentRunOutputViewer.tsx
````typescript
  1: import { useState, useEffect, useRef, useMemo } from 'react';
  2: import { motion, AnimatePresence } from 'framer-motion';
  3: import { 
  4:   Maximize2, 
  5:   Minimize2, 
  6:   Copy, 
  7:   RefreshCw, 
  8:   RotateCcw, 
  9:   ChevronDown,
 10:   Bot,
 11:   Clock,
 12:   Hash,
 13:   DollarSign,
 14:   StopCircle
 15: } from 'lucide-react';
 16: import { Button } from '@/components/ui/button';
 17: import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
 18: import { Badge } from '@/components/ui/badge';
 19: import { Toast, ToastContainer } from '@/components/ui/toast';
 20: import { Popover } from '@/components/ui/popover';
 21: import { api, type AgentRunWithMetrics } from '@/lib/api';
 22: import { useOutputCache } from '@/lib/outputCache';
 23: import { listen, type UnlistenFn } from '@tauri-apps/api/event';
 24: import { StreamMessage } from './StreamMessage';
 25: import { ErrorBoundary } from './ErrorBoundary';
 26: import { formatISOTimestamp } from '@/lib/date-utils';
 27: import { AGENT_ICONS } from './CCAgents';
 28: import type { ClaudeStreamMessage } from './AgentExecution';
 29: import { useTabState } from '@/hooks/useTabState';
 30: 
 31: interface AgentRunOutputViewerProps {
 32:   /**
 33:    * The agent run ID to display
 34:    */
 35:   agentRunId: string;
 36:   /**
 37:    * Tab ID for this agent run
 38:    */
 39:   tabId: string;
 40:   /**
 41:    * Optional className for styling
 42:    */
 43:   className?: string;
 44: }
 45: 
 46: /**
 47:  * AgentRunOutputViewer - Modal component for viewing agent execution output
 48:  * 
 49:  * @example
 50:  * <AgentRunOutputViewer
 51:  *   run={agentRun}
 52:  *   onClose={() => setSelectedRun(null)}
 53:  * />
 54:  */
 55: export function AgentRunOutputViewer({ 
 56:   agentRunId, 
 57:   tabId,
 58:   className 
 59: }: AgentRunOutputViewerProps) {
 60:   const { updateTabTitle, updateTabStatus } = useTabState();
 61:   const [run, setRun] = useState<AgentRunWithMetrics | null>(null);
 62:   const [messages, setMessages] = useState<ClaudeStreamMessage[]>([]);
 63:   const [rawJsonlOutput, setRawJsonlOutput] = useState<string[]>([]);
 64:   const [loading, setLoading] = useState(true);
 65:   const [isFullscreen, setIsFullscreen] = useState(false);
 66:   const [refreshing, setRefreshing] = useState(false);
 67:   const [toast, setToast] = useState<{ message: string; type: "success" | "error" } | null>(null);
 68:   const [copyPopoverOpen, setCopyPopoverOpen] = useState(false);
 69:   const [hasUserScrolled, setHasUserScrolled] = useState(false);
 70:   
 71:   // Track whether we're in the initial load phase
 72:   const isInitialLoadRef = useRef(true);
 73:   const hasSetupListenersRef = useRef(false);
 74:   
 75:   const scrollAreaRef = useRef<HTMLDivElement>(null);
 76:   const outputEndRef = useRef<HTMLDivElement>(null);
 77:   const fullscreenScrollRef = useRef<HTMLDivElement>(null);
 78:   const fullscreenMessagesEndRef = useRef<HTMLDivElement>(null);
 79:   const unlistenRefs = useRef<UnlistenFn[]>([]);
 80:   const { getCachedOutput, setCachedOutput } = useOutputCache();
 81: 
 82:   // Auto-scroll logic
 83:   const isAtBottom = () => {
 84:     const container = isFullscreen ? fullscreenScrollRef.current : scrollAreaRef.current;
 85:     if (container) {
 86:       const { scrollTop, scrollHeight, clientHeight } = container;
 87:       const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
 88:       return distanceFromBottom < 1;
 89:     }
 90:     return true;
 91:   };
 92: 
 93:   const scrollToBottom = () => {
 94:     if (!hasUserScrolled) {
 95:       const endRef = isFullscreen ? fullscreenMessagesEndRef.current : outputEndRef.current;
 96:       if (endRef) {
 97:         endRef.scrollIntoView({ behavior: 'smooth' });
 98:       }
 99:     }
100:   };
101: 
102:   // Load agent run on mount
103:   useEffect(() => {
104:     const loadAgentRun = async () => {
105:       try {
106:         setLoading(true);
107:         const agentRun = await api.getAgentRun(parseInt(agentRunId));
108:         setRun(agentRun);
109:         updateTabTitle(tabId, `Agent: ${agentRun.agent_name || 'Unknown'}`);
110:         updateTabStatus(tabId, agentRun.status === 'running' ? 'running' : agentRun.status === 'failed' ? 'error' : 'complete');
111:       } catch (error) {
112:         console.error('Failed to load agent run:', error);
113:         updateTabStatus(tabId, 'error');
114:       } finally {
115:         setLoading(false);
116:       }
117:     };
118:     
119:     if (agentRunId) {
120:       loadAgentRun();
121:     }
122:   }, [agentRunId, tabId, updateTabTitle, updateTabStatus]);
123: 
124:   // Cleanup on unmount
125:   useEffect(() => {
126:     return () => {
127:       unlistenRefs.current.forEach(unlisten => unlisten());
128:       unlistenRefs.current = [];
129:       hasSetupListenersRef.current = false;
130:     };
131:   }, []);
132: 
133:   // Auto-scroll when messages change
134:   useEffect(() => {
135:     const shouldAutoScroll = !hasUserScrolled || isAtBottom();
136:     if (shouldAutoScroll) {
137:       scrollToBottom();
138:     }
139:   }, [messages, hasUserScrolled, isFullscreen]);
140: 
141:   const loadOutput = async (skipCache = false) => {
142:     if (!run?.id) return;
143: 
144:     console.log('[AgentRunOutputViewer] Loading output for run:', {
145:       runId: run.id,
146:       status: run.status,
147:       sessionId: run.session_id,
148:       skipCache
149:     });
150: 
151:     try {
152:       // Check cache first if not skipping cache
153:       if (!skipCache) {
154:         const cached = getCachedOutput(run.id);
155:         if (cached) {
156:           console.log('[AgentRunOutputViewer] Found cached output');
157:           const cachedJsonlLines = cached.output.split('\n').filter(line => line.trim());
158:           setRawJsonlOutput(cachedJsonlLines);
159:           setMessages(cached.messages);
160:           // If cache is recent (less than 5 seconds old) and session isn't running, use cache only
161:           if (Date.now() - cached.lastUpdated < 5000 && run.status !== 'running') {
162:             console.log('[AgentRunOutputViewer] Using recent cache, skipping refresh');
163:             return;
164:           }
165:         }
166:       }
167: 
168:       setLoading(true);
169: 
170:       // If we have a session_id, try to load from JSONL file first
171:       if (run.session_id && run.session_id !== '') {
172:         console.log('[AgentRunOutputViewer] Attempting to load from JSONL with session_id:', run.session_id);
173:         try {
174:           const history = await api.loadAgentSessionHistory(run.session_id);
175:           console.log('[AgentRunOutputViewer] Successfully loaded JSONL history:', history.length, 'messages');
176:           
177:           // Convert history to messages format
178:           const loadedMessages: ClaudeStreamMessage[] = history.map(entry => ({
179:             ...entry,
180:             type: entry.type || "assistant"
181:           }));
182:           
183:           setMessages(loadedMessages);
184:           setRawJsonlOutput(history.map(h => JSON.stringify(h)));
185:           
186:           // Update cache
187:           setCachedOutput(run.id, {
188:             output: history.map(h => JSON.stringify(h)).join('\n'),
189:             messages: loadedMessages,
190:             lastUpdated: Date.now(),
191:             status: run.status
192:           });
193:           
194:           // Set up live event listeners for running sessions
195:           if (run.status === 'running') {
196:             console.log('[AgentRunOutputViewer] Setting up live listeners for running session');
197:             setupLiveEventListeners();
198:             
199:             try {
200:               await api.streamSessionOutput(run.id);
201:             } catch (streamError) {
202:               console.warn('[AgentRunOutputViewer] Failed to start streaming, will poll instead:', streamError);
203:             }
204:           }
205:           
206:           return;
207:         } catch (err) {
208:           console.warn('[AgentRunOutputViewer] Failed to load from JSONL:', err);
209:           console.warn('[AgentRunOutputViewer] Falling back to regular output method');
210:         }
211:       } else {
212:         console.log('[AgentRunOutputViewer] No session_id available, using fallback method');
213:       }
214: 
215:       // Fallback to the original method if JSONL loading fails or no session_id
216:       console.log('[AgentRunOutputViewer] Using getSessionOutput fallback');
217:       const rawOutput = await api.getSessionOutput(run.id);
218:       console.log('[AgentRunOutputViewer] Received raw output:', rawOutput.length, 'characters');
219:       
220:       // Parse JSONL output into messages
221:       const jsonlLines = rawOutput.split('\n').filter(line => line.trim());
222:       setRawJsonlOutput(jsonlLines);
223:       
224:       const parsedMessages: ClaudeStreamMessage[] = [];
225:       for (const line of jsonlLines) {
226:         try {
227:           const message = JSON.parse(line) as ClaudeStreamMessage;
228:           parsedMessages.push(message);
229:         } catch (err) {
230:           console.error("[AgentRunOutputViewer] Failed to parse message:", err, line);
231:         }
232:       }
233:       console.log('[AgentRunOutputViewer] Parsed', parsedMessages.length, 'messages from output');
234:       setMessages(parsedMessages);
235:       
236:       // Update cache
237:       setCachedOutput(run.id, {
238:         output: rawOutput,
239:         messages: parsedMessages,
240:         lastUpdated: Date.now(),
241:         status: run.status
242:       });
243:       
244:       // Set up live event listeners for running sessions
245:       if (run.status === 'running') {
246:         console.log('[AgentRunOutputViewer] Setting up live listeners for running session (fallback)');
247:         setupLiveEventListeners();
248:         
249:         try {
250:           await api.streamSessionOutput(run.id);
251:         } catch (streamError) {
252:           console.warn('[AgentRunOutputViewer] Failed to start streaming (fallback), will poll instead:', streamError);
253:         }
254:       }
255:     } catch (error) {
256:       console.error('Failed to load agent output:', error);
257:       setToast({ message: 'Failed to load agent output', type: 'error' });
258:     } finally {
259:       setLoading(false);
260:     }
261:   };
262: 
263:   // Set up live event listeners for running sessions
264:   const setupLiveEventListeners = async () => {
265:     if (!run?.id || hasSetupListenersRef.current) return;
266:     
267:     try {
268:       // Clean up existing listeners
269:       unlistenRefs.current.forEach(unlisten => unlisten());
270:       unlistenRefs.current = [];
271: 
272:       // Mark that we've set up listeners
273:       hasSetupListenersRef.current = true;
274:       
275:       // After setup, we're no longer in initial load
276:       // Small delay to ensure any pending messages are processed
277:       setTimeout(() => {
278:         isInitialLoadRef.current = false;
279:       }, 100);
280: 
281:       // Set up live event listeners with run ID isolation
282:       const outputUnlisten = await listen<string>(`agent-output:${run!.id}`, (event) => {
283:         try {
284:           // Skip messages during initial load phase
285:           if (isInitialLoadRef.current) {
286:             console.log('[AgentRunOutputViewer] Skipping message during initial load');
287:             return;
288:           }
289:           
290:           // Store raw JSONL
291:           setRawJsonlOutput(prev => [...prev, event.payload]);
292:           
293:           // Parse and display
294:           const message = JSON.parse(event.payload) as ClaudeStreamMessage;
295:           setMessages(prev => [...prev, message]);
296:         } catch (err) {
297:           console.error("[AgentRunOutputViewer] Failed to parse message:", err, event.payload);
298:         }
299:       });
300: 
301:       const errorUnlisten = await listen<string>(`agent-error:${run!.id}`, (event) => {
302:         console.error("[AgentRunOutputViewer] Agent error:", event.payload);
303:         setToast({ message: event.payload, type: 'error' });
304:       });
305: 
306:       const completeUnlisten = await listen<boolean>(`agent-complete:${run!.id}`, () => {
307:         setToast({ message: 'Agent execution completed', type: 'success' });
308:         // Don't set status here as the parent component should handle it
309:       });
310: 
311:       const cancelUnlisten = await listen<boolean>(`agent-cancelled:${run!.id}`, () => {
312:         setToast({ message: 'Agent execution was cancelled', type: 'error' });
313:       });
314: 
315:       unlistenRefs.current = [outputUnlisten, errorUnlisten, completeUnlisten, cancelUnlisten];
316:     } catch (error) {
317:       console.error('[AgentRunOutputViewer] Failed to set up live event listeners:', error);
318:     }
319:   };
320: 
321:   // Copy functionality
322:   const handleCopyAsJsonl = async () => {
323:     const jsonl = rawJsonlOutput.join('\n');
324:     await navigator.clipboard.writeText(jsonl);
325:     setCopyPopoverOpen(false);
326:     setToast({ message: 'Output copied as JSONL', type: 'success' });
327:   };
328: 
329:   const handleCopyAsMarkdown = async () => {
330:     if (!run) return;
331:     let markdown = `# Agent Execution: ${run.agent_name}\n\n`;
332:     markdown += `**Task:** ${run.task}\n`;
333:     markdown += `**Model:** ${run.model === 'opus' ? 'Claude 4 Opus' : 'Claude 4 Sonnet'}\n`;
334:     markdown += `**Date:** ${formatISOTimestamp(run.created_at)}\n`;
335:     if (run.metrics?.duration_ms) markdown += `**Duration:** ${(run.metrics.duration_ms / 1000).toFixed(2)}s\n`;
336:     if (run.metrics?.total_tokens) markdown += `**Total Tokens:** ${run.metrics.total_tokens}\n`;
337:     if (run.metrics?.cost_usd) markdown += `**Cost:** $${run.metrics.cost_usd.toFixed(4)} USD\n`;
338:     markdown += `\n---\n\n`;
339: 
340:     for (const msg of messages) {
341:       if (msg.type === "system" && msg.subtype === "init") {
342:         markdown += `## System Initialization\n\n`;
343:         markdown += `- Session ID: \`${msg.session_id || 'N/A'}\`\n`;
344:         markdown += `- Model: \`${msg.model || 'default'}\`\n`;
345:         if (msg.cwd) markdown += `- Working Directory: \`${msg.cwd}\`\n`;
346:         if (msg.tools?.length) markdown += `- Tools: ${msg.tools.join(', ')}\n`;
347:         markdown += `\n`;
348:       } else if (msg.type === "assistant" && msg.message) {
349:         markdown += `## Assistant\n\n`;
350:         for (const content of msg.message.content || []) {
351:           if (content.type === "text") {
352:             markdown += `${content.text}\n\n`;
353:           } else if (content.type === "tool_use") {
354:             markdown += `### Tool: ${content.name}\n\n`;
355:             markdown += `\`\`\`json\n${JSON.stringify(content.input, null, 2)}\n\`\`\`\n\n`;
356:           }
357:         }
358:         if (msg.message.usage) {
359:           markdown += `*Tokens: ${msg.message.usage.input_tokens} in, ${msg.message.usage.output_tokens} out*\n\n`;
360:         }
361:       } else if (msg.type === "user" && msg.message) {
362:         markdown += `## User\n\n`;
363:         for (const content of msg.message.content || []) {
364:           if (content.type === "text") {
365:             markdown += `${content.text}\n\n`;
366:           } else if (content.type === "tool_result") {
367:             markdown += `### Tool Result\n\n`;
368:             markdown += `\`\`\`\n${content.content}\n\`\`\`\n\n`;
369:           }
370:         }
371:       } else if (msg.type === "result") {
372:         markdown += `## Execution Result\n\n`;
373:         if (msg.result) {
374:           markdown += `${msg.result}\n\n`;
375:         }
376:         if (msg.error) {
377:           markdown += `**Error:** ${msg.error}\n\n`;
378:         }
379:       }
380:     }
381: 
382:     await navigator.clipboard.writeText(markdown);
383:     setCopyPopoverOpen(false);
384:     setToast({ message: 'Output copied as Markdown', type: 'success' });
385:   };
386: 
387:   const handleRefresh = async () => {
388:     setRefreshing(true);
389:     await loadOutput();
390:     setRefreshing(false);
391:   };
392: 
393:   const handleStop = async () => {
394:     if (!run?.id) {
395:       console.error('[AgentRunOutputViewer] No run ID available to stop');
396:       return;
397:     }
398: 
399:     try {
400:       // Call the API to kill the agent session
401:       const success = await api.killAgentSession(run.id);
402:       
403:       if (success) {
404:         console.log(`[AgentRunOutputViewer] Successfully stopped agent session ${run.id}`);
405:         setToast({ message: 'Agent execution stopped', type: 'success' });
406:         
407:         // Clean up listeners
408:         unlistenRefs.current.forEach(unlisten => unlisten());
409:         unlistenRefs.current = [];
410:         hasSetupListenersRef.current = false;
411:         
412:         // Add a message indicating execution was stopped
413:         const stopMessage: ClaudeStreamMessage = {
414:           type: "result",
415:           subtype: "error",
416:           is_error: true,
417:           result: "Execution stopped by user",
418:           duration_ms: 0,
419:           usage: {
420:             input_tokens: 0,
421:             output_tokens: 0
422:           }
423:         };
424:         setMessages(prev => [...prev, stopMessage]);
425:         
426:         // Update the tab status
427:         updateTabStatus(tabId, 'idle');
428:         
429:         // Refresh the output to get updated status
430:         await loadOutput(true);
431:       } else {
432:         console.warn(`[AgentRunOutputViewer] Failed to stop agent session ${run.id} - it may have already finished`);
433:         setToast({ message: 'Failed to stop agent - it may have already finished', type: 'error' });
434:       }
435:     } catch (err) {
436:       console.error('[AgentRunOutputViewer] Failed to stop agent:', err);
437:       setToast({ 
438:         message: `Failed to stop execution: ${err instanceof Error ? err.message : 'Unknown error'}`, 
439:         type: 'error' 
440:       });
441:     }
442:   };
443: 
444:   const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {
445:     const target = e.currentTarget;
446:     const { scrollTop, scrollHeight, clientHeight } = target;
447:     const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
448:     setHasUserScrolled(distanceFromBottom > 50);
449:   };
450: 
451:   // Load output on mount
452:   useEffect(() => {
453:     if (!run?.id) return;
454:     
455:     // Check cache immediately for instant display
456:     const cached = getCachedOutput(run!.id);
457:     if (cached) {
458:       const cachedJsonlLines = cached.output.split('\n').filter(line => line.trim());
459:       setRawJsonlOutput(cachedJsonlLines);
460:       setMessages(cached.messages);
461:     }
462:     
463:     // Then load fresh data
464:     loadOutput();
465:   }, [run?.id]);
466: 
467:   const displayableMessages = useMemo(() => {
468:     return messages.filter((message) => {
469:       if (message.isMeta && !message.leafUuid && !message.summary) return false;
470: 
471:       if (message.type === "user" && message.message) {
472:         if (message.isMeta) return false;
473: 
474:         const msg = message.message;
475:         if (!msg.content || (Array.isArray(msg.content) && msg.content.length === 0)) return false;
476: 
477:         if (Array.isArray(msg.content)) {
478:           let hasVisibleContent = false;
479:           for (const content of msg.content) {
480:             if (content.type === "text") { hasVisibleContent = true; break; }
481:             if (content.type === "tool_result") {
482:               // Check if this tool result will be displayed as a widget
483:               let willBeSkipped = false;
484:               if (content.tool_use_id) {
485:                 // Find the corresponding tool use
486:                 for (let i = messages.indexOf(message) - 1; i >= 0; i--) {
487:                   const prevMsg = messages[i];
488:                   if (prevMsg.type === 'assistant' && prevMsg.message?.content && Array.isArray(prevMsg.message.content)) {
489:                     const toolUse = prevMsg.message.content.find((c: any) => c.type === 'tool_use' && c.id === content.tool_use_id);
490:                     if (toolUse) {
491:                       const toolName = toolUse.name?.toLowerCase();
492:                       const toolsWithWidgets = ['task','edit','multiedit','todowrite','ls','read','glob','bash','write','grep'];
493:                       if (toolsWithWidgets.includes(toolName) || toolUse.name?.startsWith('mcp__')) {
494:                         willBeSkipped = true;
495:                       }
496:                       break;
497:                     }
498:                   }
499:                 }
500:               }
501:               if (!willBeSkipped) { hasVisibleContent = true; break; }
502:             }
503:           }
504:           if (!hasVisibleContent) return false;
505:         }
506:       }
507:       return true;
508:     });
509:   }, [messages]);
510: 
511:   const renderIcon = (iconName: string) => {
512:     const Icon = AGENT_ICONS[iconName as keyof typeof AGENT_ICONS] || Bot;
513:     return <Icon className="h-5 w-5" />;
514:   };
515: 
516:   const formatDuration = (ms?: number) => {
517:     if (!ms) return "N/A";
518:     const seconds = Math.floor(ms / 1000);
519:     if (seconds < 60) return `${seconds}s`;
520:     const minutes = Math.floor(seconds / 60);
521:     const remainingSeconds = seconds % 60;
522:     return `${minutes}m ${remainingSeconds}s`;
523:   };
524: 
525:   const formatTokens = (tokens?: number) => {
526:     if (!tokens) return "0";
527:     if (tokens >= 1000) {
528:       return `${(tokens / 1000).toFixed(1)}k`;
529:     }
530:     return tokens.toString();
531:   };
532: 
533:   if (!run) {
534:     return (
535:       <div className="flex items-center justify-center h-full">
536:         <div className="text-center">
537:           <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
538:           <p className="text-muted-foreground">Loading agent run...</p>
539:         </div>
540:       </div>
541:     );
542:   }
543: 
544:   return (
545:     <>
546:       <div className={`h-full flex flex-col ${className || ''}`}>
547:         <Card className="h-full flex flex-col">
548:         <CardHeader className="pb-3">
549:           <div className="flex items-start justify-between gap-4">
550:               <div className="flex items-start gap-3 flex-1 min-w-0">
551:                 <div className="mt-0.5">
552:                   {renderIcon(run.agent_icon)}
553:                 </div>
554:                 <div className="flex-1 min-w-0">
555:                   <CardTitle className="text-lg flex items-center gap-2">
556:                     {run.agent_name}
557:                     {run.status === 'running' && (
558:                       <div className="flex items-center gap-1">
559:                         <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
560:                         <span className="text-xs text-green-600 font-medium">Running</span>
561:                       </div>
562:                     )}
563:                   </CardTitle>
564:                   <p className="text-sm text-muted-foreground mt-1 truncate">
565:                     {run.task}
566:                   </p>
567:                   <div className="flex items-center gap-3 text-xs text-muted-foreground mt-2">
568:                     <Badge variant="outline" className="text-xs">
569:                       {run.model === 'opus' ? 'Claude 4 Opus' : 'Claude 4 Sonnet'}
570:                     </Badge>
571:                     <div className="flex items-center gap-1">
572:                       <Clock className="h-3 w-3" />
573:                       <span>{formatISOTimestamp(run.created_at)}</span>
574:                     </div>
575:                     {run.metrics?.duration_ms && (
576:                       <span>{formatDuration(run.metrics.duration_ms)}</span>
577:                     )}
578:                     {run.metrics?.total_tokens && (
579:                       <div className="flex items-center gap-1">
580:                         <Hash className="h-3 w-3" />
581:                         <span>{formatTokens(run.metrics.total_tokens)}</span>
582:                       </div>
583:                     )}
584:                     {run.metrics?.cost_usd && (
585:                       <div className="flex items-center gap-1">
586:                         <DollarSign className="h-3 w-3" />
587:                         <span>${run.metrics.cost_usd.toFixed(4)}</span>
588:                       </div>
589:                     )}
590:                   </div>
591:                 </div>
592:               </div>
593:               <div className="flex items-center gap-1">
594:                 <Popover
595:                   trigger={
596:                     <Button
597:                       variant="ghost"
598:                       size="sm"
599:                       className="h-8 px-2"
600:                     >
601:                       <Copy className="h-4 w-4 mr-1" />
602:                       Copy
603:                       <ChevronDown className="h-3 w-3 ml-1" />
604:                     </Button>
605:                   }
606:                   content={
607:                     <div className="w-44 p-1">
608:                       <Button
609:                         variant="ghost"
610:                         size="sm"
611:                         className="w-full justify-start"
612:                         onClick={handleCopyAsJsonl}
613:                       >
614:                         Copy as JSONL
615:                       </Button>
616:                       <Button
617:                         variant="ghost"
618:                         size="sm"
619:                         className="w-full justify-start"
620:                         onClick={handleCopyAsMarkdown}
621:                       >
622:                         Copy as Markdown
623:                       </Button>
624:                     </div>
625:                   }
626:                   open={copyPopoverOpen}
627:                   onOpenChange={setCopyPopoverOpen}
628:                   align="end"
629:                 />
630:                 <Button
631:                   variant="ghost"
632:                   size="sm"
633:                   onClick={() => setIsFullscreen(!isFullscreen)}
634:                   title={isFullscreen ? "Exit fullscreen" : "Enter fullscreen"}
635:                   className="h-8 px-2"
636:                 >
637:                   {isFullscreen ? (
638:                     <Minimize2 className="h-4 w-4" />
639:                   ) : (
640:                     <Maximize2 className="h-4 w-4" />
641:                   )}
642:                 </Button>
643:                 <Button
644:                   variant="ghost"
645:                   size="sm"
646:                   onClick={handleRefresh}
647:                   disabled={refreshing}
648:                   title="Refresh output"
649:                   className="h-8 px-2"
650:                 >
651:                   <RotateCcw className={`h-4 w-4 ${refreshing ? 'animate-spin' : ''}`} />
652:                 </Button>
653:                 {run.status === 'running' && (
654:                   <Button
655:                     variant="ghost"
656:                     size="sm"
657:                     onClick={handleStop}
658:                     disabled={refreshing}
659:                     title="Stop execution"
660:                     className="h-8 px-2 text-destructive hover:text-destructive"
661:                   >
662:                     <StopCircle className="h-4 w-4" />
663:                   </Button>
664:                 )}
665:               </div>
666:           </div>
667:         </CardHeader>
668:         <CardContent className={`${isFullscreen ? 'h-[calc(100vh-120px)]' : 'flex-1'} p-0 overflow-hidden`}>
669:           {loading ? (
670:               <div className="flex items-center justify-center h-full">
671:                 <div className="flex items-center space-x-2">
672:                   <RefreshCw className="h-4 w-4 animate-spin" />
673:                   <span>Loading output...</span>
674:                 </div>
675:               </div>
676:             ) : messages.length === 0 ? (
677:               <div className="flex items-center justify-center h-full text-muted-foreground">
678:                 <p>No output available yet</p>
679:               </div>
680:             ) : (
681:               <div 
682:                 ref={scrollAreaRef}
683:                 className="h-full overflow-y-auto p-4 space-y-2"
684:                 onScroll={handleScroll}
685:               >
686:                 <AnimatePresence>
687:                   {displayableMessages.map((message: ClaudeStreamMessage, index: number) => (
688:                     <motion.div
689:                       key={index}
690:                       initial={{ opacity: 0, y: 10 }}
691:                       animate={{ opacity: 1, y: 0 }}
692:                       transition={{ duration: 0.2 }}
693:                     >
694:                       <ErrorBoundary>
695:                         <StreamMessage message={message} streamMessages={messages} />
696:                       </ErrorBoundary>
697:                     </motion.div>
698:                   ))}
699:                 </AnimatePresence>
700:                 <div ref={outputEndRef} />
701:               </div>
702:           )}
703:         </CardContent>
704:         </Card>
705:       </div>
706: 
707:       {/* Fullscreen Modal */}
708:       {isFullscreen && (
709:         <div className="fixed inset-0 bg-background z-[60] flex flex-col">
710:           <div className="flex items-center justify-between p-4 border-b">
711:             <div className="flex items-center gap-3">
712:               {renderIcon(run.agent_icon)}
713:               <div>
714:                 <h3 className="font-semibold text-lg">{run.agent_name}</h3>
715:                 <p className="text-sm text-muted-foreground">{run.task}</p>
716:               </div>
717:             </div>
718:             <div className="flex items-center gap-2">
719:               <Popover
720:                 trigger={
721:                   <Button
722:                     variant="outline"
723:                     size="sm"
724:                   >
725:                     <Copy className="h-4 w-4 mr-2" />
726:                     Copy Output
727:                     <ChevronDown className="h-3 w-3 ml-2" />
728:                   </Button>
729:                 }
730:                 content={
731:                   <div className="w-44 p-1">
732:                     <Button
733:                       variant="ghost"
734:                       size="sm"
735:                       className="w-full justify-start"
736:                       onClick={handleCopyAsJsonl}
737:                     >
738:                       Copy as JSONL
739:                     </Button>
740:                     <Button
741:                       variant="ghost"
742:                       size="sm"
743:                       className="w-full justify-start"
744:                       onClick={handleCopyAsMarkdown}
745:                     >
746:                       Copy as Markdown
747:                     </Button>
748:                   </div>
749:                 }
750:                 align="end"
751:               />
752:               <Button
753:                 variant="outline"
754:                 size="sm"
755:                 onClick={handleRefresh}
756:                 disabled={refreshing}
757:               >
758:                 <RotateCcw className={`h-4 w-4 ${refreshing ? 'animate-spin' : ''}`} />
759:               </Button>
760:               {run.status === 'running' && (
761:                 <Button
762:                   variant="outline"
763:                   size="sm"
764:                   onClick={handleStop}
765:                   disabled={refreshing}
766:                 >
767:                   <StopCircle className="h-4 w-4 mr-2" />
768:                   Stop
769:                 </Button>
770:               )}
771:               <Button
772:                 variant="outline"
773:                 size="sm"
774:                 onClick={() => setIsFullscreen(false)}
775:               >
776:                 <Minimize2 className="h-4 w-4 mr-2" />
777:                 Exit Fullscreen
778:               </Button>
779:             </div>
780:           </div>
781:           <div 
782:             ref={fullscreenScrollRef}
783:             className="flex-1 overflow-y-auto p-6"
784:             onScroll={handleScroll}
785:           >
786:             <div className="max-w-4xl mx-auto space-y-2">
787:               {messages.length === 0 ? (
788:                 <div className="text-center text-muted-foreground py-8">
789:                   No output available yet
790:                 </div>
791:               ) : (
792:                 <>
793:                   <AnimatePresence>
794:                     {displayableMessages.map((message: ClaudeStreamMessage, index: number) => (
795:                       <motion.div
796:                         key={index}
797:                         initial={{ opacity: 0, y: 10 }}
798:                         animate={{ opacity: 1, y: 0 }}
799:                         transition={{ duration: 0.2 }}
800:                       >
801:                         <ErrorBoundary>
802:                           <StreamMessage message={message} streamMessages={messages} />
803:                         </ErrorBoundary>
804:                       </motion.div>
805:                     ))}
806:                   </AnimatePresence>
807:                   <div ref={fullscreenMessagesEndRef} />
808:                 </>
809:               )}
810:             </div>
811:           </div>
812:         </div>
813:       )}
814: 
815:       {/* Toast Notification */}
816:       <ToastContainer>
817:         {toast && (
818:           <Toast
819:             message={toast.message}
820:             type={toast.type}
821:             onDismiss={() => setToast(null)}
822:           />
823:         )}
824:       </ToastContainer>
825:     </>
826:   );
827: }
828: 
829: export default AgentRunOutputViewer;
````

## File: src/components/AgentRunsList.tsx
````typescript
  1: import React, { useState } from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import { Play, Clock, Hash, Bot } from "lucide-react";
  4: import { Card, CardContent } from "@/components/ui/card";
  5: import { Badge } from "@/components/ui/badge";
  6: import { Pagination } from "@/components/ui/pagination";
  7: import { cn } from "@/lib/utils";
  8: import { formatISOTimestamp } from "@/lib/date-utils";
  9: import type { AgentRunWithMetrics } from "@/lib/api";
 10: import { AGENT_ICONS } from "./CCAgents";
 11: import { useTabState } from "@/hooks/useTabState";
 12: 
 13: interface AgentRunsListProps {
 14:   /**
 15:    * Array of agent runs to display
 16:    */
 17:   runs: AgentRunWithMetrics[];
 18:   /**
 19:    * Callback when a run is clicked
 20:    */
 21:   onRunClick?: (run: AgentRunWithMetrics) => void;
 22:   /**
 23:    * Optional className for styling
 24:    */
 25:   className?: string;
 26: }
 27: 
 28: const ITEMS_PER_PAGE = 5;
 29: 
 30: /**
 31:  * AgentRunsList component - Displays a paginated list of agent execution runs
 32:  * 
 33:  * @example
 34:  * <AgentRunsList
 35:  *   runs={runs}
 36:  *   onRunClick={(run) => console.log('Selected:', run)}
 37:  * />
 38:  */
 39: export const AgentRunsList: React.FC<AgentRunsListProps> = ({
 40:   runs,
 41:   onRunClick,
 42:   className,
 43: }) => {
 44:   const [currentPage, setCurrentPage] = useState(1);
 45:   const { createAgentTab } = useTabState();
 46:   
 47:   // Calculate pagination
 48:   const totalPages = Math.ceil(runs.length / ITEMS_PER_PAGE);
 49:   const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
 50:   const endIndex = startIndex + ITEMS_PER_PAGE;
 51:   const currentRuns = runs.slice(startIndex, endIndex);
 52:   
 53:   // Reset to page 1 if runs change
 54:   React.useEffect(() => {
 55:     setCurrentPage(1);
 56:   }, [runs.length]);
 57:   
 58:   const renderIcon = (iconName: string) => {
 59:     const Icon = AGENT_ICONS[iconName as keyof typeof AGENT_ICONS] || Bot;
 60:     return <Icon className="h-4 w-4" />;
 61:   };
 62:   
 63:   const formatDuration = (ms?: number) => {
 64:     if (!ms) return "N/A";
 65:     const seconds = Math.floor(ms / 1000);
 66:     if (seconds < 60) return `${seconds}s`;
 67:     const minutes = Math.floor(seconds / 60);
 68:     const remainingSeconds = seconds % 60;
 69:     return `${minutes}m ${remainingSeconds}s`;
 70:   };
 71:   
 72:   const formatTokens = (tokens?: number) => {
 73:     if (!tokens) return "0";
 74:     if (tokens >= 1000) {
 75:       return `${(tokens / 1000).toFixed(1)}k`;
 76:     }
 77:     return tokens.toString();
 78:   };
 79:   
 80:   const handleRunClick = (run: AgentRunWithMetrics) => {
 81:     // If there's a callback, use it (for full-page navigation)
 82:     if (onRunClick) {
 83:       onRunClick(run);
 84:     } else if (run.id) {
 85:       // Otherwise, open in new tab
 86:       createAgentTab(run.id.toString(), run.agent_name);
 87:     }
 88:   };
 89:   
 90:   if (runs.length === 0) {
 91:     return (
 92:       <div className={cn("text-center py-8 text-muted-foreground", className)}>
 93:         <Play className="h-8 w-8 mx-auto mb-2 opacity-50" />
 94:         <p className="text-sm">No execution history yet</p>
 95:       </div>
 96:     );
 97:   }
 98: 
 99:   return (
100:     <>
101:       <div className={cn("space-y-2", className)}>
102:         <AnimatePresence mode="popLayout">
103:           {currentRuns.map((run, index) => (
104:             <motion.div
105:               key={run.id}
106:               initial={{ opacity: 0, y: 20 }}
107:               animate={{ opacity: 1, y: 0 }}
108:               exit={{ opacity: 0, y: -20 }}
109:               transition={{
110:                 duration: 0.3,
111:                 delay: index * 0.05,
112:                 ease: [0.4, 0, 0.2, 1],
113:               }}
114:             >
115:               <Card
116:                 className={cn(
117:                   "cursor-pointer transition-all hover:shadow-md hover:scale-[1.01] active:scale-[0.99]",
118:                   run.status === "running" && "border-green-500/50"
119:                 )}
120:                 onClick={() => handleRunClick(run)}
121:               >
122:                 <CardContent className="p-3">
123:                   <div className="flex items-center gap-3">
124:                     <div className="flex-shrink-0">
125:                       {renderIcon(run.agent_icon)}
126:                     </div>
127:                     
128:                     <div className="flex-1 min-w-0">
129:                       <div className="flex items-center gap-2 mb-1">
130:                         <h4 className="text-sm font-medium truncate">
131:                           {run.agent_name}
132:                         </h4>
133:                         {run.status === "running" && (
134:                           <div className="flex items-center gap-1">
135:                             <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
136:                             <span className="text-xs text-green-600 font-medium">Running</span>
137:                           </div>
138:                         )}
139:                       </div>
140:                       
141:                       <p className="text-xs text-muted-foreground truncate mb-1">
142:                         {run.task}
143:                       </p>
144:                       
145:                       <div className="flex items-center gap-3 text-xs text-muted-foreground">
146:                         <div className="flex items-center gap-1">
147:                           <Clock className="h-3 w-3" />
148:                           <span>{formatISOTimestamp(run.created_at)}</span>
149:                         </div>
150:                         
151:                         {run.metrics?.duration_ms && (
152:                           <span>{formatDuration(run.metrics.duration_ms)}</span>
153:                         )}
154:                         
155:                         {run.metrics?.total_tokens && (
156:                           <div className="flex items-center gap-1">
157:                             <Hash className="h-3 w-3" />
158:                             <span>{formatTokens(run.metrics.total_tokens)}</span>
159:                           </div>
160:                         )}
161:                       </div>
162:                     </div>
163:                     
164:                     <div className="flex-shrink-0">
165:                       <Badge 
166:                         variant={
167:                           run.status === "completed" ? "default" :
168:                           run.status === "running" ? "secondary" :
169:                           run.status === "failed" ? "destructive" :
170:                           "outline"
171:                         }
172:                         className="text-xs"
173:                       >
174:                         {run.status === "completed" ? "Completed" :
175:                          run.status === "running" ? "Running" :
176:                          run.status === "failed" ? "Failed" :
177:                          "Pending"}
178:                       </Badge>
179:                     </div>
180:                   </div>
181:                 </CardContent>
182:               </Card>
183:             </motion.div>
184:           ))}
185:         </AnimatePresence>
186:         
187:         {/* Pagination */}
188:         {totalPages > 1 && (
189:           <div className="pt-2">
190:             <Pagination
191:               currentPage={currentPage}
192:               totalPages={totalPages}
193:               onPageChange={setCurrentPage}
194:             />
195:           </div>
196:         )}
197:       </div>
198: 
199:     </>
200:   );
201: };
````

## File: src/components/AgentRunView.tsx
````typescript
  1: import React, { useState, useEffect } from "react";
  2: import { motion } from "framer-motion";
  3: import { 
  4:   ArrowLeft, 
  5:   Copy, 
  6:   ChevronDown, 
  7:   Clock,
  8:   Hash,
  9:   DollarSign,
 10:   Bot,
 11:   StopCircle
 12: } from "lucide-react";
 13: import { Button } from "@/components/ui/button";
 14: import { Badge } from "@/components/ui/badge";
 15: import { Card, CardContent } from "@/components/ui/card";
 16: import { Popover } from "@/components/ui/popover";
 17: import { api, type AgentRunWithMetrics } from "@/lib/api";
 18: import { cn } from "@/lib/utils";
 19: import { formatISOTimestamp } from "@/lib/date-utils";
 20: import { StreamMessage } from "./StreamMessage";
 21: import { AGENT_ICONS } from "./CCAgents";
 22: import type { ClaudeStreamMessage } from "./AgentExecution";
 23: import { ErrorBoundary } from "./ErrorBoundary";
 24: 
 25: interface AgentRunViewProps {
 26:   /**
 27:    * The run ID to view
 28:    */
 29:   runId: number;
 30:   /**
 31:    * Callback to go back
 32:    */
 33:   onBack: () => void;
 34:   /**
 35:    * Optional className for styling
 36:    */
 37:   className?: string;
 38: }
 39: 
 40: /**
 41:  * AgentRunView component for viewing past agent execution details
 42:  * 
 43:  * @example
 44:  * <AgentRunView runId={123} onBack={() => setView('list')} />
 45:  */
 46: export const AgentRunView: React.FC<AgentRunViewProps> = ({
 47:   runId,
 48:   onBack,
 49:   className,
 50: }) => {
 51:   const [run, setRun] = useState<AgentRunWithMetrics | null>(null);
 52:   const [messages, setMessages] = useState<ClaudeStreamMessage[]>([]);
 53:   const [loading, setLoading] = useState(true);
 54:   const [error, setError] = useState<string | null>(null);
 55:   const [copyPopoverOpen, setCopyPopoverOpen] = useState(false);
 56: 
 57:   useEffect(() => {
 58:     loadRun();
 59:   }, [runId]);
 60: 
 61:   const loadRun = async () => {
 62:     try {
 63:       setLoading(true);
 64:       setError(null);
 65:       const runData = await api.getAgentRunWithRealTimeMetrics(runId);
 66:       setRun(runData);
 67:       
 68:       // If we have a session_id, try to load from JSONL file first
 69:       if (runData.session_id && runData.session_id !== '') {
 70:         try {
 71:           const history = await api.loadAgentSessionHistory(runData.session_id);
 72:           
 73:           // Convert history to messages format
 74:           const loadedMessages: ClaudeStreamMessage[] = history.map(entry => ({
 75:             ...entry,
 76:             type: entry.type || "assistant"
 77:           }));
 78:           
 79:           setMessages(loadedMessages);
 80:           return;
 81:         } catch (err) {
 82:           console.warn('Failed to load from JSONL, falling back to output field:', err);
 83:         }
 84:       }
 85:       
 86:       // Fallback: Parse JSONL output from the output field
 87:       if (runData.output) {
 88:         const parsedMessages: ClaudeStreamMessage[] = [];
 89:         const lines = runData.output.split('\n').filter(line => line.trim());
 90:         
 91:         for (const line of lines) {
 92:           try {
 93:             const msg = JSON.parse(line) as ClaudeStreamMessage;
 94:             parsedMessages.push(msg);
 95:           } catch (err) {
 96:             console.error("Failed to parse line:", line, err);
 97:           }
 98:         }
 99:         
100:         setMessages(parsedMessages);
101:       }
102:     } catch (err) {
103:       console.error("Failed to load run:", err);
104:       setError("Failed to load execution details");
105:     } finally {
106:       setLoading(false);
107:     }
108:   };
109: 
110:   const handleCopyAsJsonl = async () => {
111:     if (!run?.output) return;
112:     await navigator.clipboard.writeText(run.output);
113:     setCopyPopoverOpen(false);
114:   };
115: 
116:   const handleCopyAsMarkdown = async () => {
117:     if (!run) return;
118:     
119:     let markdown = `# Agent Run: ${run.agent_name}\n\n`;
120:     markdown += `**Task:** ${run.task}\n`;
121:     markdown += `**Model:** ${run.model}\n`;
122:     markdown += `**Status:** ${run.status}\n`;
123:     if (run.metrics) {
124:       markdown += `**Tokens:** ${run.metrics.total_tokens || 'N/A'}\n`;
125:       markdown += `**Cost:** $${run.metrics.cost_usd?.toFixed(4) || 'N/A'}\n`;
126:     }
127:     markdown += `**Date:** ${new Date(run.created_at).toISOString()}\n\n`;
128:     markdown += `---\n\n`;
129: 
130:     for (const msg of messages) {
131:       if (msg.type === "system" && msg.subtype === "init") {
132:         markdown += `## System Initialization\n\n`;
133:         markdown += `- Session ID: \`${msg.session_id || 'N/A'}\`\n`;
134:         markdown += `- Model: \`${msg.model || 'default'}\`\n`;
135:         if (msg.cwd) markdown += `- Working Directory: \`${msg.cwd}\`\n`;
136:         if (msg.tools?.length) markdown += `- Tools: ${msg.tools.join(', ')}\n`;
137:         markdown += `\n`;
138:       } else if (msg.type === "assistant" && msg.message) {
139:         markdown += `## Assistant\n\n`;
140:         for (const content of msg.message.content || []) {
141:           if (content.type === "text") {
142:             markdown += `${content.text}\n\n`;
143:           } else if (content.type === "tool_use") {
144:             markdown += `### Tool: ${content.name}\n\n`;
145:             markdown += `\`\`\`json\n${JSON.stringify(content.input, null, 2)}\n\`\`\`\n\n`;
146:           }
147:         }
148:         if (msg.message.usage) {
149:           markdown += `*Tokens: ${msg.message.usage.input_tokens} in, ${msg.message.usage.output_tokens} out*\n\n`;
150:         }
151:       } else if (msg.type === "user" && msg.message) {
152:         markdown += `## User\n\n`;
153:         for (const content of msg.message.content || []) {
154:           if (content.type === "text") {
155:             markdown += `${content.text}\n\n`;
156:           } else if (content.type === "tool_result") {
157:             markdown += `### Tool Result\n\n`;
158:             markdown += `\`\`\`\n${content.content}\n\`\`\`\n\n`;
159:           }
160:         }
161:       } else if (msg.type === "result") {
162:         markdown += `## Execution Result\n\n`;
163:         if (msg.result) {
164:           markdown += `${msg.result}\n\n`;
165:         }
166:         if (msg.error) {
167:           markdown += `**Error:** ${msg.error}\n\n`;
168:         }
169:       }
170:     }
171: 
172:     await navigator.clipboard.writeText(markdown);
173:     setCopyPopoverOpen(false);
174:   };
175: 
176:   const handleStop = async () => {
177:     if (!runId) {
178:       console.error('[AgentRunView] No run ID available to stop');
179:       return;
180:     }
181: 
182:     try {
183:       // Call the API to kill the agent session
184:       const success = await api.killAgentSession(runId);
185:       
186:       if (success) {
187:         console.log(`[AgentRunView] Successfully stopped agent session ${runId}`);
188:         
189:         // Update the run status locally
190:         if (run) {
191:           setRun({ ...run, status: 'cancelled' });
192:         }
193:         
194:         // Add a message indicating execution was stopped
195:         const stopMessage: ClaudeStreamMessage = {
196:           type: "result",
197:           subtype: "error",
198:           is_error: true,
199:           result: "Execution stopped by user",
200:           duration_ms: 0,
201:           usage: {
202:             input_tokens: 0,
203:             output_tokens: 0
204:           }
205:         };
206:         setMessages(prev => [...prev, stopMessage]);
207:         
208:         // Reload the run data after a short delay
209:         setTimeout(() => {
210:           loadRun();
211:         }, 1000);
212:       } else {
213:         console.warn(`[AgentRunView] Failed to stop agent session ${runId} - it may have already finished`);
214:       }
215:     } catch (err) {
216:       console.error('[AgentRunView] Failed to stop agent:', err);
217:     }
218:   };
219: 
220:   const renderIcon = (iconName: string) => {
221:     const Icon = AGENT_ICONS[iconName as keyof typeof AGENT_ICONS] || Bot;
222:     return <Icon className="h-5 w-5" />;
223:   };
224: 
225:   if (loading) {
226:     return (
227:       <div className={cn("flex items-center justify-center h-full", className)}>
228:         <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
229:       </div>
230:     );
231:   }
232: 
233:   if (error || !run) {
234:     return (
235:       <div className={cn("flex flex-col items-center justify-center h-full", className)}>
236:         <p className="text-destructive mb-4">{error || "Run not found"}</p>
237:         <Button onClick={onBack}>Go Back</Button>
238:       </div>
239:     );
240:   }
241: 
242:   return (
243:     <div className={cn("flex flex-col h-full bg-background", className)}>
244:       <div className="w-full max-w-5xl mx-auto h-full flex flex-col">
245:         {/* Header */}
246:         <motion.div
247:           initial={{ opacity: 0, y: -20 }}
248:           animate={{ opacity: 1, y: 0 }}
249:           transition={{ duration: 0.3 }}
250:           className="flex items-center justify-between p-4 border-b border-border"
251:         >
252:           <div className="flex items-center space-x-3">
253:             <Button
254:               variant="ghost"
255:               size="icon"
256:               onClick={onBack}
257:               className="h-8 w-8"
258:             >
259:               <ArrowLeft className="h-4 w-4" />
260:             </Button>
261:             <div className="flex items-center gap-2">
262:               {renderIcon(run.agent_icon)}
263:               <div>
264:                 <h2 className="text-lg font-semibold">{run.agent_name}</h2>
265:                 <p className="text-xs text-muted-foreground">Execution History</p>
266:               </div>
267:             </div>
268:           </div>
269:           
270:           <div className="flex items-center gap-2">
271:             {run?.status === 'running' && (
272:               <Button
273:                 size="sm"
274:                 variant="ghost"
275:                 onClick={handleStop}
276:                 className="text-destructive hover:text-destructive"
277:               >
278:                 <StopCircle className="h-4 w-4 mr-1" />
279:                 Stop
280:               </Button>
281:             )}
282:             
283:             <Popover
284:               trigger={
285:                 <Button
286:                   variant="ghost"
287:                   size="sm"
288:                   className="flex items-center gap-2"
289:                 >
290:                   <Copy className="h-4 w-4" />
291:                   Copy Output
292:                   <ChevronDown className="h-3 w-3" />
293:                 </Button>
294:               }
295:               content={
296:                 <div className="w-44 p-1">
297:                   <Button
298:                     variant="ghost"
299:                     size="sm"
300:                     className="w-full justify-start"
301:                     onClick={handleCopyAsJsonl}
302:                   >
303:                     Copy as JSONL
304:                   </Button>
305:                   <Button
306:                     variant="ghost"
307:                     size="sm"
308:                     className="w-full justify-start"
309:                     onClick={handleCopyAsMarkdown}
310:                   >
311:                     Copy as Markdown
312:                   </Button>
313:                 </div>
314:               }
315:               open={copyPopoverOpen}
316:               onOpenChange={setCopyPopoverOpen}
317:               align="end"
318:             />
319:           </div>
320:         </motion.div>
321:         
322:         {/* Run Details */}
323:         <Card className="m-4">
324:           <CardContent className="p-4">
325:             <div className="space-y-2">
326:               <div className="flex items-center gap-2">
327:                 <h3 className="text-sm font-medium">Task:</h3>
328:                 <p className="text-sm text-muted-foreground flex-1">{run.task}</p>
329:                 <Badge variant="outline" className="text-xs">
330:                   {run.model === 'opus' ? 'Claude 4 Opus' : 'Claude 4 Sonnet'}
331:                 </Badge>
332:               </div>
333:               
334:               <div className="flex items-center gap-4 text-xs text-muted-foreground">
335:                 <div className="flex items-center gap-1">
336:                   <Clock className="h-3 w-3" />
337:                   <span>{formatISOTimestamp(run.created_at)}</span>
338:                 </div>
339:                 
340:                 {run.metrics?.duration_ms && (
341:                   <div className="flex items-center gap-1">
342:                     <Clock className="h-3 w-3" />
343:                     <span>{(run.metrics.duration_ms / 1000).toFixed(2)}s</span>
344:                   </div>
345:                 )}
346:                 
347:                 {run.metrics?.total_tokens && (
348:                   <div className="flex items-center gap-1">
349:                     <Hash className="h-3 w-3" />
350:                     <span>{run.metrics.total_tokens} tokens</span>
351:                   </div>
352:                 )}
353:                 
354:                 {run.metrics?.cost_usd && (
355:                   <div className="flex items-center gap-1">
356:                     <DollarSign className="h-3 w-3" />
357:                     <span>${run.metrics.cost_usd.toFixed(4)}</span>
358:                   </div>
359:                 )}
360:               </div>
361:             </div>
362:           </CardContent>
363:         </Card>
364: 
365:         {/* Output Display */}
366:         <div className="flex-1 overflow-hidden">
367:           <div className="h-full overflow-y-auto p-4 space-y-2">
368:             {messages.map((message, index) => (
369:               <motion.div
370:                 key={index}
371:                 initial={{ opacity: 0, y: 10 }}
372:                 animate={{ opacity: 1, y: 0 }}
373:                 transition={{ duration: 0.2, delay: index * 0.02 }}
374:               >
375:                 <ErrorBoundary>
376:                   <StreamMessage message={message} streamMessages={messages} />
377:                 </ErrorBoundary>
378:               </motion.div>
379:             ))}
380:           </div>
381:         </div>
382:       </div>
383:     </div>
384:   );
385: };
````

## File: src/components/AgentsModal.tsx
````typescript
  1: import React, { useState, useEffect } from 'react';
  2: import { motion, AnimatePresence } from 'framer-motion';
  3: import { Bot, Plus, Loader2, Play, Clock, CheckCircle, XCircle, Trash2, Import, ChevronDown, FileJson, Globe, Download } from 'lucide-react';
  4: import {
  5:   Dialog,
  6:   DialogContent,
  7:   DialogHeader,
  8:   DialogTitle,
  9:   DialogDescription,
 10: } from '@/components/ui/dialog';
 11: import {
 12:   DropdownMenu,
 13:   DropdownMenuContent,
 14:   DropdownMenuItem,
 15:   DropdownMenuTrigger,
 16: } from '@/components/ui/dropdown-menu';
 17: import { Tabs, TabsList, TabsTrigger, TabsContent } from '@/components/ui/tabs';
 18: import { Button } from '@/components/ui/button';
 19: import { Badge } from '@/components/ui/badge';
 20: import { ScrollArea } from '@/components/ui/scroll-area';
 21: import { Toast } from '@/components/ui/toast';
 22: import { api, type Agent, type AgentRunWithMetrics } from '@/lib/api';
 23: import { useTabState } from '@/hooks/useTabState';
 24: import { formatISOTimestamp } from '@/lib/date-utils';
 25: import { open as openDialog, save } from '@tauri-apps/plugin-dialog';
 26: import { invoke } from '@tauri-apps/api/core';
 27: import { GitHubAgentBrowser } from '@/components/GitHubAgentBrowser';
 28: 
 29: interface AgentsModalProps {
 30:   open: boolean;
 31:   onOpenChange: (open: boolean) => void;
 32: }
 33: 
 34: export const AgentsModal: React.FC<AgentsModalProps> = ({ open, onOpenChange }) => {
 35:   const [activeTab, setActiveTab] = useState('agents');
 36:   const [agents, setAgents] = useState<Agent[]>([]);
 37:   const [runningAgents, setRunningAgents] = useState<AgentRunWithMetrics[]>([]);
 38:   const [loading, setLoading] = useState(true);
 39:   const [agentToDelete, setAgentToDelete] = useState<Agent | null>(null);
 40:   const [showDeleteDialog, setShowDeleteDialog] = useState(false);
 41:   const [toast, setToast] = useState<{ message: string; type: "success" | "error" } | null>(null);
 42:   const [showGitHubBrowser, setShowGitHubBrowser] = useState(false);
 43:   const { createAgentTab, createCreateAgentTab } = useTabState();
 44: 
 45:   // Load agents when modal opens
 46:   useEffect(() => {
 47:     if (open) {
 48:       loadAgents();
 49:       loadRunningAgents();
 50:     }
 51:   }, [open]);
 52: 
 53:   // Refresh running agents periodically
 54:   useEffect(() => {
 55:     if (!open) return;
 56:     
 57:     const interval = setInterval(() => {
 58:       loadRunningAgents();
 59:     }, 3000); // Refresh every 3 seconds
 60: 
 61:     return () => clearInterval(interval);
 62:   }, [open]);
 63: 
 64:   const loadAgents = async () => {
 65:     try {
 66:       setLoading(true);
 67:       const agentList = await api.listAgents();
 68:       setAgents(agentList);
 69:     } catch (error) {
 70:       console.error('Failed to load agents:', error);
 71:     } finally {
 72:       setLoading(false);
 73:     }
 74:   };
 75: 
 76:   const loadRunningAgents = async () => {
 77:     try {
 78:       const runs = await api.listRunningAgentSessions();
 79:       const agentRuns = runs.map(run => ({
 80:         id: run.id,
 81:         agent_id: run.agent_id,
 82:         agent_name: run.agent_name,
 83:         task: run.task,
 84:         model: run.model,
 85:         status: 'running' as const,
 86:         created_at: run.created_at,
 87:         project_path: run.project_path,
 88:       } as AgentRunWithMetrics));
 89:       
 90:       setRunningAgents(agentRuns);
 91:     } catch (error) {
 92:       console.error('Failed to load running agents:', error);
 93:     }
 94:   };
 95: 
 96:   const handleRunAgent = async (agent: Agent) => {
 97:     // Create a new agent execution tab
 98:     const tabId = `agent-exec-${agent.id}-${Date.now()}`;
 99:     
100:     // Close modal
101:     onOpenChange(false);
102:     
103:     // Dispatch event to open agent execution in the new tab
104:     window.dispatchEvent(new CustomEvent('open-agent-execution', { 
105:       detail: { agent, tabId } 
106:     }));
107:   };
108: 
109:   const handleDeleteAgent = async (agent: Agent) => {
110:     setAgentToDelete(agent);
111:     setShowDeleteDialog(true);
112:   };
113: 
114:   const confirmDelete = async () => {
115:     if (!agentToDelete?.id) return;
116:     try {
117:       await api.deleteAgent(agentToDelete.id);
118:       loadAgents(); // Refresh the list
119:       setShowDeleteDialog(false);
120:       setAgentToDelete(null);
121:     } catch (error) {
122:       console.error('Failed to delete agent:', error);
123:     }
124:   };
125: 
126:   const handleOpenAgentRun = (run: AgentRunWithMetrics) => {
127:     // Create new tab for this agent run
128:     createAgentTab(run.id!.toString(), run.agent_name);
129:     onOpenChange(false);
130:   };
131: 
132:   const handleCreateAgent = () => {
133:     // Close modal and create new tab
134:     onOpenChange(false);
135:     createCreateAgentTab();
136:   };
137: 
138:   const handleImportFromFile = async () => {
139:     try {
140:       const filePath = await openDialog({
141:         multiple: false,
142:         filters: [{
143:           name: 'JSON',
144:           extensions: ['json']
145:         }]
146:       });
147:       
148:       if (filePath) {
149:         const agent = await api.importAgentFromFile(filePath as string);
150:         loadAgents(); // Refresh list
151:         setToast({ message: `Agent "${agent.name}" imported successfully`, type: "success" });
152:       }
153:     } catch (error) {
154:       console.error('Failed to import agent:', error);
155:       setToast({ message: "Failed to import agent", type: "error" });
156:     }
157:   };
158: 
159:   const handleImportFromGitHub = () => {
160:     setShowGitHubBrowser(true);
161:   };
162: 
163:   const handleExportAgent = async (agent: Agent) => {
164:     try {
165:       const exportData = await api.exportAgent(agent.id!);
166:       const filePath = await save({
167:         defaultPath: `${agent.name.toLowerCase().replace(/\s+/g, '-')}.json`,
168:         filters: [{
169:           name: 'JSON',
170:           extensions: ['json']
171:         }]
172:       });
173:       
174:       if (filePath) {
175:         await invoke('write_file', { path: filePath, content: JSON.stringify(exportData, null, 2) });
176:         setToast({ message: "Agent exported successfully", type: "success" });
177:       }
178:     } catch (error) {
179:       console.error('Failed to export agent:', error);
180:       setToast({ message: "Failed to export agent", type: "error" });
181:     }
182:   };
183: 
184:   const getStatusIcon = (status: string) => {
185:     switch (status) {
186:       case 'running':
187:         return <Loader2 className="w-4 h-4 animate-spin" />;
188:       case 'completed':
189:         return <CheckCircle className="w-4 h-4 text-green-500" />;
190:       case 'failed':
191:         return <XCircle className="w-4 h-4 text-red-500" />;
192:       default:
193:         return <Clock className="w-4 h-4 text-muted-foreground" />;
194:     }
195:   };
196: 
197:   return (
198:     <>
199:       <Dialog open={open} onOpenChange={onOpenChange}>
200:       <DialogContent className="max-w-4xl h-[600px] flex flex-col p-0">
201:         <DialogHeader className="px-6 pt-6">
202:           <DialogTitle className="flex items-center gap-2">
203:             <Bot className="w-5 h-5" />
204:             Agent Management
205:           </DialogTitle>
206:           <DialogDescription>
207:             Create new agents or manage running agent executions
208:           </DialogDescription>
209:         </DialogHeader>
210: 
211:         <Tabs value={activeTab} onValueChange={setActiveTab} className="flex-1 flex flex-col">
212:           <TabsList className="mx-6">
213:             <TabsTrigger value="agents">Available Agents</TabsTrigger>
214:             <TabsTrigger value="running" className="relative">
215:               Running Agents
216:               {runningAgents.length > 0 && (
217:                 <Badge variant="secondary" className="ml-2 h-5 px-1.5">
218:                   {runningAgents.length}
219:                 </Badge>
220:               )}
221:             </TabsTrigger>
222:           </TabsList>
223: 
224:           <div className="flex-1 overflow-hidden">
225:             <TabsContent value="agents" className="h-full m-0">
226:               <ScrollArea className="h-full px-6 pb-6">
227:                 {/* Action buttons at the top */}
228:                 <div className="flex gap-2 mb-4 pt-4">
229:                   <Button onClick={handleCreateAgent} className="flex-1">
230:                     <Plus className="w-4 h-4 mr-2" />
231:                     Create Agent
232:                   </Button>
233:                   <DropdownMenu>
234:                     <DropdownMenuTrigger asChild>
235:                       <Button variant="outline" className="flex-1">
236:                         <Import className="w-4 h-4 mr-2" />
237:                         Import Agent
238:                         <ChevronDown className="w-4 h-4 ml-2" />
239:                       </Button>
240:                     </DropdownMenuTrigger>
241:                     <DropdownMenuContent>
242:                       <DropdownMenuItem onClick={handleImportFromFile}>
243:                         <FileJson className="w-4 h-4 mr-2" />
244:                         From File
245:                       </DropdownMenuItem>
246:                       <DropdownMenuItem onClick={handleImportFromGitHub}>
247:                         <Globe className="w-4 h-4 mr-2" />
248:                         From GitHub
249:                       </DropdownMenuItem>
250:                     </DropdownMenuContent>
251:                   </DropdownMenu>
252:                 </div>
253:                 {loading ? (
254:                   <div className="flex items-center justify-center h-full">
255:                     <Loader2 className="w-8 h-8 animate-spin text-muted-foreground" />
256:                   </div>
257:                 ) : agents.length === 0 ? (
258:                   <div className="flex flex-col items-center justify-center h-full text-center">
259:                     <Bot className="w-12 h-12 text-muted-foreground mb-4" />
260:                     <p className="text-lg font-medium mb-2">No agents available</p>
261:                     <p className="text-sm text-muted-foreground mb-4">
262:                       Create your first agent to get started
263:                     </p>
264:                     <Button onClick={() => {
265:                       onOpenChange(false);
266:                       window.dispatchEvent(new CustomEvent('open-create-agent-tab'));
267:                     }}>
268:                       <Plus className="w-4 h-4 mr-2" />
269:                       Create Agent
270:                     </Button>
271:                   </div>
272:                 ) : (
273:                   <div className="grid gap-4 py-4">
274:                     {agents.map((agent) => (
275:                       <motion.div
276:                         key={agent.id}
277:                         initial={{ opacity: 0, y: 10 }}
278:                         animate={{ opacity: 1, y: 0 }}
279:                         className="p-4 border rounded-lg hover:bg-muted/50 transition-colors"
280:                       >
281:                         <div className="flex items-start justify-between">
282:                           <div className="flex-1">
283:                             <h3 className="font-medium flex items-center gap-2">
284:                               <Bot className="w-4 h-4" />
285:                               {agent.name}
286:                             </h3>
287:                             {agent.default_task && (
288:                               <p className="text-sm text-muted-foreground mt-1">
289:                                 {agent.default_task}
290:                               </p>
291:                             )}
292:                           </div>
293:                           <div className="flex gap-2">
294:                             <Button
295:                               size="sm"
296:                               variant="ghost"
297:                               onClick={() => handleExportAgent(agent)}
298:                             >
299:                               <Download className="w-3 h-3 mr-1" />
300:                               Export
301:                             </Button>
302:                             <Button
303:                               size="sm"
304:                               variant="ghost"
305:                               onClick={() => handleDeleteAgent(agent)}
306:                               className="text-destructive hover:text-destructive"
307:                             >
308:                               <Trash2 className="w-3 h-3 mr-1" />
309:                               Delete
310:                             </Button>
311:                             <Button
312:                               size="sm"
313:                               onClick={() => handleRunAgent(agent)}
314:                             >
315:                               <Play className="w-3 h-3 mr-1" />
316:                               Run
317:                             </Button>
318:                           </div>
319:                         </div>
320:                       </motion.div>
321:                     ))}
322:                   </div>
323:                 )}
324:               </ScrollArea>
325:             </TabsContent>
326: 
327:             <TabsContent value="running" className="h-full m-0">
328:               <ScrollArea className="h-full px-6 pb-6">
329:                 {runningAgents.length === 0 ? (
330:                   <div className="flex flex-col items-center justify-center h-full text-center">
331:                     <Clock className="w-12 h-12 text-muted-foreground mb-4" />
332:                     <p className="text-lg font-medium mb-2">No running agents</p>
333:                     <p className="text-sm text-muted-foreground">
334:                       Agent executions will appear here when started
335:                     </p>
336:                   </div>
337:                 ) : (
338:                   <div className="grid gap-4 py-4">
339:                     <AnimatePresence mode="popLayout">
340:                       {runningAgents.map((run) => (
341:                         <motion.div
342:                           key={run.id}
343:                           layout
344:                           initial={{ opacity: 0, scale: 0.95 }}
345:                           animate={{ opacity: 1, scale: 1 }}
346:                           exit={{ opacity: 0, scale: 0.95 }}
347:                           className="p-4 border rounded-lg hover:bg-muted/50 transition-colors cursor-pointer"
348:                           onClick={() => handleOpenAgentRun(run)}
349:                         >
350:                           <div className="flex items-start justify-between">
351:                             <div className="flex-1">
352:                               <h3 className="font-medium flex items-center gap-2">
353:                                 {getStatusIcon(run.status)}
354:                                 {run.agent_name}
355:                               </h3>
356:                               <p className="text-sm text-muted-foreground mt-1">
357:                                 {run.task}
358:                               </p>
359:                               <div className="flex items-center gap-4 mt-2 text-xs text-muted-foreground">
360:                                 <span>Started: {formatISOTimestamp(run.created_at)}</span>
361:                                 <Badge variant="outline" className="text-xs">
362:                                   {run.model === 'opus' ? 'Claude 4 Opus' : 'Claude 4 Sonnet'}
363:                                 </Badge>
364:                               </div>
365:                             </div>
366:                             <Button
367:                               size="sm"
368:                               variant="ghost"
369:                               onClick={(e) => {
370:                                 e.stopPropagation();
371:                                 handleOpenAgentRun(run);
372:                               }}
373:                             >
374:                               View
375:                             </Button>
376:                           </div>
377:                         </motion.div>
378:                       ))}
379:                     </AnimatePresence>
380:                   </div>
381:                 )}
382:               </ScrollArea>
383:             </TabsContent>
384:           </div>
385:         </Tabs>
386:       </DialogContent>
387:     </Dialog>
388: 
389:     {/* Delete Confirmation Dialog */}
390:     <Dialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
391:       <DialogContent>
392:         <DialogHeader>
393:           <DialogTitle>Delete Agent</DialogTitle>
394:           <DialogDescription>
395:             Are you sure you want to delete "{agentToDelete?.name}"? This action cannot be undone.
396:           </DialogDescription>
397:         </DialogHeader>
398:         <div className="flex justify-end gap-3 mt-4">
399:           <Button
400:             variant="outline"
401:             onClick={() => {
402:               setShowDeleteDialog(false);
403:               setAgentToDelete(null);
404:             }}
405:           >
406:             Cancel
407:           </Button>
408:           <Button
409:             variant="destructive"
410:             onClick={confirmDelete}
411:           >
412:             Delete
413:           </Button>
414:         </div>
415:       </DialogContent>
416:     </Dialog>
417: 
418:     {/* GitHub Agent Browser */}
419:     <GitHubAgentBrowser
420:       isOpen={showGitHubBrowser}
421:       onClose={() => setShowGitHubBrowser(false)}
422:       onImportSuccess={() => {
423:         setShowGitHubBrowser(false);
424:         loadAgents(); // Refresh the agents list
425:         setToast({ message: "Agent imported successfully", type: "success" });
426:       }}
427:     />
428: 
429:     {/* Toast notifications */}
430:     {toast && (
431:       <Toast
432:         message={toast.message}
433:         type={toast.type}
434:         onDismiss={() => setToast(null)}
435:       />
436:     )}
437:     </>
438:   );
439: };
440: 
441: export default AgentsModal;
````

## File: src/components/AnalyticsConsent.tsx
````typescript
  1: import React, { useState, useEffect } from 'react';
  2: import { motion, AnimatePresence } from 'framer-motion';
  3: import { BarChart3, Shield, X, Check, Info } from 'lucide-react';
  4: import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from '@/components/ui/dialog';
  5: import { Button } from '@/components/ui/button';
  6: import { Card } from '@/components/ui/card';
  7: import { analytics } from '@/lib/analytics';
  8: import { cn } from '@/lib/utils';
  9: 
 10: interface AnalyticsConsentProps {
 11:   open?: boolean;
 12:   onOpenChange?: (open: boolean) => void;
 13:   onComplete?: () => void;
 14: }
 15: 
 16: export const AnalyticsConsent: React.FC<AnalyticsConsentProps> = ({
 17:   open: controlledOpen,
 18:   onOpenChange,
 19:   onComplete,
 20: }) => {
 21:   const [internalOpen, setInternalOpen] = useState(false);
 22:   const [hasShownConsent, setHasShownConsent] = useState(false);
 23:   
 24:   const isControlled = controlledOpen !== undefined;
 25:   const open = isControlled ? controlledOpen : internalOpen;
 26:   
 27:   useEffect(() => {
 28:     // Check if we should show the consent dialog
 29:     const checkConsent = async () => {
 30:       await analytics.initialize();
 31:       const settings = analytics.getSettings();
 32:       
 33:       if (!settings?.hasConsented && !hasShownConsent) {
 34:         if (!isControlled) {
 35:           setInternalOpen(true);
 36:         }
 37:         setHasShownConsent(true);
 38:       }
 39:     };
 40:     
 41:     checkConsent();
 42:   }, [isControlled, hasShownConsent]);
 43:   
 44:   const handleOpenChange = (newOpen: boolean) => {
 45:     if (isControlled && onOpenChange) {
 46:       onOpenChange(newOpen);
 47:     } else {
 48:       setInternalOpen(newOpen);
 49:     }
 50:   };
 51:   
 52:   const handleAccept = async () => {
 53:     await analytics.enable();
 54:     handleOpenChange(false);
 55:     onComplete?.();
 56:   };
 57:   
 58:   const handleDecline = async () => {
 59:     await analytics.disable();
 60:     handleOpenChange(false);
 61:     onComplete?.();
 62:   };
 63:   
 64:   return (
 65:     <Dialog open={open} onOpenChange={handleOpenChange}>
 66:       <DialogContent className="max-w-2xl p-0 overflow-hidden">
 67:         <div className="p-6 pb-0">
 68:           <DialogHeader>
 69:             <div className="flex items-center gap-3 mb-2">
 70:               <div className="p-2 bg-purple-100 dark:bg-purple-900/20 rounded-lg">
 71:                 <BarChart3 className="h-6 w-6 text-purple-600 dark:text-purple-400" />
 72:               </div>
 73:               <DialogTitle className="text-2xl">Help Improve Claudia</DialogTitle>
 74:             </div>
 75:             <DialogDescription className="text-base mt-2">
 76:               We'd like to collect anonymous usage data to improve your experience.
 77:             </DialogDescription>
 78:           </DialogHeader>
 79:         </div>
 80:         
 81:         <div className="p-6 space-y-4">
 82:           <div className="space-y-3">
 83:             <Card className="p-4 border-green-200 dark:border-green-900 bg-green-50 dark:bg-green-950/20">
 84:               <div className="flex gap-3">
 85:                 <Check className="h-5 w-5 text-green-600 dark:text-green-400 flex-shrink-0 mt-0.5" />
 86:                 <div className="space-y-1">
 87:                   <p className="font-medium text-green-900 dark:text-green-100">What we collect:</p>
 88:                   <ul className="text-sm text-green-800 dark:text-green-200 space-y-1">
 89:                     <li>• Feature usage (which tools and commands you use)</li>
 90:                     <li>• Performance metrics (app speed and reliability)</li>
 91:                     <li>• Error reports (to fix bugs and improve stability)</li>
 92:                     <li>• General usage patterns (session frequency and duration)</li>
 93:                   </ul>
 94:                 </div>
 95:               </div>
 96:             </Card>
 97:             
 98:             <Card className="p-4 border-blue-200 dark:border-blue-900 bg-blue-50 dark:bg-blue-950/20">
 99:               <div className="flex gap-3">
100:                 <Shield className="h-5 w-5 text-blue-600 dark:text-blue-400 flex-shrink-0 mt-0.5" />
101:                 <div className="space-y-1">
102:                   <p className="font-medium text-blue-900 dark:text-blue-100">Your privacy is protected:</p>
103:                   <ul className="text-sm text-blue-800 dark:text-blue-200 space-y-1">
104:                     <li>• No personal information is collected</li>
105:                     <li>• No file contents, paths, or project names</li>
106:                     <li>• No API keys or sensitive data</li>
107:                     <li>• Completely anonymous with random IDs</li>
108:                     <li>• You can opt-out anytime in Settings</li>
109:                   </ul>
110:                 </div>
111:               </div>
112:             </Card>
113:           </div>
114:           
115:           <div className="bg-gray-50 dark:bg-gray-900/50 rounded-lg p-4">
116:             <div className="flex gap-2 items-start">
117:               <Info className="h-4 w-4 text-gray-500 flex-shrink-0 mt-0.5" />
118:               <p className="text-sm text-gray-600 dark:text-gray-400">
119:                 This data helps us understand which features are most valuable, identify performance 
120:                 issues, and prioritize improvements. Your choice won't affect any functionality.
121:               </p>
122:             </div>
123:           </div>
124:         </div>
125:         
126:         <div className="p-6 pt-0 flex gap-3">
127:           <Button
128:             onClick={handleDecline}
129:             variant="outline"
130:             className="flex-1"
131:           >
132:             No Thanks
133:           </Button>
134:           <Button
135:             onClick={handleAccept}
136:             className="flex-1 bg-purple-600 hover:bg-purple-700 text-white"
137:           >
138:             Allow Analytics
139:           </Button>
140:         </div>
141:       </DialogContent>
142:     </Dialog>
143:   );
144: };
145: 
146: interface AnalyticsConsentBannerProps {
147:   className?: string;
148: }
149: 
150: export const AnalyticsConsentBanner: React.FC<AnalyticsConsentBannerProps> = ({
151:   className,
152: }) => {
153:   const [visible, setVisible] = useState(false);
154:   const [hasChecked, setHasChecked] = useState(false);
155:   
156:   useEffect(() => {
157:     const checkConsent = async () => {
158:       if (hasChecked) return;
159:       
160:       await analytics.initialize();
161:       const settings = analytics.getSettings();
162:       
163:       if (!settings?.hasConsented) {
164:         setVisible(true);
165:       }
166:       setHasChecked(true);
167:     };
168:     
169:     // Delay banner appearance for better UX
170:     const timer = setTimeout(checkConsent, 2000);
171:     return () => clearTimeout(timer);
172:   }, [hasChecked]);
173:   
174:   const handleAccept = async () => {
175:     await analytics.enable();
176:     setVisible(false);
177:   };
178:   
179:   const handleDecline = async () => {
180:     await analytics.disable();
181:     setVisible(false);
182:   };
183:   
184:   return (
185:     <AnimatePresence>
186:       {visible && (
187:         <motion.div
188:           initial={{ y: 100, opacity: 0 }}
189:           animate={{ y: 0, opacity: 1 }}
190:           exit={{ y: 100, opacity: 0 }}
191:           transition={{ type: "spring", damping: 25, stiffness: 300 }}
192:           className={cn(
193:             "fixed bottom-4 right-4 z-50 max-w-md",
194:             className
195:           )}
196:         >
197:           <Card className="p-4 shadow-lg border-purple-200 dark:border-purple-800">
198:             <div className="flex items-start gap-3">
199:               <BarChart3 className="h-5 w-5 text-purple-600 dark:text-purple-400 flex-shrink-0 mt-0.5" />
200:               <div className="space-y-2 flex-1">
201:                 <p className="text-sm font-medium">Help improve Claudia</p>
202:                 <p className="text-xs text-gray-600 dark:text-gray-400">
203:                   We collect anonymous usage data to improve your experience. No personal data is collected.
204:                 </p>
205:                 <div className="flex gap-2 pt-1">
206:                   <Button
207:                     size="sm"
208:                     variant="outline"
209:                     onClick={handleDecline}
210:                     className="text-xs"
211:                   >
212:                     No Thanks
213:                   </Button>
214:                   <Button
215:                     size="sm"
216:                     onClick={handleAccept}
217:                     className="text-xs bg-purple-600 hover:bg-purple-700 text-white"
218:                   >
219:                     Allow
220:                   </Button>
221:                 </div>
222:               </div>
223:               <button
224:                 onClick={() => setVisible(false)}
225:                 className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
226:               >
227:                 <X className="h-4 w-4" />
228:               </button>
229:             </div>
230:           </Card>
231:         </motion.div>
232:       )}
233:     </AnimatePresence>
234:   );
235: };
````

## File: src/components/AnalyticsErrorBoundary.tsx
````typescript
 1: import React, { Component, ErrorInfo, ReactNode } from 'react';
 2: import { eventBuilders, analytics } from '@/lib/analytics';
 3: 
 4: interface Props {
 5:   children: ReactNode;
 6:   fallback?: (error: Error, reset: () => void) => ReactNode;
 7: }
 8: 
 9: interface State {
10:   hasError: boolean;
11:   error: Error | null;
12: }
13: 
14: /**
15:  * Error boundary component that tracks UI errors to analytics
16:  */
17: export class AnalyticsErrorBoundary extends Component<Props, State> {
18:   constructor(props: Props) {
19:     super(props);
20:     this.state = { hasError: false, error: null };
21:   }
22: 
23:   static getDerivedStateFromError(error: Error): State {
24:     return { hasError: true, error };
25:   }
26: 
27:   componentDidCatch(error: Error, errorInfo: ErrorInfo) {
28:     // Track UI error to analytics
29:     const event = eventBuilders.uiError({
30:       component_name: errorInfo.componentStack?.split('\n')[0] || 'Unknown',
31:       error_type: error.name || 'UnknownError',
32:       user_action: undefined, // Could be enhanced with context
33:     });
34:     
35:     analytics.track(event.event, event.properties);
36:     
37:     // Log to console for debugging
38:     console.error('UI Error caught by boundary:', error, errorInfo);
39:   }
40: 
41:   reset = () => {
42:     this.setState({ hasError: false, error: null });
43:   };
44: 
45:   render() {
46:     if (this.state.hasError && this.state.error) {
47:       // Use custom fallback if provided
48:       if (this.props.fallback) {
49:         return this.props.fallback(this.state.error, this.reset);
50:       }
51:       
52:       // Default fallback UI
53:       return (
54:         <div className="flex flex-col items-center justify-center min-h-[200px] p-8 text-center">
55:           <h2 className="text-lg font-semibold text-destructive mb-2">
56:             Something went wrong
57:           </h2>
58:           <p className="text-sm text-muted-foreground mb-4">
59:             {this.state.error.message}
60:           </p>
61:           <button
62:             onClick={this.reset}
63:             className="px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90"
64:           >
65:             Try again
66:           </button>
67:         </div>
68:       );
69:     }
70: 
71:     return this.props.children;
72:   }
73: }
74: 
75: /**
76:  * Hook to wrap components with analytics error tracking
77:  */
78: export function withAnalyticsErrorBoundary<P extends object>(
79:   Component: React.ComponentType<P>,
80:   fallback?: (error: Error, reset: () => void) => ReactNode
81: ) {
82:   return (props: P) => (
83:     <AnalyticsErrorBoundary fallback={fallback}>
84:       <Component {...props} />
85:     </AnalyticsErrorBoundary>
86:   );
87: }
````

## File: src/components/App.cleaned.tsx
````typescript
  1: import { useState, useEffect } from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import { OutputCacheProvider } from "@/lib/outputCache";
  4: import { TabProvider } from "@/contexts/TabContext";
  5: import { NFOCredits } from "@/components/NFOCredits";
  6: import { ClaudeBinaryDialog } from "@/components/ClaudeBinaryDialog";
  7: import { Toast, ToastContainer } from "@/components/ui/toast";
  8: import { TabManager } from "@/components/TabManager";
  9: import { TabContent } from "@/components/TabContent";
 10: import { AgentsModal } from "@/components/AgentsModal";
 11: import { useTabState } from "@/hooks/useTabState";
 12: 
 13: /**
 14:  * AppContent component - Contains the main app logic, wrapped by providers
 15:  */
 16: function AppContent() {
 17:   const { } = useTabState();
 18:   const [showNFO, setShowNFO] = useState(false);
 19:   const [showClaudeBinaryDialog, setShowClaudeBinaryDialog] = useState(false);
 20:   const [toast, setToast] = useState<{ message: string; type: "success" | "error" | "info" } | null>(null);
 21:   const [showAgentsModal, setShowAgentsModal] = useState(false);
 22:   const [, setClaudeExecutableExists] = useState(true);
 23: 
 24:   // Keyboard shortcuts for tab navigation
 25:   useEffect(() => {
 26:     const handleKeyDown = (e: KeyboardEvent) => {
 27:       const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
 28:       const modKey = isMac ? e.metaKey : e.ctrlKey;
 29:       
 30:       if (modKey) {
 31:         switch (e.key) {
 32:           case 't':
 33:             e.preventDefault();
 34:             window.dispatchEvent(new CustomEvent('create-chat-tab'));
 35:             break;
 36:           case 'w':
 37:             e.preventDefault();
 38:             window.dispatchEvent(new CustomEvent('close-current-tab'));
 39:             break;
 40:           case 'Tab':
 41:             e.preventDefault();
 42:             if (e.shiftKey) {
 43:               window.dispatchEvent(new CustomEvent('switch-to-previous-tab'));
 44:             } else {
 45:               window.dispatchEvent(new CustomEvent('switch-to-next-tab'));
 46:             }
 47:             break;
 48:           default:
 49:             // Handle number keys 1-9
 50:             const num = parseInt(e.key);
 51:             if (!isNaN(num) && num >= 1 && num <= 9) {
 52:               e.preventDefault();
 53:               window.dispatchEvent(new CustomEvent('switch-to-tab', { detail: num - 1 }));
 54:             }
 55:             break;
 56:         }
 57:       }
 58:     };
 59: 
 60:     window.addEventListener('keydown', handleKeyDown);
 61:     return () => window.removeEventListener('keydown', handleKeyDown);
 62:   }, []);
 63: 
 64:   // Check if Claude executable exists on mount
 65:   useEffect(() => {
 66:     const checkClaudeExecutable = async () => {
 67:       try {
 68:         // Check if claude executable exists - method not available in API
 69:         const exists = true; // Default to true for now
 70:         if (!exists) {
 71:           setShowClaudeBinaryDialog(true);
 72:         }
 73:       } catch (error) {
 74:         console.error("Error checking Claude executable:", error);
 75:       }
 76:     };
 77: 
 78:     checkClaudeExecutable();
 79:   }, []);
 80: 
 81:   // Custom event handlers
 82:   useEffect(() => {
 83:     const handleCreateProjectTab = () => {
 84:       window.dispatchEvent(new CustomEvent('create-project-tab'));
 85:     };
 86: 
 87:     const handleShowNFO = () => setShowNFO(true);
 88:     const handleShowAgents = () => setShowAgentsModal(true);
 89: 
 90:     const projectButton = document.getElementById('create-project-tab-btn');
 91:     if (projectButton) {
 92:       projectButton.addEventListener('click', handleCreateProjectTab);
 93:     }
 94: 
 95:     // Listen for custom events to show modals
 96:     window.addEventListener('show-nfo', handleShowNFO);
 97:     window.addEventListener('show-agents-modal', handleShowAgents);
 98: 
 99:     return () => {
100:       if (projectButton) {
101:         projectButton.removeEventListener('click', handleCreateProjectTab);
102:       }
103:       window.removeEventListener('show-nfo', handleShowNFO);
104:       window.removeEventListener('show-agents-modal', handleShowAgents);
105:     };
106:   }, []);
107: 
108:   return (
109:     <AnimatePresence mode="wait">
110:       <motion.div
111:         initial={{ opacity: 0 }}
112:         animate={{ opacity: 1 }}
113:         exit={{ opacity: 0 }}
114:         className="min-h-screen bg-background flex flex-col"
115:       >
116:         {/* Tab-based interface */}
117:         <div className="flex-1 flex flex-col">
118:           <TabManager />
119:           <TabContent />
120:         </div>
121: 
122:         {/* Global Modals */}
123:         {showNFO && <NFOCredits onClose={() => setShowNFO(false)} />}
124:         
125:         <ClaudeBinaryDialog 
126:           open={showClaudeBinaryDialog} 
127:           onOpenChange={setShowClaudeBinaryDialog}
128:           onSuccess={() => {
129:             setClaudeExecutableExists(true);
130:             setToast({ message: "Claude binary path set successfully", type: "success" });
131:           }}
132:           onError={(message) => {
133:             setToast({ message, type: "error" });
134:           }}
135:         />
136:         
137:         <AgentsModal
138:           open={showAgentsModal}
139:           onOpenChange={setShowAgentsModal}
140:         />
141: 
142:         {/* Toast Container */}
143:         {toast && (
144:           <ToastContainer>
145:             <Toast
146:               message={toast.message}
147:               type={toast.type}
148:               onDismiss={() => setToast(null)}
149:             />
150:           </ToastContainer>
151:         )}
152:       </motion.div>
153:     </AnimatePresence>
154:   );
155: }
156: 
157: /**
158:  * App component - Main entry point with providers
159:  */
160: function App() {
161:   return (
162:     <OutputCacheProvider>
163:       <TabProvider>
164:         <AppContent />
165:       </TabProvider>
166:     </OutputCacheProvider>
167:   );
168: }
169: 
170: export default App;
````

## File: src/components/CCAgents.tsx
````typescript
  1: import React, { useState, useEffect } from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import { 
  4:   Plus, 
  5:   Edit, 
  6:   Trash2, 
  7:   Play,
  8:   Bot,
  9:   ArrowLeft,
 10:   History,
 11:   Download,
 12:   Upload,
 13:   Globe,
 14:   FileJson,
 15:   ChevronDown
 16: } from "lucide-react";
 17: import { Button } from "@/components/ui/button";
 18: import { Card, CardContent, CardFooter } from "@/components/ui/card";
 19: import {
 20:   DropdownMenu,
 21:   DropdownMenuContent,
 22:   DropdownMenuItem,
 23:   DropdownMenuTrigger,
 24: } from "@/components/ui/dropdown-menu";
 25: import {
 26:   Dialog,
 27:   DialogContent,
 28:   DialogDescription,
 29:   DialogFooter,
 30:   DialogHeader,
 31:   DialogTitle,
 32: } from "@/components/ui/dialog";
 33: import { api, type Agent, type AgentRunWithMetrics } from "@/lib/api";
 34: import { save, open } from "@tauri-apps/plugin-dialog";
 35: import { invoke } from "@tauri-apps/api/core";
 36: import { cn } from "@/lib/utils";
 37: import { Toast, ToastContainer } from "@/components/ui/toast";
 38: import { CreateAgent } from "./CreateAgent";
 39: import { AgentExecution } from "./AgentExecution";
 40: import { AgentRunsList } from "./AgentRunsList";
 41: import { GitHubAgentBrowser } from "./GitHubAgentBrowser";
 42: import { ICON_MAP } from "./IconPicker";
 43: 
 44: interface CCAgentsProps {
 45:   /**
 46:    * Callback to go back to the main view
 47:    */
 48:   onBack: () => void;
 49:   /**
 50:    * Optional className for styling
 51:    */
 52:   className?: string;
 53: }
 54: 
 55: // Available icons for agents - now using all icons from IconPicker
 56: export const AGENT_ICONS = ICON_MAP;
 57: 
 58: export type AgentIconName = keyof typeof AGENT_ICONS;
 59: 
 60: /**
 61:  * CCAgents component for managing Claude Code agents
 62:  * 
 63:  * @example
 64:  * <CCAgents onBack={() => setView('home')} />
 65:  */
 66: export const CCAgents: React.FC<CCAgentsProps> = ({ onBack, className }) => {
 67:   const [agents, setAgents] = useState<Agent[]>([]);
 68:   const [runs, setRuns] = useState<AgentRunWithMetrics[]>([]);
 69:   const [loading, setLoading] = useState(true);
 70:   const [runsLoading, setRunsLoading] = useState(false);
 71:   const [error, setError] = useState<string | null>(null);
 72:   const [toast, setToast] = useState<{ message: string; type: "success" | "error" } | null>(null);
 73:   const [currentPage, setCurrentPage] = useState(1);
 74:   const [view, setView] = useState<"list" | "create" | "edit" | "execute">("list");
 75:   const [selectedAgent, setSelectedAgent] = useState<Agent | null>(null);
 76:   // const [selectedRunId, setSelectedRunId] = useState<number | null>(null);
 77:   const [showGitHubBrowser, setShowGitHubBrowser] = useState(false);
 78:   const [showDeleteDialog, setShowDeleteDialog] = useState(false);
 79:   const [agentToDelete, setAgentToDelete] = useState<Agent | null>(null);
 80:   const [isDeleting, setIsDeleting] = useState(false);
 81: 
 82:   const AGENTS_PER_PAGE = 9; // 3x3 grid
 83: 
 84:   useEffect(() => {
 85:     loadAgents();
 86:     loadRuns();
 87:   }, []);
 88: 
 89:   const loadAgents = async () => {
 90:     try {
 91:       setLoading(true);
 92:       setError(null);
 93:       const agentsList = await api.listAgents();
 94:       setAgents(agentsList);
 95:     } catch (err) {
 96:       console.error("Failed to load agents:", err);
 97:       setError("Failed to load agents");
 98:       setToast({ message: "Failed to load agents", type: "error" });
 99:     } finally {
100:       setLoading(false);
101:     }
102:   };
103: 
104:   const loadRuns = async () => {
105:     try {
106:       setRunsLoading(true);
107:       const runsList = await api.listAgentRuns();
108:       setRuns(runsList);
109:     } catch (err) {
110:       console.error("Failed to load runs:", err);
111:     } finally {
112:       setRunsLoading(false);
113:     }
114:   };
115: 
116:   /**
117:    * Initiates the delete agent process by showing the confirmation dialog
118:    * @param agent - The agent to be deleted
119:    */
120:   const handleDeleteAgent = (agent: Agent) => {
121:     setAgentToDelete(agent);
122:     setShowDeleteDialog(true);
123:   };
124: 
125:   /**
126:    * Confirms and executes the agent deletion
127:    * Only called when user explicitly confirms the deletion
128:    */
129:   const confirmDeleteAgent = async () => {
130:     if (!agentToDelete?.id) return;
131: 
132:     try {
133:       setIsDeleting(true);
134:       await api.deleteAgent(agentToDelete.id);
135:       setToast({ message: "Agent deleted successfully", type: "success" });
136:       await loadAgents();
137:       await loadRuns(); // Reload runs as they might be affected
138:     } catch (err) {
139:       console.error("Failed to delete agent:", err);
140:       setToast({ message: "Failed to delete agent", type: "error" });
141:     } finally {
142:       setIsDeleting(false);
143:       setShowDeleteDialog(false);
144:       setAgentToDelete(null);
145:     }
146:   };
147: 
148:   /**
149:    * Cancels the delete operation and closes the dialog
150:    */
151:   const cancelDeleteAgent = () => {
152:     setShowDeleteDialog(false);
153:     setAgentToDelete(null);
154:   };
155: 
156:   const handleEditAgent = (agent: Agent) => {
157:     setSelectedAgent(agent);
158:     setView("edit");
159:   };
160: 
161:   const handleExecuteAgent = (agent: Agent) => {
162:     setSelectedAgent(agent);
163:     setView("execute");
164:   };
165: 
166:   const handleAgentCreated = async () => {
167:     setView("list");
168:     await loadAgents();
169:     setToast({ message: "Agent created successfully", type: "success" });
170:   };
171: 
172:   const handleAgentUpdated = async () => {
173:     setView("list");
174:     await loadAgents();
175:     setToast({ message: "Agent updated successfully", type: "success" });
176:   };
177: 
178:   // const handleRunClick = (run: AgentRunWithMetrics) => {
179:   //   if (run.id) {
180:   //     setSelectedRunId(run.id);
181:   //     setView("viewRun");
182:   //   }
183:   // };
184: 
185:   const handleExecutionComplete = async () => {
186:     // Reload runs when returning from execution
187:     await loadRuns();
188:   };
189: 
190:   const handleExportAgent = async (agent: Agent) => {
191:     try {
192:       // Show native save dialog
193:       const filePath = await save({
194:         defaultPath: `${agent.name.toLowerCase().replace(/\s+/g, '-')}.claudia.json`,
195:         filters: [{
196:           name: 'Claudia Agent',
197:           extensions: ['claudia.json']
198:         }]
199:       });
200:       
201:       if (!filePath) {
202:         // User cancelled the dialog
203:         return;
204:       }
205:       
206:       // Export the agent to the selected file
207:       await invoke('export_agent_to_file', { 
208:         id: agent.id!,
209:         filePath 
210:       });
211:       
212:       setToast({ message: `Agent "${agent.name}" exported successfully`, type: "success" });
213:     } catch (err) {
214:       console.error("Failed to export agent:", err);
215:       setToast({ message: "Failed to export agent", type: "error" });
216:     }
217:   };
218: 
219:   const handleImportAgent = async () => {
220:     try {
221:       // Show native open dialog
222:       const filePath = await open({
223:         multiple: false,
224:         filters: [{
225:           name: 'Claudia Agent',
226:           extensions: ['claudia.json', 'json']
227:         }]
228:       });
229:       
230:       if (!filePath) {
231:         // User cancelled the dialog
232:         return;
233:       }
234:       
235:       // Import the agent from the selected file
236:       await api.importAgentFromFile(filePath as string);
237:       
238:       setToast({ message: "Agent imported successfully", type: "success" });
239:       await loadAgents();
240:     } catch (err) {
241:       console.error("Failed to import agent:", err);
242:       const errorMessage = err instanceof Error ? err.message : "Failed to import agent";
243:       setToast({ message: errorMessage, type: "error" });
244:     }
245:   };
246: 
247:   // Pagination calculations
248:   const totalPages = Math.ceil(agents.length / AGENTS_PER_PAGE);
249:   const startIndex = (currentPage - 1) * AGENTS_PER_PAGE;
250:   const paginatedAgents = agents.slice(startIndex, startIndex + AGENTS_PER_PAGE);
251: 
252:   const renderIcon = (iconName: string) => {
253:     const Icon = AGENT_ICONS[iconName as AgentIconName] || AGENT_ICONS.bot;
254:     return <Icon className="h-12 w-12" />;
255:   };
256: 
257:   if (view === "create") {
258:     return (
259:       <CreateAgent
260:         onBack={() => setView("list")}
261:         onAgentCreated={handleAgentCreated}
262:       />
263:     );
264:   }
265: 
266:   if (view === "edit" && selectedAgent) {
267:     return (
268:       <CreateAgent
269:         agent={selectedAgent}
270:         onBack={() => setView("list")}
271:         onAgentCreated={handleAgentUpdated}
272:       />
273:     );
274:   }
275: 
276:   if (view === "execute" && selectedAgent) {
277:     return (
278:       <AgentExecution
279:         agent={selectedAgent}
280:         onBack={() => {
281:           setView("list");
282:           handleExecutionComplete();
283:         }}
284:       />
285:     );
286:   }
287: 
288:   // Removed viewRun case - now using modal preview in AgentRunsList
289: 
290:   return (
291:     <div className={cn("flex flex-col h-full bg-background", className)}>
292:       <div className="w-full max-w-6xl mx-auto flex flex-col h-full p-6">
293:         {/* Header */}
294:         <motion.div
295:           initial={{ opacity: 0, y: -20 }}
296:           animate={{ opacity: 1, y: 0 }}
297:           transition={{ duration: 0.3 }}
298:           className="mb-6"
299:         >
300:           <div className="flex items-center justify-between">
301:             <div className="flex items-center gap-3">
302:               <Button
303:                 variant="ghost"
304:                 size="icon"
305:                 onClick={onBack}
306:                 className="h-8 w-8"
307:               >
308:                 <ArrowLeft className="h-4 w-4" />
309:               </Button>
310:               <div>
311:                 <h1 className="text-2xl font-bold">CC Agents</h1>
312:                 <p className="text-sm text-muted-foreground">
313:                   Manage your Claude Code agents
314:                 </p>
315:               </div>
316:             </div>
317:             <div className="flex items-center gap-2">
318:               <DropdownMenu>
319:                 <DropdownMenuTrigger asChild>
320:                   <Button
321:                     size="default"
322:                     variant="outline"
323:                     className="flex items-center gap-2"
324:                   >
325:                     <Download className="h-4 w-4" />
326:                     Import
327:                     <ChevronDown className="h-3 w-3" />
328:                   </Button>
329:                 </DropdownMenuTrigger>
330:                 <DropdownMenuContent align="end">
331:                   <DropdownMenuItem onClick={handleImportAgent}>
332:                     <FileJson className="h-4 w-4 mr-2" />
333:                     From File
334:                   </DropdownMenuItem>
335:                   <DropdownMenuItem onClick={() => setShowGitHubBrowser(true)}>
336:                     <Globe className="h-4 w-4 mr-2" />
337:                     From GitHub
338:                   </DropdownMenuItem>
339:                 </DropdownMenuContent>
340:               </DropdownMenu>
341:               <Button
342:                 onClick={() => setView("create")}
343:                 size="default"
344:                 className="flex items-center gap-2"
345:               >
346:                 <Plus className="h-4 w-4" />
347:                 Create CC Agent
348:               </Button>
349:             </div>
350:           </div>
351:         </motion.div>
352: 
353:         {/* Error display */}
354:         {error && (
355:           <motion.div
356:             initial={{ opacity: 0 }}
357:             animate={{ opacity: 1 }}
358:             className="mb-4 rounded-lg border border-destructive/50 bg-destructive/10 p-3 text-sm text-destructive"
359:           >
360:             {error}
361:           </motion.div>
362:         )}
363: 
364:         {/* Main Content */}
365:         <div className="flex-1 overflow-y-auto">
366:           <AnimatePresence mode="wait">
367:             <motion.div
368:               key="agents"
369:               initial={{ opacity: 0, y: 20 }}
370:               animate={{ opacity: 1, y: 0 }}
371:               exit={{ opacity: 0, y: -20 }}
372:               transition={{ duration: 0.2 }}
373:               className="pt-6 space-y-8"
374:             >
375:               {/* Agents Grid */}
376:               <div>
377:                 {loading ? (
378:                   <div className="flex items-center justify-center h-64">
379:                     <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
380:                   </div>
381:                 ) : agents.length === 0 ? (
382:                   <div className="flex flex-col items-center justify-center h-64 text-center">
383:                     <Bot className="h-16 w-16 text-muted-foreground mb-4" />
384:                     <h3 className="text-lg font-medium mb-2">No agents yet</h3>
385:                     <p className="text-sm text-muted-foreground mb-4">
386:                       Create your first CC Agent to get started
387:                     </p>
388:                     <Button onClick={() => setView("create")} size="default">
389:                       <Plus className="h-4 w-4 mr-2" />
390:                       Create CC Agent
391:                     </Button>
392:                   </div>
393:                 ) : (
394:                   <>
395:                     <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
396:                       <AnimatePresence mode="popLayout">
397:                         {paginatedAgents.map((agent, index) => (
398:                           <motion.div
399:                             key={agent.id}
400:                             initial={{ opacity: 0, scale: 0.9 }}
401:                             animate={{ opacity: 1, scale: 1 }}
402:                             exit={{ opacity: 0, scale: 0.9 }}
403:                             transition={{ duration: 0.2, delay: index * 0.05 }}
404:                           >
405:                             <Card className="h-full hover:shadow-lg transition-shadow">
406:                               <CardContent className="p-6 flex flex-col items-center text-center">
407:                                 <div className="mb-4 p-4 rounded-full bg-primary/10 text-primary">
408:                                   {renderIcon(agent.icon)}
409:                                 </div>
410:                                 <h3 className="text-lg font-semibold mb-2">
411:                                   {agent.name}
412:                                 </h3>
413:                                 <p className="text-xs text-muted-foreground">
414:                                   Created: {new Date(agent.created_at).toLocaleDateString()}
415:                                 </p>
416:                               </CardContent>
417:                               <CardFooter className="p-4 pt-0 flex justify-center gap-1 flex-wrap">
418:                                 <Button
419:                                   size="sm"
420:                                   variant="ghost"
421:                                   onClick={() => handleExecuteAgent(agent)}
422:                                   className="flex items-center gap-1"
423:                                   title="Execute agent"
424:                                 >
425:                                   <Play className="h-3 w-3" />
426:                                   Execute
427:                                 </Button>
428:                                 <Button
429:                                   size="sm"
430:                                   variant="ghost"
431:                                   onClick={() => handleEditAgent(agent)}
432:                                   className="flex items-center gap-1"
433:                                   title="Edit agent"
434:                                 >
435:                                   <Edit className="h-3 w-3" />
436:                                   Edit
437:                                 </Button>
438:                                 <Button
439:                                   size="sm"
440:                                   variant="ghost"
441:                                   onClick={() => handleExportAgent(agent)}
442:                                   className="flex items-center gap-1"
443:                                   title="Export agent to .claudia.json"
444:                                 >
445:                                   <Upload className="h-3 w-3" />
446:                                   Export
447:                                 </Button>
448:                                 <Button
449:                                   size="sm"
450:                                   variant="ghost"
451:                                   onClick={() => handleDeleteAgent(agent)}
452:                                   className="flex items-center gap-1 text-destructive hover:text-destructive"
453:                                   title="Delete agent"
454:                                 >
455:                                   <Trash2 className="h-3 w-3" />
456:                                   Delete
457:                                 </Button>
458:                               </CardFooter>
459:                             </Card>
460:                           </motion.div>
461:                         ))}
462:                       </AnimatePresence>
463:                     </div>
464: 
465:                     {/* Pagination */}
466:                     {totalPages > 1 && (
467:                       <div className="mt-6 flex justify-center gap-2">
468:                         <Button
469:                           size="sm"
470:                           variant="outline"
471:                           onClick={() => setCurrentPage(p => Math.max(1, p - 1))}
472:                           disabled={currentPage === 1}
473:                         >
474:                           Previous
475:                         </Button>
476:                         <span className="flex items-center px-3 text-sm">
477:                           Page {currentPage} of {totalPages}
478:                         </span>
479:                         <Button
480:                           size="sm"
481:                           variant="outline"
482:                           onClick={() => setCurrentPage(p => Math.min(totalPages, p + 1))}
483:                           disabled={currentPage === totalPages}
484:                         >
485:                           Next
486:                         </Button>
487:                       </div>
488:                     )}
489:                   </>
490:                 )}
491:               </div>
492: 
493:               {/* Execution History */}
494:               {!loading && agents.length > 0 && (
495:                 <div className="overflow-hidden">
496:                   <div className="flex items-center gap-2 mb-4">
497:                     <History className="h-5 w-5 text-muted-foreground" />
498:                     <h2 className="text-lg font-semibold">Recent Executions</h2>
499:                   </div>
500:                   {runsLoading ? (
501:                     <div className="flex items-center justify-center h-32">
502:                       <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
503:                     </div>
504:                   ) : (
505:                     <AgentRunsList 
506:                       runs={runs} 
507:                     />
508:                   )}
509:                 </div>
510:               )}
511:             </motion.div>
512:           </AnimatePresence>
513:         </div>
514:       </div>
515: 
516:       {/* Toast Notification */}
517:       <ToastContainer>
518:         {toast && (
519:           <Toast
520:             message={toast.message}
521:             type={toast.type}
522:             onDismiss={() => setToast(null)}
523:           />
524:         )}
525:       </ToastContainer>
526: 
527:       {/* GitHub Agent Browser */}
528:       <GitHubAgentBrowser
529:         isOpen={showGitHubBrowser}
530:         onClose={() => setShowGitHubBrowser(false)}
531:         onImportSuccess={async () => {
532:           setShowGitHubBrowser(false);
533:           await loadAgents();
534:           setToast({ message: "Agent imported successfully from GitHub", type: "success" });
535:         }}
536:       />
537: 
538:       {/* Delete Confirmation Dialog */}
539:       <Dialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
540:         <DialogContent className="sm:max-w-md">
541:           <DialogHeader>
542:             <DialogTitle className="flex items-center gap-2">
543:               <Trash2 className="h-5 w-5 text-destructive" />
544:               Delete Agent
545:             </DialogTitle>
546:             <DialogDescription>
547:               Are you sure you want to delete the agent "{agentToDelete?.name}"? 
548:               This action cannot be undone and will permanently remove the agent and all its associated data.
549:             </DialogDescription>
550:           </DialogHeader>
551:           <DialogFooter className="flex flex-col-reverse sm:flex-row sm:justify-end gap-2">
552:             <Button
553:               variant="outline"
554:               onClick={cancelDeleteAgent}
555:               disabled={isDeleting}
556:               className="w-full sm:w-auto"
557:             >
558:               Cancel
559:             </Button>
560:             <Button
561:               variant="destructive"
562:               onClick={confirmDeleteAgent}
563:               disabled={isDeleting}
564:               className="w-full sm:w-auto"
565:             >
566:               {isDeleting ? (
567:                 <>
568:                   <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2" />
569:                   Deleting...
570:                 </>
571:               ) : (
572:                 <>
573:                   <Trash2 className="h-4 w-4 mr-2" />
574:                   Delete Agent
575:                 </>
576:               )}
577:             </Button>
578:           </DialogFooter>
579:         </DialogContent>
580:       </Dialog>
581:     </div>
582:   );
583: };
````

## File: src/components/CheckpointSettings.tsx
````typescript
  1: import React, { useState, useEffect } from "react";
  2: import { motion } from "framer-motion";
  3: import { 
  4:   Settings,
  5:   Save,
  6:   Trash2,
  7:   HardDrive,
  8:   AlertCircle
  9: } from "lucide-react";
 10: import { Button } from "@/components/ui/button";
 11: import { Label } from "@/components/ui/label";
 12: import { Switch } from "@/components/ui/switch";
 13: import { SelectComponent, type SelectOption } from "@/components/ui/select";
 14: import { Input } from "@/components/ui/input";
 15: import { api, type CheckpointStrategy } from "@/lib/api";
 16: import { cn } from "@/lib/utils";
 17: 
 18: interface CheckpointSettingsProps {
 19:   sessionId: string;
 20:   projectId: string;
 21:   projectPath: string;
 22:   onClose?: () => void;
 23:   className?: string;
 24: }
 25: 
 26: /**
 27:  * CheckpointSettings component for managing checkpoint configuration
 28:  * 
 29:  * @example
 30:  * <CheckpointSettings 
 31:  *   sessionId={session.id}
 32:  *   projectId={session.project_id}
 33:  *   projectPath={projectPath}
 34:  * />
 35:  */
 36: export const CheckpointSettings: React.FC<CheckpointSettingsProps> = ({
 37:   sessionId,
 38:   projectId,
 39:   projectPath,
 40:   onClose,
 41:   className,
 42: }) => {
 43:   const [autoCheckpointEnabled, setAutoCheckpointEnabled] = useState(true);
 44:   const [checkpointStrategy, setCheckpointStrategy] = useState<CheckpointStrategy>("smart");
 45:   const [totalCheckpoints, setTotalCheckpoints] = useState(0);
 46:   const [keepCount, setKeepCount] = useState(10);
 47:   const [isLoading, setIsLoading] = useState(false);
 48:   const [isSaving, setIsSaving] = useState(false);
 49:   const [error, setError] = useState<string | null>(null);
 50:   const [successMessage, setSuccessMessage] = useState<string | null>(null);
 51: 
 52:   const strategyOptions: SelectOption[] = [
 53:     { value: "manual", label: "Manual Only" },
 54:     { value: "per_prompt", label: "After Each Prompt" },
 55:     { value: "per_tool_use", label: "After Tool Use" },
 56:     { value: "smart", label: "Smart (Recommended)" },
 57:   ];
 58: 
 59:   useEffect(() => {
 60:     loadSettings();
 61:   }, [sessionId, projectId, projectPath]);
 62: 
 63:   const loadSettings = async () => {
 64:     try {
 65:       setIsLoading(true);
 66:       setError(null);
 67:       
 68:       const settings = await api.getCheckpointSettings(sessionId, projectId, projectPath);
 69:       setAutoCheckpointEnabled(settings.auto_checkpoint_enabled);
 70:       setCheckpointStrategy(settings.checkpoint_strategy);
 71:       setTotalCheckpoints(settings.total_checkpoints);
 72:     } catch (err) {
 73:       console.error("Failed to load checkpoint settings:", err);
 74:       setError("Failed to load checkpoint settings");
 75:     } finally {
 76:       setIsLoading(false);
 77:     }
 78:   };
 79: 
 80:   const handleSaveSettings = async () => {
 81:     try {
 82:       setIsSaving(true);
 83:       setError(null);
 84:       setSuccessMessage(null);
 85:       
 86:       await api.updateCheckpointSettings(
 87:         sessionId,
 88:         projectId,
 89:         projectPath,
 90:         autoCheckpointEnabled,
 91:         checkpointStrategy
 92:       );
 93:       
 94:       setSuccessMessage("Settings saved successfully");
 95:       setTimeout(() => setSuccessMessage(null), 3000);
 96:     } catch (err) {
 97:       console.error("Failed to save checkpoint settings:", err);
 98:       setError("Failed to save checkpoint settings");
 99:     } finally {
100:       setIsSaving(false);
101:     }
102:   };
103: 
104:   const handleCleanup = async () => {
105:     try {
106:       setIsLoading(true);
107:       setError(null);
108:       setSuccessMessage(null);
109:       
110:       const removed = await api.cleanupOldCheckpoints(
111:         sessionId,
112:         projectId,
113:         projectPath,
114:         keepCount
115:       );
116:       
117:       setSuccessMessage(`Removed ${removed} old checkpoints`);
118:       setTimeout(() => setSuccessMessage(null), 3000);
119:       
120:       // Reload settings to get updated count
121:       await loadSettings();
122:     } catch (err) {
123:       console.error("Failed to cleanup checkpoints:", err);
124:       setError("Failed to cleanup checkpoints");
125:     } finally {
126:       setIsLoading(false);
127:     }
128:   };
129: 
130:   return (
131:     <motion.div
132:       initial={{ opacity: 0, y: 20 }}
133:       animate={{ opacity: 1, y: 0 }}
134:       exit={{ opacity: 0, y: -20 }}
135:       className={cn("space-y-6", className)}
136:     >
137:       <div className="flex items-center justify-between">
138:         <div className="flex items-center gap-2">
139:           <Settings className="h-5 w-5" />
140:           <h3 className="text-lg font-semibold">Checkpoint Settings</h3>
141:         </div>
142:         {onClose && (
143:           <Button variant="ghost" size="sm" onClick={onClose}>
144:             Close
145:           </Button>
146:         )}
147:       </div>
148: 
149:       {/* Experimental Feature Warning */}
150:       <div className="rounded-lg border border-yellow-500/50 bg-yellow-500/10 p-3">
151:         <div className="flex items-start gap-2">
152:           <AlertCircle className="h-4 w-4 text-yellow-600 mt-0.5" />
153:           <div className="text-xs">
154:             <p className="font-medium text-yellow-600">Experimental Feature</p>
155:             <p className="text-yellow-600/80">
156:               Checkpointing may affect directory structure or cause data loss. Use with caution.
157:             </p>
158:           </div>
159:         </div>
160:       </div>
161: 
162:       {error && (
163:         <motion.div
164:           initial={{ opacity: 0 }}
165:           animate={{ opacity: 1 }}
166:           className="rounded-lg border border-destructive/50 bg-destructive/10 p-3 text-xs text-destructive"
167:         >
168:           <div className="flex items-center gap-2">
169:             <AlertCircle className="h-4 w-4" />
170:             {error}
171:           </div>
172:         </motion.div>
173:       )}
174: 
175:       {successMessage && (
176:         <motion.div
177:           initial={{ opacity: 0 }}
178:           animate={{ opacity: 1 }}
179:           className="rounded-lg border border-green-500/50 bg-green-500/10 p-3 text-xs text-green-600"
180:         >
181:           {successMessage}
182:         </motion.div>
183:       )}
184: 
185:       <div className="space-y-4">
186:         {/* Auto-checkpoint toggle */}
187:         <div className="flex items-center justify-between">
188:           <div className="space-y-0.5">
189:             <Label htmlFor="auto-checkpoint">Automatic Checkpoints</Label>
190:             <p className="text-sm text-muted-foreground">
191:               Automatically create checkpoints based on the selected strategy
192:             </p>
193:           </div>
194:           <Switch
195:             id="auto-checkpoint"
196:             checked={autoCheckpointEnabled}
197:             onCheckedChange={setAutoCheckpointEnabled}
198:             disabled={isLoading}
199:           />
200:         </div>
201: 
202:         {/* Checkpoint strategy */}
203:         <div className="space-y-2">
204:           <Label htmlFor="strategy">Checkpoint Strategy</Label>
205:           <SelectComponent
206:             value={checkpointStrategy}
207:             onValueChange={(value: string) => setCheckpointStrategy(value as CheckpointStrategy)}
208:             options={strategyOptions}
209:             disabled={isLoading || !autoCheckpointEnabled}
210:           />
211:           <p className="text-xs text-muted-foreground">
212:             {checkpointStrategy === "manual" && "Checkpoints will only be created manually"}
213:             {checkpointStrategy === "per_prompt" && "A checkpoint will be created after each user prompt"}
214:             {checkpointStrategy === "per_tool_use" && "A checkpoint will be created after each tool use"}
215:             {checkpointStrategy === "smart" && "Checkpoints will be created after destructive operations"}
216:           </p>
217:         </div>
218: 
219:         {/* Save button */}
220:         <Button
221:           onClick={handleSaveSettings}
222:           disabled={isLoading || isSaving}
223:           className="w-full"
224:         >
225:           {isSaving ? (
226:             <>
227:               <Save className="h-4 w-4 mr-2 animate-spin" />
228:               Saving...
229:             </>
230:           ) : (
231:             <>
232:               <Save className="h-4 w-4 mr-2" />
233:               Save Settings
234:             </>
235:           )}
236:         </Button>
237:       </div>
238: 
239:       <div className="border-t pt-6 space-y-4">
240:         <div className="flex items-center justify-between">
241:           <div className="space-y-0.5">
242:             <Label>Storage Management</Label>
243:             <p className="text-sm text-muted-foreground">
244:               Total checkpoints: {totalCheckpoints}
245:             </p>
246:           </div>
247:           <HardDrive className="h-5 w-5 text-muted-foreground" />
248:         </div>
249: 
250:         {/* Cleanup settings */}
251:         <div className="space-y-2">
252:           <Label htmlFor="keep-count">Keep Recent Checkpoints</Label>
253:           <div className="flex gap-2">
254:             <Input
255:               id="keep-count"
256:               type="number"
257:               min="1"
258:               max="100"
259:               value={keepCount}
260:               onChange={(e) => setKeepCount(parseInt(e.target.value) || 10)}
261:               disabled={isLoading}
262:               className="flex-1"
263:             />
264:             <Button
265:               variant="destructive"
266:               onClick={handleCleanup}
267:               disabled={isLoading || totalCheckpoints <= keepCount}
268:             >
269:               <Trash2 className="h-4 w-4 mr-2" />
270:               Clean Up
271:             </Button>
272:           </div>
273:           <p className="text-xs text-muted-foreground">
274:             Remove old checkpoints, keeping only the most recent {keepCount}
275:           </p>
276:         </div>
277:       </div>
278:     </motion.div>
279:   );
280: };
````

## File: src/components/ClaudeBinaryDialog.tsx
````typescript
  1: import { useState, useEffect } from "react";
  2: import { api, type ClaudeInstallation } from "@/lib/api";
  3: import { Button } from "@/components/ui/button";
  4: import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
  5: import { ExternalLink, FileQuestion, Terminal, AlertCircle, Loader2 } from "lucide-react";
  6: import { ClaudeVersionSelector } from "./ClaudeVersionSelector";
  7: 
  8: interface ClaudeBinaryDialogProps {
  9:   open: boolean;
 10:   onOpenChange: (open: boolean) => void;
 11:   onSuccess: () => void;
 12:   onError: (message: string) => void;
 13: }
 14: 
 15: export function ClaudeBinaryDialog({ open, onOpenChange, onSuccess, onError }: ClaudeBinaryDialogProps) {
 16:   const [selectedInstallation, setSelectedInstallation] = useState<ClaudeInstallation | null>(null);
 17:   const [isValidating, setIsValidating] = useState(false);
 18:   const [hasInstallations, setHasInstallations] = useState(true);
 19:   const [checkingInstallations, setCheckingInstallations] = useState(true);
 20: 
 21:   useEffect(() => {
 22:     if (open) {
 23:       checkInstallations();
 24:     }
 25:   }, [open]);
 26: 
 27:   const checkInstallations = async () => {
 28:     try {
 29:       setCheckingInstallations(true);
 30:       const installations = await api.listClaudeInstallations();
 31:       setHasInstallations(installations.length > 0);
 32:     } catch (error) {
 33:       // If the API call fails, it means no installations found
 34:       setHasInstallations(false);
 35:     } finally {
 36:       setCheckingInstallations(false);
 37:     }
 38:   };
 39: 
 40:   const handleSave = async () => {
 41:     if (!selectedInstallation) {
 42:       onError("Please select a Claude installation");
 43:       return;
 44:     }
 45: 
 46:     setIsValidating(true);
 47:     try {
 48:       await api.setClaudeBinaryPath(selectedInstallation.path);
 49:       onSuccess();
 50:       onOpenChange(false);
 51:     } catch (error) {
 52:       console.error("Failed to save Claude binary path:", error);
 53:       onError(error instanceof Error ? error.message : "Failed to save Claude binary path");
 54:     } finally {
 55:       setIsValidating(false);
 56:     }
 57:   };
 58: 
 59:   return (
 60:     <Dialog open={open} onOpenChange={onOpenChange}>
 61:       <DialogContent className="sm:max-w-[600px]">
 62:         <DialogHeader>
 63:           <DialogTitle className="flex items-center gap-2">
 64:             <FileQuestion className="w-5 h-5" />
 65:             Select Claude Code Installation
 66:           </DialogTitle>
 67:           <DialogDescription className="space-y-3 mt-4">
 68:             {checkingInstallations ? (
 69:               <div className="flex items-center justify-center py-8">
 70:                 <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
 71:                 <span className="ml-2 text-sm text-muted-foreground">Searching for Claude installations...</span>
 72:               </div>
 73:             ) : hasInstallations ? (
 74:               <p>
 75:                 Multiple Claude Code installations were found on your system. 
 76:                 Please select which one you'd like to use.
 77:               </p>
 78:             ) : (
 79:               <>
 80:                 <p>
 81:                   Claude Code was not found in any of the common installation locations. 
 82:                   Please install Claude Code to continue.
 83:                 </p>
 84:                 <div className="flex items-center gap-2 p-3 bg-muted rounded-md">
 85:                   <AlertCircle className="w-4 h-4 text-muted-foreground" />
 86:                   <p className="text-sm text-muted-foreground">
 87:                     <span className="font-medium">Searched locations:</span> PATH, /usr/local/bin, 
 88:                     /opt/homebrew/bin, ~/.nvm/versions/node/*/bin, ~/.claude/local, ~/.local/bin
 89:                   </p>
 90:                 </div>
 91:               </>
 92:             )}
 93:             {!checkingInstallations && (
 94:               <div className="flex items-center gap-2 p-3 bg-muted rounded-md">
 95:                 <Terminal className="w-4 h-4 text-muted-foreground" />
 96:                 <p className="text-sm text-muted-foreground">
 97:                   <span className="font-medium">Tip:</span> You can install Claude Code using{" "}
 98:                   <code className="px-1 py-0.5 bg-black/10 dark:bg-white/10 rounded">npm install -g @claude</code>
 99:                 </p>
100:               </div>
101:             )}
102:           </DialogDescription>
103:         </DialogHeader>
104: 
105:         {!checkingInstallations && hasInstallations && (
106:           <div className="py-4">
107:             <ClaudeVersionSelector
108:               onSelect={(installation) => setSelectedInstallation(installation)}
109:               selectedPath={null}
110:             />
111:           </div>
112:         )}
113: 
114:         <DialogFooter className="gap-3">
115:           <Button
116:             variant="outline"
117:             onClick={() => window.open("https://docs.claude.ai/claude/how-to-install", "_blank")}
118:             className="mr-auto"
119:           >
120:             <ExternalLink className="w-4 h-4 mr-2" />
121:             Installation Guide
122:           </Button>
123:           <Button
124:             variant="outline"
125:             onClick={() => onOpenChange(false)}
126:             disabled={isValidating}
127:           >
128:             Cancel
129:           </Button>
130:           <Button 
131:             onClick={handleSave} 
132:             disabled={isValidating || !selectedInstallation || !hasInstallations}
133:           >
134:             {isValidating ? "Validating..." : hasInstallations ? "Save Selection" : "No Installations Found"}
135:           </Button>
136:         </DialogFooter>
137:       </DialogContent>
138:     </Dialog>
139:   );
140: }
````

## File: src/components/ClaudeCodeSession.refactored.tsx
````typescript
  1: import React, { useState, useEffect, useRef, useCallback } from "react";
  2: import { motion } from "framer-motion";
  3: import { Button } from "@/components/ui/button";
  4: import { Input } from "@/components/ui/input";
  5: import { Label } from "@/components/ui/label";
  6: import { api, type Session } from "@/lib/api";
  7: import { cn } from "@/lib/utils";
  8: import { open } from "@tauri-apps/plugin-dialog";
  9: import { FloatingPromptInput, type FloatingPromptInputRef } from "./FloatingPromptInput";
 10: import { ErrorBoundary } from "./ErrorBoundary";
 11: import { TimelineNavigator } from "./TimelineNavigator";
 12: import { CheckpointSettings } from "./CheckpointSettings";
 13: import { SlashCommandsManager } from "./SlashCommandsManager";
 14: import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
 15: import { SplitPane } from "@/components/ui/split-pane";
 16: import { WebviewPreview } from "./WebviewPreview";
 17: 
 18: // Import refactored components and hooks
 19: import { useClaudeMessages } from "./claude-code-session/useClaudeMessages";
 20: import { useCheckpoints } from "./claude-code-session/useCheckpoints";
 21: import { SessionHeader } from "./claude-code-session/SessionHeader";
 22: import { MessageList } from "./claude-code-session/MessageList";
 23: import { PromptQueue } from "./claude-code-session/PromptQueue";
 24: 
 25: interface ClaudeCodeSessionProps {
 26:   session?: Session;
 27:   initialProjectPath?: string;
 28:   onBack: () => void;
 29:   onProjectSettings?: (projectPath: string) => void;
 30:   className?: string;
 31:   onStreamingChange?: (isStreaming: boolean, sessionId: string | null) => void;
 32: }
 33: 
 34: export const ClaudeCodeSession: React.FC<ClaudeCodeSessionProps> = ({
 35:   session,
 36:   initialProjectPath = "",
 37:   onBack,
 38:   onProjectSettings,
 39:   className,
 40:   onStreamingChange,
 41: }) => {
 42:   const [projectPath, setProjectPath] = useState(initialProjectPath || session?.project_path || "");
 43:   const [error, setError] = useState<string | null>(null);
 44:   const [copyPopoverOpen, setCopyPopoverOpen] = useState(false);
 45:   const [isFirstPrompt, setIsFirstPrompt] = useState(!session);
 46:   const [totalTokens, setTotalTokens] = useState(0);
 47:   const [claudeSessionId, setClaudeSessionId] = useState<string | null>(null);
 48:   const [showTimeline, setShowTimeline] = useState(false);
 49:   const [showSettings, setShowSettings] = useState(false);
 50:   const [showForkDialog, setShowForkDialog] = useState(false);
 51:   const [showSlashCommandsSettings, setShowSlashCommandsSettings] = useState(false);
 52:   const [forkCheckpointId, setForkCheckpointId] = useState<string | null>(null);
 53:   const [forkSessionName, setForkSessionName] = useState("");
 54:   const [queuedPrompts, setQueuedPrompts] = useState<Array<{ id: string; prompt: string; model: "sonnet" | "opus" }>>([]);
 55:   const [showPreview, setShowPreview] = useState(false);
 56:   const [previewUrl, setPreviewUrl] = useState<string | null>(null);
 57:   const [isPreviewMaximized, setIsPreviewMaximized] = useState(false);
 58:   const promptInputRef = useRef<FloatingPromptInputRef>(null);
 59:   const processQueueTimeoutRef = useRef<NodeJS.Timeout | null>(null);
 60: 
 61:   // Use custom hooks
 62:   const {
 63:     messages,
 64:     rawJsonlOutput,
 65:     isStreaming,
 66:     currentSessionId: _currentSessionId,
 67:     clearMessages,
 68:     loadMessages
 69:   } = useClaudeMessages({
 70:     onSessionInfo: (info) => {
 71:       setClaudeSessionId(info.sessionId);
 72:     },
 73:     onTokenUpdate: setTotalTokens,
 74:     onStreamingChange
 75:   });
 76: 
 77:   const {
 78:     checkpoints: _checkpoints,
 79:     timelineVersion,
 80:     loadCheckpoints,
 81:     createCheckpoint: _createCheckpoint,
 82:     restoreCheckpoint,
 83:     forkCheckpoint
 84:   } = useCheckpoints({
 85:     sessionId: claudeSessionId,
 86:     projectId: session?.project_id || '',
 87:     projectPath: projectPath,
 88:     onToast: (message: string, type: 'success' | 'error') => {
 89:       console.log(`Toast: ${type} - ${message}`);
 90:     }
 91:   });
 92: 
 93:   // Handle path selection
 94:   const handleSelectPath = async () => {
 95:     const selected = await open({
 96:       directory: true,
 97:       multiple: false,
 98:       title: "Select Project Directory"
 99:     });
100:     
101:     if (selected && typeof selected === 'string') {
102:       setProjectPath(selected);
103:       setError(null);
104:       setIsFirstPrompt(true);
105:     }
106:   };
107: 
108:   // Handle sending prompts
109:   const handleSendPrompt = useCallback(async (prompt: string, model: "sonnet" | "opus") => {
110:     if (!projectPath || !prompt.trim()) return;
111: 
112:     // Add to queue if streaming
113:     if (isStreaming) {
114:       const id = Date.now().toString();
115:       setQueuedPrompts(prev => [...prev, { id, prompt, model }]);
116:       return;
117:     }
118: 
119:     try {
120:       setError(null);
121:       
122:       if (isFirstPrompt) {
123:         await api.executeClaudeCode(projectPath, prompt, model);
124:         setIsFirstPrompt(false);
125:       } else if (claudeSessionId) {
126:         await api.continueClaudeCode(projectPath, prompt, model);
127:       }
128:     } catch (error) {
129:       console.error("Failed to send prompt:", error);
130:       setError(error instanceof Error ? error.message : "Failed to send prompt");
131:     }
132:   }, [projectPath, isStreaming, isFirstPrompt, claudeSessionId]);
133: 
134:   // Process queued prompts
135:   const processQueuedPrompts = useCallback(async () => {
136:     if (queuedPrompts.length === 0 || isStreaming) return;
137: 
138:     const nextPrompt = queuedPrompts[0];
139:     setQueuedPrompts(prev => prev.slice(1));
140:     
141:     await handleSendPrompt(nextPrompt.prompt, nextPrompt.model);
142:   }, [queuedPrompts, isStreaming, handleSendPrompt]);
143: 
144:   // Effect to process queue when streaming stops
145:   useEffect(() => {
146:     if (!isStreaming && queuedPrompts.length > 0) {
147:       processQueueTimeoutRef.current = setTimeout(processQueuedPrompts, 500);
148:     }
149:     
150:     return () => {
151:       if (processQueueTimeoutRef.current) {
152:         clearTimeout(processQueueTimeoutRef.current);
153:       }
154:     };
155:   }, [isStreaming, queuedPrompts.length, processQueuedPrompts]);
156: 
157:   // Copy handlers
158:   const handleCopyAsJsonl = async () => {
159:     try {
160:       await navigator.clipboard.writeText(rawJsonlOutput.join('\n'));
161:       setCopyPopoverOpen(false);
162:       console.log("Session output copied as JSONL");
163:     } catch (error) {
164:       console.error("Failed to copy:", error);
165:     }
166:   };
167: 
168:   const handleCopyAsMarkdown = async () => {
169:     try {
170:       const markdown = messages
171:         .filter(msg => msg.type === 'user' || msg.type === 'assistant')
172:         .map(msg => {
173:           if (msg.type === 'user') {
174:             return `## User\n\n${msg.message || ''}`;
175:           } else if (msg.type === 'assistant' && msg.message?.content) {
176:             const content = Array.isArray(msg.message.content) 
177:               ? msg.message.content.map((item: any) => {
178:                   if (typeof item === 'string') return item;
179:                   if (item.type === 'text') return item.text;
180:                   return '';
181:                 }).filter(Boolean).join('')
182:               : msg.message.content;
183:             return `## Assistant\n\n${content}`;
184:           }
185:           return '';
186:         })
187:         .filter(Boolean)
188:         .join('\n\n---\n\n');
189:       
190:       await navigator.clipboard.writeText(markdown);
191:       setCopyPopoverOpen(false);
192:       console.log("Session output copied as Markdown");
193:     } catch (error) {
194:       console.error("Failed to copy:", error);
195:     }
196:   };
197: 
198:   // Fork dialog handlers
199:   const handleFork = (checkpointId: string) => {
200:     setForkCheckpointId(checkpointId);
201:     setForkSessionName("");
202:     setShowForkDialog(true);
203:   };
204: 
205:   const handleConfirmFork = async () => {
206:     if (!forkCheckpointId || !forkSessionName.trim()) return;
207: 
208:     const forkedSession = await forkCheckpoint(forkCheckpointId, forkSessionName);
209:     if (forkedSession) {
210:       setShowForkDialog(false);
211:       // Navigate to forked session
212:       window.location.reload(); // Or use proper navigation
213:     }
214:   };
215: 
216:   // Link detection handler
217:   const handleLinkDetected = (url: string) => {
218:     setPreviewUrl(url);
219:     if (!showPreview) {
220:       setShowPreview(true);
221:     }
222:   };
223: 
224:   // Load session if provided
225:   useEffect(() => {
226:     if (session) {
227:       setProjectPath(session.project_path);
228:       setClaudeSessionId(session.id);
229:       loadMessages(session.id);
230:       loadCheckpoints();
231:     }
232:   }, [session, loadMessages, loadCheckpoints]);
233: 
234:   return (
235:     <ErrorBoundary>
236:       <div className={cn("flex flex-col h-screen bg-background", className)}>
237:         {/* Header */}
238:         <SessionHeader
239:           projectPath={projectPath}
240:           claudeSessionId={claudeSessionId}
241:           totalTokens={totalTokens}
242:           isStreaming={isStreaming}
243:           hasMessages={messages.length > 0}
244:           showTimeline={showTimeline}
245:           copyPopoverOpen={copyPopoverOpen}
246:           onBack={onBack}
247:           onSelectPath={handleSelectPath}
248:           onCopyAsJsonl={handleCopyAsJsonl}
249:           onCopyAsMarkdown={handleCopyAsMarkdown}
250:           onToggleTimeline={() => setShowTimeline(!showTimeline)}
251:           onProjectSettings={onProjectSettings ? () => onProjectSettings(projectPath) : undefined}
252:           onSlashCommandsSettings={() => setShowSlashCommandsSettings(true)}
253:           setCopyPopoverOpen={setCopyPopoverOpen}
254:         />
255: 
256:         {/* Main content area */}
257:         <div className="flex-1 flex">
258:           {showPreview ? (
259:             <SplitPane
260:               left={
261:                 <div className="flex flex-col h-full">
262:                   <MessageList
263:                     messages={messages}
264:                     projectPath={projectPath}
265:                     isStreaming={isStreaming}
266:                     onLinkDetected={handleLinkDetected}
267:                     className="flex-1"
268:                   />
269:                   <PromptQueue
270:                     queuedPrompts={queuedPrompts}
271:                     onRemove={(id) => setQueuedPrompts(prev => prev.filter(p => p.id !== id))}
272:                   />
273:                 </div>
274:               }
275:               right={
276:                 <WebviewPreview
277:                   initialUrl={previewUrl || ""}
278:                   isMaximized={isPreviewMaximized}
279:                   onClose={() => setShowPreview(false)}
280:                   onUrlChange={setPreviewUrl}
281:                   onToggleMaximize={() => setIsPreviewMaximized(!isPreviewMaximized)}
282:                 />
283:               }
284:               initialSplit={60}
285:             />
286:           ) : (
287:             <div className="flex flex-col flex-1">
288:               <MessageList
289:                 messages={messages}
290:                 projectPath={projectPath}
291:                 isStreaming={isStreaming}
292:                 onLinkDetected={handleLinkDetected}
293:                 className="flex-1"
294:               />
295:               <PromptQueue
296:                 queuedPrompts={queuedPrompts}
297:                 onRemove={(id) => setQueuedPrompts(prev => prev.filter(p => p.id !== id))}
298:               />
299:             </div>
300:           )}
301:         </div>
302: 
303:         {/* Error display */}
304:         {error && (
305:           <motion.div
306:             initial={{ opacity: 0, y: 20 }}
307:             animate={{ opacity: 1, y: 0 }}
308:             className="mx-4 mb-4 p-3 bg-destructive/10 border border-destructive/20 rounded-md"
309:           >
310:             <p className="text-sm text-destructive">{error}</p>
311:           </motion.div>
312:         )}
313: 
314:         {/* Floating prompt input */}
315:         {projectPath && (
316:           <FloatingPromptInput
317:             ref={promptInputRef}
318:             onSend={handleSendPrompt}
319:             disabled={!projectPath}
320:             isLoading={isStreaming}
321:             onCancel={async () => {
322:               if (claudeSessionId && isStreaming) {
323:                 await api.cancelClaudeExecution(claudeSessionId);
324:               }
325:             }}
326:           />
327:         )}
328: 
329:         {/* Timeline Navigator */}
330:         {showTimeline && claudeSessionId && session && (
331:           <TimelineNavigator
332:             sessionId={claudeSessionId}
333:             projectId={session.project_id}
334:             projectPath={projectPath}
335:             currentMessageIndex={messages.length}
336:             onCheckpointSelect={async (checkpoint) => {
337:               const success = await restoreCheckpoint(checkpoint.id);
338:               if (success) {
339:                 clearMessages();
340:                 loadMessages(claudeSessionId);
341:               }
342:             }}
343:             onFork={handleFork}
344:             refreshVersion={timelineVersion}
345:           />
346:         )}
347: 
348:         {/* Settings dialogs */}
349:         {showSettings && claudeSessionId && session && (
350:           <CheckpointSettings
351:             sessionId={claudeSessionId}
352:             projectId={session.project_id}
353:             projectPath={projectPath}
354:             onClose={() => setShowSettings(false)}
355:           />
356:         )}
357: 
358:         {showSlashCommandsSettings && projectPath && (
359:           <SlashCommandsManager
360:             projectPath={projectPath}
361:           />
362:         )}
363: 
364:         {/* Fork dialog */}
365:         <Dialog open={showForkDialog} onOpenChange={setShowForkDialog}>
366:           <DialogContent>
367:             <DialogHeader>
368:               <DialogTitle>Fork Session from Checkpoint</DialogTitle>
369:               <DialogDescription>
370:                 Create a new session branching from this checkpoint. The original session will remain unchanged.
371:               </DialogDescription>
372:             </DialogHeader>
373:             <div className="space-y-4 py-4">
374:               <div>
375:                 <Label htmlFor="fork-name">New Session Name</Label>
376:                 <Input
377:                   id="fork-name"
378:                   value={forkSessionName}
379:                   onChange={(e) => setForkSessionName(e.target.value)}
380:                   placeholder="Enter a name for the forked session"
381:                   className="mt-2"
382:                 />
383:               </div>
384:             </div>
385:             <DialogFooter>
386:               <Button variant="outline" onClick={() => setShowForkDialog(false)}>
387:                 Cancel
388:               </Button>
389:               <Button 
390:                 onClick={handleConfirmFork}
391:                 disabled={!forkSessionName.trim()}
392:               >
393:                 Fork Session
394:               </Button>
395:             </DialogFooter>
396:           </DialogContent>
397:         </Dialog>
398:       </div>
399:     </ErrorBoundary>
400:   );
401: };
````

## File: src/components/ClaudeCodeSession.tsx
````typescript
   1: import React, { useState, useEffect, useRef, useMemo } from "react";
   2: import { motion, AnimatePresence } from "framer-motion";
   3: import { 
   4:   ArrowLeft,
   5:   Terminal,
   6:   FolderOpen,
   7:   Copy,
   8:   ChevronDown,
   9:   GitBranch,
  10:   Settings,
  11:   ChevronUp,
  12:   X,
  13:   Hash,
  14:   Command
  15: } from "lucide-react";
  16: import { Button } from "@/components/ui/button";
  17: import { Input } from "@/components/ui/input";
  18: import { Label } from "@/components/ui/label";
  19: import { Popover } from "@/components/ui/popover";
  20: import { api, type Session } from "@/lib/api";
  21: import { cn } from "@/lib/utils";
  22: import { open } from "@tauri-apps/plugin-dialog";
  23: import { listen, type UnlistenFn } from "@tauri-apps/api/event";
  24: import { StreamMessage } from "./StreamMessage";
  25: import { FloatingPromptInput, type FloatingPromptInputRef } from "./FloatingPromptInput";
  26: import { ErrorBoundary } from "./ErrorBoundary";
  27: import { TimelineNavigator } from "./TimelineNavigator";
  28: import { CheckpointSettings } from "./CheckpointSettings";
  29: import { SlashCommandsManager } from "./SlashCommandsManager";
  30: import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
  31: import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
  32: import { SplitPane } from "@/components/ui/split-pane";
  33: import { WebviewPreview } from "./WebviewPreview";
  34: import type { ClaudeStreamMessage } from "./AgentExecution";
  35: import { useVirtualizer } from "@tanstack/react-virtual";
  36: import { useTrackEvent, useComponentMetrics, useWorkflowTracking } from "@/hooks";
  37: 
  38: interface ClaudeCodeSessionProps {
  39:   /**
  40:    * Optional session to resume (when clicking from SessionList)
  41:    */
  42:   session?: Session;
  43:   /**
  44:    * Initial project path (for new sessions)
  45:    */
  46:   initialProjectPath?: string;
  47:   /**
  48:    * Callback to go back
  49:    */
  50:   onBack: () => void;
  51:   /**
  52:    * Callback to open hooks configuration
  53:    */
  54:   onProjectSettings?: (projectPath: string) => void;
  55:   /**
  56:    * Optional className for styling
  57:    */
  58:   className?: string;
  59:   /**
  60:    * Callback when streaming state changes
  61:    */
  62:   onStreamingChange?: (isStreaming: boolean, sessionId: string | null) => void;
  63: }
  64: 
  65: /**
  66:  * ClaudeCodeSession component for interactive Claude Code sessions
  67:  * 
  68:  * @example
  69:  * <ClaudeCodeSession onBack={() => setView('projects')} />
  70:  */
  71: export const ClaudeCodeSession: React.FC<ClaudeCodeSessionProps> = ({
  72:   session,
  73:   initialProjectPath = "",
  74:   onBack,
  75:   onProjectSettings,
  76:   className,
  77:   onStreamingChange,
  78: }) => {
  79:   const [projectPath, setProjectPath] = useState(initialProjectPath || session?.project_path || "");
  80:   const [messages, setMessages] = useState<ClaudeStreamMessage[]>([]);
  81:   const [isLoading, setIsLoading] = useState(false);
  82:   const [error, setError] = useState<string | null>(null);
  83:   const [rawJsonlOutput, setRawJsonlOutput] = useState<string[]>([]);
  84:   const [copyPopoverOpen, setCopyPopoverOpen] = useState(false);
  85:   const [isFirstPrompt, setIsFirstPrompt] = useState(!session);
  86:   const [totalTokens, setTotalTokens] = useState(0);
  87:   const [extractedSessionInfo, setExtractedSessionInfo] = useState<{ sessionId: string; projectId: string } | null>(null);
  88:   const [claudeSessionId, setClaudeSessionId] = useState<string | null>(null);
  89:   const [showTimeline, setShowTimeline] = useState(false);
  90:   const [timelineVersion, setTimelineVersion] = useState(0);
  91:   const [showSettings, setShowSettings] = useState(false);
  92:   const [showForkDialog, setShowForkDialog] = useState(false);
  93:   const [showSlashCommandsSettings, setShowSlashCommandsSettings] = useState(false);
  94:   const [forkCheckpointId, setForkCheckpointId] = useState<string | null>(null);
  95:   const [forkSessionName, setForkSessionName] = useState("");
  96:   
  97:   // Queued prompts state
  98:   const [queuedPrompts, setQueuedPrompts] = useState<Array<{ id: string; prompt: string; model: "sonnet" | "opus" }>>([]);
  99:   
 100:   // New state for preview feature
 101:   const [showPreview, setShowPreview] = useState(false);
 102:   const [previewUrl, setPreviewUrl] = useState("");
 103:   const [showPreviewPrompt, setShowPreviewPrompt] = useState(false);
 104:   const [splitPosition, setSplitPosition] = useState(50);
 105:   const [isPreviewMaximized, setIsPreviewMaximized] = useState(false);
 106:   
 107:   // Add collapsed state for queued prompts
 108:   const [queuedPromptsCollapsed, setQueuedPromptsCollapsed] = useState(false);
 109:   
 110:   const parentRef = useRef<HTMLDivElement>(null);
 111:   const unlistenRefs = useRef<UnlistenFn[]>([]);
 112:   const hasActiveSessionRef = useRef(false);
 113:   const floatingPromptRef = useRef<FloatingPromptInputRef>(null);
 114:   const queuedPromptsRef = useRef<Array<{ id: string; prompt: string; model: "sonnet" | "opus" }>>([]);
 115:   const isMountedRef = useRef(true);
 116:   const isListeningRef = useRef(false);
 117:   const sessionStartTime = useRef<number>(Date.now());
 118:   
 119:   // Session metrics state for enhanced analytics
 120:   const sessionMetrics = useRef({
 121:     firstMessageTime: null as number | null,
 122:     promptsSent: 0,
 123:     toolsExecuted: 0,
 124:     toolsFailed: 0,
 125:     filesCreated: 0,
 126:     filesModified: 0,
 127:     filesDeleted: 0,
 128:     codeBlocksGenerated: 0,
 129:     errorsEncountered: 0,
 130:     lastActivityTime: Date.now(),
 131:     toolExecutionTimes: [] as number[],
 132:     checkpointCount: 0,
 133:     wasResumed: !!session,
 134:     modelChanges: [] as Array<{ from: string; to: string; timestamp: number }>,
 135:   });
 136: 
 137:   // Analytics tracking
 138:   const trackEvent = useTrackEvent();
 139:   useComponentMetrics('ClaudeCodeSession');
 140:   // const aiTracking = useAIInteractionTracking('sonnet'); // Default model
 141:   const workflowTracking = useWorkflowTracking('claude_session');
 142:   
 143:   // Keep ref in sync with state
 144:   useEffect(() => {
 145:     queuedPromptsRef.current = queuedPrompts;
 146:   }, [queuedPrompts]);
 147: 
 148:   // Get effective session info (from prop or extracted) - use useMemo to ensure it updates
 149:   const effectiveSession = useMemo(() => {
 150:     if (session) return session;
 151:     if (extractedSessionInfo) {
 152:       return {
 153:         id: extractedSessionInfo.sessionId,
 154:         project_id: extractedSessionInfo.projectId,
 155:         project_path: projectPath,
 156:         created_at: Date.now(),
 157:       } as Session;
 158:     }
 159:     return null;
 160:   }, [session, extractedSessionInfo, projectPath]);
 161: 
 162:   // Filter out messages that shouldn't be displayed
 163:   const displayableMessages = useMemo(() => {
 164:     return messages.filter((message, index) => {
 165:       // Skip meta messages that don't have meaningful content
 166:       if (message.isMeta && !message.leafUuid && !message.summary) {
 167:         return false;
 168:       }
 169: 
 170:       // Skip user messages that only contain tool results that are already displayed
 171:       if (message.type === "user" && message.message) {
 172:         if (message.isMeta) return false;
 173: 
 174:         const msg = message.message;
 175:         if (!msg.content || (Array.isArray(msg.content) && msg.content.length === 0)) {
 176:           return false;
 177:         }
 178: 
 179:         if (Array.isArray(msg.content)) {
 180:           let hasVisibleContent = false;
 181:           for (const content of msg.content) {
 182:             if (content.type === "text") {
 183:               hasVisibleContent = true;
 184:               break;
 185:             }
 186:             if (content.type === "tool_result") {
 187:               let willBeSkipped = false;
 188:               if (content.tool_use_id) {
 189:                 // Look for the matching tool_use in previous assistant messages
 190:                 for (let i = index - 1; i >= 0; i--) {
 191:                   const prevMsg = messages[i];
 192:                   if (prevMsg.type === 'assistant' && prevMsg.message?.content && Array.isArray(prevMsg.message.content)) {
 193:                     const toolUse = prevMsg.message.content.find((c: any) => 
 194:                       c.type === 'tool_use' && c.id === content.tool_use_id
 195:                     );
 196:                     if (toolUse) {
 197:                       const toolName = toolUse.name?.toLowerCase();
 198:                       const toolsWithWidgets = [
 199:                         'task', 'edit', 'multiedit', 'todowrite', 'ls', 'read', 
 200:                         'glob', 'bash', 'write', 'grep'
 201:                       ];
 202:                       if (toolsWithWidgets.includes(toolName) || toolUse.name?.startsWith('mcp__')) {
 203:                         willBeSkipped = true;
 204:                       }
 205:                       break;
 206:                     }
 207:                   }
 208:                 }
 209:               }
 210:               if (!willBeSkipped) {
 211:                 hasVisibleContent = true;
 212:                 break;
 213:               }
 214:             }
 215:           }
 216:           if (!hasVisibleContent) {
 217:             return false;
 218:           }
 219:         }
 220:       }
 221:       return true;
 222:     });
 223:   }, [messages]);
 224: 
 225:   const rowVirtualizer = useVirtualizer({
 226:     count: displayableMessages.length,
 227:     getScrollElement: () => parentRef.current,
 228:     estimateSize: () => 150, // Estimate, will be dynamically measured
 229:     overscan: 5,
 230:   });
 231: 
 232:   // Debug logging
 233:   useEffect(() => {
 234:     console.log('[ClaudeCodeSession] State update:', {
 235:       projectPath,
 236:       session,
 237:       extractedSessionInfo,
 238:       effectiveSession,
 239:       messagesCount: messages.length,
 240:       isLoading
 241:     });
 242:   }, [projectPath, session, extractedSessionInfo, effectiveSession, messages.length, isLoading]);
 243: 
 244:   // Load session history if resuming
 245:   useEffect(() => {
 246:     if (session) {
 247:       // Set the claudeSessionId immediately when we have a session
 248:       setClaudeSessionId(session.id);
 249:       
 250:       // Load session history first, then check for active session
 251:       const initializeSession = async () => {
 252:         await loadSessionHistory();
 253:         // After loading history, check if the session is still active
 254:         if (isMountedRef.current) {
 255:           await checkForActiveSession();
 256:         }
 257:       };
 258:       
 259:       initializeSession();
 260:     }
 261:   }, [session]); // Remove hasLoadedSession dependency to ensure it runs on mount
 262: 
 263:   // Report streaming state changes
 264:   useEffect(() => {
 265:     onStreamingChange?.(isLoading, claudeSessionId);
 266:   }, [isLoading, claudeSessionId, onStreamingChange]);
 267: 
 268:   // Auto-scroll to bottom when new messages arrive
 269:   useEffect(() => {
 270:     if (displayableMessages.length > 0) {
 271:       rowVirtualizer.scrollToIndex(displayableMessages.length - 1, { align: 'end', behavior: 'smooth' });
 272:     }
 273:   }, [displayableMessages.length, rowVirtualizer]);
 274: 
 275:   // Calculate total tokens from messages
 276:   useEffect(() => {
 277:     const tokens = messages.reduce((total, msg) => {
 278:       if (msg.message?.usage) {
 279:         return total + msg.message.usage.input_tokens + msg.message.usage.output_tokens;
 280:       }
 281:       if (msg.usage) {
 282:         return total + msg.usage.input_tokens + msg.usage.output_tokens;
 283:       }
 284:       return total;
 285:     }, 0);
 286:     setTotalTokens(tokens);
 287:   }, [messages]);
 288: 
 289:   const loadSessionHistory = async () => {
 290:     if (!session) return;
 291:     
 292:     try {
 293:       setIsLoading(true);
 294:       setError(null);
 295:       
 296:       const history = await api.loadSessionHistory(session.id, session.project_id);
 297:       
 298:       // Convert history to messages format
 299:       const loadedMessages: ClaudeStreamMessage[] = history.map(entry => ({
 300:         ...entry,
 301:         type: entry.type || "assistant"
 302:       }));
 303:       
 304:       setMessages(loadedMessages);
 305:       setRawJsonlOutput(history.map(h => JSON.stringify(h)));
 306:       
 307:       // After loading history, we're continuing a conversation
 308:       setIsFirstPrompt(false);
 309:     } catch (err) {
 310:       console.error("Failed to load session history:", err);
 311:       setError("Failed to load session history");
 312:     } finally {
 313:       setIsLoading(false);
 314:     }
 315:   };
 316: 
 317:   const checkForActiveSession = async () => {
 318:     // If we have a session prop, check if it's still active
 319:     if (session) {
 320:       try {
 321:         const activeSessions = await api.listRunningClaudeSessions();
 322:         const activeSession = activeSessions.find((s: any) => {
 323:           if ('process_type' in s && s.process_type && 'ClaudeSession' in s.process_type) {
 324:             return (s.process_type as any).ClaudeSession.session_id === session.id;
 325:           }
 326:           return false;
 327:         });
 328:         
 329:         if (activeSession) {
 330:           // Session is still active, reconnect to its stream
 331:           console.log('[ClaudeCodeSession] Found active session, reconnecting:', session.id);
 332:           // IMPORTANT: Set claudeSessionId before reconnecting
 333:           setClaudeSessionId(session.id);
 334:           
 335:           // Don't add buffered messages here - they've already been loaded by loadSessionHistory
 336:           // Just set up listeners for new messages
 337:           
 338:           // Set up listeners for the active session
 339:           reconnectToSession(session.id);
 340:         }
 341:       } catch (err) {
 342:         console.error('Failed to check for active sessions:', err);
 343:       }
 344:     }
 345:   };
 346: 
 347:   const reconnectToSession = async (sessionId: string) => {
 348:     console.log('[ClaudeCodeSession] Reconnecting to session:', sessionId);
 349:     
 350:     // Prevent duplicate listeners
 351:     if (isListeningRef.current) {
 352:       console.log('[ClaudeCodeSession] Already listening to session, skipping reconnect');
 353:       return;
 354:     }
 355:     
 356:     // Clean up previous listeners
 357:     unlistenRefs.current.forEach(unlisten => unlisten());
 358:     unlistenRefs.current = [];
 359:     
 360:     // IMPORTANT: Set the session ID before setting up listeners
 361:     setClaudeSessionId(sessionId);
 362:     
 363:     // Mark as listening
 364:     isListeningRef.current = true;
 365:     
 366:     // Set up session-specific listeners
 367:     const outputUnlisten = await listen<string>(`claude-output:${sessionId}`, async (event) => {
 368:       try {
 369:         console.log('[ClaudeCodeSession] Received claude-output on reconnect:', event.payload);
 370:         
 371:         if (!isMountedRef.current) return;
 372:         
 373:         // Store raw JSONL
 374:         setRawJsonlOutput(prev => [...prev, event.payload]);
 375:         
 376:         // Parse and display
 377:         const message = JSON.parse(event.payload) as ClaudeStreamMessage;
 378:         setMessages(prev => [...prev, message]);
 379:       } catch (err) {
 380:         console.error("Failed to parse message:", err, event.payload);
 381:       }
 382:     });
 383: 
 384:     const errorUnlisten = await listen<string>(`claude-error:${sessionId}`, (event) => {
 385:       console.error("Claude error:", event.payload);
 386:       if (isMountedRef.current) {
 387:         setError(event.payload);
 388:       }
 389:     });
 390: 
 391:     const completeUnlisten = await listen<boolean>(`claude-complete:${sessionId}`, async (event) => {
 392:       console.log('[ClaudeCodeSession] Received claude-complete on reconnect:', event.payload);
 393:       if (isMountedRef.current) {
 394:         setIsLoading(false);
 395:         hasActiveSessionRef.current = false;
 396:       }
 397:     });
 398: 
 399:     unlistenRefs.current = [outputUnlisten, errorUnlisten, completeUnlisten];
 400:     
 401:     // Mark as loading to show the session is active
 402:     if (isMountedRef.current) {
 403:       setIsLoading(true);
 404:       hasActiveSessionRef.current = true;
 405:     }
 406:   };
 407: 
 408:   const handleSelectPath = async () => {
 409:     try {
 410:       const selected = await open({
 411:         directory: true,
 412:         multiple: false,
 413:         title: "Select Project Directory"
 414:       });
 415:       
 416:       if (selected) {
 417:         setProjectPath(selected as string);
 418:         setError(null);
 419:       }
 420:     } catch (err) {
 421:       console.error("Failed to select directory:", err);
 422:       const errorMessage = err instanceof Error ? err.message : String(err);
 423:       setError(`Failed to select directory: ${errorMessage}`);
 424:     }
 425:   };
 426: 
 427:   const handleSendPrompt = async (prompt: string, model: "sonnet" | "opus") => {
 428:     console.log('[ClaudeCodeSession] handleSendPrompt called with:', { prompt, model, projectPath, claudeSessionId, effectiveSession });
 429:     
 430:     if (!projectPath) {
 431:       setError("Please select a project directory first");
 432:       return;
 433:     }
 434: 
 435:     // If already loading, queue the prompt
 436:     if (isLoading) {
 437:       const newPrompt = {
 438:         id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
 439:         prompt,
 440:         model
 441:       };
 442:       setQueuedPrompts(prev => [...prev, newPrompt]);
 443:       return;
 444:     }
 445: 
 446:     try {
 447:       setIsLoading(true);
 448:       setError(null);
 449:       hasActiveSessionRef.current = true;
 450:       
 451:       // For resuming sessions, ensure we have the session ID
 452:       if (effectiveSession && !claudeSessionId) {
 453:         setClaudeSessionId(effectiveSession.id);
 454:       }
 455:       
 456:       // Only clean up and set up new listeners if not already listening
 457:       if (!isListeningRef.current) {
 458:         // Clean up previous listeners
 459:         unlistenRefs.current.forEach(unlisten => unlisten());
 460:         unlistenRefs.current = [];
 461:         
 462:         // Mark as setting up listeners
 463:         isListeningRef.current = true;
 464:         
 465:         // --------------------------------------------------------------------
 466:         // 1️⃣  Event Listener Setup Strategy
 467:         // --------------------------------------------------------------------
 468:         // Claude Code may emit a *new* session_id even when we pass --resume. If
 469:         // we listen only on the old session-scoped channel we will miss the
 470:         // stream until the user navigates away & back. To avoid this we:
 471:         //   • Always start with GENERIC listeners (no suffix) so we catch the
 472:         //     very first "system:init" message regardless of the session id.
 473:         //   • Once that init message provides the *actual* session_id, we
 474:         //     dynamically switch to session-scoped listeners and stop the
 475:         //     generic ones to prevent duplicate handling.
 476:         // --------------------------------------------------------------------
 477: 
 478:         console.log('[ClaudeCodeSession] Setting up generic event listeners first');
 479: 
 480:         let currentSessionId: string | null = claudeSessionId || effectiveSession?.id || null;
 481: 
 482:         // Helper to attach session-specific listeners **once we are sure**
 483:         const attachSessionSpecificListeners = async (sid: string) => {
 484:           console.log('[ClaudeCodeSession] Attaching session-specific listeners for', sid);
 485: 
 486:           const specificOutputUnlisten = await listen<string>(`claude-output:${sid}`, (evt) => {
 487:             handleStreamMessage(evt.payload);
 488:           });
 489: 
 490:           const specificErrorUnlisten = await listen<string>(`claude-error:${sid}`, (evt) => {
 491:             console.error('Claude error (scoped):', evt.payload);
 492:             setError(evt.payload);
 493:           });
 494: 
 495:           const specificCompleteUnlisten = await listen<boolean>(`claude-complete:${sid}`, (evt) => {
 496:             console.log('[ClaudeCodeSession] Received claude-complete (scoped):', evt.payload);
 497:             processComplete(evt.payload);
 498:           });
 499: 
 500:           // Replace existing unlisten refs with these new ones (after cleaning up)
 501:           unlistenRefs.current.forEach((u) => u());
 502:           unlistenRefs.current = [specificOutputUnlisten, specificErrorUnlisten, specificCompleteUnlisten];
 503:         };
 504: 
 505:         // Generic listeners (catch-all)
 506:         const genericOutputUnlisten = await listen<string>('claude-output', async (event) => {
 507:           handleStreamMessage(event.payload);
 508: 
 509:           // Attempt to extract session_id on the fly (for the very first init)
 510:           try {
 511:             const msg = JSON.parse(event.payload) as ClaudeStreamMessage;
 512:             if (msg.type === 'system' && msg.subtype === 'init' && msg.session_id) {
 513:               if (!currentSessionId || currentSessionId !== msg.session_id) {
 514:                 console.log('[ClaudeCodeSession] Detected new session_id from generic listener:', msg.session_id);
 515:                 currentSessionId = msg.session_id;
 516:                 setClaudeSessionId(msg.session_id);
 517: 
 518:                 // If we haven't extracted session info before, do it now
 519:                 if (!extractedSessionInfo) {
 520:                   const projectId = projectPath.replace(/[^a-zA-Z0-9]/g, '-');
 521:                   setExtractedSessionInfo({ sessionId: msg.session_id, projectId });
 522:                 }
 523: 
 524:                 // Switch to session-specific listeners
 525:                 await attachSessionSpecificListeners(msg.session_id);
 526:               }
 527:             }
 528:           } catch {
 529:             /* ignore parse errors */
 530:           }
 531:         });
 532: 
 533:         // Helper to process any JSONL stream message string
 534:         function handleStreamMessage(payload: string) {
 535:           try {
 536:             // Don't process if component unmounted
 537:             if (!isMountedRef.current) return;
 538:             
 539:             // Store raw JSONL
 540:             setRawJsonlOutput((prev) => [...prev, payload]);
 541: 
 542:             const message = JSON.parse(payload) as ClaudeStreamMessage;
 543:             
 544:             // Track enhanced tool execution
 545:             if (message.type === 'assistant' && message.message?.content) {
 546:               const toolUses = message.message.content.filter((c: any) => c.type === 'tool_use');
 547:               toolUses.forEach((toolUse: any) => {
 548:                 // Increment tools executed counter
 549:                 sessionMetrics.current.toolsExecuted += 1;
 550:                 sessionMetrics.current.lastActivityTime = Date.now();
 551:                 
 552:                 // Track file operations
 553:                 const toolName = toolUse.name?.toLowerCase() || '';
 554:                 if (toolName.includes('create') || toolName.includes('write')) {
 555:                   sessionMetrics.current.filesCreated += 1;
 556:                 } else if (toolName.includes('edit') || toolName.includes('multiedit') || toolName.includes('search_replace')) {
 557:                   sessionMetrics.current.filesModified += 1;
 558:                 } else if (toolName.includes('delete')) {
 559:                   sessionMetrics.current.filesDeleted += 1;
 560:                 }
 561:                 
 562:                 // Track tool start - we'll track completion when we get the result
 563:                 workflowTracking.trackStep(toolUse.name);
 564:               });
 565:             }
 566:             
 567:             // Track tool results
 568:             if (message.type === 'user' && message.message?.content) {
 569:               const toolResults = message.message.content.filter((c: any) => c.type === 'tool_result');
 570:               toolResults.forEach((result: any) => {
 571:                 const isError = result.is_error || false;
 572:                 // Note: We don't have execution time here, but we can track success/failure
 573:                 if (isError) {
 574:                   sessionMetrics.current.toolsFailed += 1;
 575:                   sessionMetrics.current.errorsEncountered += 1;
 576:                   
 577:                   trackEvent.enhancedError({
 578:                     error_type: 'tool_execution',
 579:                     error_code: 'tool_failed',
 580:                     error_message: result.content,
 581:                     context: `Tool execution failed`,
 582:                     user_action_before_error: 'executing_tool',
 583:                     recovery_attempted: false,
 584:                     recovery_successful: false,
 585:                     error_frequency: 1,
 586:                     stack_trace_hash: undefined
 587:                   });
 588:                 }
 589:               });
 590:             }
 591:             
 592:             // Track code blocks generated
 593:             if (message.type === 'assistant' && message.message?.content) {
 594:               const codeBlocks = message.message.content.filter((c: any) => 
 595:                 c.type === 'text' && c.text?.includes('```')
 596:               );
 597:               if (codeBlocks.length > 0) {
 598:                 // Count code blocks in text content
 599:                 codeBlocks.forEach((block: any) => {
 600:                   const matches = (block.text.match(/```/g) || []).length;
 601:                   sessionMetrics.current.codeBlocksGenerated += Math.floor(matches / 2);
 602:                 });
 603:               }
 604:             }
 605:             
 606:             // Track errors in system messages
 607:             if (message.type === 'system' && (message.subtype === 'error' || message.error)) {
 608:               sessionMetrics.current.errorsEncountered += 1;
 609:             }
 610:             
 611:             setMessages((prev) => [...prev, message]);
 612:           } catch (err) {
 613:             console.error('Failed to parse message:', err, payload);
 614:           }
 615:         }
 616: 
 617:         // Helper to handle completion events (both generic and scoped)
 618:         const processComplete = async (success: boolean) => {
 619:           setIsLoading(false);
 620:           hasActiveSessionRef.current = false;
 621:           isListeningRef.current = false; // Reset listening state
 622:           
 623:           // Track enhanced session stopped metrics when session completes
 624:           if (effectiveSession && claudeSessionId) {
 625:             const sessionStartTimeValue = messages.length > 0 ? messages[0].timestamp || Date.now() : Date.now();
 626:             const duration = Date.now() - sessionStartTimeValue;
 627:             const metrics = sessionMetrics.current;
 628:             const timeToFirstMessage = metrics.firstMessageTime 
 629:               ? metrics.firstMessageTime - sessionStartTime.current 
 630:               : undefined;
 631:             const idleTime = Date.now() - metrics.lastActivityTime;
 632:             const avgResponseTime = metrics.toolExecutionTimes.length > 0
 633:               ? metrics.toolExecutionTimes.reduce((a, b) => a + b, 0) / metrics.toolExecutionTimes.length
 634:               : undefined;
 635:             
 636:             trackEvent.enhancedSessionStopped({
 637:               // Basic metrics
 638:               duration_ms: duration,
 639:               messages_count: messages.length,
 640:               reason: success ? 'completed' : 'error',
 641:               
 642:               // Timing metrics
 643:               time_to_first_message_ms: timeToFirstMessage,
 644:               average_response_time_ms: avgResponseTime,
 645:               idle_time_ms: idleTime,
 646:               
 647:               // Interaction metrics
 648:               prompts_sent: metrics.promptsSent,
 649:               tools_executed: metrics.toolsExecuted,
 650:               tools_failed: metrics.toolsFailed,
 651:               files_created: metrics.filesCreated,
 652:               files_modified: metrics.filesModified,
 653:               files_deleted: metrics.filesDeleted,
 654:               
 655:               // Content metrics
 656:               total_tokens_used: totalTokens,
 657:               code_blocks_generated: metrics.codeBlocksGenerated,
 658:               errors_encountered: metrics.errorsEncountered,
 659:               
 660:               // Session context
 661:               model: metrics.modelChanges.length > 0 
 662:                 ? metrics.modelChanges[metrics.modelChanges.length - 1].to 
 663:                 : 'sonnet',
 664:               has_checkpoints: metrics.checkpointCount > 0,
 665:               checkpoint_count: metrics.checkpointCount,
 666:               was_resumed: metrics.wasResumed,
 667:               
 668:               // Agent context (if applicable)
 669:               agent_type: undefined, // TODO: Pass from agent execution
 670:               agent_name: undefined, // TODO: Pass from agent execution
 671:               agent_success: success,
 672:               
 673:               // Stop context
 674:               stop_source: 'completed',
 675:               final_state: success ? 'success' : 'failed',
 676:               has_pending_prompts: queuedPrompts.length > 0,
 677:               pending_prompts_count: queuedPrompts.length,
 678:             });
 679:           }
 680: 
 681:           if (effectiveSession && success) {
 682:             try {
 683:               const settings = await api.getCheckpointSettings(
 684:                 effectiveSession.id,
 685:                 effectiveSession.project_id,
 686:                 projectPath
 687:               );
 688: 
 689:               if (settings.auto_checkpoint_enabled) {
 690:                 await api.checkAutoCheckpoint(
 691:                   effectiveSession.id,
 692:                   effectiveSession.project_id,
 693:                   projectPath,
 694:                   prompt
 695:                 );
 696:                 // Reload timeline to show new checkpoint
 697:                 setTimelineVersion((v) => v + 1);
 698:               }
 699:             } catch (err) {
 700:               console.error('Failed to check auto checkpoint:', err);
 701:             }
 702:           }
 703: 
 704:           // Process queued prompts after completion
 705:           if (queuedPromptsRef.current.length > 0) {
 706:             const [nextPrompt, ...remainingPrompts] = queuedPromptsRef.current;
 707:             setQueuedPrompts(remainingPrompts);
 708:             
 709:             // Small delay to ensure UI updates
 710:             setTimeout(() => {
 711:               handleSendPrompt(nextPrompt.prompt, nextPrompt.model);
 712:             }, 100);
 713:           }
 714:         };
 715: 
 716:         const genericErrorUnlisten = await listen<string>('claude-error', (evt) => {
 717:           console.error('Claude error:', evt.payload);
 718:           setError(evt.payload);
 719:         });
 720: 
 721:         const genericCompleteUnlisten = await listen<boolean>('claude-complete', (evt) => {
 722:           console.log('[ClaudeCodeSession] Received claude-complete (generic):', evt.payload);
 723:           processComplete(evt.payload);
 724:         });
 725: 
 726:         // Store the generic unlisteners for now; they may be replaced later.
 727:         unlistenRefs.current = [genericOutputUnlisten, genericErrorUnlisten, genericCompleteUnlisten];
 728: 
 729:         // --------------------------------------------------------------------
 730:         // 2️⃣  Auto-checkpoint logic moved after listener setup (unchanged)
 731:         // --------------------------------------------------------------------
 732: 
 733:         // Add the user message immediately to the UI (after setting up listeners)
 734:         const userMessage: ClaudeStreamMessage = {
 735:           type: "user",
 736:           message: {
 737:             content: [
 738:               {
 739:                 type: "text",
 740:                 text: prompt
 741:               }
 742:             ]
 743:           }
 744:         };
 745:         setMessages(prev => [...prev, userMessage]);
 746:         
 747:         // Update session metrics
 748:         sessionMetrics.current.promptsSent += 1;
 749:         sessionMetrics.current.lastActivityTime = Date.now();
 750:         if (!sessionMetrics.current.firstMessageTime) {
 751:           sessionMetrics.current.firstMessageTime = Date.now();
 752:         }
 753:         
 754:         // Track model changes
 755:         const lastModel = sessionMetrics.current.modelChanges.length > 0 
 756:           ? sessionMetrics.current.modelChanges[sessionMetrics.current.modelChanges.length - 1].to
 757:           : (sessionMetrics.current.wasResumed ? 'sonnet' : model); // Default to sonnet if resumed
 758:         
 759:         if (lastModel !== model) {
 760:           sessionMetrics.current.modelChanges.push({
 761:             from: lastModel,
 762:             to: model,
 763:             timestamp: Date.now()
 764:           });
 765:         }
 766:         
 767:         // Track enhanced prompt submission
 768:         const codeBlockMatches = prompt.match(/```[\s\S]*?```/g) || [];
 769:         const hasCode = codeBlockMatches.length > 0;
 770:         const conversationDepth = messages.filter(m => m.user_message).length;
 771:         const sessionAge = sessionStartTime.current ? Date.now() - sessionStartTime.current : 0;
 772:         const wordCount = prompt.split(/\s+/).filter(word => word.length > 0).length;
 773:         
 774:         trackEvent.enhancedPromptSubmitted({
 775:           prompt_length: prompt.length,
 776:           model: model,
 777:           has_attachments: false, // TODO: Add attachment support when implemented
 778:           source: 'keyboard', // TODO: Track actual source (keyboard vs button)
 779:           word_count: wordCount,
 780:           conversation_depth: conversationDepth,
 781:           prompt_complexity: wordCount < 20 ? 'simple' : wordCount < 100 ? 'moderate' : 'complex',
 782:           contains_code: hasCode,
 783:           language_detected: hasCode ? codeBlockMatches?.[0]?.match(/```(\w+)/)?.[1] : undefined,
 784:           session_age_ms: sessionAge
 785:         });
 786: 
 787:         // Execute the appropriate command
 788:         if (effectiveSession && !isFirstPrompt) {
 789:           console.log('[ClaudeCodeSession] Resuming session:', effectiveSession.id);
 790:           trackEvent.sessionResumed(effectiveSession.id);
 791:           trackEvent.modelSelected(model);
 792:           await api.resumeClaudeCode(projectPath, effectiveSession.id, prompt, model);
 793:         } else {
 794:           console.log('[ClaudeCodeSession] Starting new session');
 795:           setIsFirstPrompt(false);
 796:           trackEvent.sessionCreated(model, 'prompt_input');
 797:           trackEvent.modelSelected(model);
 798:           await api.executeClaudeCode(projectPath, prompt, model);
 799:         }
 800:       }
 801:     } catch (err) {
 802:       console.error("Failed to send prompt:", err);
 803:       setError("Failed to send prompt");
 804:       setIsLoading(false);
 805:       hasActiveSessionRef.current = false;
 806:     }
 807:   };
 808: 
 809:   const handleCopyAsJsonl = async () => {
 810:     const jsonl = rawJsonlOutput.join('\n');
 811:     await navigator.clipboard.writeText(jsonl);
 812:     setCopyPopoverOpen(false);
 813:   };
 814: 
 815:   const handleCopyAsMarkdown = async () => {
 816:     let markdown = `# Claude Code Session\n\n`;
 817:     markdown += `**Project:** ${projectPath}\n`;
 818:     markdown += `**Date:** ${new Date().toISOString()}\n\n`;
 819:     markdown += `---\n\n`;
 820: 
 821:     for (const msg of messages) {
 822:       if (msg.type === "system" && msg.subtype === "init") {
 823:         markdown += `## System Initialization\n\n`;
 824:         markdown += `- Session ID: \`${msg.session_id || 'N/A'}\`\n`;
 825:         markdown += `- Model: \`${msg.model || 'default'}\`\n`;
 826:         if (msg.cwd) markdown += `- Working Directory: \`${msg.cwd}\`\n`;
 827:         if (msg.tools?.length) markdown += `- Tools: ${msg.tools.join(', ')}\n`;
 828:         markdown += `\n`;
 829:       } else if (msg.type === "assistant" && msg.message) {
 830:         markdown += `## Assistant\n\n`;
 831:         for (const content of msg.message.content || []) {
 832:           if (content.type === "text") {
 833:             const textContent = typeof content.text === 'string' 
 834:               ? content.text 
 835:               : (content.text?.text || JSON.stringify(content.text || content));
 836:             markdown += `${textContent}\n\n`;
 837:           } else if (content.type === "tool_use") {
 838:             markdown += `### Tool: ${content.name}\n\n`;
 839:             markdown += `\`\`\`json\n${JSON.stringify(content.input, null, 2)}\n\`\`\`\n\n`;
 840:           }
 841:         }
 842:         if (msg.message.usage) {
 843:           markdown += `*Tokens: ${msg.message.usage.input_tokens} in, ${msg.message.usage.output_tokens} out*\n\n`;
 844:         }
 845:       } else if (msg.type === "user" && msg.message) {
 846:         markdown += `## User\n\n`;
 847:         for (const content of msg.message.content || []) {
 848:           if (content.type === "text") {
 849:             const textContent = typeof content.text === 'string' 
 850:               ? content.text 
 851:               : (content.text?.text || JSON.stringify(content.text));
 852:             markdown += `${textContent}\n\n`;
 853:           } else if (content.type === "tool_result") {
 854:             markdown += `### Tool Result\n\n`;
 855:             let contentText = '';
 856:             if (typeof content.content === 'string') {
 857:               contentText = content.content;
 858:             } else if (content.content && typeof content.content === 'object') {
 859:               if (content.content.text) {
 860:                 contentText = content.content.text;
 861:               } else if (Array.isArray(content.content)) {
 862:                 contentText = content.content
 863:                   .map((c: any) => (typeof c === 'string' ? c : c.text || JSON.stringify(c)))
 864:                   .join('\n');
 865:               } else {
 866:                 contentText = JSON.stringify(content.content, null, 2);
 867:               }
 868:             }
 869:             markdown += `\`\`\`\n${contentText}\n\`\`\`\n\n`;
 870:           }
 871:         }
 872:       } else if (msg.type === "result") {
 873:         markdown += `## Execution Result\n\n`;
 874:         if (msg.result) {
 875:           markdown += `${msg.result}\n\n`;
 876:         }
 877:         if (msg.error) {
 878:           markdown += `**Error:** ${msg.error}\n\n`;
 879:         }
 880:       }
 881:     }
 882: 
 883:     await navigator.clipboard.writeText(markdown);
 884:     setCopyPopoverOpen(false);
 885:   };
 886: 
 887:   const handleCheckpointSelect = async () => {
 888:     // Reload messages from the checkpoint
 889:     await loadSessionHistory();
 890:     // Ensure timeline reloads to highlight current checkpoint
 891:     setTimelineVersion((v) => v + 1);
 892:   };
 893:   
 894:   const handleCheckpointCreated = () => {
 895:     // Update checkpoint count in session metrics
 896:     sessionMetrics.current.checkpointCount += 1;
 897:   };
 898: 
 899:   const handleCancelExecution = async () => {
 900:     if (!claudeSessionId || !isLoading) return;
 901:     
 902:     try {
 903:       const sessionStartTime = messages.length > 0 ? messages[0].timestamp || Date.now() : Date.now();
 904:       const duration = Date.now() - sessionStartTime;
 905:       
 906:       await api.cancelClaudeExecution(claudeSessionId);
 907:       
 908:       // Calculate metrics for enhanced analytics
 909:       const metrics = sessionMetrics.current;
 910:       const timeToFirstMessage = metrics.firstMessageTime 
 911:         ? metrics.firstMessageTime - sessionStartTime.current 
 912:         : undefined;
 913:       const idleTime = Date.now() - metrics.lastActivityTime;
 914:       const avgResponseTime = metrics.toolExecutionTimes.length > 0
 915:         ? metrics.toolExecutionTimes.reduce((a, b) => a + b, 0) / metrics.toolExecutionTimes.length
 916:         : undefined;
 917:       
 918:       // Track enhanced session stopped
 919:       trackEvent.enhancedSessionStopped({
 920:         // Basic metrics
 921:         duration_ms: duration,
 922:         messages_count: messages.length,
 923:         reason: 'user_stopped',
 924:         
 925:         // Timing metrics
 926:         time_to_first_message_ms: timeToFirstMessage,
 927:         average_response_time_ms: avgResponseTime,
 928:         idle_time_ms: idleTime,
 929:         
 930:         // Interaction metrics
 931:         prompts_sent: metrics.promptsSent,
 932:         tools_executed: metrics.toolsExecuted,
 933:         tools_failed: metrics.toolsFailed,
 934:         files_created: metrics.filesCreated,
 935:         files_modified: metrics.filesModified,
 936:         files_deleted: metrics.filesDeleted,
 937:         
 938:         // Content metrics
 939:         total_tokens_used: totalTokens,
 940:         code_blocks_generated: metrics.codeBlocksGenerated,
 941:         errors_encountered: metrics.errorsEncountered,
 942:         
 943:         // Session context
 944:         model: metrics.modelChanges.length > 0 
 945:           ? metrics.modelChanges[metrics.modelChanges.length - 1].to 
 946:           : 'sonnet', // Default to sonnet
 947:         has_checkpoints: metrics.checkpointCount > 0,
 948:         checkpoint_count: metrics.checkpointCount,
 949:         was_resumed: metrics.wasResumed,
 950:         
 951:         // Agent context (if applicable)
 952:         agent_type: undefined, // TODO: Pass from agent execution
 953:         agent_name: undefined, // TODO: Pass from agent execution
 954:         agent_success: undefined, // TODO: Pass from agent execution
 955:         
 956:         // Stop context
 957:         stop_source: 'user_button',
 958:         final_state: 'cancelled',
 959:         has_pending_prompts: queuedPrompts.length > 0,
 960:         pending_prompts_count: queuedPrompts.length,
 961:       });
 962:       
 963:       // Clean up listeners
 964:       unlistenRefs.current.forEach(unlisten => unlisten());
 965:       unlistenRefs.current = [];
 966:       
 967:       // Reset states
 968:       setIsLoading(false);
 969:       hasActiveSessionRef.current = false;
 970:       isListeningRef.current = false;
 971:       setError(null);
 972:       
 973:       // Clear queued prompts
 974:       setQueuedPrompts([]);
 975:       
 976:       // Add a message indicating the session was cancelled
 977:       const cancelMessage: ClaudeStreamMessage = {
 978:         type: "system",
 979:         subtype: "info",
 980:         result: "Session cancelled by user",
 981:         timestamp: new Date().toISOString()
 982:       };
 983:       setMessages(prev => [...prev, cancelMessage]);
 984:     } catch (err) {
 985:       console.error("Failed to cancel execution:", err);
 986:       
 987:       // Even if backend fails, we should update UI to reflect stopped state
 988:       // Add error message but still stop the UI loading state
 989:       const errorMessage: ClaudeStreamMessage = {
 990:         type: "system",
 991:         subtype: "error",
 992:         result: `Failed to cancel execution: ${err instanceof Error ? err.message : 'Unknown error'}. The process may still be running in the background.`,
 993:         timestamp: new Date().toISOString()
 994:       };
 995:       setMessages(prev => [...prev, errorMessage]);
 996:       
 997:       // Clean up listeners anyway
 998:       unlistenRefs.current.forEach(unlisten => unlisten());
 999:       unlistenRefs.current = [];
1000:       
1001:       // Reset states to allow user to continue
1002:       setIsLoading(false);
1003:       hasActiveSessionRef.current = false;
1004:       isListeningRef.current = false;
1005:       setError(null);
1006:     }
1007:   };
1008: 
1009:   const handleFork = (checkpointId: string) => {
1010:     setForkCheckpointId(checkpointId);
1011:     setForkSessionName(`Fork-${new Date().toISOString().slice(0, 10)}`);
1012:     setShowForkDialog(true);
1013:   };
1014: 
1015:   const handleConfirmFork = async () => {
1016:     if (!forkCheckpointId || !forkSessionName.trim() || !effectiveSession) return;
1017:     
1018:     try {
1019:       setIsLoading(true);
1020:       setError(null);
1021:       
1022:       const newSessionId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
1023:       await api.forkFromCheckpoint(
1024:         forkCheckpointId,
1025:         effectiveSession.id,
1026:         effectiveSession.project_id,
1027:         projectPath,
1028:         newSessionId,
1029:         forkSessionName
1030:       );
1031:       
1032:       // Open the new forked session
1033:       // You would need to implement navigation to the new session
1034:       console.log("Forked to new session:", newSessionId);
1035:       
1036:       setShowForkDialog(false);
1037:       setForkCheckpointId(null);
1038:       setForkSessionName("");
1039:     } catch (err) {
1040:       console.error("Failed to fork checkpoint:", err);
1041:       setError("Failed to fork checkpoint");
1042:     } finally {
1043:       setIsLoading(false);
1044:     }
1045:   };
1046: 
1047:   // Handle URL detection from terminal output
1048:   const handleLinkDetected = (url: string) => {
1049:     if (!showPreview && !showPreviewPrompt) {
1050:       setPreviewUrl(url);
1051:       setShowPreviewPrompt(true);
1052:     }
1053:   };
1054: 
1055:   const handleClosePreview = () => {
1056:     setShowPreview(false);
1057:     setIsPreviewMaximized(false);
1058:     // Keep the previewUrl so it can be restored when reopening
1059:   };
1060: 
1061:   const handlePreviewUrlChange = (url: string) => {
1062:     console.log('[ClaudeCodeSession] Preview URL changed to:', url);
1063:     setPreviewUrl(url);
1064:   };
1065: 
1066:   const handleTogglePreviewMaximize = () => {
1067:     setIsPreviewMaximized(!isPreviewMaximized);
1068:     // Reset split position when toggling maximize
1069:     if (isPreviewMaximized) {
1070:       setSplitPosition(50);
1071:     }
1072:   };
1073: 
1074:   // Cleanup event listeners and track mount state
1075:   useEffect(() => {
1076:     isMountedRef.current = true;
1077:     
1078:     return () => {
1079:       console.log('[ClaudeCodeSession] Component unmounting, cleaning up listeners');
1080:       isMountedRef.current = false;
1081:       isListeningRef.current = false;
1082:       
1083:       // Track session completion with engagement metrics
1084:       if (effectiveSession) {
1085:         trackEvent.sessionCompleted();
1086:         
1087:         // Track session engagement
1088:         const sessionDuration = sessionStartTime.current ? Date.now() - sessionStartTime.current : 0;
1089:         const messageCount = messages.filter(m => m.user_message).length;
1090:         const toolsUsed = new Set<string>();
1091:         messages.forEach(msg => {
1092:           if (msg.type === 'assistant' && msg.message?.content) {
1093:             const tools = msg.message.content.filter((c: any) => c.type === 'tool_use');
1094:             tools.forEach((tool: any) => toolsUsed.add(tool.name));
1095:           }
1096:         });
1097:         
1098:         // Calculate engagement score (0-100)
1099:         const engagementScore = Math.min(100, 
1100:           (messageCount * 10) + 
1101:           (toolsUsed.size * 5) + 
1102:           (sessionDuration > 300000 ? 20 : sessionDuration / 15000) // 5+ min session gets 20 points
1103:         );
1104:         
1105:         trackEvent.sessionEngagement({
1106:           session_duration_ms: sessionDuration,
1107:           messages_sent: messageCount,
1108:           tools_used: Array.from(toolsUsed),
1109:           files_modified: 0, // TODO: Track file modifications
1110:           engagement_score: Math.round(engagementScore)
1111:         });
1112:       }
1113:       
1114:       // Clean up listeners
1115:       unlistenRefs.current.forEach(unlisten => unlisten());
1116:       unlistenRefs.current = [];
1117:       
1118:       // Clear checkpoint manager when session ends
1119:       if (effectiveSession) {
1120:         api.clearCheckpointManager(effectiveSession.id).catch(err => {
1121:           console.error("Failed to clear checkpoint manager:", err);
1122:         });
1123:       }
1124:     };
1125:   }, [effectiveSession, projectPath]);
1126: 
1127:   const messagesList = (
1128:     <div
1129:       ref={parentRef}
1130:       className="flex-1 overflow-y-auto relative pb-40"
1131:       style={{
1132:         contain: 'strict',
1133:       }}
1134:     >
1135:       <div
1136:         className="relative w-full max-w-5xl mx-auto px-4 pt-8 pb-4"
1137:         style={{
1138:           height: `${Math.max(rowVirtualizer.getTotalSize(), 100)}px`,
1139:           minHeight: '100px',
1140:         }}
1141:       >
1142:         <AnimatePresence>
1143:           {rowVirtualizer.getVirtualItems().map((virtualItem) => {
1144:             const message = displayableMessages[virtualItem.index];
1145:             return (
1146:               <motion.div
1147:                 key={virtualItem.key}
1148:                 data-index={virtualItem.index}
1149:                 ref={(el) => el && rowVirtualizer.measureElement(el)}
1150:                 initial={{ opacity: 0, y: 20 }}
1151:                 animate={{ opacity: 1, y: 0 }}
1152:                 exit={{ opacity: 0, y: -20 }}
1153:                 transition={{ duration: 0.3 }}
1154:                 className="absolute inset-x-4 pb-4"
1155:                 style={{
1156:                   top: virtualItem.start,
1157:                 }}
1158:               >
1159:                 <StreamMessage 
1160:                   message={message} 
1161:                   streamMessages={messages}
1162:                   onLinkDetected={handleLinkDetected}
1163:                 />
1164:               </motion.div>
1165:             );
1166:           })}
1167:         </AnimatePresence>
1168:       </div>
1169: 
1170:       {/* Loading indicator under the latest message */}
1171:       {isLoading && (
1172:         <motion.div
1173:           initial={{ opacity: 0 }}
1174:           animate={{ opacity: 1 }}
1175:           className="flex items-center justify-center py-4 mb-40"
1176:         >
1177:           <div className="rotating-symbol text-primary" />
1178:         </motion.div>
1179:       )}
1180: 
1181:       {/* Error indicator */}
1182:       {error && (
1183:         <motion.div
1184:           initial={{ opacity: 0 }}
1185:           animate={{ opacity: 1 }}
1186:           className="rounded-lg border border-destructive/50 bg-destructive/10 p-4 text-sm text-destructive mb-40 w-full max-w-5xl mx-auto"
1187:         >
1188:           {error}
1189:         </motion.div>
1190:       )}
1191:     </div>
1192:   );
1193: 
1194:   const projectPathInput = !session && (
1195:     <motion.div
1196:       initial={{ opacity: 0 }}
1197:       animate={{ opacity: 1 }}
1198:       transition={{ delay: 0.1 }}
1199:       className="p-4 border-b border-border flex-shrink-0"
1200:     >
1201:       <Label htmlFor="project-path" className="text-sm font-medium">
1202:         Project Directory
1203:       </Label>
1204:       <div className="flex items-center gap-2 mt-1">
1205:         <Input
1206:           id="project-path"
1207:           value={projectPath}
1208:           onChange={(e) => setProjectPath(e.target.value)}
1209:           placeholder="/path/to/your/project"
1210:           className="flex-1"
1211:           disabled={isLoading}
1212:         />
1213:         <Button
1214:           onClick={handleSelectPath}
1215:           size="icon"
1216:           variant="outline"
1217:           disabled={isLoading}
1218:         >
1219:           <FolderOpen className="h-4 w-4" />
1220:         </Button>
1221:       </div>
1222:     </motion.div>
1223:   );
1224: 
1225:   // If preview is maximized, render only the WebviewPreview in full screen
1226:   if (showPreview && isPreviewMaximized) {
1227:     return (
1228:       <AnimatePresence>
1229:         <motion.div 
1230:           className="fixed inset-0 z-50 bg-background"
1231:           initial={{ opacity: 0 }}
1232:           animate={{ opacity: 1 }}
1233:           exit={{ opacity: 0 }}
1234:           transition={{ duration: 0.2 }}
1235:         >
1236:           <WebviewPreview
1237:             initialUrl={previewUrl}
1238:             onClose={handleClosePreview}
1239:             isMaximized={isPreviewMaximized}
1240:             onToggleMaximize={handleTogglePreviewMaximize}
1241:             onUrlChange={handlePreviewUrlChange}
1242:             className="h-full"
1243:           />
1244:         </motion.div>
1245:       </AnimatePresence>
1246:     );
1247:   }
1248: 
1249:   return (
1250:     <div className={cn("flex flex-col h-full bg-background", className)}>
1251:       <div className="w-full h-full flex flex-col">
1252:         {/* Header */}
1253:         <motion.div
1254:           initial={{ opacity: 0, y: -20 }}
1255:           animate={{ opacity: 1, y: 0 }}
1256:           transition={{ duration: 0.3 }}
1257:           className="flex items-center justify-between p-4 border-b border-border"
1258:         >
1259:           <div className="flex items-center space-x-3">
1260:             <Button
1261:               variant="ghost"
1262:               size="icon"
1263:               onClick={onBack}
1264:               className="h-8 w-8"
1265:             >
1266:               <ArrowLeft className="h-4 w-4" />
1267:             </Button>
1268:             <div className="flex items-center gap-2">
1269:               <Terminal className="h-5 w-5 text-muted-foreground" />
1270:               <div className="flex-1">
1271:                 <h1 className="text-xl font-bold">Claude Code Session</h1>
1272:                 <p className="text-sm text-muted-foreground">
1273:                   {projectPath ? `${projectPath}` : "No project selected"}
1274:                 </p>
1275:               </div>
1276:             </div>
1277:           </div>
1278:           
1279:           <div className="flex items-center gap-2">
1280:             {projectPath && onProjectSettings && (
1281:               <Button
1282:                 variant="outline"
1283:                 size="sm"
1284:                 onClick={() => onProjectSettings(projectPath)}
1285:                 disabled={isLoading}
1286:               >
1287:                 <Settings className="h-4 w-4 mr-2" />
1288:                 Hooks
1289:               </Button>
1290:             )}
1291:             {projectPath && (
1292:               <Button
1293:                 variant="outline"
1294:                 size="sm"
1295:                 onClick={() => setShowSlashCommandsSettings(true)}
1296:                 disabled={isLoading}
1297:               >
1298:                 <Command className="h-4 w-4 mr-2" />
1299:                 Commands
1300:               </Button>
1301:             )}
1302:             <div className="flex items-center gap-2">
1303:               {showSettings && (
1304:                 <CheckpointSettings
1305:                   sessionId={effectiveSession?.id || ''}
1306:                   projectId={effectiveSession?.project_id || ''}
1307:                   projectPath={projectPath}
1308:                 />
1309:               )}
1310:               <TooltipProvider>
1311:                 <Tooltip>
1312:                   <TooltipTrigger asChild>
1313:                     <Button
1314:                       variant="ghost"
1315:                       size="icon"
1316:                       onClick={() => setShowSettings(!showSettings)}
1317:                       className="h-8 w-8"
1318:                     >
1319:                       <Settings className={cn("h-4 w-4", showSettings && "text-primary")} />
1320:                     </Button>
1321:                   </TooltipTrigger>
1322:                   <TooltipContent>
1323:                     <p>Checkpoint Settings</p>
1324:                   </TooltipContent>
1325:                 </Tooltip>
1326:               </TooltipProvider>
1327:               {effectiveSession && (
1328:                 <TooltipProvider>
1329:                   <Tooltip>
1330:                     <TooltipTrigger asChild>
1331:                       <Button
1332:                         variant="ghost"
1333:                         size="icon"
1334:                         onClick={() => setShowTimeline(!showTimeline)}
1335:                         className="h-8 w-8"
1336:                       >
1337:                         <GitBranch className={cn("h-4 w-4", showTimeline && "text-primary")} />
1338:                       </Button>
1339:                     </TooltipTrigger>
1340:                     <TooltipContent>
1341:                       <p>Timeline Navigator</p>
1342:                     </TooltipContent>
1343:                   </Tooltip>
1344:                 </TooltipProvider>
1345:               )}
1346:               {messages.length > 0 && (
1347:                 <Popover
1348:                   trigger={
1349:                     <Button
1350:                       variant="ghost"
1351:                       size="sm"
1352:                       className="flex items-center gap-2"
1353:                     >
1354:                       <Copy className="h-4 w-4" />
1355:                       Copy Output
1356:                       <ChevronDown className="h-3 w-3" />
1357:                     </Button>
1358:                   }
1359:                   content={
1360:                     <div className="w-44 p-1">
1361:                       <Button
1362:                         variant="ghost"
1363:                         size="sm"
1364:                         onClick={handleCopyAsMarkdown}
1365:                         className="w-full justify-start"
1366:                       >
1367:                         Copy as Markdown
1368:                       </Button>
1369:                       <Button
1370:                         variant="ghost"
1371:                         size="sm"
1372:                         onClick={handleCopyAsJsonl}
1373:                         className="w-full justify-start"
1374:                       >
1375:                         Copy as JSONL
1376:                       </Button>
1377:                     </div>
1378:                   }
1379:                   open={copyPopoverOpen}
1380:                   onOpenChange={setCopyPopoverOpen}
1381:                 />
1382:               )}
1383:             </div>
1384:           </div>
1385:         </motion.div>
1386: 
1387:         {/* Main Content Area */}
1388:         <div className={cn(
1389:           "flex-1 overflow-hidden transition-all duration-300",
1390:           showTimeline && "sm:mr-96"
1391:         )}>
1392:           {showPreview ? (
1393:             // Split pane layout when preview is active
1394:             <SplitPane
1395:               left={
1396:                 <div className="h-full flex flex-col">
1397:                   {projectPathInput}
1398:                   {messagesList}
1399:                 </div>
1400:               }
1401:               right={
1402:                 <WebviewPreview
1403:                   initialUrl={previewUrl}
1404:                   onClose={handleClosePreview}
1405:                   isMaximized={isPreviewMaximized}
1406:                   onToggleMaximize={handleTogglePreviewMaximize}
1407:                   onUrlChange={handlePreviewUrlChange}
1408:                 />
1409:               }
1410:               initialSplit={splitPosition}
1411:               onSplitChange={setSplitPosition}
1412:               minLeftWidth={400}
1413:               minRightWidth={400}
1414:               className="h-full"
1415:             />
1416:           ) : (
1417:             // Original layout when no preview
1418:             <div className="h-full flex flex-col max-w-5xl mx-auto">
1419:               {projectPathInput}
1420:               {messagesList}
1421:               
1422:               {isLoading && messages.length === 0 && (
1423:                 <div className="flex items-center justify-center h-full">
1424:                   <div className="flex items-center gap-3">
1425:                     <div className="rotating-symbol text-primary" />
1426:                     <span className="text-sm text-muted-foreground">
1427:                       {session ? "Loading session history..." : "Initializing Claude Code..."}
1428:                     </span>
1429:                   </div>
1430:                 </div>
1431:               )}
1432:             </div>
1433:           )}
1434:         </div>
1435: 
1436:         {/* Floating Prompt Input - Always visible */}
1437:         <ErrorBoundary>
1438:           {/* Queued Prompts Display */}
1439:           <AnimatePresence>
1440:             {queuedPrompts.length > 0 && (
1441:               <motion.div
1442:                 initial={{ opacity: 0, y: 20 }}
1443:                 animate={{ opacity: 1, y: 0 }}
1444:                 exit={{ opacity: 0, y: 20 }}
1445:                 className="fixed bottom-24 left-1/2 -translate-x-1/2 z-30 w-full max-w-3xl px-4"
1446:               >
1447:                 <div className="bg-background/95 backdrop-blur-md border rounded-lg shadow-lg p-3 space-y-2">
1448:                   <div className="flex items-center justify-between">
1449:                     <div className="text-xs font-medium text-muted-foreground mb-1">
1450:                       Queued Prompts ({queuedPrompts.length})
1451:                     </div>
1452:                     <Button variant="ghost" size="icon" onClick={() => setQueuedPromptsCollapsed(prev => !prev)}>
1453:                       {queuedPromptsCollapsed ? <ChevronUp className="h-3 w-3" /> : <ChevronDown className="h-3 w-3" />}
1454:                     </Button>
1455:                   </div>
1456:                   {!queuedPromptsCollapsed && queuedPrompts.map((queuedPrompt, index) => (
1457:                     <motion.div
1458:                       key={queuedPrompt.id}
1459:                       initial={{ opacity: 0, x: -20 }}
1460:                       animate={{ opacity: 1, x: 0 }}
1461:                       exit={{ opacity: 0, x: 20 }}
1462:                       transition={{ delay: index * 0.05 }}
1463:                       className="flex items-start gap-2 bg-muted/50 rounded-md p-2"
1464:                     >
1465:                       <div className="flex-1 min-w-0">
1466:                         <div className="flex items-center gap-2 mb-1">
1467:                           <span className="text-xs font-medium text-muted-foreground">#{index + 1}</span>
1468:                           <span className="text-xs px-1.5 py-0.5 bg-primary/10 text-primary rounded">
1469:                             {queuedPrompt.model === "opus" ? "Opus" : "Sonnet"}
1470:                           </span>
1471:                         </div>
1472:                         <p className="text-sm line-clamp-2 break-words">{queuedPrompt.prompt}</p>
1473:                       </div>
1474:                       <Button
1475:                         variant="ghost"
1476:                         size="icon"
1477:                         className="h-6 w-6 flex-shrink-0"
1478:                         onClick={() => setQueuedPrompts(prev => prev.filter(p => p.id !== queuedPrompt.id))}
1479:                       >
1480:                         <X className="h-3 w-3" />
1481:                       </Button>
1482:                     </motion.div>
1483:                   ))}
1484:                 </div>
1485:               </motion.div>
1486:             )}
1487:           </AnimatePresence>
1488: 
1489:           {/* Navigation Arrows - positioned above prompt bar with spacing */}
1490:           {displayableMessages.length > 5 && (
1491:             <motion.div
1492:               initial={{ opacity: 0, scale: 0.8 }}
1493:               animate={{ opacity: 1, scale: 1 }}
1494:               exit={{ opacity: 0, scale: 0.8 }}
1495:               transition={{ delay: 0.5 }}
1496:               className="fixed bottom-32 right-6 z-50"
1497:             >
1498:               <div className="flex items-center bg-background/95 backdrop-blur-md border rounded-full shadow-lg overflow-hidden">
1499:                 <Button
1500:                   variant="ghost"
1501:                   size="sm"
1502:                   onClick={() => {
1503:                     // Use virtualizer to scroll to the first item
1504:                     if (displayableMessages.length > 0) {
1505:                       // Scroll to top of the container
1506:                       parentRef.current?.scrollTo({
1507:                         top: 0,
1508:                         behavior: 'smooth'
1509:                       });
1510:                       
1511:                       // After smooth scroll completes, trigger a small scroll to ensure rendering
1512:                       setTimeout(() => {
1513:                         if (parentRef.current) {
1514:                           // Scroll down 1px then back to 0 to trigger virtualizer update
1515:                           parentRef.current.scrollTop = 1;
1516:                           requestAnimationFrame(() => {
1517:                             if (parentRef.current) {
1518:                               parentRef.current.scrollTop = 0;
1519:                             }
1520:                           });
1521:                         }
1522:                       }, 500); // Wait for smooth scroll to complete
1523:                     }
1524:                   }}
1525:                   className="px-3 py-2 hover:bg-accent rounded-none"
1526:                   title="Scroll to top"
1527:                 >
1528:                   <ChevronUp className="h-4 w-4" />
1529:                 </Button>
1530:                 <div className="w-px h-4 bg-border" />
1531:                 <Button
1532:                   variant="ghost"
1533:                   size="sm"
1534:                   onClick={() => {
1535:                     // Use virtualizer to scroll to the last item
1536:                     if (displayableMessages.length > 0) {
1537:                       // Scroll to bottom of the container
1538:                       const scrollElement = parentRef.current;
1539:                       if (scrollElement) {
1540:                         scrollElement.scrollTo({
1541:                           top: scrollElement.scrollHeight,
1542:                           behavior: 'smooth'
1543:                         });
1544:                       }
1545:                     }
1546:                   }}
1547:                   className="px-3 py-2 hover:bg-accent rounded-none"
1548:                   title="Scroll to bottom"
1549:                 >
1550:                   <ChevronDown className="h-4 w-4" />
1551:                 </Button>
1552:               </div>
1553:             </motion.div>
1554:           )}
1555: 
1556:           <div className={cn(
1557:             "fixed bottom-0 left-0 right-0 transition-all duration-300 z-50",
1558:             showTimeline && "sm:right-96"
1559:           )}>
1560:             <FloatingPromptInput
1561:               ref={floatingPromptRef}
1562:               onSend={handleSendPrompt}
1563:               onCancel={handleCancelExecution}
1564:               isLoading={isLoading}
1565:               disabled={!projectPath}
1566:               projectPath={projectPath}
1567:             />
1568:           </div>
1569: 
1570:           {/* Token Counter - positioned under the Send button */}
1571:           {totalTokens > 0 && (
1572:             <div className="fixed bottom-0 left-0 right-0 z-30 pointer-events-none">
1573:               <div className="max-w-5xl mx-auto">
1574:                 <div className="flex justify-end px-4 pb-2">
1575:                   <motion.div
1576:                     initial={{ opacity: 0, scale: 0.8 }}
1577:                     animate={{ opacity: 1, scale: 1 }}
1578:                     exit={{ opacity: 0, scale: 0.8 }}
1579:                     className="bg-background/95 backdrop-blur-md border rounded-full px-3 py-1 shadow-lg pointer-events-auto"
1580:                   >
1581:                     <div className="flex items-center gap-1.5 text-xs">
1582:                       <Hash className="h-3 w-3 text-muted-foreground" />
1583:                       <span className="font-mono">{totalTokens.toLocaleString()}</span>
1584:                       <span className="text-muted-foreground">tokens</span>
1585:                     </div>
1586:                   </motion.div>
1587:                 </div>
1588:               </div>
1589:             </div>
1590:           )}
1591:         </ErrorBoundary>
1592: 
1593:         {/* Timeline */}
1594:         <AnimatePresence>
1595:           {showTimeline && effectiveSession && (
1596:             <motion.div
1597:               initial={{ x: "100%" }}
1598:               animate={{ x: 0 }}
1599:               exit={{ x: "100%" }}
1600:               transition={{ type: "spring", damping: 20, stiffness: 300 }}
1601:               className="fixed right-0 top-0 h-full w-full sm:w-96 bg-background border-l border-border shadow-xl z-30 overflow-hidden"
1602:             >
1603:               <div className="h-full flex flex-col">
1604:                 {/* Timeline Header */}
1605:                 <div className="flex items-center justify-between p-4 border-b border-border">
1606:                   <h3 className="text-lg font-semibold">Session Timeline</h3>
1607:                   <Button
1608:                     variant="ghost"
1609:                     size="icon"
1610:                     onClick={() => setShowTimeline(false)}
1611:                     className="h-8 w-8"
1612:                   >
1613:                     <X className="h-4 w-4" />
1614:                   </Button>
1615:                 </div>
1616:                 
1617:                 {/* Timeline Content */}
1618:                 <div className="flex-1 overflow-y-auto p-4">
1619:                   <TimelineNavigator
1620:                     sessionId={effectiveSession.id}
1621:                     projectId={effectiveSession.project_id}
1622:                     projectPath={projectPath}
1623:                     currentMessageIndex={messages.length - 1}
1624:                     onCheckpointSelect={handleCheckpointSelect}
1625:                     onFork={handleFork}
1626:                     onCheckpointCreated={handleCheckpointCreated}
1627:                     refreshVersion={timelineVersion}
1628:                   />
1629:                 </div>
1630:               </div>
1631:             </motion.div>
1632:           )}
1633:         </AnimatePresence>
1634:       </div>
1635: 
1636:       {/* Fork Dialog */}
1637:       <Dialog open={showForkDialog} onOpenChange={setShowForkDialog}>
1638:         <DialogContent>
1639:           <DialogHeader>
1640:             <DialogTitle>Fork Session</DialogTitle>
1641:             <DialogDescription>
1642:               Create a new session branch from the selected checkpoint.
1643:             </DialogDescription>
1644:           </DialogHeader>
1645:           
1646:           <div className="space-y-4 py-4">
1647:             <div className="space-y-2">
1648:               <Label htmlFor="fork-name">New Session Name</Label>
1649:               <Input
1650:                 id="fork-name"
1651:                 placeholder="e.g., Alternative approach"
1652:                 value={forkSessionName}
1653:                 onChange={(e) => setForkSessionName(e.target.value)}
1654:                 onKeyPress={(e) => {
1655:                   if (e.key === "Enter" && !isLoading) {
1656:                     handleConfirmFork();
1657:                   }
1658:                 }}
1659:               />
1660:             </div>
1661:           </div>
1662:           
1663:           <DialogFooter>
1664:             <Button
1665:               variant="outline"
1666:               onClick={() => setShowForkDialog(false)}
1667:               disabled={isLoading}
1668:             >
1669:               Cancel
1670:             </Button>
1671:             <Button
1672:               onClick={handleConfirmFork}
1673:               disabled={isLoading || !forkSessionName.trim()}
1674:             >
1675:               Create Fork
1676:             </Button>
1677:           </DialogFooter>
1678:         </DialogContent>
1679:       </Dialog>
1680: 
1681:       {/* Settings Dialog */}
1682:       {showSettings && effectiveSession && (
1683:         <Dialog open={showSettings} onOpenChange={setShowSettings}>
1684:           <DialogContent className="max-w-2xl">
1685:             <CheckpointSettings
1686:               sessionId={effectiveSession.id}
1687:               projectId={effectiveSession.project_id}
1688:               projectPath={projectPath}
1689:               onClose={() => setShowSettings(false)}
1690:             />
1691:           </DialogContent>
1692:         </Dialog>
1693:       )}
1694: 
1695:       {/* Slash Commands Settings Dialog */}
1696:       {showSlashCommandsSettings && (
1697:         <Dialog open={showSlashCommandsSettings} onOpenChange={setShowSlashCommandsSettings}>
1698:           <DialogContent className="max-w-4xl max-h-[80vh] overflow-hidden">
1699:             <DialogHeader>
1700:               <DialogTitle>Slash Commands</DialogTitle>
1701:               <DialogDescription>
1702:                 Manage project-specific slash commands for {projectPath}
1703:               </DialogDescription>
1704:             </DialogHeader>
1705:             <div className="flex-1 overflow-y-auto">
1706:               <SlashCommandsManager projectPath={projectPath} />
1707:             </div>
1708:           </DialogContent>
1709:         </Dialog>
1710:       )}
1711:     </div>
1712:   );
1713: };
````

## File: src/components/ClaudeFileEditor.tsx
````typescript
  1: import React, { useState, useEffect } from "react";
  2: import MDEditor from "@uiw/react-md-editor";
  3: import { motion } from "framer-motion";
  4: import { ArrowLeft, Save, Loader2 } from "lucide-react";
  5: import { Button } from "@/components/ui/button";
  6: import { Toast, ToastContainer } from "@/components/ui/toast";
  7: import { api, type ClaudeMdFile } from "@/lib/api";
  8: import { cn } from "@/lib/utils";
  9: 
 10: interface ClaudeFileEditorProps {
 11:   /**
 12:    * The CLAUDE.md file to edit
 13:    */
 14:   file: ClaudeMdFile;
 15:   /**
 16:    * Callback to go back to the previous view
 17:    */
 18:   onBack: () => void;
 19:   /**
 20:    * Optional className for styling
 21:    */
 22:   className?: string;
 23: }
 24: 
 25: /**
 26:  * ClaudeFileEditor component for editing project-specific CLAUDE.md files
 27:  * 
 28:  * @example
 29:  * <ClaudeFileEditor 
 30:  *   file={claudeMdFile} 
 31:  *   onBack={() => setEditingFile(null)} 
 32:  * />
 33:  */
 34: export const ClaudeFileEditor: React.FC<ClaudeFileEditorProps> = ({
 35:   file,
 36:   onBack,
 37:   className,
 38: }) => {
 39:   const [content, setContent] = useState<string>("");
 40:   const [originalContent, setOriginalContent] = useState<string>("");
 41:   const [loading, setLoading] = useState(true);
 42:   const [saving, setSaving] = useState(false);
 43:   const [error, setError] = useState<string | null>(null);
 44:   const [toast, setToast] = useState<{ message: string; type: "success" | "error" } | null>(null);
 45:   
 46:   const hasChanges = content !== originalContent;
 47:   
 48:   // Load the file content on mount
 49:   useEffect(() => {
 50:     loadFileContent();
 51:   }, [file.absolute_path]);
 52:   
 53:   const loadFileContent = async () => {
 54:     try {
 55:       setLoading(true);
 56:       setError(null);
 57:       const fileContent = await api.readClaudeMdFile(file.absolute_path);
 58:       setContent(fileContent);
 59:       setOriginalContent(fileContent);
 60:     } catch (err) {
 61:       console.error("Failed to load file:", err);
 62:       setError("Failed to load CLAUDE.md file");
 63:     } finally {
 64:       setLoading(false);
 65:     }
 66:   };
 67:   
 68:   const handleSave = async () => {
 69:     try {
 70:       setSaving(true);
 71:       setError(null);
 72:       setToast(null);
 73:       await api.saveClaudeMdFile(file.absolute_path, content);
 74:       setOriginalContent(content);
 75:       setToast({ message: "File saved successfully", type: "success" });
 76:     } catch (err) {
 77:       console.error("Failed to save file:", err);
 78:       setError("Failed to save CLAUDE.md file");
 79:       setToast({ message: "Failed to save file", type: "error" });
 80:     } finally {
 81:       setSaving(false);
 82:     }
 83:   };
 84:   
 85:   const handleBack = () => {
 86:     if (hasChanges) {
 87:       const confirmLeave = window.confirm(
 88:         "You have unsaved changes. Are you sure you want to leave?"
 89:       );
 90:       if (!confirmLeave) return;
 91:     }
 92:     onBack();
 93:   };
 94:   
 95:   return (
 96:     <div className={cn("flex flex-col h-full bg-background", className)}>
 97:       <div className="w-full max-w-5xl mx-auto flex flex-col h-full">
 98:         {/* Header */}
 99:         <motion.div
100:           initial={{ opacity: 0, y: -20 }}
101:           animate={{ opacity: 1, y: 0 }}
102:           transition={{ duration: 0.3 }}
103:           className="flex items-center justify-between p-4 border-b border-border"
104:         >
105:           <div className="flex items-center space-x-3">
106:             <Button
107:               variant="ghost"
108:               size="icon"
109:               onClick={handleBack}
110:               className="h-8 w-8"
111:             >
112:               <ArrowLeft className="h-4 w-4" />
113:             </Button>
114:             <div className="min-w-0 flex-1">
115:               <h2 className="text-lg font-semibold truncate">{file.relative_path}</h2>
116:               <p className="text-xs text-muted-foreground">
117:                 Edit project-specific Claude Code system prompt
118:               </p>
119:             </div>
120:           </div>
121:           
122:           <Button
123:             onClick={handleSave}
124:             disabled={!hasChanges || saving}
125:             size="sm"
126:           >
127:             {saving ? (
128:               <Loader2 className="mr-2 h-4 w-4 animate-spin" />
129:             ) : (
130:               <Save className="mr-2 h-4 w-4" />
131:             )}
132:             {saving ? "Saving..." : "Save"}
133:           </Button>
134:         </motion.div>
135:         
136:         {/* Error display */}
137:         {error && (
138:           <motion.div
139:             initial={{ opacity: 0 }}
140:             animate={{ opacity: 1 }}
141:             className="mx-4 mt-4 rounded-lg border border-destructive/50 bg-destructive/10 p-3 text-xs text-destructive"
142:           >
143:             {error}
144:           </motion.div>
145:         )}
146:         
147:         {/* Editor */}
148:         <div className="flex-1 p-4 overflow-hidden">
149:           {loading ? (
150:             <div className="flex items-center justify-center h-full">
151:               <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
152:             </div>
153:           ) : (
154:             <div className="h-full rounded-lg border border-border overflow-hidden shadow-sm" data-color-mode="dark">
155:               <MDEditor
156:                 value={content}
157:                 onChange={(val) => setContent(val || "")}
158:                 preview="edit"
159:                 height="100%"
160:                 visibleDragbar={false}
161:               />
162:             </div>
163:           )}
164:         </div>
165:       </div>
166:       
167:       {/* Toast Notification */}
168:       <ToastContainer>
169:         {toast && (
170:           <Toast
171:             message={toast.message}
172:             type={toast.type}
173:             onDismiss={() => setToast(null)}
174:           />
175:         )}
176:       </ToastContainer>
177:     </div>
178:   );
179: };
````

## File: src/components/ClaudeMemoriesDropdown.tsx
````typescript
  1: import React, { useState, useEffect } from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import { ChevronDown, Edit2, FileText, Loader2 } from "lucide-react";
  4: import { Button } from "@/components/ui/button";
  5: import { Card } from "@/components/ui/card";
  6: import { cn } from "@/lib/utils";
  7: import { api, type ClaudeMdFile } from "@/lib/api";
  8: import { formatUnixTimestamp } from "@/lib/date-utils";
  9: 
 10: interface ClaudeMemoriesDropdownProps {
 11:   /**
 12:    * The project path to search for CLAUDE.md files
 13:    */
 14:   projectPath: string;
 15:   /**
 16:    * Callback when an edit button is clicked
 17:    */
 18:   onEditFile: (file: ClaudeMdFile) => void;
 19:   /**
 20:    * Optional className for styling
 21:    */
 22:   className?: string;
 23: }
 24: 
 25: /**
 26:  * ClaudeMemoriesDropdown component - Shows all CLAUDE.md files in a project
 27:  * 
 28:  * @example
 29:  * <ClaudeMemoriesDropdown
 30:  *   projectPath="/Users/example/project"
 31:  *   onEditFile={(file) => console.log('Edit file:', file)}
 32:  * />
 33:  */
 34: export const ClaudeMemoriesDropdown: React.FC<ClaudeMemoriesDropdownProps> = ({
 35:   projectPath,
 36:   onEditFile,
 37:   className,
 38: }) => {
 39:   const [isOpen, setIsOpen] = useState(false);
 40:   const [files, setFiles] = useState<ClaudeMdFile[]>([]);
 41:   const [loading, setLoading] = useState(false);
 42:   const [error, setError] = useState<string | null>(null);
 43:   
 44:   // Load CLAUDE.md files when dropdown opens
 45:   useEffect(() => {
 46:     if (isOpen && files.length === 0) {
 47:       loadClaudeMdFiles();
 48:     }
 49:   }, [isOpen]);
 50:   
 51:   const loadClaudeMdFiles = async () => {
 52:     try {
 53:       setLoading(true);
 54:       setError(null);
 55:       const foundFiles = await api.findClaudeMdFiles(projectPath);
 56:       setFiles(foundFiles);
 57:     } catch (err) {
 58:       console.error("Failed to load CLAUDE.md files:", err);
 59:       setError("Failed to load CLAUDE.md files");
 60:     } finally {
 61:       setLoading(false);
 62:     }
 63:   };
 64:   
 65:   const formatFileSize = (bytes: number): string => {
 66:     if (bytes < 1024) return `${bytes} B`;
 67:     if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
 68:     return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
 69:   };
 70:   
 71:   return (
 72:     <div className={cn("w-full", className)}>
 73:       <Card className="overflow-hidden">
 74:         {/* Dropdown Header */}
 75:         <button
 76:           onClick={() => setIsOpen(!isOpen)}
 77:           className="w-full flex items-center justify-between p-3 hover:bg-accent/50 transition-colors"
 78:         >
 79:           <div className="flex items-center space-x-2">
 80:             <FileText className="h-4 w-4 text-muted-foreground" />
 81:             <span className="text-sm font-medium">CLAUDE.md Memories</span>
 82:             {files.length > 0 && !loading && (
 83:               <span className="text-xs text-muted-foreground">({files.length})</span>
 84:             )}
 85:           </div>
 86:           <motion.div
 87:             animate={{ rotate: isOpen ? 180 : 0 }}
 88:             transition={{ duration: 0.2 }}
 89:           >
 90:             <ChevronDown className="h-4 w-4 text-muted-foreground" />
 91:           </motion.div>
 92:         </button>
 93:         
 94:         {/* Dropdown Content */}
 95:         <AnimatePresence>
 96:           {isOpen && (
 97:             <motion.div
 98:               initial={{ height: 0 }}
 99:               animate={{ height: "auto" }}
100:               exit={{ height: 0 }}
101:               transition={{ duration: 0.2 }}
102:               className="overflow-hidden"
103:             >
104:               <div className="border-t border-border">
105:                 {loading ? (
106:                   <div className="p-4 flex items-center justify-center">
107:                     <Loader2 className="h-5 w-5 animate-spin text-muted-foreground" />
108:                   </div>
109:                 ) : error ? (
110:                   <div className="p-3 text-xs text-destructive">{error}</div>
111:                 ) : files.length === 0 ? (
112:                   <div className="p-3 text-xs text-muted-foreground text-center">
113:                     No CLAUDE.md files found in this project
114:                   </div>
115:                 ) : (
116:                   <div className="max-h-64 overflow-y-auto">
117:                     {files.map((file, index) => (
118:                       <motion.div
119:                         key={file.absolute_path}
120:                         initial={{ opacity: 0, x: -10 }}
121:                         animate={{ opacity: 1, x: 0 }}
122:                         transition={{ delay: index * 0.05 }}
123:                         className="flex items-center justify-between p-3 hover:bg-accent/50 transition-colors border-b border-border last:border-b-0"
124:                       >
125:                         <div className="flex-1 min-w-0 mr-2">
126:                           <p className="text-xs font-mono truncate">{file.relative_path}</p>
127:                           <div className="flex items-center space-x-3 mt-1">
128:                             <span className="text-xs text-muted-foreground">
129:                               {formatFileSize(file.size)}
130:                             </span>
131:                             <span className="text-xs text-muted-foreground">
132:                               Modified {formatUnixTimestamp(file.modified)}
133:                             </span>
134:                           </div>
135:                         </div>
136:                         <Button
137:                           variant="ghost"
138:                           size="icon"
139:                           className="h-7 w-7 flex-shrink-0"
140:                           onClick={(e) => {
141:                             e.stopPropagation();
142:                             onEditFile(file);
143:                           }}
144:                         >
145:                           <Edit2 className="h-3 w-3" />
146:                         </Button>
147:                       </motion.div>
148:                     ))}
149:                   </div>
150:                 )}
151:               </div>
152:             </motion.div>
153:           )}
154:         </AnimatePresence>
155:       </Card>
156:     </div>
157:   );
158: };
````

## File: src/components/ClaudeVersionSelector.tsx
````typescript
  1: import React, { useState, useEffect } from "react";
  2: import { Button } from "@/components/ui/button";
  3: import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
  4: import { Badge } from "@/components/ui/badge";
  5: import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
  6: import { Label } from "@/components/ui/label";
  7: import { api, type ClaudeInstallation } from "@/lib/api";
  8: import { cn } from "@/lib/utils";
  9: import { CheckCircle, HardDrive, Settings } from "lucide-react";
 10: 
 11: interface ClaudeVersionSelectorProps {
 12:   /**
 13:    * Currently selected installation path
 14:    */
 15:   selectedPath?: string | null;
 16:   /**
 17:    * Callback when an installation is selected
 18:    */
 19:   onSelect: (installation: ClaudeInstallation) => void;
 20:   /**
 21:    * Optional className for styling
 22:    */
 23:   className?: string;
 24:   /**
 25:    * Whether to show the save button
 26:    */
 27:   showSaveButton?: boolean;
 28:   /**
 29:    * Callback when save is clicked
 30:    */
 31:   onSave?: () => void;
 32:   /**
 33:    * Whether save is in progress
 34:    */
 35:   isSaving?: boolean;
 36: }
 37: 
 38: /**
 39:  * ClaudeVersionSelector component for selecting Claude Code installations
 40:  * Supports system installations and user preferences
 41:  * 
 42:  * @example
 43:  * <ClaudeVersionSelector
 44:  *   selectedPath={currentPath}
 45:  *   onSelect={(installation) => setSelectedInstallation(installation)}
 46:  * />
 47:  */
 48: export const ClaudeVersionSelector: React.FC<ClaudeVersionSelectorProps> = ({
 49:   selectedPath,
 50:   onSelect,
 51:   className,
 52:   showSaveButton = false,
 53:   onSave,
 54:   isSaving = false,
 55: }) => {
 56:   const [installations, setInstallations] = useState<ClaudeInstallation[]>([]);
 57:   const [loading, setLoading] = useState(true);
 58:   const [error, setError] = useState<string | null>(null);
 59:   const [selectedInstallation, setSelectedInstallation] = useState<ClaudeInstallation | null>(null);
 60: 
 61:   useEffect(() => {
 62:     loadInstallations();
 63:   }, []);
 64: 
 65:   useEffect(() => {
 66:     // Update selected installation when selectedPath changes
 67:     if (selectedPath && installations.length > 0) {
 68:       const found = installations.find(i => i.path === selectedPath);
 69:       if (found) {
 70:         setSelectedInstallation(found);
 71:       }
 72:     }
 73:   }, [selectedPath, installations]);
 74: 
 75:   const loadInstallations = async () => {
 76:     try {
 77:       setLoading(true);
 78:       setError(null);
 79:       const foundInstallations = await api.listClaudeInstallations();
 80:       setInstallations(foundInstallations);
 81:       
 82:       // If we have a selected path, find and select it
 83:       if (selectedPath) {
 84:         const found = foundInstallations.find(i => i.path === selectedPath);
 85:         if (found) {
 86:           setSelectedInstallation(found);
 87:         }
 88:       } else if (foundInstallations.length > 0) {
 89:         // Auto-select the first (best) installation
 90:         setSelectedInstallation(foundInstallations[0]);
 91:         onSelect(foundInstallations[0]);
 92:       }
 93:     } catch (err) {
 94:       console.error("Failed to load Claude installations:", err);
 95:       setError(err instanceof Error ? err.message : "Failed to load Claude installations");
 96:     } finally {
 97:       setLoading(false);
 98:     }
 99:   };
100: 
101:   const handleInstallationChange = (installationPath: string) => {
102:     const installation = installations.find(i => i.path === installationPath);
103:     if (installation) {
104:       setSelectedInstallation(installation);
105:       onSelect(installation);
106:     }
107:   };
108: 
109:   const getInstallationIcon = (installation: ClaudeInstallation) => {
110:     switch (installation.installation_type) {
111:       case "System":
112:         return <HardDrive className="h-4 w-4" />;
113:       case "Custom":
114:         return <Settings className="h-4 w-4" />;
115:       default:
116:         return <HardDrive className="h-4 w-4" />;
117:     }
118:   };
119: 
120:   const getInstallationTypeColor = (installation: ClaudeInstallation) => {
121:     switch (installation.installation_type) {
122:       case "System":
123:         return "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300";
124:       case "Custom":
125:         return "bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-300";
126:       default:
127:         return "bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-300";
128:     }
129:   };
130: 
131:   if (loading) {
132:     return (
133:       <Card className={className}>
134:         <CardHeader>
135:           <CardTitle>Claude Code Installation</CardTitle>
136:           <CardDescription>Loading available installations...</CardDescription>
137:         </CardHeader>
138:         <CardContent>
139:           <div className="flex items-center justify-center py-4">
140:             <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
141:           </div>
142:         </CardContent>
143:       </Card>
144:     );
145:   }
146: 
147:   if (error) {
148:     return (
149:       <Card className={className}>
150:         <CardHeader>
151:           <CardTitle>Claude Code Installation</CardTitle>
152:           <CardDescription>Error loading installations</CardDescription>
153:         </CardHeader>
154:         <CardContent>
155:           <div className="text-sm text-destructive mb-4">{error}</div>
156:           <Button onClick={loadInstallations} variant="outline" size="sm">
157:             Retry
158:           </Button>
159:         </CardContent>
160:       </Card>
161:     );
162:   }
163: 
164:   const systemInstallations = installations.filter(i => i.installation_type === "System");
165:   const customInstallations = installations.filter(i => i.installation_type === "Custom");
166: 
167:   return (
168:     <Card className={className}>
169:       <CardHeader>
170:         <CardTitle className="flex items-center gap-2">
171:           <CheckCircle className="h-5 w-5" />
172:           Claude Code Installation
173:         </CardTitle>
174:         <CardDescription>
175:           Choose your preferred Claude Code installation.
176:         </CardDescription>
177:       </CardHeader>
178:       <CardContent className="space-y-6">
179:         {/* Available Installations */}
180:         <div className="space-y-3">
181:           <Label className="text-sm font-medium">Available Installations</Label>
182:           <Select value={selectedInstallation?.path || ""} onValueChange={handleInstallationChange}>
183:             <SelectTrigger>
184:               <SelectValue placeholder="Select Claude installation">
185:                 {selectedInstallation && (
186:                   <div className="flex items-center gap-2">
187:                     {getInstallationIcon(selectedInstallation)}
188:                     <span className="truncate">{selectedInstallation.path}</span>
189:                     <Badge variant="secondary" className={cn("text-xs", getInstallationTypeColor(selectedInstallation))}>
190:                       {selectedInstallation.installation_type}
191:                     </Badge>
192:                   </div>
193:                 )}
194:               </SelectValue>
195:             </SelectTrigger>
196:             <SelectContent>
197:               {systemInstallations.length > 0 && (
198:                 <>
199:                   <div className="px-2 py-1.5 text-xs font-semibold text-muted-foreground">System Installations</div>
200:                   {systemInstallations.map((installation) => (
201:                     <SelectItem key={installation.path} value={installation.path}>
202:                       <div className="flex items-center gap-2 w-full">
203:                         {getInstallationIcon(installation)}
204:                         <div className="flex-1 min-w-0">
205:                           <div className="font-medium truncate">{installation.path}</div>
206:                           <div className="text-xs text-muted-foreground">
207:                             {installation.version || "Version unknown"} • {installation.source}
208:                           </div>
209:                         </div>
210:                         <Badge variant="outline" className="text-xs">
211:                           System
212:                         </Badge>
213:                       </div>
214:                     </SelectItem>
215:                   ))}
216:                 </>
217:               )}
218: 
219:               {customInstallations.length > 0 && (
220:                 <>
221:                   <div className="px-2 py-1.5 text-xs font-semibold text-muted-foreground">Custom Installations</div>
222:                   {customInstallations.map((installation) => (
223:                     <SelectItem key={installation.path} value={installation.path}>
224:                       <div className="flex items-center gap-2 w-full">
225:                         {getInstallationIcon(installation)}
226:                         <div className="flex-1 min-w-0">
227:                           <div className="font-medium truncate">{installation.path}</div>
228:                           <div className="text-xs text-muted-foreground">
229:                             {installation.version || "Version unknown"} • {installation.source}
230:                           </div>
231:                         </div>
232:                         <Badge variant="outline" className="text-xs">
233:                           Custom
234:                         </Badge>
235:                       </div>
236:                     </SelectItem>
237:                   ))}
238:                 </>
239:               )}
240:             </SelectContent>
241:           </Select>
242:         </div>
243: 
244:         {/* Installation Details */}
245:         {selectedInstallation && (
246:           <div className="p-3 bg-muted rounded-lg space-y-2">
247:             <div className="flex items-center justify-between">
248:               <span className="text-sm font-medium">Selected Installation</span>
249:               <Badge className={cn("text-xs", getInstallationTypeColor(selectedInstallation))}>
250:                 {selectedInstallation.installation_type}
251:               </Badge>
252:             </div>
253:             <div className="text-sm text-muted-foreground">
254:               <div><strong>Path:</strong> {selectedInstallation.path}</div>
255:               <div><strong>Source:</strong> {selectedInstallation.source}</div>
256:               {selectedInstallation.version && (
257:                 <div><strong>Version:</strong> {selectedInstallation.version}</div>
258:               )}
259:             </div>
260:           </div>
261:         )}
262: 
263:         {/* Save Button */}
264:         {showSaveButton && (
265:           <Button 
266:             onClick={onSave} 
267:             disabled={isSaving || !selectedInstallation}
268:             className="w-full"
269:           >
270:             {isSaving ? "Saving..." : "Save Selection"}
271:           </Button>
272:         )}
273:       </CardContent>
274:     </Card>
275:   );
276: };
````

## File: src/components/CreateAgent.tsx
````typescript
  1: import React, { useState } from "react";
  2: import { motion } from "framer-motion";
  3: import { ArrowLeft, Save, Loader2, ChevronDown } from "lucide-react";
  4: import { Button } from "@/components/ui/button";
  5: import { Input } from "@/components/ui/input";
  6: import { Label } from "@/components/ui/label";
  7: import { Toast, ToastContainer } from "@/components/ui/toast";
  8: import { api, type Agent } from "@/lib/api";
  9: import { cn } from "@/lib/utils";
 10: import MDEditor from "@uiw/react-md-editor";
 11: import { type AgentIconName } from "./CCAgents";
 12: import { IconPicker, ICON_MAP } from "./IconPicker";
 13: 
 14: 
 15: interface CreateAgentProps {
 16:   /**
 17:    * Optional agent to edit (if provided, component is in edit mode)
 18:    */
 19:   agent?: Agent;
 20:   /**
 21:    * Callback to go back to the agents list
 22:    */
 23:   onBack: () => void;
 24:   /**
 25:    * Callback when agent is created/updated
 26:    */
 27:   onAgentCreated: () => void;
 28:   /**
 29:    * Optional className for styling
 30:    */
 31:   className?: string;
 32: }
 33: 
 34: /**
 35:  * CreateAgent component for creating or editing a CC agent
 36:  * 
 37:  * @example
 38:  * <CreateAgent onBack={() => setView('list')} onAgentCreated={handleCreated} />
 39:  */
 40: export const CreateAgent: React.FC<CreateAgentProps> = ({
 41:   agent,
 42:   onBack,
 43:   onAgentCreated,
 44:   className,
 45: }) => {
 46:   const [name, setName] = useState(agent?.name || "");
 47:   const [selectedIcon, setSelectedIcon] = useState<AgentIconName>((agent?.icon as AgentIconName) || "bot");
 48:   const [systemPrompt, setSystemPrompt] = useState(agent?.system_prompt || "");
 49:   const [defaultTask, setDefaultTask] = useState(agent?.default_task || "");
 50:   const [model, setModel] = useState(agent?.model || "sonnet");
 51:   const [saving, setSaving] = useState(false);
 52:   const [error, setError] = useState<string | null>(null);
 53:   const [toast, setToast] = useState<{ message: string; type: "success" | "error" } | null>(null);
 54:   const [showIconPicker, setShowIconPicker] = useState(false);
 55: 
 56:   const isEditMode = !!agent;
 57: 
 58:   const handleSave = async () => {
 59:     if (!name.trim()) {
 60:       setError("Agent name is required");
 61:       return;
 62:     }
 63: 
 64:     if (!systemPrompt.trim()) {
 65:       setError("System prompt is required");
 66:       return;
 67:     }
 68: 
 69:     try {
 70:       setSaving(true);
 71:       setError(null);
 72:       
 73:       if (isEditMode && agent.id) {
 74:         await api.updateAgent(
 75:           agent.id, 
 76:           name, 
 77:           selectedIcon, 
 78:           systemPrompt, 
 79:           defaultTask || undefined, 
 80:           model
 81:         );
 82:       } else {
 83:         await api.createAgent(
 84:           name, 
 85:           selectedIcon, 
 86:           systemPrompt, 
 87:           defaultTask || undefined, 
 88:           model
 89:         );
 90:       }
 91:       
 92:       onAgentCreated();
 93:     } catch (err) {
 94:       console.error("Failed to save agent:", err);
 95:       setError(isEditMode ? "Failed to update agent" : "Failed to create agent");
 96:       setToast({ 
 97:         message: isEditMode ? "Failed to update agent" : "Failed to create agent", 
 98:         type: "error" 
 99:       });
100:     } finally {
101:       setSaving(false);
102:     }
103:   };
104: 
105:   const handleBack = () => {
106:     if ((name !== (agent?.name || "") || 
107:          selectedIcon !== (agent?.icon || "bot") || 
108:          systemPrompt !== (agent?.system_prompt || "") ||
109:          defaultTask !== (agent?.default_task || "") ||
110:          model !== (agent?.model || "sonnet")) && 
111:         !confirm("You have unsaved changes. Are you sure you want to leave?")) {
112:       return;
113:     }
114:     onBack();
115:   };
116: 
117:   return (
118:     <div className={cn("flex flex-col h-full bg-background", className)}>
119:       <div className="w-full max-w-5xl mx-auto flex flex-col h-full">
120:         {/* Header */}
121:         <motion.div
122:           initial={{ opacity: 0, y: -20 }}
123:           animate={{ opacity: 1, y: 0 }}
124:           transition={{ duration: 0.3 }}
125:           className="flex items-center justify-between p-4 border-b border-border"
126:         >
127:           <div className="flex items-center space-x-3">
128:             <Button
129:               variant="ghost"
130:               size="icon"
131:               onClick={handleBack}
132:               className="h-8 w-8"
133:             >
134:               <ArrowLeft className="h-4 w-4" />
135:             </Button>
136:             <div>
137:               <h2 className="text-lg font-semibold">
138:                 {isEditMode ? "Edit CC Agent" : "Create CC Agent"}
139:               </h2>
140:               <p className="text-xs text-muted-foreground">
141:                 {isEditMode ? "Update your Claude Code agent" : "Create a new Claude Code agent"}
142:               </p>
143:             </div>
144:           </div>
145:           
146:           <Button
147:             onClick={handleSave}
148:             disabled={saving || !name.trim() || !systemPrompt.trim()}
149:             size="sm"
150:           >
151:             {saving ? (
152:               <Loader2 className="mr-2 h-4 w-4 animate-spin" />
153:             ) : (
154:               <Save className="mr-2 h-4 w-4" />
155:             )}
156:             {saving ? "Saving..." : "Save"}
157:           </Button>
158:         </motion.div>
159:         
160:         {/* Error display */}
161:         {error && (
162:           <motion.div
163:             initial={{ opacity: 0 }}
164:             animate={{ opacity: 1 }}
165:             className="mx-4 mt-4 rounded-lg border border-destructive/50 bg-destructive/10 p-3 text-xs text-destructive"
166:           >
167:             {error}
168:           </motion.div>
169:         )}
170:         
171:         {/* Form */}
172:         <div className="flex-1 overflow-y-auto px-4 py-6">
173:           <motion.div
174:             initial={{ opacity: 0, y: 20 }}
175:             animate={{ opacity: 1, y: 0 }}
176:             transition={{ duration: 0.3, delay: 0.1 }}
177:             className="space-y-6"
178:           >
179:                 {/* Basic Information */}
180:                 <div className="space-y-4">
181:                   <div>
182:                     <h3 className="text-sm font-medium mb-4">Basic Information</h3>
183:                   </div>
184:               
185:               {/* Name and Icon */}
186:               <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
187:                 <div className="space-y-2">
188:                   <Label htmlFor="name">Agent Name</Label>
189:                   <Input
190:                     id="name"
191:                     value={name}
192:                     onChange={(e) => setName(e.target.value)}
193:                     placeholder="e.g., Code Assistant"
194:                     required
195:                   />
196:                 </div>
197:                 
198:                 <div className="space-y-2">
199:                   <Label>Agent Icon</Label>
200:                   <div
201:                     onClick={() => setShowIconPicker(true)}
202:                     className="h-10 px-3 py-2 bg-background border border-input rounded-md cursor-pointer hover:bg-accent hover:text-accent-foreground transition-colors flex items-center justify-between"
203:                   >
204:                     <div className="flex items-center gap-2">
205:                       {(() => {
206:                         const Icon = ICON_MAP[selectedIcon] || ICON_MAP.bot;
207:                         return (
208:                           <>
209:                             <Icon className="h-4 w-4" />
210:                             <span className="text-sm">{selectedIcon}</span>
211:                           </>
212:                         );
213:                       })()}
214:                     </div>
215:                     <ChevronDown className="h-4 w-4 text-muted-foreground" />
216:                   </div>
217:                 </div>
218:               </div>
219: 
220:               {/* Model Selection */}
221:               <div className="space-y-2">
222:                 <Label>Model</Label>
223:                 <div className="flex flex-col sm:flex-row gap-3">
224:                   <button
225:                     type="button"
226:                     onClick={() => setModel("sonnet")}
227:                     className={cn(
228:                       "flex-1 px-4 py-2.5 rounded-full border-2 font-medium transition-all",
229:                       "hover:scale-[1.02] active:scale-[0.98]",
230:                       model === "sonnet" 
231:                         ? "border-primary bg-primary text-primary-foreground shadow-lg" 
232:                         : "border-muted-foreground/30 hover:border-muted-foreground/50"
233:                     )}
234:                   >
235:                     <div className="flex items-center justify-center gap-2.5">
236:                       <div className={cn(
237:                         "w-4 h-4 rounded-full border-2 flex items-center justify-center flex-shrink-0",
238:                         model === "sonnet" ? "border-primary-foreground" : "border-current"
239:                       )}>
240:                         {model === "sonnet" && (
241:                           <div className="w-2 h-2 rounded-full bg-primary-foreground" />
242:                         )}
243:                       </div>
244:                       <div className="text-left">
245:                         <div className="text-sm font-semibold">Claude 4 Sonnet</div>
246:                         <div className="text-xs opacity-80">Faster, efficient for most tasks</div>
247:                       </div>
248:                     </div>
249:                   </button>
250:                   
251:                   <button
252:                     type="button"
253:                     onClick={() => setModel("opus")}
254:                     className={cn(
255:                       "flex-1 px-4 py-2.5 rounded-full border-2 font-medium transition-all",
256:                       "hover:scale-[1.02] active:scale-[0.98]",
257:                       model === "opus" 
258:                         ? "border-primary bg-primary text-primary-foreground shadow-lg" 
259:                         : "border-muted-foreground/30 hover:border-muted-foreground/50"
260:                     )}
261:                   >
262:                     <div className="flex items-center justify-center gap-2.5">
263:                       <div className={cn(
264:                         "w-4 h-4 rounded-full border-2 flex items-center justify-center flex-shrink-0",
265:                         model === "opus" ? "border-primary-foreground" : "border-current"
266:                       )}>
267:                         {model === "opus" && (
268:                           <div className="w-2 h-2 rounded-full bg-primary-foreground" />
269:                         )}
270:                       </div>
271:                       <div className="text-left">
272:                         <div className="text-sm font-semibold">Claude 4 Opus</div>
273:                         <div className="text-xs opacity-80">More capable, better for complex tasks</div>
274:                       </div>
275:                     </div>
276:                   </button>
277:                 </div>
278:               </div>
279: 
280:               {/* Default Task */}
281:               <div className="space-y-2">
282:                 <Label htmlFor="default-task">Default Task (Optional)</Label>
283:                 <Input
284:                   id="default-task"
285:                   type="text"
286:                   placeholder="e.g., Review this code for security issues"
287:                   value={defaultTask}
288:                   onChange={(e) => setDefaultTask(e.target.value)}
289:                   className="max-w-md"
290:                 />
291:                 <p className="text-xs text-muted-foreground">
292:                   This will be used as the default task placeholder when executing the agent
293:                 </p>
294:               </div>
295: 
296:               {/* System Prompt Editor */}
297:               <div className="space-y-2">
298:                 <Label>System Prompt</Label>
299:                 <p className="text-xs text-muted-foreground mb-2">
300:                   Define the behavior and capabilities of your CC Agent
301:                 </p>
302:                 <div className="rounded-lg border border-border overflow-hidden shadow-sm" data-color-mode="dark">
303:                   <MDEditor
304:                     value={systemPrompt}
305:                     onChange={(val) => setSystemPrompt(val || "")}
306:                     preview="edit"
307:                     height={400}
308:                     visibleDragbar={false}
309:                   />
310:                 </div>
311:               </div>
312:             </div>
313:           </motion.div>
314:         </div>
315:       </div>
316:   
317:   {/* Toast Notification */}
318:   <ToastContainer>
319:     {toast && (
320:       <Toast
321:         message={toast.message}
322:         type={toast.type}
323:         onDismiss={() => setToast(null)}
324:       />
325:     )}
326:   </ToastContainer>
327: 
328:   {/* Icon Picker Dialog */}
329:   <IconPicker
330:     value={selectedIcon}
331:     onSelect={(iconName) => {
332:       setSelectedIcon(iconName as AgentIconName);
333:       setShowIconPicker(false);
334:     }}
335:     isOpen={showIconPicker}
336:     onClose={() => setShowIconPicker(false)}
337:   />
338: </div>
339:   );
340: };
````

## File: src/components/ErrorBoundary.tsx
````typescript
 1: import React, { Component, ReactNode } from "react";
 2: import { AlertCircle } from "lucide-react";
 3: import { Button } from "@/components/ui/button";
 4: import { Card, CardContent } from "@/components/ui/card";
 5: 
 6: interface ErrorBoundaryProps {
 7:   children: ReactNode;
 8:   fallback?: (error: Error, reset: () => void) => ReactNode;
 9: }
10: 
11: interface ErrorBoundaryState {
12:   hasError: boolean;
13:   error: Error | null;
14: }
15: 
16: /**
17:  * Error Boundary component to catch and display React rendering errors
18:  */
19: export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
20:   constructor(props: ErrorBoundaryProps) {
21:     super(props);
22:     this.state = { hasError: false, error: null };
23:   }
24: 
25:   static getDerivedStateFromError(error: Error): ErrorBoundaryState {
26:     // Update state so the next render will show the fallback UI
27:     return { hasError: true, error };
28:   }
29: 
30:   componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
31:     // Log the error to console
32:     console.error("Error caught by boundary:", error, errorInfo);
33:   }
34: 
35:   reset = () => {
36:     this.setState({ hasError: false, error: null });
37:   };
38: 
39:   render() {
40:     if (this.state.hasError && this.state.error) {
41:       // Use custom fallback if provided
42:       if (this.props.fallback) {
43:         return this.props.fallback(this.state.error, this.reset);
44:       }
45: 
46:       // Default error UI
47:       return (
48:         <div className="flex items-center justify-center min-h-[200px] p-4">
49:           <Card className="max-w-md w-full">
50:             <CardContent className="p-6">
51:               <div className="flex items-start gap-4">
52:                 <AlertCircle className="h-8 w-8 text-destructive flex-shrink-0 mt-0.5" />
53:                 <div className="flex-1 space-y-2">
54:                   <h3 className="text-lg font-semibold">Something went wrong</h3>
55:                   <p className="text-sm text-muted-foreground">
56:                     An error occurred while rendering this component.
57:                   </p>
58:                   {this.state.error.message && (
59:                     <details className="mt-2">
60:                       <summary className="text-sm cursor-pointer text-muted-foreground hover:text-foreground">
61:                         Error details
62:                       </summary>
63:                       <pre className="mt-2 text-xs bg-muted p-2 rounded overflow-auto">
64:                         {this.state.error.message}
65:                       </pre>
66:                     </details>
67:                   )}
68:                   <Button
69:                     onClick={this.reset}
70:                     size="sm"
71:                     className="mt-4"
72:                   >
73:                     Try again
74:                   </Button>
75:                 </div>
76:               </div>
77:             </CardContent>
78:           </Card>
79:         </div>
80:       );
81:     }
82: 
83:     return this.props.children;
84:   }
85: }
````

## File: src/components/ExecutionControlBar.tsx
````typescript
  1: import React from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import { StopCircle, Clock, Hash } from "lucide-react";
  4: import { Button } from "@/components/ui/button";
  5: import { cn } from "@/lib/utils";
  6: 
  7: interface ExecutionControlBarProps {
  8:   isExecuting: boolean;
  9:   onStop: () => void;
 10:   totalTokens?: number;
 11:   elapsedTime?: number; // in seconds
 12:   className?: string;
 13: }
 14: 
 15: /**
 16:  * Floating control bar shown during agent execution
 17:  * Provides stop functionality and real-time statistics
 18:  */
 19: export const ExecutionControlBar: React.FC<ExecutionControlBarProps> = ({ 
 20:   isExecuting, 
 21:   onStop, 
 22:   totalTokens = 0,
 23:   elapsedTime = 0,
 24:   className 
 25: }) => {
 26:   // Format elapsed time
 27:   const formatTime = (seconds: number) => {
 28:     const mins = Math.floor(seconds / 60);
 29:     const secs = seconds % 60;
 30:     if (mins > 0) {
 31:       return `${mins}m ${secs.toFixed(0)}s`;
 32:     }
 33:     return `${secs.toFixed(1)}s`;
 34:   };
 35: 
 36:   // Format token count
 37:   const formatTokens = (tokens: number) => {
 38:     if (tokens >= 1000) {
 39:       return `${(tokens / 1000).toFixed(1)}k`;
 40:     }
 41:     return tokens.toString();
 42:   };
 43: 
 44:   return (
 45:     <AnimatePresence>
 46:       {isExecuting && (
 47:         <motion.div
 48:           initial={{ y: 100, opacity: 0 }}
 49:           animate={{ y: 0, opacity: 1 }}
 50:           exit={{ y: 100, opacity: 0 }}
 51:           transition={{ type: "spring", stiffness: 300, damping: 30 }}
 52:           className={cn(
 53:             "fixed bottom-6 left-1/2 -translate-x-1/2 z-50",
 54:             "bg-background/95 backdrop-blur-md border rounded-full shadow-lg",
 55:             "px-6 py-3 flex items-center gap-4",
 56:             className
 57:           )}
 58:         >
 59:           {/* Rotating symbol indicator */}
 60:           <div className="relative flex items-center justify-center">
 61:             <div className="rotating-symbol text-primary"></div>
 62:           </div>
 63: 
 64:           {/* Status text */}
 65:           <span className="text-sm font-medium">Executing...</span>
 66: 
 67:           {/* Divider */}
 68:           <div className="h-4 w-px bg-border" />
 69: 
 70:           {/* Stats */}
 71:           <div className="flex items-center gap-4 text-xs text-muted-foreground">
 72:             {/* Time */}
 73:             <div className="flex items-center gap-1.5">
 74:               <Clock className="h-3.5 w-3.5" />
 75:               <span>{formatTime(elapsedTime)}</span>
 76:             </div>
 77: 
 78:             {/* Tokens */}
 79:             <div className="flex items-center gap-1.5">
 80:               <Hash className="h-3.5 w-3.5" />
 81:               <span>{formatTokens(totalTokens)} tokens</span>
 82:             </div>
 83:           </div>
 84: 
 85:           {/* Divider */}
 86:           <div className="h-4 w-px bg-border" />
 87: 
 88:           {/* Stop button */}
 89:           <Button
 90:             size="sm"
 91:             variant="destructive"
 92:             onClick={onStop}
 93:             className="gap-2"
 94:           >
 95:             <StopCircle className="h-3.5 w-3.5" />
 96:             Stop
 97:           </Button>
 98:         </motion.div>
 99:       )}
100:     </AnimatePresence>
101:   );
102: };
````

## File: src/components/FilePicker.optimized.tsx
````typescript
  1: import React, { useState, useEffect, useRef, useCallback, useMemo } from "react";
  2: import { motion } from "framer-motion";
  3: import { useVirtualizer } from "@tanstack/react-virtual";
  4: import { Button } from "@/components/ui/button";
  5: import { api } from "@/lib/api";
  6: import { 
  7:   X, 
  8:   Folder, 
  9:   File, 
 10:   ArrowLeft,
 11:   FileCode,
 12:   FileText,
 13:   FileImage,
 14:   Search,
 15:   ChevronRight
 16: } from "lucide-react";
 17: import type { FileEntry } from "@/lib/api";
 18: import { cn } from "@/lib/utils";
 19: 
 20: // Global caches that persist across component instances
 21: const globalDirectoryCache = new Map<string, FileEntry[]>();
 22: const globalSearchCache = new Map<string, FileEntry[]>();
 23: 
 24: interface FilePickerProps {
 25:   basePath: string;
 26:   onSelect: (entry: FileEntry) => void;
 27:   onClose: () => void;
 28:   initialQuery?: string;
 29:   className?: string;
 30:   allowDirectorySelection?: boolean;
 31: }
 32: 
 33: // Memoized file icon selector
 34: const getFileIcon = (entry: FileEntry) => {
 35:   if (entry.is_directory) return Folder;
 36:   
 37:   const ext = entry.name.split('.').pop()?.toLowerCase();
 38:   switch (ext) {
 39:     case 'js':
 40:     case 'jsx':
 41:     case 'ts':
 42:     case 'tsx':
 43:     case 'py':
 44:     case 'java':
 45:     case 'cpp':
 46:     case 'c':
 47:     case 'go':
 48:     case 'rs':
 49:       return FileCode;
 50:     case 'md':
 51:     case 'txt':
 52:     case 'json':
 53:     case 'xml':
 54:     case 'yaml':
 55:     case 'yml':
 56:       return FileText;
 57:     case 'png':
 58:     case 'jpg':
 59:     case 'jpeg':
 60:     case 'gif':
 61:     case 'svg':
 62:     case 'webp':
 63:       return FileImage;
 64:     default:
 65:       return File;
 66:   }
 67: };
 68: 
 69: const formatFileSize = (bytes: number): string => {
 70:   if (bytes === 0) return '0 B';
 71:   const k = 1024;
 72:   const sizes = ['B', 'KB', 'MB', 'GB'];
 73:   const i = Math.floor(Math.log(bytes) / Math.log(k));
 74:   return `${(bytes / Math.pow(k, i)).toFixed(1)} ${sizes[i]}`;
 75: };
 76: 
 77: export const FilePicker: React.FC<FilePickerProps> = React.memo(({
 78:   basePath,
 79:   onSelect,
 80:   onClose,
 81:   initialQuery = "",
 82:   className,
 83:   allowDirectorySelection = false
 84: }) => {
 85:   const [currentPath, setCurrentPath] = useState(basePath);
 86:   const [entries, setEntries] = useState<FileEntry[]>([]);
 87:   const [searchQuery, setSearchQuery] = useState(initialQuery);
 88:   const [selectedIndex, setSelectedIndex] = useState(0);
 89:   const [isLoading, setIsLoading] = useState(false);
 90:   const [error, setError] = useState<string | null>(null);
 91:   
 92:   const searchInputRef = useRef<HTMLInputElement>(null);
 93:   const scrollContainerRef = useRef<HTMLDivElement>(null);
 94:   const searchDebounceRef = useRef<NodeJS.Timeout>();
 95: 
 96:   // Filter and sort entries
 97:   const displayEntries = useMemo(() => {
 98:     const filtered = searchQuery.trim()
 99:       ? entries.filter(entry => 
100:           entry.name.toLowerCase().includes(searchQuery.toLowerCase())
101:         )
102:       : entries;
103:     
104:     return filtered.sort((a, b) => {
105:       if (a.is_directory !== b.is_directory) {
106:         return a.is_directory ? -1 : 1;
107:       }
108:       return a.name.localeCompare(b.name);
109:     });
110:   }, [entries, searchQuery]);
111: 
112:   // Virtual scrolling setup
113:   const virtualizer = useVirtualizer({
114:     count: displayEntries.length,
115:     getScrollElement: () => scrollContainerRef.current,
116:     estimateSize: () => 32, // Height of each item
117:     overscan: 10, // Number of items to render outside viewport
118:   });
119: 
120:   const virtualItems = virtualizer.getVirtualItems();
121: 
122:   // Load directory contents
123:   const loadDirectory = useCallback(async (path: string) => {
124:     const cacheKey = path;
125:     
126:     // Check cache first
127:     if (globalDirectoryCache.has(cacheKey)) {
128:       setEntries(globalDirectoryCache.get(cacheKey)!);
129:       return;
130:     }
131: 
132:     setIsLoading(true);
133:     setError(null);
134:     
135:     try {
136:       const result = await api.listDirectoryContents(path);
137:       globalDirectoryCache.set(cacheKey, result);
138:       setEntries(result);
139:     } catch (err) {
140:       setError(err instanceof Error ? err.message : 'Failed to load directory');
141:     } finally {
142:       setIsLoading(false);
143:     }
144:   }, []);
145: 
146:   // Search functionality
147:   const performSearch = useCallback(async (query: string) => {
148:     if (!query.trim()) {
149:       loadDirectory(currentPath);
150:       return;
151:     }
152: 
153:     const cacheKey = `${currentPath}:${query}`;
154:     
155:     if (globalSearchCache.has(cacheKey)) {
156:       setEntries(globalSearchCache.get(cacheKey)!);
157:       return;
158:     }
159: 
160:     setIsLoading(true);
161:     setError(null);
162:     
163:     try {
164:       const result = await api.searchFiles(currentPath, query);
165:       globalSearchCache.set(cacheKey, result);
166:       setEntries(result);
167:     } catch (err) {
168:       setError(err instanceof Error ? err.message : 'Search failed');
169:     } finally {
170:       setIsLoading(false);
171:     }
172:   }, [currentPath, loadDirectory]);
173: 
174:   // Handle entry click
175:   const handleEntryClick = useCallback((entry: FileEntry) => {
176:     if (!entry.is_directory || allowDirectorySelection) {
177:       onSelect(entry);
178:     }
179:   }, [onSelect, allowDirectorySelection]);
180: 
181:   // Handle entry double click
182:   const handleEntryDoubleClick = useCallback((entry: FileEntry) => {
183:     if (entry.is_directory) {
184:       setCurrentPath(entry.path);
185:       setSearchQuery("");
186:       setSelectedIndex(0);
187:     } else {
188:       onSelect(entry);
189:     }
190:   }, [onSelect]);
191: 
192:   // Keyboard navigation
193:   const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
194:     if (displayEntries.length === 0) return;
195: 
196:     switch (e.key) {
197:       case 'ArrowUp':
198:         e.preventDefault();
199:         setSelectedIndex(prev => Math.max(0, prev - 1));
200:         break;
201:       case 'ArrowDown':
202:         e.preventDefault();
203:         setSelectedIndex(prev => Math.min(displayEntries.length - 1, prev + 1));
204:         break;
205:       case 'Enter':
206:         e.preventDefault();
207:         const selectedEntry = displayEntries[selectedIndex];
208:         if (selectedEntry) {
209:           if (e.shiftKey || !selectedEntry.is_directory) {
210:             handleEntryClick(selectedEntry);
211:           } else {
212:             handleEntryDoubleClick(selectedEntry);
213:           }
214:         }
215:         break;
216:       case 'Escape':
217:         e.preventDefault();
218:         onClose();
219:         break;
220:     }
221:   }, [displayEntries, selectedIndex, handleEntryClick, handleEntryDoubleClick, onClose]);
222: 
223:   // Debounced search
224:   useEffect(() => {
225:     if (searchDebounceRef.current) {
226:       clearTimeout(searchDebounceRef.current);
227:     }
228: 
229:     searchDebounceRef.current = setTimeout(() => {
230:       performSearch(searchQuery);
231:     }, 300);
232: 
233:     return () => {
234:       if (searchDebounceRef.current) {
235:         clearTimeout(searchDebounceRef.current);
236:       }
237:     };
238:   }, [searchQuery, performSearch]);
239: 
240:   // Load initial directory
241:   useEffect(() => {
242:     loadDirectory(currentPath);
243:   }, [currentPath, loadDirectory]);
244: 
245:   // Focus search input on mount
246:   useEffect(() => {
247:     searchInputRef.current?.focus();
248:   }, []);
249: 
250:   // Scroll selected item into view
251:   useEffect(() => {
252:     const item = virtualizer.getVirtualItems().find(
253:       vItem => vItem.index === selectedIndex
254:     );
255:     if (item) {
256:       virtualizer.scrollToIndex(selectedIndex, { align: 'center' });
257:     }
258:   }, [selectedIndex, virtualizer]);
259: 
260:   return (
261:     <motion.div
262:       initial={{ opacity: 0, scale: 0.95 }}
263:       animate={{ opacity: 1, scale: 1 }}
264:       exit={{ opacity: 0, scale: 0.95 }}
265:       className={cn("flex flex-col bg-background rounded-lg shadow-lg", className)}
266:       onKeyDown={handleKeyDown}
267:     >
268:       {/* Header */}
269:       <div className="flex items-center gap-2 p-4 border-b">
270:         <Button
271:           variant="ghost"
272:           size="icon"
273:           onClick={() => {
274:             const parentPath = currentPath.split('/').slice(0, -1).join('/') || '/';
275:             setCurrentPath(parentPath);
276:             setSearchQuery("");
277:           }}
278:           disabled={currentPath === '/' || currentPath === basePath}
279:           className="h-8 w-8"
280:         >
281:           <ArrowLeft className="h-4 w-4" />
282:         </Button>
283: 
284:         <div className="flex-1 flex items-center gap-2">
285:           <Search className="h-4 w-4 text-muted-foreground" />
286:           <input
287:             ref={searchInputRef}
288:             type="text"
289:             value={searchQuery}
290:             onChange={(e) => setSearchQuery(e.target.value)}
291:             placeholder="Search files..."
292:             className="flex-1 bg-transparent outline-none text-sm"
293:           />
294:         </div>
295: 
296:         <Button
297:           variant="ghost"
298:           size="icon"
299:           onClick={onClose}
300:           className="h-8 w-8"
301:         >
302:           <X className="h-4 w-4" />
303:         </Button>
304:       </div>
305: 
306:       {/* Current path */}
307:       <div className="px-4 py-2 border-b">
308:         <div className="text-xs text-muted-foreground truncate">
309:           {currentPath}
310:         </div>
311:       </div>
312: 
313:       {/* File list with virtual scrolling */}
314:       <div 
315:         ref={scrollContainerRef}
316:         className="flex-1 overflow-auto"
317:         style={{ height: '400px' }}
318:       >
319:         {isLoading && (
320:           <div className="flex items-center justify-center h-full">
321:             <div className="text-sm text-muted-foreground">Loading...</div>
322:           </div>
323:         )}
324: 
325:         {error && (
326:           <div className="flex items-center justify-center h-full">
327:             <div className="text-sm text-destructive">{error}</div>
328:           </div>
329:         )}
330: 
331:         {!isLoading && !error && displayEntries.length === 0 && (
332:           <div className="flex flex-col items-center justify-center h-full">
333:             <Search className="h-8 w-8 text-muted-foreground mb-2" />
334:             <span className="text-sm text-muted-foreground">
335:               {searchQuery.trim() ? 'No files found' : 'Empty directory'}
336:             </span>
337:           </div>
338:         )}
339: 
340:         {displayEntries.length > 0 && (
341:           <div
342:             style={{
343:               height: `${virtualizer.getTotalSize()}px`,
344:               width: '100%',
345:               position: 'relative',
346:             }}
347:           >
348:             {virtualItems.map((virtualRow) => {
349:               const entry = displayEntries[virtualRow.index];
350:               const Icon = getFileIcon(entry);
351:               const isSelected = virtualRow.index === selectedIndex;
352:               
353:               return (
354:                 <div
355:                   key={virtualRow.key}
356:                   style={{
357:                     position: 'absolute',
358:                     top: 0,
359:                     left: 0,
360:                     width: '100%',
361:                     height: `${virtualRow.size}px`,
362:                     transform: `translateY(${virtualRow.start}px)`,
363:                   }}
364:                 >
365:                   <button
366:                     onClick={() => handleEntryClick(entry)}
367:                     onDoubleClick={() => handleEntryDoubleClick(entry)}
368:                     onMouseEnter={() => setSelectedIndex(virtualRow.index)}
369:                     className={cn(
370:                       "w-full flex items-center gap-2 px-2 py-1.5",
371:                       "hover:bg-accent transition-colors",
372:                       "text-left text-sm h-8",
373:                       isSelected && "bg-accent"
374:                     )}
375:                     title={entry.is_directory ? "Click to select • Double-click to enter" : "Click to select"}
376:                   >
377:                     <Icon className={cn(
378:                       "h-4 w-4 flex-shrink-0",
379:                       entry.is_directory ? "text-blue-500" : "text-muted-foreground"
380:                     )} />
381:                     
382:                     <span className="flex-1 truncate">
383:                       {entry.name}
384:                     </span>
385:                     
386:                     {!entry.is_directory && entry.size > 0 && (
387:                       <span className="text-xs text-muted-foreground">
388:                         {formatFileSize(entry.size)}
389:                       </span>
390:                     )}
391:                     
392:                     {entry.is_directory && (
393:                       <ChevronRight className="h-4 w-4 text-muted-foreground" />
394:                     )}
395:                   </button>
396:                 </div>
397:               );
398:             })}
399:           </div>
400:         )}
401:       </div>
402: 
403:       {/* Footer */}
404:       <div className="flex items-center justify-between p-4 border-t">
405:         <div className="text-xs text-muted-foreground">
406:           {displayEntries.length} {displayEntries.length === 1 ? 'item' : 'items'}
407:         </div>
408:         {allowDirectorySelection && (
409:           <div className="text-xs text-muted-foreground">
410:             Shift+Enter to select directory
411:           </div>
412:         )}
413:       </div>
414:     </motion.div>
415:   );
416: });
````

## File: src/components/FilePicker.tsx
````typescript
  1: import React, { useState, useEffect, useRef } from "react";
  2: import { motion } from "framer-motion";
  3: import { Button } from "@/components/ui/button";
  4: import { api } from "@/lib/api";
  5: import { 
  6:   X, 
  7:   Folder, 
  8:   File, 
  9:   ArrowLeft,
 10:   FileCode,
 11:   FileText,
 12:   FileImage,
 13:   Search,
 14:   ChevronRight
 15: } from "lucide-react";
 16: import type { FileEntry } from "@/lib/api";
 17: import { cn } from "@/lib/utils";
 18: 
 19: // Global caches that persist across component instances
 20: const globalDirectoryCache = new Map<string, FileEntry[]>();
 21: const globalSearchCache = new Map<string, FileEntry[]>();
 22: 
 23: // Note: These caches persist for the lifetime of the application.
 24: // In a production app, you might want to:
 25: // 1. Add TTL (time-to-live) to expire old entries
 26: // 2. Implement LRU (least recently used) eviction
 27: // 3. Clear caches when the working directory changes
 28: // 4. Add a maximum cache size limit
 29: 
 30: interface FilePickerProps {
 31:   /**
 32:    * The base directory path to browse
 33:    */
 34:   basePath: string;
 35:   /**
 36:    * Callback when a file/directory is selected
 37:    */
 38:   onSelect: (entry: FileEntry) => void;
 39:   /**
 40:    * Callback to close the picker
 41:    */
 42:   onClose: () => void;
 43:   /**
 44:    * Initial search query
 45:    */
 46:   initialQuery?: string;
 47:   /**
 48:    * Optional className for styling
 49:    */
 50:   className?: string;
 51: }
 52: 
 53: // File icon mapping based on extension
 54: const getFileIcon = (entry: FileEntry) => {
 55:   if (entry.is_directory) return Folder;
 56:   
 57:   const ext = entry.extension?.toLowerCase();
 58:   if (!ext) return File;
 59:   
 60:   // Code files
 61:   if (['ts', 'tsx', 'js', 'jsx', 'py', 'rs', 'go', 'java', 'cpp', 'c', 'h'].includes(ext)) {
 62:     return FileCode;
 63:   }
 64:   
 65:   // Text/Markdown files
 66:   if (['md', 'txt', 'json', 'yaml', 'yml', 'toml', 'xml', 'html', 'css'].includes(ext)) {
 67:     return FileText;
 68:   }
 69:   
 70:   // Image files
 71:   if (['png', 'jpg', 'jpeg', 'gif', 'svg', 'webp', 'ico'].includes(ext)) {
 72:     return FileImage;
 73:   }
 74:   
 75:   return File;
 76: };
 77: 
 78: // Format file size to human readable
 79: const formatFileSize = (bytes: number): string => {
 80:   if (bytes === 0) return '';
 81:   const k = 1024;
 82:   const sizes = ['B', 'KB', 'MB', 'GB'];
 83:   const i = Math.floor(Math.log(bytes) / Math.log(k));
 84:   return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;
 85: };
 86: 
 87: /**
 88:  * FilePicker component - File browser with fuzzy search
 89:  * 
 90:  * @example
 91:  * <FilePicker
 92:  *   basePath="/Users/example/project"
 93:  *   onSelect={(entry) => console.log('Selected:', entry)}
 94:  *   onClose={() => setShowPicker(false)}
 95:  * />
 96:  */
 97: export const FilePicker: React.FC<FilePickerProps> = ({
 98:   basePath,
 99:   onSelect,
100:   onClose,
101:   initialQuery = "",
102:   className,
103: }) => {
104:   const searchQuery = initialQuery;
105:   
106:   const [currentPath, setCurrentPath] = useState(basePath);
107:   const [entries, setEntries] = useState<FileEntry[]>(() => 
108:     searchQuery.trim() ? [] : globalDirectoryCache.get(basePath) || []
109:   );
110:   const [searchResults, setSearchResults] = useState<FileEntry[]>(() => {
111:     if (searchQuery.trim()) {
112:       const cacheKey = `${basePath}:${searchQuery}`;
113:       return globalSearchCache.get(cacheKey) || [];
114:     }
115:     return [];
116:   });
117:   const [isLoading, setIsLoading] = useState(false);
118:   const [error, setError] = useState<string | null>(null);
119:   const [pathHistory, setPathHistory] = useState<string[]>([basePath]);
120:   const [selectedIndex, setSelectedIndex] = useState(0);
121:   const [isShowingCached, setIsShowingCached] = useState(() => {
122:     // Check if we're showing cached data on mount
123:     if (searchQuery.trim()) {
124:       const cacheKey = `${basePath}:${searchQuery}`;
125:       return globalSearchCache.has(cacheKey);
126:     }
127:     return globalDirectoryCache.has(basePath);
128:   });
129:   
130:   const searchDebounceRef = useRef<NodeJS.Timeout | null>(null);
131:   const fileListRef = useRef<HTMLDivElement>(null);
132:   
133:   // Computed values
134:   const displayEntries = searchQuery.trim() ? searchResults : entries;
135:   const canGoBack = pathHistory.length > 1;
136:   
137:   // Get relative path for display
138:   const relativePath = currentPath.startsWith(basePath) 
139:     ? currentPath.slice(basePath.length) || '/'
140:     : currentPath;
141: 
142:   // Load directory contents
143:   useEffect(() => {
144:     loadDirectory(currentPath);
145:   }, [currentPath]);
146: 
147:   // Debounced search
148:   useEffect(() => {
149:     if (searchDebounceRef.current) {
150:       clearTimeout(searchDebounceRef.current);
151:     }
152: 
153:     if (searchQuery.trim()) {
154:       const cacheKey = `${basePath}:${searchQuery}`;
155:       
156:       // Immediately show cached results if available
157:       if (globalSearchCache.has(cacheKey)) {
158:         console.log('[FilePicker] Immediately showing cached search results for:', searchQuery);
159:         setSearchResults(globalSearchCache.get(cacheKey) || []);
160:         setIsShowingCached(true);
161:         setError(null);
162:       }
163:       
164:       // Schedule fresh search after debounce
165:       searchDebounceRef.current = setTimeout(() => {
166:         performSearch(searchQuery);
167:       }, 300);
168:     } else {
169:       setSearchResults([]);
170:       setIsShowingCached(false);
171:     }
172: 
173:     return () => {
174:       if (searchDebounceRef.current) {
175:         clearTimeout(searchDebounceRef.current);
176:       }
177:     };
178:   }, [searchQuery, basePath]);
179: 
180:   // Reset selected index when entries change
181:   useEffect(() => {
182:     setSelectedIndex(0);
183:   }, [entries, searchResults]);
184: 
185:   // Keyboard navigation
186:   useEffect(() => {
187:     const handleKeyDown = (e: KeyboardEvent) => {
188:       const displayEntries = searchQuery.trim() ? searchResults : entries;
189:       
190:       switch (e.key) {
191:         case 'Escape':
192:           e.preventDefault();
193:           onClose();
194:           break;
195:           
196:         case 'Enter':
197:           e.preventDefault();
198:           // Enter always selects the current item (file or directory)
199:           if (displayEntries.length > 0 && selectedIndex < displayEntries.length) {
200:             onSelect(displayEntries[selectedIndex]);
201:           }
202:           break;
203:           
204:         case 'ArrowUp':
205:           e.preventDefault();
206:           setSelectedIndex(prev => Math.max(0, prev - 1));
207:           break;
208:           
209:         case 'ArrowDown':
210:           e.preventDefault();
211:           setSelectedIndex(prev => Math.min(displayEntries.length - 1, prev + 1));
212:           break;
213:           
214:         case 'ArrowRight':
215:           e.preventDefault();
216:           // Right arrow enters directories
217:           if (displayEntries.length > 0 && selectedIndex < displayEntries.length) {
218:             const entry = displayEntries[selectedIndex];
219:             if (entry.is_directory) {
220:               navigateToDirectory(entry.path);
221:             }
222:           }
223:           break;
224:           
225:         case 'ArrowLeft':
226:           e.preventDefault();
227:           // Left arrow goes back to parent directory
228:           if (canGoBack) {
229:             navigateBack();
230:           }
231:           break;
232:       }
233:     };
234: 
235:     window.addEventListener('keydown', handleKeyDown);
236:     return () => window.removeEventListener('keydown', handleKeyDown);
237:   }, [entries, searchResults, selectedIndex, searchQuery, canGoBack]);
238: 
239:   // Scroll selected item into view
240:   useEffect(() => {
241:     if (fileListRef.current) {
242:       const selectedElement = fileListRef.current.querySelector(`[data-index="${selectedIndex}"]`);
243:       if (selectedElement) {
244:         selectedElement.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
245:       }
246:     }
247:   }, [selectedIndex]);
248: 
249:   const loadDirectory = async (path: string) => {
250:     try {
251:       console.log('[FilePicker] Loading directory:', path);
252:       
253:       // Check cache first and show immediately
254:       if (globalDirectoryCache.has(path)) {
255:         console.log('[FilePicker] Showing cached contents for:', path);
256:         setEntries(globalDirectoryCache.get(path) || []);
257:         setIsShowingCached(true);
258:         setError(null);
259:       } else {
260:         // Only show loading if we don't have cached data
261:         setIsLoading(true);
262:       }
263:       
264:       // Always fetch fresh data in background
265:       const contents = await api.listDirectoryContents(path);
266:       console.log('[FilePicker] Loaded fresh contents:', contents.length, 'items');
267:       
268:       // Cache the results
269:       globalDirectoryCache.set(path, contents);
270:       
271:       // Update with fresh data
272:       setEntries(contents);
273:       setIsShowingCached(false);
274:       setError(null);
275:     } catch (err) {
276:       console.error('[FilePicker] Failed to load directory:', path, err);
277:       console.error('[FilePicker] Error details:', err);
278:       // Only set error if we don't have cached data to show
279:       if (!globalDirectoryCache.has(path)) {
280:         setError(err instanceof Error ? err.message : 'Failed to load directory');
281:       }
282:     } finally {
283:       setIsLoading(false);
284:     }
285:   };
286: 
287:   const performSearch = async (query: string) => {
288:     try {
289:       console.log('[FilePicker] Searching for:', query, 'in:', basePath);
290:       
291:       // Create cache key that includes both query and basePath
292:       const cacheKey = `${basePath}:${query}`;
293:       
294:       // Check cache first and show immediately
295:       if (globalSearchCache.has(cacheKey)) {
296:         console.log('[FilePicker] Showing cached search results for:', query);
297:         setSearchResults(globalSearchCache.get(cacheKey) || []);
298:         setIsShowingCached(true);
299:         setError(null);
300:       } else {
301:         // Only show loading if we don't have cached data
302:         setIsLoading(true);
303:       }
304:       
305:       // Always fetch fresh results in background
306:       const results = await api.searchFiles(basePath, query);
307:       console.log('[FilePicker] Fresh search results:', results.length, 'items');
308:       
309:       // Cache the results
310:       globalSearchCache.set(cacheKey, results);
311:       
312:       // Update with fresh results
313:       setSearchResults(results);
314:       setIsShowingCached(false);
315:       setError(null);
316:     } catch (err) {
317:       console.error('[FilePicker] Search failed:', query, err);
318:       // Only set error if we don't have cached data to show
319:       const cacheKey = `${basePath}:${query}`;
320:       if (!globalSearchCache.has(cacheKey)) {
321:         setError(err instanceof Error ? err.message : 'Search failed');
322:       }
323:     } finally {
324:       setIsLoading(false);
325:     }
326:   };
327: 
328:   const navigateToDirectory = (path: string) => {
329:     setCurrentPath(path);
330:     setPathHistory(prev => [...prev, path]);
331:   };
332: 
333:   const navigateBack = () => {
334:     if (pathHistory.length > 1) {
335:       const newHistory = [...pathHistory];
336:       newHistory.pop(); // Remove current
337:       const previousPath = newHistory[newHistory.length - 1];
338:       
339:       // Don't go beyond the base path
340:       if (previousPath.startsWith(basePath) || previousPath === basePath) {
341:         setCurrentPath(previousPath);
342:         setPathHistory(newHistory);
343:       }
344:     }
345:   };
346: 
347:   const handleEntryClick = (entry: FileEntry) => {
348:     // Single click always selects (file or directory)
349:     onSelect(entry);
350:   };
351:   
352:   const handleEntryDoubleClick = (entry: FileEntry) => {
353:     // Double click navigates into directories
354:     if (entry.is_directory) {
355:       navigateToDirectory(entry.path);
356:     }
357:   };
358: 
359:   return (
360:     <motion.div
361:       initial={{ opacity: 0, scale: 0.95 }}
362:       animate={{ opacity: 1, scale: 1 }}
363:       exit={{ opacity: 0, scale: 0.95 }}
364:       className={cn(
365:         "absolute bottom-full mb-2 left-0 z-50",
366:         "w-[500px] h-[400px]",
367:         "bg-background border border-border rounded-lg shadow-lg",
368:         "flex flex-col overflow-hidden",
369:         className
370:       )}
371:     >
372:       {/* Header */}
373:       <div className="border-b border-border p-3">
374:         <div className="flex items-center justify-between">
375:           <div className="flex items-center gap-2">
376:             <Button
377:               variant="ghost"
378:               size="icon"
379:               onClick={navigateBack}
380:               disabled={!canGoBack}
381:               className="h-8 w-8"
382:             >
383:               <ArrowLeft className="h-4 w-4" />
384:             </Button>
385:             <span className="text-sm font-mono text-muted-foreground truncate max-w-[300px]">
386:               {relativePath}
387:             </span>
388:           </div>
389:           <Button
390:             variant="ghost"
391:             size="icon"
392:             onClick={onClose}
393:             className="h-8 w-8"
394:           >
395:             <X className="h-4 w-4" />
396:           </Button>
397:         </div>
398:       </div>
399: 
400:       {/* File List */}
401:       <div className="flex-1 overflow-y-auto relative">
402:         {/* Show loading only if no cached data */}
403:         {isLoading && displayEntries.length === 0 && (
404:           <div className="flex items-center justify-center h-full">
405:             <span className="text-sm text-muted-foreground">Loading...</span>
406:           </div>
407:         )}
408: 
409:         {/* Show subtle indicator when displaying cached data while fetching fresh */}
410:         {isShowingCached && isLoading && displayEntries.length > 0 && (
411:           <div className="absolute top-1 right-2 text-xs text-muted-foreground/50 italic">
412:             updating...
413:           </div>
414:         )}
415: 
416:         {error && displayEntries.length === 0 && (
417:           <div className="flex items-center justify-center h-full">
418:             <span className="text-sm text-destructive">{error}</span>
419:           </div>
420:         )}
421: 
422:         {!isLoading && !error && displayEntries.length === 0 && (
423:           <div className="flex flex-col items-center justify-center h-full">
424:             <Search className="h-8 w-8 text-muted-foreground mb-2" />
425:             <span className="text-sm text-muted-foreground">
426:               {searchQuery.trim() ? 'No files found' : 'Empty directory'}
427:             </span>
428:           </div>
429:         )}
430: 
431:         {displayEntries.length > 0 && (
432:           <div className="p-2 space-y-0.5" ref={fileListRef}>
433:             {displayEntries.map((entry, index) => {
434:               const Icon = getFileIcon(entry);
435:               const isSearching = searchQuery.trim() !== '';
436:               const isSelected = index === selectedIndex;
437:               
438:               return (
439:                 <button
440:                   key={entry.path}
441:                   data-index={index}
442:                   onClick={() => handleEntryClick(entry)}
443:                   onDoubleClick={() => handleEntryDoubleClick(entry)}
444:                   onMouseEnter={() => setSelectedIndex(index)}
445:                   className={cn(
446:                     "w-full flex items-center gap-2 px-2 py-1.5 rounded-md",
447:                     "hover:bg-accent transition-colors",
448:                     "text-left text-sm",
449:                     isSelected && "bg-accent"
450:                   )}
451:                   title={entry.is_directory ? "Click to select • Double-click to enter" : "Click to select"}
452:                 >
453:                   <Icon className={cn(
454:                     "h-4 w-4 flex-shrink-0",
455:                     entry.is_directory ? "text-blue-500" : "text-muted-foreground"
456:                   )} />
457:                   
458:                   <span className="flex-1 truncate">
459:                     {entry.name}
460:                   </span>
461:                   
462:                   {!entry.is_directory && entry.size > 0 && (
463:                     <span className="text-xs text-muted-foreground">
464:                       {formatFileSize(entry.size)}
465:                     </span>
466:                   )}
467:                   
468:                   {entry.is_directory && (
469:                     <ChevronRight className="h-4 w-4 text-muted-foreground" />
470:                   )}
471:                   
472:                   {isSearching && (
473:                     <span className="text-xs text-muted-foreground font-mono truncate max-w-[150px]">
474:                       {entry.path.replace(basePath, '').replace(/^\//, '')}
475:                     </span>
476:                   )}
477:                 </button>
478:               );
479:             })}
480:           </div>
481:         )}
482:       </div>
483: 
484:       {/* Footer */}
485:       <div className="border-t border-border p-2">
486:         <p className="text-xs text-muted-foreground text-center">
487:           ↑↓ Navigate • Enter Select • → Enter Directory • ← Go Back • Esc Close
488:         </p>
489:       </div>
490:     </motion.div>
491:   );
492: };
````

## File: src/components/FloatingPromptInput.tsx
````typescript
   1: import React, { useState, useRef, useEffect } from "react";
   2: import { motion, AnimatePresence } from "framer-motion";
   3: import {
   4:   Send,
   5:   Maximize2,
   6:   Minimize2,
   7:   ChevronUp,
   8:   Sparkles,
   9:   Zap,
  10:   Square,
  11:   Brain
  12: } from "lucide-react";
  13: import { cn } from "@/lib/utils";
  14: import { Button } from "@/components/ui/button";
  15: import { Popover } from "@/components/ui/popover";
  16: import { Textarea } from "@/components/ui/textarea";
  17: import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
  18: import { FilePicker } from "./FilePicker";
  19: import { SlashCommandPicker } from "./SlashCommandPicker";
  20: import { ImagePreview } from "./ImagePreview";
  21: import { type FileEntry, type SlashCommand } from "@/lib/api";
  22: import { getCurrentWebviewWindow } from "@tauri-apps/api/webviewWindow";
  23: 
  24: interface FloatingPromptInputProps {
  25:   /**
  26:    * Callback when prompt is sent
  27:    */
  28:   onSend: (prompt: string, model: "sonnet" | "opus") => void;
  29:   /**
  30:    * Whether the input is loading
  31:    */
  32:   isLoading?: boolean;
  33:   /**
  34:    * Whether the input is disabled
  35:    */
  36:   disabled?: boolean;
  37:   /**
  38:    * Default model to select
  39:    */
  40:   defaultModel?: "sonnet" | "opus";
  41:   /**
  42:    * Project path for file picker
  43:    */
  44:   projectPath?: string;
  45:   /**
  46:    * Optional className for styling
  47:    */
  48:   className?: string;
  49:   /**
  50:    * Callback when cancel is clicked (only during loading)
  51:    */
  52:   onCancel?: () => void;
  53: }
  54: 
  55: export interface FloatingPromptInputRef {
  56:   addImage: (imagePath: string) => void;
  57: }
  58: 
  59: /**
  60:  * Thinking mode type definition
  61:  */
  62: type ThinkingMode = "auto" | "think" | "think_hard" | "think_harder" | "ultrathink";
  63: 
  64: /**
  65:  * Thinking mode configuration
  66:  */
  67: type ThinkingModeConfig = {
  68:   id: ThinkingMode;
  69:   name: string;
  70:   description: string;
  71:   level: number; // 0-4 for visual indicator
  72:   phrase?: string; // The phrase to append
  73: };
  74: 
  75: const THINKING_MODES: ThinkingModeConfig[] = [
  76:   {
  77:     id: "auto",
  78:     name: "Auto",
  79:     description: "Let Claude decide",
  80:     level: 0
  81:   },
  82:   {
  83:     id: "think",
  84:     name: "Think",
  85:     description: "Basic reasoning",
  86:     level: 1,
  87:     phrase: "think"
  88:   },
  89:   {
  90:     id: "think_hard",
  91:     name: "Think Hard",
  92:     description: "Deeper analysis",
  93:     level: 2,
  94:     phrase: "think hard"
  95:   },
  96:   {
  97:     id: "think_harder",
  98:     name: "Think Harder",
  99:     description: "Extensive reasoning",
 100:     level: 3,
 101:     phrase: "think harder"
 102:   },
 103:   {
 104:     id: "ultrathink",
 105:     name: "Ultrathink",
 106:     description: "Maximum computation",
 107:     level: 4,
 108:     phrase: "ultrathink"
 109:   }
 110: ];
 111: 
 112: /**
 113:  * ThinkingModeIndicator component - Shows visual indicator bars for thinking level
 114:  */
 115: const ThinkingModeIndicator: React.FC<{ level: number }> = ({ level }) => {
 116:   return (
 117:     <div className="flex items-center gap-0.5">
 118:       {[1, 2, 3, 4].map((i) => (
 119:         <div
 120:           key={i}
 121:           className={cn(
 122:             "w-1 h-3 rounded-full transition-colors",
 123:             i <= level ? "bg-blue-500" : "bg-muted"
 124:           )}
 125:         />
 126:       ))}
 127:     </div>
 128:   );
 129: };
 130: 
 131: type Model = {
 132:   id: "sonnet" | "opus";
 133:   name: string;
 134:   description: string;
 135:   icon: React.ReactNode;
 136: };
 137: 
 138: const MODELS: Model[] = [
 139:   {
 140:     id: "sonnet",
 141:     name: "Claude 4 Sonnet",
 142:     description: "Faster, efficient for most tasks",
 143:     icon: <Zap className="h-4 w-4" />
 144:   },
 145:   {
 146:     id: "opus",
 147:     name: "Claude 4 Opus",
 148:     description: "More capable, better for complex tasks",
 149:     icon: <Sparkles className="h-4 w-4" />
 150:   }
 151: ];
 152: 
 153: /**
 154:  * FloatingPromptInput component - Fixed position prompt input with model picker
 155:  * 
 156:  * @example
 157:  * const promptRef = useRef<FloatingPromptInputRef>(null);
 158:  * <FloatingPromptInput
 159:  *   ref={promptRef}
 160:  *   onSend={(prompt, model) => console.log('Send:', prompt, model)}
 161:  *   isLoading={false}
 162:  * />
 163:  */
 164: const FloatingPromptInputInner = (
 165:   {
 166:     onSend,
 167:     isLoading = false,
 168:     disabled = false,
 169:     defaultModel = "sonnet",
 170:     projectPath,
 171:     className,
 172:     onCancel,
 173:   }: FloatingPromptInputProps,
 174:   ref: React.Ref<FloatingPromptInputRef>,
 175: ) => {
 176:   const [prompt, setPrompt] = useState("");
 177:   const [selectedModel, setSelectedModel] = useState<"sonnet" | "opus">(defaultModel);
 178:   const [selectedThinkingMode, setSelectedThinkingMode] = useState<ThinkingMode>("auto");
 179:   const [isExpanded, setIsExpanded] = useState(false);
 180:   const [modelPickerOpen, setModelPickerOpen] = useState(false);
 181:   const [thinkingModePickerOpen, setThinkingModePickerOpen] = useState(false);
 182:   const [showFilePicker, setShowFilePicker] = useState(false);
 183:   const [filePickerQuery, setFilePickerQuery] = useState("");
 184:   const [showSlashCommandPicker, setShowSlashCommandPicker] = useState(false);
 185:   const [slashCommandQuery, setSlashCommandQuery] = useState("");
 186:   const [cursorPosition, setCursorPosition] = useState(0);
 187:   const [embeddedImages, setEmbeddedImages] = useState<string[]>([]);
 188:   const [dragActive, setDragActive] = useState(false);
 189: 
 190:   const textareaRef = useRef<HTMLTextAreaElement>(null);
 191:   const expandedTextareaRef = useRef<HTMLTextAreaElement>(null);
 192:   const unlistenDragDropRef = useRef<(() => void) | null>(null);
 193: 
 194:   // Expose a method to add images programmatically
 195:   React.useImperativeHandle(
 196:     ref,
 197:     () => ({
 198:       addImage: (imagePath: string) => {
 199:         setPrompt(currentPrompt => {
 200:           const existingPaths = extractImagePaths(currentPrompt);
 201:           if (existingPaths.includes(imagePath)) {
 202:             return currentPrompt; // Image already added
 203:           }
 204: 
 205:           // Wrap path in quotes if it contains spaces
 206:           const mention = imagePath.includes(' ') ? `@"${imagePath}"` : `@${imagePath}`;
 207:           const newPrompt = currentPrompt + (currentPrompt.endsWith(' ') || currentPrompt === '' ? '' : ' ') + mention + ' ';
 208: 
 209:           // Focus the textarea
 210:           setTimeout(() => {
 211:             const target = isExpanded ? expandedTextareaRef.current : textareaRef.current;
 212:             target?.focus();
 213:             target?.setSelectionRange(newPrompt.length, newPrompt.length);
 214:           }, 0);
 215: 
 216:           return newPrompt;
 217:         });
 218:       }
 219:     }),
 220:     [isExpanded]
 221:   );
 222: 
 223:   // Helper function to check if a file is an image
 224:   const isImageFile = (path: string): boolean => {
 225:     // Check if it's a data URL
 226:     if (path.startsWith('data:image/')) {
 227:       return true;
 228:     }
 229:     // Otherwise check file extension
 230:     const ext = path.split('.').pop()?.toLowerCase();
 231:     return ['png', 'jpg', 'jpeg', 'gif', 'svg', 'webp', 'ico', 'bmp'].includes(ext || '');
 232:   };
 233: 
 234:   // Extract image paths from prompt text
 235:   const extractImagePaths = (text: string): string[] => {
 236:     console.log('[extractImagePaths] Input text length:', text.length);
 237:     
 238:     // Updated regex to handle both quoted and unquoted paths
 239:     // Pattern 1: @"path with spaces or data URLs" - quoted paths
 240:     // Pattern 2: @path - unquoted paths (continues until @ or end)
 241:     const quotedRegex = /@"([^"]+)"/g;
 242:     const unquotedRegex = /@([^@\n\s]+)/g;
 243:     
 244:     const pathsSet = new Set<string>(); // Use Set to ensure uniqueness
 245:     
 246:     // First, extract quoted paths (including data URLs)
 247:     let matches = Array.from(text.matchAll(quotedRegex));
 248:     console.log('[extractImagePaths] Quoted matches:', matches.length);
 249:     
 250:     for (const match of matches) {
 251:       const path = match[1]; // No need to trim, quotes preserve exact path
 252:       console.log('[extractImagePaths] Processing quoted path:', path.startsWith('data:') ? 'data URL' : path);
 253:       
 254:       // For data URLs, use as-is; for file paths, convert to absolute
 255:       const fullPath = path.startsWith('data:') 
 256:         ? path 
 257:         : (path.startsWith('/') ? path : (projectPath ? `${projectPath}/${path}` : path));
 258:       
 259:       if (isImageFile(fullPath)) {
 260:         pathsSet.add(fullPath);
 261:       }
 262:     }
 263:     
 264:     // Remove quoted mentions from text to avoid double-matching
 265:     let textWithoutQuoted = text.replace(quotedRegex, '');
 266:     
 267:     // Then extract unquoted paths (typically file paths)
 268:     matches = Array.from(textWithoutQuoted.matchAll(unquotedRegex));
 269:     console.log('[extractImagePaths] Unquoted matches:', matches.length);
 270:     
 271:     for (const match of matches) {
 272:       const path = match[1].trim();
 273:       // Skip if it looks like a data URL fragment (shouldn't happen with proper quoting)
 274:       if (path.includes('data:')) continue;
 275:       
 276:       console.log('[extractImagePaths] Processing unquoted path:', path);
 277:       
 278:       // Convert relative path to absolute if needed
 279:       const fullPath = path.startsWith('/') ? path : (projectPath ? `${projectPath}/${path}` : path);
 280:       
 281:       if (isImageFile(fullPath)) {
 282:         pathsSet.add(fullPath);
 283:       }
 284:     }
 285: 
 286:     const uniquePaths = Array.from(pathsSet);
 287:     console.log('[extractImagePaths] Final extracted paths (unique):', uniquePaths.length);
 288:     return uniquePaths;
 289:   };
 290: 
 291:   // Update embedded images when prompt changes
 292:   useEffect(() => {
 293:     console.log('[useEffect] Prompt changed:', prompt);
 294:     const imagePaths = extractImagePaths(prompt);
 295:     console.log('[useEffect] Setting embeddedImages to:', imagePaths);
 296:     setEmbeddedImages(imagePaths);
 297:   }, [prompt, projectPath]);
 298: 
 299:   // Set up Tauri drag-drop event listener
 300:   useEffect(() => {
 301:     // This effect runs only once on component mount to set up the listener.
 302:     let lastDropTime = 0;
 303: 
 304:     const setupListener = async () => {
 305:       try {
 306:         // If a listener from a previous mount/render is still around, clean it up.
 307:         if (unlistenDragDropRef.current) {
 308:           unlistenDragDropRef.current();
 309:         }
 310: 
 311:         const webview = getCurrentWebviewWindow();
 312:         unlistenDragDropRef.current = await webview.onDragDropEvent((event) => {
 313:           if (event.payload.type === 'enter' || event.payload.type === 'over') {
 314:             setDragActive(true);
 315:           } else if (event.payload.type === 'leave') {
 316:             setDragActive(false);
 317:           } else if (event.payload.type === 'drop' && event.payload.paths) {
 318:             setDragActive(false);
 319: 
 320:             const currentTime = Date.now();
 321:             if (currentTime - lastDropTime < 200) {
 322:               // This debounce is crucial to handle the storm of drop events
 323:               // that Tauri/OS can fire for a single user action.
 324:               return;
 325:             }
 326:             lastDropTime = currentTime;
 327: 
 328:             const droppedPaths = event.payload.paths as string[];
 329:             const imagePaths = droppedPaths.filter(isImageFile);
 330: 
 331:             if (imagePaths.length > 0) {
 332:               setPrompt(currentPrompt => {
 333:                 const existingPaths = extractImagePaths(currentPrompt);
 334:                 const newPaths = imagePaths.filter(p => !existingPaths.includes(p));
 335: 
 336:                 if (newPaths.length === 0) {
 337:                   return currentPrompt; // All dropped images are already in the prompt
 338:                 }
 339: 
 340:                 // Wrap paths with spaces in quotes for clarity
 341:                 const mentionsToAdd = newPaths.map(p => {
 342:                   // If path contains spaces, wrap in quotes
 343:                   if (p.includes(' ')) {
 344:                     return `@"${p}"`;
 345:                   }
 346:                   return `@${p}`;
 347:                 }).join(' ');
 348:                 const newPrompt = currentPrompt + (currentPrompt.endsWith(' ') || currentPrompt === '' ? '' : ' ') + mentionsToAdd + ' ';
 349: 
 350:                 setTimeout(() => {
 351:                   const target = isExpanded ? expandedTextareaRef.current : textareaRef.current;
 352:                   target?.focus();
 353:                   target?.setSelectionRange(newPrompt.length, newPrompt.length);
 354:                 }, 0);
 355: 
 356:                 return newPrompt;
 357:               });
 358:             }
 359:           }
 360:         });
 361:       } catch (error) {
 362:         console.error('Failed to set up Tauri drag-drop listener:', error);
 363:       }
 364:     };
 365: 
 366:     setupListener();
 367: 
 368:     return () => {
 369:       // On unmount, ensure we clean up the listener.
 370:       if (unlistenDragDropRef.current) {
 371:         unlistenDragDropRef.current();
 372:         unlistenDragDropRef.current = null;
 373:       }
 374:     };
 375:   }, []); // Empty dependency array ensures this runs only on mount/unmount.
 376: 
 377:   useEffect(() => {
 378:     // Focus the appropriate textarea when expanded state changes
 379:     if (isExpanded && expandedTextareaRef.current) {
 380:       expandedTextareaRef.current.focus();
 381:     } else if (!isExpanded && textareaRef.current) {
 382:       textareaRef.current.focus();
 383:     }
 384:   }, [isExpanded]);
 385: 
 386:   const handleSend = () => {
 387:     if (prompt.trim() && !disabled) {
 388:       let finalPrompt = prompt.trim();
 389:       
 390:       // Append thinking phrase if not auto mode
 391:       const thinkingMode = THINKING_MODES.find(m => m.id === selectedThinkingMode);
 392:       if (thinkingMode && thinkingMode.phrase) {
 393:         finalPrompt = `${finalPrompt}.\n\n${thinkingMode.phrase}.`;
 394:       }
 395:       
 396:       onSend(finalPrompt, selectedModel);
 397:       setPrompt("");
 398:       setEmbeddedImages([]);
 399:     }
 400:   };
 401: 
 402:   const handleTextChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
 403:     const newValue = e.target.value;
 404:     const newCursorPosition = e.target.selectionStart || 0;
 405: 
 406:     // Check if / was just typed at the beginning of input or after whitespace
 407:     if (newValue.length > prompt.length && newValue[newCursorPosition - 1] === '/') {
 408:       // Check if it's at the start or after whitespace
 409:       const isStartOfCommand = newCursorPosition === 1 || 
 410:         (newCursorPosition > 1 && /\s/.test(newValue[newCursorPosition - 2]));
 411:       
 412:       if (isStartOfCommand) {
 413:         console.log('[FloatingPromptInput] / detected for slash command');
 414:         setShowSlashCommandPicker(true);
 415:         setSlashCommandQuery("");
 416:         setCursorPosition(newCursorPosition);
 417:       }
 418:     }
 419: 
 420:     // Check if @ was just typed
 421:     if (projectPath?.trim() && newValue.length > prompt.length && newValue[newCursorPosition - 1] === '@') {
 422:       console.log('[FloatingPromptInput] @ detected, projectPath:', projectPath);
 423:       setShowFilePicker(true);
 424:       setFilePickerQuery("");
 425:       setCursorPosition(newCursorPosition);
 426:     }
 427: 
 428:     // Check if we're typing after / (for slash command search)
 429:     if (showSlashCommandPicker && newCursorPosition >= cursorPosition) {
 430:       // Find the / position before cursor
 431:       let slashPosition = -1;
 432:       for (let i = newCursorPosition - 1; i >= 0; i--) {
 433:         if (newValue[i] === '/') {
 434:           slashPosition = i;
 435:           break;
 436:         }
 437:         // Stop if we hit whitespace (new word)
 438:         if (newValue[i] === ' ' || newValue[i] === '\n') {
 439:           break;
 440:         }
 441:       }
 442: 
 443:       if (slashPosition !== -1) {
 444:         const query = newValue.substring(slashPosition + 1, newCursorPosition);
 445:         setSlashCommandQuery(query);
 446:       } else {
 447:         // / was removed or cursor moved away
 448:         setShowSlashCommandPicker(false);
 449:         setSlashCommandQuery("");
 450:       }
 451:     }
 452: 
 453:     // Check if we're typing after @ (for search query)
 454:     if (showFilePicker && newCursorPosition >= cursorPosition) {
 455:       // Find the @ position before cursor
 456:       let atPosition = -1;
 457:       for (let i = newCursorPosition - 1; i >= 0; i--) {
 458:         if (newValue[i] === '@') {
 459:           atPosition = i;
 460:           break;
 461:         }
 462:         // Stop if we hit whitespace (new word)
 463:         if (newValue[i] === ' ' || newValue[i] === '\n') {
 464:           break;
 465:         }
 466:       }
 467: 
 468:       if (atPosition !== -1) {
 469:         const query = newValue.substring(atPosition + 1, newCursorPosition);
 470:         setFilePickerQuery(query);
 471:       } else {
 472:         // @ was removed or cursor moved away
 473:         setShowFilePicker(false);
 474:         setFilePickerQuery("");
 475:       }
 476:     }
 477: 
 478:     setPrompt(newValue);
 479:     setCursorPosition(newCursorPosition);
 480:   };
 481: 
 482:   const handleFileSelect = (entry: FileEntry) => {
 483:     if (textareaRef.current) {
 484:       // Find the @ position before cursor
 485:       let atPosition = -1;
 486:       for (let i = cursorPosition - 1; i >= 0; i--) {
 487:         if (prompt[i] === '@') {
 488:           atPosition = i;
 489:           break;
 490:         }
 491:         // Stop if we hit whitespace (new word)
 492:         if (prompt[i] === ' ' || prompt[i] === '\n') {
 493:           break;
 494:         }
 495:       }
 496: 
 497:       if (atPosition === -1) {
 498:         // @ not found, this shouldn't happen but handle gracefully
 499:         console.error('[FloatingPromptInput] @ position not found');
 500:         return;
 501:       }
 502: 
 503:       // Replace the @ and partial query with the selected path (file or directory)
 504:       const textarea = textareaRef.current;
 505:       const beforeAt = prompt.substring(0, atPosition);
 506:       const afterCursor = prompt.substring(cursorPosition);
 507:       const relativePath = entry.path.startsWith(projectPath || '')
 508:         ? entry.path.slice((projectPath || '').length + 1)
 509:         : entry.path;
 510: 
 511:       const newPrompt = `${beforeAt}@${relativePath} ${afterCursor}`;
 512:       setPrompt(newPrompt);
 513:       setShowFilePicker(false);
 514:       setFilePickerQuery("");
 515: 
 516:       // Focus back on textarea and set cursor position after the inserted path
 517:       setTimeout(() => {
 518:         textarea.focus();
 519:         const newCursorPos = beforeAt.length + relativePath.length + 2; // +2 for @ and space
 520:         textarea.setSelectionRange(newCursorPos, newCursorPos);
 521:       }, 0);
 522:     }
 523:   };
 524: 
 525:   const handleFilePickerClose = () => {
 526:     setShowFilePicker(false);
 527:     setFilePickerQuery("");
 528:     // Return focus to textarea
 529:     setTimeout(() => {
 530:       textareaRef.current?.focus();
 531:     }, 0);
 532:   };
 533: 
 534:   const handleSlashCommandSelect = (command: SlashCommand) => {
 535:     const textarea = isExpanded ? expandedTextareaRef.current : textareaRef.current;
 536:     if (!textarea) return;
 537: 
 538:     // Find the / position before cursor
 539:     let slashPosition = -1;
 540:     for (let i = cursorPosition - 1; i >= 0; i--) {
 541:       if (prompt[i] === '/') {
 542:         slashPosition = i;
 543:         break;
 544:       }
 545:       // Stop if we hit whitespace (new word)
 546:       if (prompt[i] === ' ' || prompt[i] === '\n') {
 547:         break;
 548:       }
 549:     }
 550: 
 551:     if (slashPosition === -1) {
 552:       console.error('[FloatingPromptInput] / position not found');
 553:       return;
 554:     }
 555: 
 556:     // Simply insert the command syntax
 557:     const beforeSlash = prompt.substring(0, slashPosition);
 558:     const afterCursor = prompt.substring(cursorPosition);
 559:     
 560:     if (command.accepts_arguments) {
 561:       // Insert command with placeholder for arguments
 562:       const newPrompt = `${beforeSlash}${command.full_command} `;
 563:       setPrompt(newPrompt);
 564:       setShowSlashCommandPicker(false);
 565:       setSlashCommandQuery("");
 566: 
 567:       // Focus and position cursor after the command
 568:       setTimeout(() => {
 569:         textarea.focus();
 570:         const newCursorPos = beforeSlash.length + command.full_command.length + 1;
 571:         textarea.setSelectionRange(newCursorPos, newCursorPos);
 572:       }, 0);
 573:     } else {
 574:       // Insert command and close picker
 575:       const newPrompt = `${beforeSlash}${command.full_command} ${afterCursor}`;
 576:       setPrompt(newPrompt);
 577:       setShowSlashCommandPicker(false);
 578:       setSlashCommandQuery("");
 579: 
 580:       // Focus and position cursor after the command
 581:       setTimeout(() => {
 582:         textarea.focus();
 583:         const newCursorPos = beforeSlash.length + command.full_command.length + 1;
 584:         textarea.setSelectionRange(newCursorPos, newCursorPos);
 585:       }, 0);
 586:     }
 587:   };
 588: 
 589:   const handleSlashCommandPickerClose = () => {
 590:     setShowSlashCommandPicker(false);
 591:     setSlashCommandQuery("");
 592:     // Return focus to textarea
 593:     setTimeout(() => {
 594:       const textarea = isExpanded ? expandedTextareaRef.current : textareaRef.current;
 595:       textarea?.focus();
 596:     }, 0);
 597:   };
 598: 
 599:   const handleKeyDown = (e: React.KeyboardEvent) => {
 600:     if (showFilePicker && e.key === 'Escape') {
 601:       e.preventDefault();
 602:       setShowFilePicker(false);
 603:       setFilePickerQuery("");
 604:       return;
 605:     }
 606: 
 607:     if (showSlashCommandPicker && e.key === 'Escape') {
 608:       e.preventDefault();
 609:       setShowSlashCommandPicker(false);
 610:       setSlashCommandQuery("");
 611:       return;
 612:     }
 613: 
 614:     if (e.key === "Enter" && !e.shiftKey && !isExpanded && !showFilePicker && !showSlashCommandPicker) {
 615:       e.preventDefault();
 616:       handleSend();
 617:     }
 618:   };
 619: 
 620:   const handlePaste = async (e: React.ClipboardEvent) => {
 621:     const items = e.clipboardData?.items;
 622:     if (!items) return;
 623: 
 624:     for (const item of items) {
 625:       if (item.type.startsWith('image/')) {
 626:         e.preventDefault();
 627:         
 628:         // Get the image blob
 629:         const blob = item.getAsFile();
 630:         if (!blob) continue;
 631: 
 632:         try {
 633:           // Convert blob to base64
 634:           const reader = new FileReader();
 635:           reader.onload = () => {
 636:             const base64Data = reader.result as string;
 637:             
 638:             // Add the base64 data URL directly to the prompt
 639:             setPrompt(currentPrompt => {
 640:               // Use the data URL directly as the image reference
 641:               const mention = `@"${base64Data}"`;
 642:               const newPrompt = currentPrompt + (currentPrompt.endsWith(' ') || currentPrompt === '' ? '' : ' ') + mention + ' ';
 643:               
 644:               // Focus the textarea and move cursor to end
 645:               setTimeout(() => {
 646:                 const target = isExpanded ? expandedTextareaRef.current : textareaRef.current;
 647:                 target?.focus();
 648:                 target?.setSelectionRange(newPrompt.length, newPrompt.length);
 649:               }, 0);
 650: 
 651:               return newPrompt;
 652:             });
 653:           };
 654:           
 655:           reader.readAsDataURL(blob);
 656:         } catch (error) {
 657:           console.error('Failed to paste image:', error);
 658:         }
 659:       }
 660:     }
 661:   };
 662: 
 663:   // Browser drag and drop handlers - just prevent default behavior
 664:   // Actual file handling is done via Tauri's window-level drag-drop events
 665:   const handleDrag = (e: React.DragEvent) => {
 666:     e.preventDefault();
 667:     e.stopPropagation();
 668:     // Visual feedback is handled by Tauri events
 669:   };
 670: 
 671:   const handleDrop = (e: React.DragEvent) => {
 672:     e.preventDefault();
 673:     e.stopPropagation();
 674:     // File processing is handled by Tauri's onDragDropEvent
 675:   };
 676: 
 677:   const handleRemoveImage = (index: number) => {
 678:     // Remove the corresponding @mention from the prompt
 679:     const imagePath = embeddedImages[index];
 680:     
 681:     // For data URLs, we need to handle them specially since they're always quoted
 682:     if (imagePath.startsWith('data:')) {
 683:       // Simply remove the exact quoted data URL
 684:       const quotedPath = `@"${imagePath}"`;
 685:       const newPrompt = prompt.replace(quotedPath, '').trim();
 686:       setPrompt(newPrompt);
 687:       return;
 688:     }
 689:     
 690:     // For file paths, use the original logic
 691:     const escapedPath = imagePath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
 692:     const escapedRelativePath = imagePath.replace(projectPath + '/', '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
 693:     
 694:     // Create patterns for both quoted and unquoted mentions
 695:     const patterns = [
 696:       // Quoted full path
 697:       new RegExp(`@"${escapedPath}"\\s?`, 'g'),
 698:       // Unquoted full path
 699:       new RegExp(`@${escapedPath}\\s?`, 'g'),
 700:       // Quoted relative path
 701:       new RegExp(`@"${escapedRelativePath}"\\s?`, 'g'),
 702:       // Unquoted relative path
 703:       new RegExp(`@${escapedRelativePath}\\s?`, 'g')
 704:     ];
 705: 
 706:     let newPrompt = prompt;
 707:     for (const pattern of patterns) {
 708:       newPrompt = newPrompt.replace(pattern, '');
 709:     }
 710: 
 711:     setPrompt(newPrompt.trim());
 712:   };
 713: 
 714:   const selectedModelData = MODELS.find(m => m.id === selectedModel) || MODELS[0];
 715: 
 716:   return (
 717:     <>
 718:       {/* Expanded Modal */}
 719:       <AnimatePresence>
 720:         {isExpanded && (
 721:           <motion.div
 722:             initial={{ opacity: 0 }}
 723:             animate={{ opacity: 1 }}
 724:             exit={{ opacity: 0 }}
 725:             className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-background/80 backdrop-blur-sm"
 726:             onClick={() => setIsExpanded(false)}
 727:           >
 728:             <motion.div
 729:               initial={{ scale: 0.95, opacity: 0 }}
 730:               animate={{ scale: 1, opacity: 1 }}
 731:               exit={{ scale: 0.95, opacity: 0 }}
 732:               className="bg-background border border-border rounded-lg shadow-lg w-full max-w-2xl p-4 space-y-4"
 733:               onClick={(e) => e.stopPropagation()}
 734:             >
 735:               <div className="flex items-center justify-between">
 736:                 <h3 className="text-sm font-medium">Compose your prompt</h3>
 737:                 <Button
 738:                   variant="ghost"
 739:                   size="icon"
 740:                   onClick={() => setIsExpanded(false)}
 741:                   className="h-8 w-8"
 742:                 >
 743:                   <Minimize2 className="h-4 w-4" />
 744:                 </Button>
 745:               </div>
 746: 
 747:               {/* Image previews in expanded mode */}
 748:               {embeddedImages.length > 0 && (
 749:                 <ImagePreview
 750:                   images={embeddedImages}
 751:                   onRemove={handleRemoveImage}
 752:                   className="border-t border-border pt-2"
 753:                 />
 754:               )}
 755: 
 756:               <Textarea
 757:                 ref={expandedTextareaRef}
 758:                 value={prompt}
 759:                 onChange={handleTextChange}
 760:                 onPaste={handlePaste}
 761:                 placeholder="Type your prompt here..."
 762:                 className="min-h-[200px] resize-none"
 763:                 disabled={disabled}
 764:                 onDragEnter={handleDrag}
 765:                 onDragLeave={handleDrag}
 766:                 onDragOver={handleDrag}
 767:                 onDrop={handleDrop}
 768:               />
 769: 
 770:               <div className="flex items-center justify-between">
 771:                 <div className="flex items-center gap-4">
 772:                   <div className="flex items-center gap-2">
 773:                     <span className="text-xs text-muted-foreground">Model:</span>
 774:                     <Button
 775:                       variant="outline"
 776:                       size="sm"
 777:                       onClick={() => setModelPickerOpen(!modelPickerOpen)}
 778:                       className="gap-2"
 779:                     >
 780:                       {selectedModelData.icon}
 781:                       {selectedModelData.name}
 782:                     </Button>
 783:                   </div>
 784: 
 785:                   <div className="flex items-center gap-2">
 786:                     <span className="text-xs text-muted-foreground">Thinking:</span>
 787:                     <Popover
 788:                       trigger={
 789:                         <TooltipProvider>
 790:                           <Tooltip>
 791:                             <TooltipTrigger asChild>
 792:                               <Button
 793:                                 variant="outline"
 794:                                 size="sm"
 795:                                 onClick={() => setThinkingModePickerOpen(!thinkingModePickerOpen)}
 796:                                 className="gap-2"
 797:                               >
 798:                                 <Brain className="h-4 w-4" />
 799:                                 <ThinkingModeIndicator 
 800:                                   level={THINKING_MODES.find(m => m.id === selectedThinkingMode)?.level || 0} 
 801:                                 />
 802:                               </Button>
 803:                             </TooltipTrigger>
 804:                             <TooltipContent>
 805:                               <p className="font-medium">{THINKING_MODES.find(m => m.id === selectedThinkingMode)?.name || "Auto"}</p>
 806:                               <p className="text-xs text-muted-foreground">{THINKING_MODES.find(m => m.id === selectedThinkingMode)?.description}</p>
 807:                             </TooltipContent>
 808:                           </Tooltip>
 809:                         </TooltipProvider>
 810:                       }
 811:                       content={
 812:                         <div className="w-[280px] p-1">
 813:                           {THINKING_MODES.map((mode) => (
 814:                             <button
 815:                               key={mode.id}
 816:                               onClick={() => {
 817:                                 setSelectedThinkingMode(mode.id);
 818:                                 setThinkingModePickerOpen(false);
 819:                               }}
 820:                               className={cn(
 821:                                 "w-full flex items-start gap-3 p-3 rounded-md transition-colors text-left",
 822:                                 "hover:bg-accent",
 823:                                 selectedThinkingMode === mode.id && "bg-accent"
 824:                               )}
 825:                             >
 826:                               <Brain className="h-4 w-4 mt-0.5" />
 827:                               <div className="flex-1 space-y-1">
 828:                                 <div className="font-medium text-sm">
 829:                                   {mode.name}
 830:                                 </div>
 831:                                 <div className="text-xs text-muted-foreground">
 832:                                   {mode.description}
 833:                                 </div>
 834:                               </div>
 835:                               <ThinkingModeIndicator level={mode.level} />
 836:                             </button>
 837:                           ))}
 838:                         </div>
 839:                       }
 840:                       open={thinkingModePickerOpen}
 841:                       onOpenChange={setThinkingModePickerOpen}
 842:                       align="start"
 843:                       side="top"
 844:                     />
 845:                   </div>
 846:                 </div>
 847: 
 848:                 <Button
 849:                   onClick={handleSend}
 850:                   disabled={!prompt.trim() || disabled}
 851:                   size="default"
 852:                   className="min-w-[60px]"
 853:                 >
 854:                   {isLoading ? (
 855:                     <div className="rotating-symbol text-primary-foreground" />
 856:                   ) : (
 857:                     <Send className="h-4 w-4" />
 858:                   )}
 859:                 </Button>
 860:               </div>
 861:             </motion.div>
 862:           </motion.div>
 863:         )}
 864:       </AnimatePresence>
 865: 
 866:       {/* Fixed Position Input Bar */}
 867:       <div
 868:         className={cn(
 869:           "fixed bottom-0 left-0 right-0 z-40 bg-background border-t border-border",
 870:           dragActive && "ring-2 ring-primary ring-offset-2",
 871:           className
 872:         )}
 873:         onDragEnter={handleDrag}
 874:         onDragLeave={handleDrag}
 875:         onDragOver={handleDrag}
 876:         onDrop={handleDrop}
 877:       >
 878:         <div className="max-w-5xl mx-auto">
 879:           {/* Image previews */}
 880:           {embeddedImages.length > 0 && (
 881:             <ImagePreview
 882:               images={embeddedImages}
 883:               onRemove={handleRemoveImage}
 884:               className="border-b border-border"
 885:             />
 886:           )}
 887: 
 888:           <div className="p-4">
 889:             <div className="flex items-end gap-3">
 890:               {/* Model Picker */}
 891:               <Popover
 892:                 trigger={
 893:                   <Button
 894:                     variant="outline"
 895:                     size="default"
 896:                     disabled={disabled}
 897:                     className="gap-2 min-w-[180px] justify-start"
 898:                   >
 899:                     {selectedModelData.icon}
 900:                     <span className="flex-1 text-left">{selectedModelData.name}</span>
 901:                     <ChevronUp className="h-4 w-4 opacity-50" />
 902:                   </Button>
 903:                 }
 904:                 content={
 905:                   <div className="w-[300px] p-1">
 906:                     {MODELS.map((model) => (
 907:                       <button
 908:                         key={model.id}
 909:                         onClick={() => {
 910:                           setSelectedModel(model.id);
 911:                           setModelPickerOpen(false);
 912:                         }}
 913:                         className={cn(
 914:                           "w-full flex items-start gap-3 p-3 rounded-md transition-colors text-left",
 915:                           "hover:bg-accent",
 916:                           selectedModel === model.id && "bg-accent"
 917:                         )}
 918:                       >
 919:                         <div className="mt-0.5">{model.icon}</div>
 920:                         <div className="flex-1 space-y-1">
 921:                           <div className="font-medium text-sm">{model.name}</div>
 922:                           <div className="text-xs text-muted-foreground">
 923:                             {model.description}
 924:                           </div>
 925:                         </div>
 926:                       </button>
 927:                     ))}
 928:                   </div>
 929:                 }
 930:                 open={modelPickerOpen}
 931:                 onOpenChange={setModelPickerOpen}
 932:                 align="start"
 933:                 side="top"
 934:               />
 935: 
 936:               {/* Thinking Mode Picker */}
 937:               <Popover
 938:                 trigger={
 939:                   <TooltipProvider>
 940:                     <Tooltip>
 941:                       <TooltipTrigger asChild>
 942:                         <Button
 943:                           variant="outline"
 944:                           size="default"
 945:                           disabled={disabled}
 946:                           className="gap-2"
 947:                         >
 948:                           <Brain className="h-4 w-4" />
 949:                           <ThinkingModeIndicator 
 950:                             level={THINKING_MODES.find(m => m.id === selectedThinkingMode)?.level || 0} 
 951:                           />
 952:                         </Button>
 953:                       </TooltipTrigger>
 954:                       <TooltipContent>
 955:                         <p className="font-medium">{THINKING_MODES.find(m => m.id === selectedThinkingMode)?.name || "Auto"}</p>
 956:                         <p className="text-xs text-muted-foreground">{THINKING_MODES.find(m => m.id === selectedThinkingMode)?.description}</p>
 957:                       </TooltipContent>
 958:                     </Tooltip>
 959:                   </TooltipProvider>
 960:                 }
 961:                 content={
 962:                   <div className="w-[280px] p-1">
 963:                     {THINKING_MODES.map((mode) => (
 964:                       <button
 965:                         key={mode.id}
 966:                         onClick={() => {
 967:                           setSelectedThinkingMode(mode.id);
 968:                           setThinkingModePickerOpen(false);
 969:                         }}
 970:                         className={cn(
 971:                           "w-full flex items-start gap-3 p-3 rounded-md transition-colors text-left",
 972:                           "hover:bg-accent",
 973:                           selectedThinkingMode === mode.id && "bg-accent"
 974:                         )}
 975:                       >
 976:                         <Brain className="h-4 w-4 mt-0.5" />
 977:                         <div className="flex-1 space-y-1">
 978:                           <div className="font-medium text-sm">
 979:                             {mode.name}
 980:                           </div>
 981:                           <div className="text-xs text-muted-foreground">
 982:                             {mode.description}
 983:                           </div>
 984:                         </div>
 985:                         <ThinkingModeIndicator level={mode.level} />
 986:                       </button>
 987:                     ))}
 988:                   </div>
 989:                 }
 990:                 open={thinkingModePickerOpen}
 991:                 onOpenChange={setThinkingModePickerOpen}
 992:                 align="start"
 993:                 side="top"
 994:               />
 995: 
 996:               {/* Prompt Input */}
 997:               <div className="flex-1 relative">
 998:                 <Textarea
 999:                   ref={textareaRef}
1000:                   value={prompt}
1001:                   onChange={handleTextChange}
1002:                   onKeyDown={handleKeyDown}
1003:                   onPaste={handlePaste}
1004:                   placeholder={dragActive ? "Drop images here..." : "Ask Claude anything..."}
1005:                   disabled={disabled}
1006:                   className={cn(
1007:                     "min-h-[44px] max-h-[120px] resize-none pr-10",
1008:                     dragActive && "border-primary"
1009:                   )}
1010:                   rows={1}
1011:                 />
1012: 
1013:                 <Button
1014:                   variant="ghost"
1015:                   size="icon"
1016:                   onClick={() => setIsExpanded(true)}
1017:                   disabled={disabled}
1018:                   className="absolute right-1 bottom-1 h-8 w-8"
1019:                 >
1020:                   <Maximize2 className="h-4 w-4" />
1021:                 </Button>
1022: 
1023:                 {/* File Picker */}
1024:                 <AnimatePresence>
1025:                   {showFilePicker && projectPath && projectPath.trim() && (
1026:                     <FilePicker
1027:                       basePath={projectPath.trim()}
1028:                       onSelect={handleFileSelect}
1029:                       onClose={handleFilePickerClose}
1030:                       initialQuery={filePickerQuery}
1031:                     />
1032:                   )}
1033:                 </AnimatePresence>
1034: 
1035:                 {/* Slash Command Picker */}
1036:                 <AnimatePresence>
1037:                   {showSlashCommandPicker && (
1038:                     <SlashCommandPicker
1039:                       projectPath={projectPath}
1040:                       onSelect={handleSlashCommandSelect}
1041:                       onClose={handleSlashCommandPickerClose}
1042:                       initialQuery={slashCommandQuery}
1043:                     />
1044:                   )}
1045:                 </AnimatePresence>
1046:               </div>
1047: 
1048:               {/* Send/Stop Button */}
1049:               <Button
1050:                 onClick={isLoading ? onCancel : handleSend}
1051:                 disabled={isLoading ? false : (!prompt.trim() || disabled)}
1052:                 variant={isLoading ? "destructive" : "default"}
1053:                 size="default"
1054:                 className="min-w-[60px]"
1055:               >
1056:                 {isLoading ? (
1057:                   <>
1058:                     <Square className="h-4 w-4 mr-1" />
1059:                     Stop
1060:                   </>
1061:                 ) : (
1062:                   <Send className="h-4 w-4" />
1063:                 )}
1064:               </Button>
1065:             </div>
1066: 
1067:             <div className="mt-2 text-xs text-muted-foreground">
1068:               Press Enter to send, Shift+Enter for new line{projectPath?.trim() && ", @ to mention files, / for commands, drag & drop or paste images"}
1069:             </div>
1070:           </div>
1071:         </div>
1072:       </div>
1073:     </>
1074:   );
1075: };
1076: 
1077: export const FloatingPromptInput = React.forwardRef<
1078:   FloatingPromptInputRef,
1079:   FloatingPromptInputProps
1080: >(FloatingPromptInputInner);
1081: 
1082: FloatingPromptInput.displayName = 'FloatingPromptInput';
````

## File: src/components/GitHubAgentBrowser.tsx
````typescript
  1: import React, { useState, useEffect } from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import {
  4:   Search,
  5:   Download,
  6:   Loader2,
  7:   AlertCircle,
  8:   Eye,
  9:   Check,
 10:   Globe,
 11:   FileJson,
 12: } from "lucide-react";
 13: import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
 14: import { Button } from "@/components/ui/button";
 15: import { Input } from "@/components/ui/input";
 16: import { Card, CardContent, CardFooter } from "@/components/ui/card";
 17: import { Badge } from "@/components/ui/badge";
 18: import { api, type GitHubAgentFile, type AgentExport, type Agent } from "@/lib/api";
 19: import { type AgentIconName } from "./CCAgents";
 20: import { ICON_MAP } from "./IconPicker";
 21: import { open } from "@tauri-apps/plugin-shell";
 22: 
 23: interface GitHubAgentBrowserProps {
 24:   isOpen: boolean;
 25:   onClose: () => void;
 26:   onImportSuccess: () => void;
 27: }
 28: 
 29: interface AgentPreview {
 30:   file: GitHubAgentFile;
 31:   data: AgentExport | null;
 32:   loading: boolean;
 33:   error: string | null;
 34: }
 35: 
 36: export const GitHubAgentBrowser: React.FC<GitHubAgentBrowserProps> = ({
 37:   isOpen,
 38:   onClose,
 39:   onImportSuccess,
 40: }) => {
 41:   const [agents, setAgents] = useState<GitHubAgentFile[]>([]);
 42:   const [loading, setLoading] = useState(true);
 43:   const [error, setError] = useState<string | null>(null);
 44:   const [searchQuery, setSearchQuery] = useState("");
 45:   const [selectedAgent, setSelectedAgent] = useState<AgentPreview | null>(null);
 46:   const [importing, setImporting] = useState(false);
 47:   const [existingAgents, setExistingAgents] = useState<Agent[]>([]);
 48: 
 49:   useEffect(() => {
 50:     if (isOpen) {
 51:       fetchAgents();
 52:       fetchExistingAgents();
 53:     }
 54:   }, [isOpen]);
 55: 
 56:   const fetchExistingAgents = async () => {
 57:     try {
 58:       const agents = await api.listAgents();
 59:       setExistingAgents(agents);
 60:     } catch (err) {
 61:       console.error("Failed to fetch existing agents:", err);
 62:     }
 63:   };
 64: 
 65:   const fetchAgents = async () => {
 66:     try {
 67:       setLoading(true);
 68:       setError(null);
 69:       const agentFiles = await api.fetchGitHubAgents();
 70:       setAgents(agentFiles);
 71:     } catch (err) {
 72:       console.error("Failed to fetch GitHub agents:", err);
 73:       setError("Failed to fetch agents from GitHub. Please check your internet connection.");
 74:     } finally {
 75:       setLoading(false);
 76:     }
 77:   };
 78: 
 79:   const handlePreviewAgent = async (file: GitHubAgentFile) => {
 80:     setSelectedAgent({
 81:       file,
 82:       data: null,
 83:       loading: true,
 84:       error: null,
 85:     });
 86: 
 87:     try {
 88:       const agentData = await api.fetchGitHubAgentContent(file.download_url);
 89:       setSelectedAgent({
 90:         file,
 91:         data: agentData,
 92:         loading: false,
 93:         error: null,
 94:       });
 95:     } catch (err) {
 96:       console.error("Failed to fetch agent content:", err);
 97:       setSelectedAgent({
 98:         file,
 99:         data: null,
100:         loading: false,
101:         error: "Failed to load agent details",
102:       });
103:     }
104:   };
105: 
106:   const isAgentImported = (fileName: string) => {
107:     const agentName = getAgentDisplayName(fileName);
108:     return existingAgents.some(agent => 
109:       agent.name.toLowerCase() === agentName.toLowerCase()
110:     );
111:   };
112: 
113:   const handleImportAgent = async () => {
114:     if (!selectedAgent?.file) return;
115: 
116:     try {
117:       setImporting(true);
118:       await api.importAgentFromGitHub(selectedAgent.file.download_url);
119:       
120:       // Refresh existing agents list
121:       await fetchExistingAgents();
122:       
123:       // Close preview
124:       setSelectedAgent(null);
125:       
126:       // Notify parent
127:       onImportSuccess();
128:     } catch (err) {
129:       console.error("Failed to import agent:", err);
130:       alert(`Failed to import agent: ${err instanceof Error ? err.message : "Unknown error"}`);
131:     } finally {
132:       setImporting(false);
133:     }
134:   };
135: 
136:   const filteredAgents = agents.filter(agent =>
137:     agent.name.toLowerCase().includes(searchQuery.toLowerCase())
138:   );
139: 
140:   const getAgentDisplayName = (fileName: string) => {
141:     return fileName.replace(".claudia.json", "").replace(/-/g, " ")
142:       .split(" ")
143:       .map(word => word.charAt(0).toUpperCase() + word.slice(1))
144:       .join(" ");
145:   };
146: 
147:   const renderIcon = (iconName: string) => {
148:     const Icon = ICON_MAP[iconName as AgentIconName] || ICON_MAP.bot;
149:     return <Icon className="h-8 w-8" />;
150:   };
151: 
152:   const handleGitHubLinkClick = async (e: React.MouseEvent) => {
153:     e.preventDefault();
154:     try {
155:       await open("https://github.com/getAsterisk/claudia/tree/main/cc_agents");
156:     } catch (error) {
157:       console.error('Failed to open GitHub link:', error);
158:     }
159:   };
160: 
161:   return (
162:     <Dialog open={isOpen} onOpenChange={onClose}>
163:       <DialogContent className="max-w-4xl max-h-[80vh] overflow-hidden flex flex-col">
164:         <DialogHeader>
165:           <DialogTitle className="flex items-center gap-2">
166:             <Globe className="h-5 w-5" />
167:             Import Agent from GitHub
168:           </DialogTitle>
169:         </DialogHeader>
170: 
171:         <div className="flex-1 overflow-hidden flex flex-col">
172:           {/* Repository Info */}
173:           <div className="px-4 py-3 bg-muted/50 rounded-lg mb-4">
174:             <p className="text-sm text-muted-foreground">
175:               Agents are fetched from{" "}
176:               <button
177:                 onClick={handleGitHubLinkClick}
178:                 className="text-primary hover:underline inline-flex items-center gap-1"
179:               >
180:                 github.com/getAsterisk/claudia/cc_agents
181:                 <Globe className="h-3 w-3" />
182:               </button>
183:             </p>
184:             <p className="text-sm text-muted-foreground mt-1">
185:               You can contribute your custom agents to the repository!
186:             </p>
187:           </div>
188: 
189:           {/* Search Bar */}
190:           <div className="mb-4">
191:             <div className="relative">
192:               <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
193:               <Input
194:                 placeholder="Search agents..."
195:                 value={searchQuery}
196:                 onChange={(e) => setSearchQuery(e.target.value)}
197:                 className="pl-10"
198:               />
199:             </div>
200:           </div>
201: 
202:           {/* Content */}
203:           <div className="flex-1 overflow-y-auto">
204:             {loading ? (
205:               <div className="flex items-center justify-center h-64">
206:                 <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
207:               </div>
208:             ) : error ? (
209:               <div className="flex flex-col items-center justify-center h-64 text-center">
210:                 <AlertCircle className="h-12 w-12 text-destructive mb-4" />
211:                 <p className="text-sm text-muted-foreground mb-4">{error}</p>
212:                 <Button onClick={fetchAgents} variant="outline" size="sm">
213:                   Try Again
214:                 </Button>
215:               </div>
216:             ) : filteredAgents.length === 0 ? (
217:               <div className="flex flex-col items-center justify-center h-64 text-center">
218:                 <FileJson className="h-12 w-12 text-muted-foreground mb-4" />
219:                 <p className="text-sm text-muted-foreground">
220:                   {searchQuery ? "No agents found matching your search" : "No agents available"}
221:                 </p>
222:               </div>
223:             ) : (
224:               <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 pb-4">
225:                 <AnimatePresence mode="popLayout">
226:                   {filteredAgents.map((agent, index) => (
227:                     <motion.div
228:                       key={agent.sha}
229:                       initial={{ opacity: 0, scale: 0.9 }}
230:                       animate={{ opacity: 1, scale: 1 }}
231:                       exit={{ opacity: 0, scale: 0.9 }}
232:                       transition={{ duration: 0.2, delay: index * 0.05 }}
233:                     >
234:                       <Card className="h-full hover:shadow-lg transition-shadow cursor-pointer"
235:                             onClick={() => handlePreviewAgent(agent)}>
236:                         <CardContent className="p-4">
237:                           <div className="flex items-start justify-between mb-3">
238:                             <div className="flex items-center gap-3 flex-1">
239:                               <div className="p-2 rounded-lg bg-primary/10 text-primary flex-shrink-0">
240:                                 {/* Default to bot icon for now, will be loaded from preview */}
241:                                 {(() => {
242:                                   const Icon = ICON_MAP.bot;
243:                                   return <Icon className="h-6 w-6" />;
244:                                 })()}
245:                               </div>
246:                               <h3 className="text-sm font-semibold line-clamp-2">
247:                                 {getAgentDisplayName(agent.name)}
248:                               </h3>
249:                             </div>
250:                             {isAgentImported(agent.name) && (
251:                               <Badge variant="secondary" className="ml-2 flex-shrink-0">
252:                                 <Check className="h-3 w-3 mr-1" />
253:                                 Imported
254:                               </Badge>
255:                             )}
256:                           </div>
257:                           <p className="text-xs text-muted-foreground">
258:                             {(agent.size / 1024).toFixed(1)} KB
259:                           </p>
260:                         </CardContent>
261:                         <CardFooter className="p-4 pt-0">
262:                           <Button
263:                             size="sm"
264:                             variant="outline"
265:                             className="w-full"
266:                             onClick={(e) => {
267:                               e.stopPropagation();
268:                               handlePreviewAgent(agent);
269:                             }}
270:                           >
271:                             <Eye className="h-3 w-3 mr-2" />
272:                             Preview
273:                           </Button>
274:                         </CardFooter>
275:                       </Card>
276:                     </motion.div>
277:                   ))}
278:                 </AnimatePresence>
279:               </div>
280:             )}
281:           </div>
282:         </div>
283:       </DialogContent>
284: 
285:       {/* Agent Preview Dialog */}
286:       <AnimatePresence>
287:         {selectedAgent && (
288:           <Dialog open={!!selectedAgent} onOpenChange={() => setSelectedAgent(null)}>
289:             <DialogContent className="max-w-2xl max-h-[80vh] overflow-hidden flex flex-col">
290:               <DialogHeader>
291:                 <DialogTitle>Agent Preview</DialogTitle>
292:               </DialogHeader>
293: 
294:               <div className="flex-1 overflow-y-auto">
295:                 {selectedAgent.loading ? (
296:                   <div className="flex items-center justify-center h-64">
297:                     <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
298:                   </div>
299:                 ) : selectedAgent.error ? (
300:                   <div className="flex flex-col items-center justify-center h-64 text-center">
301:                     <AlertCircle className="h-12 w-12 text-destructive mb-4" />
302:                     <p className="text-sm text-muted-foreground">{selectedAgent.error}</p>
303:                   </div>
304:                 ) : selectedAgent.data ? (
305:                   <div className="space-y-4">
306:                     {/* Agent Info */}
307:                     <div className="flex items-start gap-4">
308:                       <div className="p-3 rounded-lg bg-primary/10 text-primary">
309:                         {renderIcon(selectedAgent.data.agent.icon)}
310:                       </div>
311:                       <div className="flex-1">
312:                         <h3 className="text-lg font-semibold">
313:                           {selectedAgent.data.agent.name}
314:                         </h3>
315:                         <div className="flex items-center gap-2 mt-1">
316:                           <Badge variant="outline">{selectedAgent.data.agent.model}</Badge>
317:                         </div>
318:                       </div>
319:                     </div>
320: 
321:                     {/* System Prompt */}
322:                     <div>
323:                       <h4 className="text-sm font-medium mb-2">System Prompt</h4>
324:                       <div className="bg-muted rounded-lg p-3 max-h-48 overflow-y-auto">
325:                         <pre className="text-xs whitespace-pre-wrap font-mono">
326:                           {selectedAgent.data.agent.system_prompt}
327:                         </pre>
328:                       </div>
329:                     </div>
330: 
331:                     {/* Default Task */}
332:                     {selectedAgent.data.agent.default_task && (
333:                       <div>
334:                         <h4 className="text-sm font-medium mb-2">Default Task</h4>
335:                         <div className="bg-muted rounded-lg p-3">
336:                           <p className="text-sm">{selectedAgent.data.agent.default_task}</p>
337:                         </div>
338:                       </div>
339:                     )}
340: 
341: 
342: 
343:                     {/* Metadata */}
344:                     <div className="text-xs text-muted-foreground">
345:                       <p>Version: {selectedAgent.data.version}</p>
346:                       <p>Exported: {new Date(selectedAgent.data.exported_at).toLocaleDateString()}</p>
347:                     </div>
348:                   </div>
349:                 ) : null}
350:               </div>
351: 
352:               {/* Actions */}
353:               {selectedAgent.data && (
354:                 <div className="flex justify-end gap-2 mt-4 pt-4 border-t">
355:                   <Button
356:                     variant="outline"
357:                     onClick={() => setSelectedAgent(null)}
358:                   >
359:                     Cancel
360:                   </Button>
361:                   <Button
362:                     onClick={handleImportAgent}
363:                     disabled={importing || isAgentImported(selectedAgent.file.name)}
364:                   >
365:                     {importing ? (
366:                       <>
367:                         <Loader2 className="h-4 w-4 mr-2 animate-spin" />
368:                         Importing...
369:                       </>
370:                     ) : isAgentImported(selectedAgent.file.name) ? (
371:                       <>
372:                         <Check className="h-4 w-4 mr-2" />
373:                         Already Imported
374:                       </>
375:                     ) : (
376:                       <>
377:                         <Download className="h-4 w-4 mr-2" />
378:                         Import Agent
379:                       </>
380:                     )}
381:                   </Button>
382:                 </div>
383:               )}
384:             </DialogContent>
385:           </Dialog>
386:         )}
387:       </AnimatePresence>
388:     </Dialog>
389:   );
390: };
````

## File: src/components/HooksEditor.tsx
````typescript
  1: /**
  2:  * HooksEditor component for managing Claude Code hooks configuration
  3:  */
  4: 
  5: import React, { useState, useEffect } from 'react';
  6: import { motion, AnimatePresence } from 'framer-motion';
  7: import { 
  8:   Plus, 
  9:   Trash2, 
 10:   AlertTriangle, 
 11:   Code2,
 12:   Terminal,
 13:   FileText,
 14:   ChevronRight,
 15:   ChevronDown,
 16:   Clock,
 17:   Zap,
 18:   Shield,
 19:   PlayCircle,
 20:   Info,
 21:   Save,
 22:   Loader2
 23: } from 'lucide-react';
 24: import { Button } from '@/components/ui/button';
 25: import { Input } from '@/components/ui/input';
 26: import { Label } from '@/components/ui/label';
 27: import { Card } from '@/components/ui/card';
 28: import { Tabs, TabsList, TabsTrigger, TabsContent } from '@/components/ui/tabs';
 29: import { Textarea } from '@/components/ui/textarea';
 30: import { Badge } from '@/components/ui/badge';
 31: import { 
 32:   Select,
 33:   SelectContent,
 34:   SelectItem,
 35:   SelectTrigger,
 36:   SelectValue,
 37: } from '@/components/ui/select';
 38: import {
 39:   Dialog,
 40:   DialogContent,
 41:   DialogDescription,
 42:   DialogHeader,
 43:   DialogTitle,
 44: } from '@/components/ui/dialog';
 45: import {
 46:   Tooltip,
 47:   TooltipContent,
 48:   TooltipProvider,
 49:   TooltipTrigger,
 50: } from '@/components/ui/tooltip';
 51: import { cn } from '@/lib/utils';
 52: import { HooksManager } from '@/lib/hooksManager';
 53: import { api } from '@/lib/api';
 54: import {
 55:   HooksConfiguration,
 56:   HookEvent,
 57:   HookMatcher,
 58:   HookCommand,
 59:   HookTemplate,
 60:   COMMON_TOOL_MATCHERS,
 61:   HOOK_TEMPLATES,
 62: } from '@/types/hooks';
 63: 
 64: interface HooksEditorProps {
 65:   projectPath?: string;
 66:   scope: 'project' | 'local' | 'user';
 67:   readOnly?: boolean;
 68:   className?: string;
 69:   onChange?: (hasChanges: boolean, getHooks: () => HooksConfiguration) => void;
 70:   hideActions?: boolean;
 71: }
 72: 
 73: interface EditableHookCommand extends HookCommand {
 74:   id: string;
 75: }
 76: 
 77: interface EditableHookMatcher extends Omit<HookMatcher, 'hooks'> {
 78:   id: string;
 79:   hooks: EditableHookCommand[];
 80:   expanded?: boolean;
 81: }
 82: 
 83: const EVENT_INFO: Record<HookEvent, { label: string; description: string; icon: React.ReactNode }> = {
 84:   PreToolUse: {
 85:     label: 'Pre Tool Use',
 86:     description: 'Runs before tool calls, can block and provide feedback',
 87:     icon: <Shield className="h-4 w-4" />
 88:   },
 89:   PostToolUse: {
 90:     label: 'Post Tool Use',
 91:     description: 'Runs after successful tool completion',
 92:     icon: <PlayCircle className="h-4 w-4" />
 93:   },
 94:   Notification: {
 95:     label: 'Notification',
 96:     description: 'Customizes notifications when Claude needs attention',
 97:     icon: <Zap className="h-4 w-4" />
 98:   },
 99:   Stop: {
100:     label: 'Stop',
101:     description: 'Runs when Claude finishes responding',
102:     icon: <Code2 className="h-4 w-4" />
103:   },
104:   SubagentStop: {
105:     label: 'Subagent Stop',
106:     description: 'Runs when a Claude subagent (Task) finishes',
107:     icon: <Terminal className="h-4 w-4" />
108:   }
109: };
110: 
111: export const HooksEditor: React.FC<HooksEditorProps> = ({
112:   projectPath,
113:   scope,
114:   readOnly = false,
115:   className,
116:   onChange,
117:   hideActions = false
118: }) => {
119:   const [selectedEvent, setSelectedEvent] = useState<HookEvent>('PreToolUse');
120:   const [showTemplateDialog, setShowTemplateDialog] = useState(false);
121:   const [validationErrors, setValidationErrors] = useState<string[]>([]);
122:   const [validationWarnings, setValidationWarnings] = useState<string[]>([]);
123:   const isInitialMount = React.useRef(true);
124:   const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
125:   const [isSaving, setIsSaving] = useState(false);
126:   const [isLoading, setIsLoading] = useState(false);
127:   const [loadError, setLoadError] = useState<string | null>(null);
128:   const [hooks, setHooks] = useState<HooksConfiguration>({});
129:   
130:   // Events with matchers (tool-related)
131:   const matcherEvents = ['PreToolUse', 'PostToolUse'] as const;
132:   // Events without matchers (non-tool-related)
133:   const directEvents = ['Notification', 'Stop', 'SubagentStop'] as const;
134:   
135:   // Convert hooks to editable format with IDs
136:   const [editableHooks, setEditableHooks] = useState<{
137:     PreToolUse: EditableHookMatcher[];
138:     PostToolUse: EditableHookMatcher[];
139:     Notification: EditableHookCommand[];
140:     Stop: EditableHookCommand[];
141:     SubagentStop: EditableHookCommand[];
142:   }>(() => {
143:     const result = {
144:       PreToolUse: [],
145:       PostToolUse: [],
146:       Notification: [],
147:       Stop: [],
148:       SubagentStop: []
149:     } as any;
150:     
151:     // Initialize matcher events
152:     matcherEvents.forEach(event => {
153:       const matchers = hooks?.[event] as HookMatcher[] | undefined;
154:       if (matchers && Array.isArray(matchers)) {
155:         result[event] = matchers.map(matcher => ({
156:           ...matcher,
157:           id: HooksManager.generateId(),
158:           expanded: false,
159:           hooks: (matcher.hooks || []).map(hook => ({
160:             ...hook,
161:             id: HooksManager.generateId()
162:           }))
163:         }));
164:       }
165:     });
166:     
167:     // Initialize direct events
168:     directEvents.forEach(event => {
169:       const commands = hooks?.[event] as HookCommand[] | undefined;
170:       if (commands && Array.isArray(commands)) {
171:         result[event] = commands.map(hook => ({
172:           ...hook,
173:           id: HooksManager.generateId()
174:         }));
175:       }
176:     });
177:     
178:     return result;
179:   });
180: 
181:   // Load hooks when projectPath or scope changes
182:   useEffect(() => {
183:     // For user scope, we don't need a projectPath
184:     if (scope === 'user' || projectPath) {
185:       setIsLoading(true);
186:       setLoadError(null);
187:       
188:       api.getHooksConfig(scope, projectPath)
189:         .then((config) => {
190:           setHooks(config || {});
191:           setHasUnsavedChanges(false);
192:         })
193:         .catch((err) => {
194:           console.error("Failed to load hooks configuration:", err);
195:           setLoadError(err instanceof Error ? err.message : "Failed to load hooks configuration");
196:           setHooks({});
197:         })
198:         .finally(() => {
199:           setIsLoading(false);
200:         });
201:     } else {
202:       // No projectPath for project/local scopes
203:       setHooks({});
204:     }
205:   }, [projectPath, scope]);
206: 
207:   // Reset initial mount flag when hooks prop changes
208:   useEffect(() => {
209:     isInitialMount.current = true;
210:     setHasUnsavedChanges(false); // Reset unsaved changes when hooks prop changes
211:     
212:     // Reinitialize editable hooks when hooks prop changes
213:     const result = {
214:       PreToolUse: [],
215:       PostToolUse: [],
216:       Notification: [],
217:       Stop: [],
218:       SubagentStop: []
219:     } as any;
220:     
221:     // Initialize matcher events
222:     matcherEvents.forEach(event => {
223:       const matchers = hooks?.[event] as HookMatcher[] | undefined;
224:       if (matchers && Array.isArray(matchers)) {
225:         result[event] = matchers.map(matcher => ({
226:           ...matcher,
227:           id: HooksManager.generateId(),
228:           expanded: false,
229:           hooks: (matcher.hooks || []).map(hook => ({
230:             ...hook,
231:             id: HooksManager.generateId()
232:           }))
233:         }));
234:       }
235:     });
236:     
237:     // Initialize direct events
238:     directEvents.forEach(event => {
239:       const commands = hooks?.[event] as HookCommand[] | undefined;
240:       if (commands && Array.isArray(commands)) {
241:         result[event] = commands.map(hook => ({
242:           ...hook,
243:           id: HooksManager.generateId()
244:         }));
245:       }
246:     });
247:     
248:     setEditableHooks(result);
249:   }, [hooks]);
250: 
251:   // Track changes when editable hooks change (but don't save automatically)
252:   useEffect(() => {
253:     if (isInitialMount.current) {
254:       isInitialMount.current = false;
255:       return;
256:     }
257:     
258:     setHasUnsavedChanges(true);
259:   }, [editableHooks]);
260: 
261:   // Notify parent of changes
262:   useEffect(() => {
263:     if (onChange) {
264:       const getHooks = () => {
265:         const newHooks: HooksConfiguration = {};
266:         
267:         // Handle matcher events
268:         matcherEvents.forEach(event => {
269:           const matchers = editableHooks[event];
270:           if (matchers.length > 0) {
271:             newHooks[event] = matchers.map(({ id, expanded, ...matcher }) => ({
272:               ...matcher,
273:               hooks: matcher.hooks.map(({ id, ...hook }) => hook)
274:             }));
275:           }
276:         });
277:         
278:         // Handle direct events
279:         directEvents.forEach(event => {
280:           const commands = editableHooks[event];
281:           if (commands.length > 0) {
282:             newHooks[event] = commands.map(({ id, ...hook }) => hook);
283:           }
284:         });
285:         
286:         return newHooks;
287:       };
288:       
289:       onChange(hasUnsavedChanges, getHooks);
290:     }
291:   }, [hasUnsavedChanges, editableHooks, onChange]);
292: 
293:   // Save function to be called explicitly
294:   const handleSave = async () => {
295:     if (scope !== 'user' && !projectPath) return;
296:     
297:     setIsSaving(true);
298:     
299:     const newHooks: HooksConfiguration = {};
300:     
301:     // Handle matcher events
302:     matcherEvents.forEach(event => {
303:       const matchers = editableHooks[event];
304:       if (matchers.length > 0) {
305:         newHooks[event] = matchers.map(({ id, expanded, ...matcher }) => ({
306:           ...matcher,
307:           hooks: matcher.hooks.map(({ id, ...hook }) => hook)
308:         }));
309:       }
310:     });
311:     
312:     // Handle direct events
313:     directEvents.forEach(event => {
314:       const commands = editableHooks[event];
315:       if (commands.length > 0) {
316:         newHooks[event] = commands.map(({ id, ...hook }) => hook);
317:       }
318:     });
319:     
320:     try {
321:       await api.updateHooksConfig(scope, newHooks, projectPath);
322:       setHooks(newHooks);
323:       setHasUnsavedChanges(false);
324:     } catch (error) {
325:       console.error('Failed to save hooks:', error);
326:       setLoadError(error instanceof Error ? error.message : 'Failed to save hooks');
327:     } finally {
328:       setIsSaving(false);
329:     }
330:   };
331: 
332:   const addMatcher = (event: HookEvent) => {
333:     // Only for events with matchers
334:     if (!matcherEvents.includes(event as any)) return;
335:     
336:     const newMatcher: EditableHookMatcher = {
337:       id: HooksManager.generateId(),
338:       matcher: '',
339:       hooks: [],
340:       expanded: true
341:     };
342:     
343:     setEditableHooks(prev => ({
344:       ...prev,
345:       [event]: [...(prev[event as 'PreToolUse' | 'PostToolUse'] as EditableHookMatcher[]), newMatcher]
346:     }));
347:   };
348:   
349:   const addDirectCommand = (event: HookEvent) => {
350:     // Only for events without matchers
351:     if (!directEvents.includes(event as any)) return;
352:     
353:     const newCommand: EditableHookCommand = {
354:       id: HooksManager.generateId(),
355:       type: 'command',
356:       command: ''
357:     };
358:     
359:     setEditableHooks(prev => ({
360:       ...prev,
361:       [event]: [...(prev[event as 'Notification' | 'Stop' | 'SubagentStop'] as EditableHookCommand[]), newCommand]
362:     }));
363:   };
364: 
365:   const updateMatcher = (event: HookEvent, matcherId: string, updates: Partial<EditableHookMatcher>) => {
366:     if (!matcherEvents.includes(event as any)) return;
367:     
368:     setEditableHooks(prev => ({
369:       ...prev,
370:       [event]: (prev[event as 'PreToolUse' | 'PostToolUse'] as EditableHookMatcher[]).map(matcher =>
371:         matcher.id === matcherId ? { ...matcher, ...updates } : matcher
372:       )
373:     }));
374:   };
375: 
376:   const removeMatcher = (event: HookEvent, matcherId: string) => {
377:     if (!matcherEvents.includes(event as any)) return;
378:     
379:     setEditableHooks(prev => ({
380:       ...prev,
381:       [event]: (prev[event as 'PreToolUse' | 'PostToolUse'] as EditableHookMatcher[]).filter(matcher => matcher.id !== matcherId)
382:     }));
383:   };
384:   
385:   const updateDirectCommand = (event: HookEvent, commandId: string, updates: Partial<EditableHookCommand>) => {
386:     if (!directEvents.includes(event as any)) return;
387:     
388:     setEditableHooks(prev => ({
389:       ...prev,
390:       [event]: (prev[event as 'Notification' | 'Stop' | 'SubagentStop'] as EditableHookCommand[]).map(cmd =>
391:         cmd.id === commandId ? { ...cmd, ...updates } : cmd
392:       )
393:     }));
394:   };
395:   
396:   const removeDirectCommand = (event: HookEvent, commandId: string) => {
397:     if (!directEvents.includes(event as any)) return;
398:     
399:     setEditableHooks(prev => ({
400:       ...prev,
401:       [event]: (prev[event as 'Notification' | 'Stop' | 'SubagentStop'] as EditableHookCommand[]).filter(cmd => cmd.id !== commandId)
402:     }));
403:   };
404: 
405:   const applyTemplate = (template: HookTemplate) => {
406:     if (matcherEvents.includes(template.event as any)) {
407:       // For events with matchers
408:       const newMatcher: EditableHookMatcher = {
409:         id: HooksManager.generateId(),
410:         matcher: template.matcher,
411:         hooks: template.commands.map(cmd => ({
412:           id: HooksManager.generateId(),
413:           type: 'command' as const,
414:           command: cmd
415:         })),
416:         expanded: true
417:       };
418:       
419:       setEditableHooks(prev => ({
420:         ...prev,
421:         [template.event]: [...(prev[template.event as 'PreToolUse' | 'PostToolUse'] as EditableHookMatcher[]), newMatcher]
422:       }));
423:     } else {
424:       // For direct events
425:       const newCommands: EditableHookCommand[] = template.commands.map(cmd => ({
426:         id: HooksManager.generateId(),
427:         type: 'command' as const,
428:         command: cmd
429:       }));
430:       
431:       setEditableHooks(prev => ({
432:         ...prev,
433:         [template.event]: [...(prev[template.event as 'Notification' | 'Stop' | 'SubagentStop'] as EditableHookCommand[]), ...newCommands]
434:       }));
435:     }
436:     
437:     setSelectedEvent(template.event);
438:     setShowTemplateDialog(false);
439:   };
440: 
441:   const validateHooks = async () => {
442:     if (!hooks) {
443:       setValidationErrors([]);
444:       setValidationWarnings([]);
445:       return;
446:     }
447:     
448:     const result = await HooksManager.validateConfig(hooks);
449:     setValidationErrors(result.errors.map(e => e.message));
450:     setValidationWarnings(result.warnings.map(w => `${w.message} in command: ${(w.command || '').substring(0, 50)}...`));
451:   };
452: 
453:   useEffect(() => {
454:     validateHooks();
455:   }, [hooks]);
456: 
457:   const addCommand = (event: HookEvent, matcherId: string) => {
458:     if (!matcherEvents.includes(event as any)) return;
459:     
460:     const newCommand: EditableHookCommand = {
461:       id: HooksManager.generateId(),
462:       type: 'command',
463:       command: ''
464:     };
465:     
466:     setEditableHooks(prev => ({
467:       ...prev,
468:       [event]: (prev[event as 'PreToolUse' | 'PostToolUse'] as EditableHookMatcher[]).map(matcher =>
469:         matcher.id === matcherId
470:           ? { ...matcher, hooks: [...matcher.hooks, newCommand] }
471:           : matcher
472:       )
473:     }));
474:   };
475: 
476:   const updateCommand = (
477:     event: HookEvent,
478:     matcherId: string,
479:     commandId: string,
480:     updates: Partial<EditableHookCommand>
481:   ) => {
482:     if (!matcherEvents.includes(event as any)) return;
483:     
484:     setEditableHooks(prev => ({
485:       ...prev,
486:       [event]: (prev[event as 'PreToolUse' | 'PostToolUse'] as EditableHookMatcher[]).map(matcher =>
487:         matcher.id === matcherId
488:           ? {
489:               ...matcher,
490:               hooks: matcher.hooks.map(cmd =>
491:                 cmd.id === commandId ? { ...cmd, ...updates } : cmd
492:               )
493:             }
494:           : matcher
495:       )
496:     }));
497:   };
498: 
499:   const removeCommand = (event: HookEvent, matcherId: string, commandId: string) => {
500:     if (!matcherEvents.includes(event as any)) return;
501:     
502:     setEditableHooks(prev => ({
503:       ...prev,
504:       [event]: (prev[event as 'PreToolUse' | 'PostToolUse'] as EditableHookMatcher[]).map(matcher =>
505:         matcher.id === matcherId
506:           ? { ...matcher, hooks: matcher.hooks.filter(cmd => cmd.id !== commandId) }
507:           : matcher
508:       )
509:     }));
510:   };
511: 
512:   const renderMatcher = (event: HookEvent, matcher: EditableHookMatcher) => (
513:     <Card key={matcher.id} className="p-4 space-y-4">
514:       <div className="flex items-start gap-4">
515:         <Button
516:           variant="ghost"
517:           size="sm"
518:           className="p-0 h-6 w-6"
519:           onClick={() => updateMatcher(event, matcher.id, { expanded: !matcher.expanded })}
520:         >
521:           {matcher.expanded ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}
522:         </Button>
523:         
524:         <div className="flex-1 space-y-2">
525:           <div className="flex items-center gap-2">
526:             <Label htmlFor={`matcher-${matcher.id}`}>Pattern</Label>
527:             <TooltipProvider>
528:               <Tooltip>
529:                 <TooltipTrigger asChild>
530:                   <Info className="h-3 w-3 text-muted-foreground" />
531:                 </TooltipTrigger>
532:                 <TooltipContent>
533:                   <p>Tool name pattern (regex supported). Leave empty to match all tools.</p>
534:                 </TooltipContent>
535:               </Tooltip>
536:             </TooltipProvider>
537:           </div>
538:           
539:           <div className="flex items-center gap-2">
540:             <Input
541:               id={`matcher-${matcher.id}`}
542:               placeholder="e.g., Bash, Edit|Write, mcp__.*"
543:               value={matcher.matcher || ''}
544:               onChange={(e) => updateMatcher(event, matcher.id, { matcher: e.target.value })}
545:               disabled={readOnly}
546:               className="flex-1"
547:             />
548:             
549:             <Select
550:               value={matcher.matcher || 'custom'}
551:               onValueChange={(value) => {
552:                 if (value !== 'custom') {
553:                   updateMatcher(event, matcher.id, { matcher: value });
554:                 }
555:               }}
556:               disabled={readOnly}
557:             >
558:               <SelectTrigger className="w-40">
559:                 <SelectValue placeholder="Common patterns" />
560:               </SelectTrigger>
561:               <SelectContent>
562:                 <SelectItem value="custom">Custom</SelectItem>
563:                 {COMMON_TOOL_MATCHERS.map(pattern => (
564:                   <SelectItem key={pattern} value={pattern}>{pattern}</SelectItem>
565:                 ))}
566:               </SelectContent>
567:             </Select>
568:             
569:             {!readOnly && (
570:               <Button
571:                 variant="ghost"
572:                 size="sm"
573:                 onClick={() => removeMatcher(event, matcher.id)}
574:               >
575:                 <Trash2 className="h-4 w-4" />
576:               </Button>
577:             )}
578:           </div>
579:         </div>
580:       </div>
581:       
582:       <AnimatePresence>
583:         {matcher.expanded && (
584:           <motion.div
585:             initial={{ opacity: 0, height: 0 }}
586:             animate={{ opacity: 1, height: 'auto' }}
587:             exit={{ opacity: 0, height: 0 }}
588:             className="space-y-4 pl-10"
589:           >
590:             <div className="space-y-2">
591:               <div className="flex items-center justify-between">
592:                 <Label>Commands</Label>
593:                 {!readOnly && (
594:                   <Button
595:                     variant="outline"
596:                     size="sm"
597:                     onClick={() => addCommand(event, matcher.id)}
598:                   >
599:                     <Plus className="h-3 w-3 mr-1" />
600:                     Add Command
601:                   </Button>
602:                 )}
603:               </div>
604:               
605:               {matcher.hooks.length === 0 ? (
606:                 <p className="text-sm text-muted-foreground">No commands added yet</p>
607:               ) : (
608:                 <div className="space-y-2">
609:                   {matcher.hooks.map((hook) => (
610:                     <div key={hook.id} className="space-y-2">
611:                       <div className="flex items-start gap-2">
612:                         <div className="flex-1 space-y-2">
613:                           <Textarea
614:                             placeholder="Enter shell command..."
615:                             value={hook.command || ''}
616:                             onChange={(e) => updateCommand(event, matcher.id, hook.id, { command: e.target.value })}
617:                             disabled={readOnly}
618:                             className="font-mono text-sm min-h-[80px]"
619:                           />
620:                           
621:                           <div className="flex items-center gap-4">
622:                             <div className="flex items-center gap-2">
623:                               <Clock className="h-3 w-3 text-muted-foreground" />
624:                               <Input
625:                                 type="number"
626:                                 placeholder="60"
627:                                 value={hook.timeout || ''}
628:                                 onChange={(e) => updateCommand(event, matcher.id, hook.id, { 
629:                                   timeout: e.target.value ? parseInt(e.target.value) : undefined 
630:                                 })}
631:                                 disabled={readOnly}
632:                                 className="w-20 h-8"
633:                               />
634:                               <span className="text-sm text-muted-foreground">seconds</span>
635:                             </div>
636:                             
637:                             {!readOnly && (
638:                               <Button
639:                                 variant="ghost"
640:                                 size="sm"
641:                                 onClick={() => removeCommand(event, matcher.id, hook.id)}
642:                               >
643:                                 <Trash2 className="h-4 w-4" />
644:                               </Button>
645:                             )}
646:                           </div>
647:                         </div>
648:                       </div>
649:                       
650:                       {/* Show warnings for this command */}
651:                       {(() => {
652:                         const warnings = HooksManager.checkDangerousPatterns(hook.command || '');
653:                         return warnings.length > 0 && (
654:                           <div className="flex items-start gap-2 p-2 bg-yellow-500/10 rounded-md">
655:                             <AlertTriangle className="h-4 w-4 text-yellow-600 mt-0.5" />
656:                             <div className="space-y-1">
657:                               {warnings.map((warning, i) => (
658:                                 <p key={i} className="text-xs text-yellow-600">{warning}</p>
659:                               ))}
660:                             </div>
661:                           </div>
662:                         );
663:                       })()}
664:                     </div>
665:                   ))}
666:                 </div>
667:               )}
668:             </div>
669:           </motion.div>
670:         )}
671:       </AnimatePresence>
672:     </Card>
673:   );
674:   
675:   const renderDirectCommand = (event: HookEvent, command: EditableHookCommand) => (
676:     <Card key={command.id} className="p-4 space-y-2">
677:       <div className="flex items-start gap-2">
678:         <div className="flex-1 space-y-2">
679:           <Textarea
680:             placeholder="Enter shell command..."
681:             value={command.command || ''}
682:             onChange={(e) => updateDirectCommand(event, command.id, { command: e.target.value })}
683:             disabled={readOnly}
684:             className="font-mono text-sm min-h-[80px]"
685:           />
686:           
687:           <div className="flex items-center gap-4">
688:             <div className="flex items-center gap-2">
689:               <Clock className="h-3 w-3 text-muted-foreground" />
690:               <Input
691:                 type="number"
692:                 placeholder="60"
693:                 value={command.timeout || ''}
694:                 onChange={(e) => updateDirectCommand(event, command.id, { 
695:                   timeout: e.target.value ? parseInt(e.target.value) : undefined 
696:                 })}
697:                 disabled={readOnly}
698:                 className="w-20 h-8"
699:               />
700:               <span className="text-sm text-muted-foreground">seconds</span>
701:             </div>
702:             
703:             {!readOnly && (
704:               <Button
705:                 variant="ghost"
706:                 size="sm"
707:                 onClick={() => removeDirectCommand(event, command.id)}
708:               >
709:                 <Trash2 className="h-4 w-4" />
710:               </Button>
711:             )}
712:           </div>
713:         </div>
714:       </div>
715:       
716:       {/* Show warnings for this command */}
717:       {(() => {
718:         const warnings = HooksManager.checkDangerousPatterns(command.command || '');
719:         return warnings.length > 0 && (
720:           <div className="flex items-start gap-2 p-2 bg-yellow-500/10 rounded-md">
721:             <AlertTriangle className="h-4 w-4 text-yellow-600 mt-0.5" />
722:             <div className="space-y-1">
723:               {warnings.map((warning, i) => (
724:                 <p key={i} className="text-xs text-yellow-600">{warning}</p>
725:               ))}
726:             </div>
727:           </div>
728:         );
729:       })()}
730:     </Card>
731:   );
732: 
733:   return (
734:     <div className={cn("space-y-6", className)}>
735:       {/* Loading State */}
736:       {isLoading && (
737:         <div className="flex items-center justify-center p-8">
738:           <Loader2 className="h-6 w-6 animate-spin mr-2" />
739:           <span className="text-sm text-muted-foreground">Loading hooks configuration...</span>
740:         </div>
741:       )}
742:       
743:       {/* Error State */}
744:       {loadError && !isLoading && (
745:         <div className="rounded-lg border border-destructive/50 bg-destructive/10 p-3 text-xs text-destructive flex items-center gap-2">
746:           <AlertTriangle className="h-4 w-4 flex-shrink-0" />
747:           {loadError}
748:         </div>
749:       )}
750:       
751:       {/* Main Content */}
752:       {!isLoading && (
753:         <>
754:           {/* Header */}
755:           <div className="space-y-2">
756:             <div className="flex items-center justify-between">
757:               <h3 className="text-lg font-semibold">Hooks Configuration</h3>
758:               <div className="flex items-center gap-2">
759:                 <Badge variant={scope === 'project' ? 'secondary' : scope === 'local' ? 'outline' : 'default'}>
760:                   {scope === 'project' ? 'Project' : scope === 'local' ? 'Local' : 'User'} Scope
761:                 </Badge>
762:                 {!readOnly && (
763:                   <>
764:                     <Button
765:                       variant="outline"
766:                       size="sm"
767:                       onClick={() => setShowTemplateDialog(true)}
768:                     >
769:                       <FileText className="h-4 w-4 mr-2" />
770:                       Templates
771:                     </Button>
772:                     {!hideActions && (
773:                       <Button
774:                         variant={hasUnsavedChanges ? "default" : "outline"}
775:                         size="sm"
776:                         onClick={handleSave}
777:                         disabled={!hasUnsavedChanges || isSaving || !projectPath}
778:                       >
779:                         {isSaving ? (
780:                           <Loader2 className="h-4 w-4 mr-2 animate-spin" />
781:                         ) : (
782:                           <Save className="h-4 w-4 mr-2" />
783:                         )}
784:                         {isSaving ? "Saving..." : "Save"}
785:                       </Button>
786:                     )}
787:                   </>
788:                 )}
789:               </div>
790:             </div>
791:             <p className="text-sm text-muted-foreground">
792:               Configure shell commands to execute at various points in Claude Code's lifecycle.
793:               {scope === 'local' && ' These settings are not committed to version control.'}
794:             </p>
795:             {hasUnsavedChanges && !readOnly && (
796:               <p className="text-sm text-amber-600">
797:                 You have unsaved changes. Click Save to persist them.
798:               </p>
799:             )}
800:           </div>
801: 
802:           {/* Validation Messages */}
803:           {validationErrors.length > 0 && (
804:             <div className="p-3 bg-red-500/10 rounded-md space-y-1">
805:               <p className="text-sm font-medium text-red-600">Validation Errors:</p>
806:               {validationErrors.map((error, i) => (
807:                 <p key={i} className="text-xs text-red-600">• {error}</p>
808:               ))}
809:             </div>
810:           )}
811: 
812:           {validationWarnings.length > 0 && (
813:             <div className="p-3 bg-yellow-500/10 rounded-md space-y-1">
814:               <p className="text-sm font-medium text-yellow-600">Security Warnings:</p>
815:               {validationWarnings.map((warning, i) => (
816:                 <p key={i} className="text-xs text-yellow-600">• {warning}</p>
817:               ))}
818:             </div>
819:           )}
820: 
821:           {/* Event Tabs */}
822:           <Tabs value={selectedEvent} onValueChange={(v) => setSelectedEvent(v as HookEvent)}>
823:             <TabsList className="w-full">
824:               {(Object.keys(EVENT_INFO) as HookEvent[]).map(event => {
825:                 const isMatcherEvent = matcherEvents.includes(event as any);
826:                 const count = isMatcherEvent 
827:                   ? (editableHooks[event as 'PreToolUse' | 'PostToolUse'] as EditableHookMatcher[]).length
828:                   : (editableHooks[event as 'Notification' | 'Stop' | 'SubagentStop'] as EditableHookCommand[]).length;
829:                 
830:                 return (
831:                   <TabsTrigger key={event} value={event} className="flex items-center gap-2">
832:                     {EVENT_INFO[event].icon}
833:                     <span className="hidden sm:inline">{EVENT_INFO[event].label}</span>
834:                     {count > 0 && (
835:                       <Badge variant="secondary" className="ml-1 h-5 px-1">
836:                         {count}
837:                       </Badge>
838:                     )}
839:                   </TabsTrigger>
840:                 );
841:               })}
842:             </TabsList>
843: 
844:             {(Object.keys(EVENT_INFO) as HookEvent[]).map(event => {
845:               const isMatcherEvent = matcherEvents.includes(event as any);
846:               const items = isMatcherEvent 
847:                 ? (editableHooks[event as 'PreToolUse' | 'PostToolUse'] as EditableHookMatcher[])
848:                 : (editableHooks[event as 'Notification' | 'Stop' | 'SubagentStop'] as EditableHookCommand[]);
849:               
850:               return (
851:                 <TabsContent key={event} value={event} className="space-y-4">
852:                   <div className="space-y-2">
853:                     <p className="text-sm text-muted-foreground">
854:                       {EVENT_INFO[event].description}
855:                     </p>
856:                   </div>
857: 
858:                   {items.length === 0 ? (
859:                     <Card className="p-8 text-center">
860:                       <p className="text-muted-foreground mb-4">No hooks configured for this event</p>
861:                       {!readOnly && (
862:                         <Button onClick={() => isMatcherEvent ? addMatcher(event) : addDirectCommand(event)}>
863:                           <Plus className="h-4 w-4 mr-2" />
864:                           Add Hook
865:                         </Button>
866:                       )}
867:                     </Card>
868:                   ) : (
869:                     <div className="space-y-4">
870:                       {isMatcherEvent 
871:                         ? (items as EditableHookMatcher[]).map(matcher => renderMatcher(event, matcher))
872:                         : (items as EditableHookCommand[]).map(command => renderDirectCommand(event, command))
873:                       }
874:                       
875:                       {!readOnly && (
876:                         <Button
877:                           variant="outline"
878:                           onClick={() => isMatcherEvent ? addMatcher(event) : addDirectCommand(event)}
879:                           className="w-full"
880:                         >
881:                           <Plus className="h-4 w-4 mr-2" />
882:                           Add Another {isMatcherEvent ? 'Matcher' : 'Command'}
883:                         </Button>
884:                       )}
885:                     </div>
886:                   )}
887:                 </TabsContent>
888:               );
889:             })}
890:           </Tabs>
891: 
892:           {/* Template Dialog */}
893:           <Dialog open={showTemplateDialog} onOpenChange={setShowTemplateDialog}>
894:             <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto">
895:               <DialogHeader>
896:                 <DialogTitle>Hook Templates</DialogTitle>
897:                 <DialogDescription>
898:                   Choose a pre-configured hook template to get started quickly
899:                 </DialogDescription>
900:               </DialogHeader>
901:               
902:               <div className="space-y-4 py-4">
903:                 {HOOK_TEMPLATES.map(template => (
904:                   <Card
905:                     key={template.id}
906:                     className="p-4 cursor-pointer hover:bg-accent"
907:                     onClick={() => applyTemplate(template)}
908:                   >
909:                     <div className="space-y-2">
910:                       <div className="flex items-center justify-between">
911:                         <h4 className="font-medium">{template.name}</h4>
912:                         <Badge>{EVENT_INFO[template.event].label}</Badge>
913:                       </div>
914:                       <p className="text-sm text-muted-foreground">{template.description}</p>
915:                       {matcherEvents.includes(template.event as any) && template.matcher && (
916:                         <p className="text-xs font-mono bg-muted px-2 py-1 rounded inline-block">
917:                           Matcher: {template.matcher}
918:                         </p>
919:                       )}
920:                     </div>
921:                   </Card>
922:                 ))}
923:               </div>
924:             </DialogContent>
925:           </Dialog>
926:         </>
927:       )}
928:     </div>
929:   );
930: };
````

## File: src/components/IconPicker.tsx
````typescript
  1: import React, { useState, useMemo } from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import {
  4:   // Interface & Navigation
  5:   Home,
  6:   Menu,
  7:   Settings,
  8:   User,
  9:   Users,
 10:   LogOut,
 11:   Bell,
 12:   Bookmark,
 13:   Calendar,
 14:   Clock,
 15:   Eye,
 16:   EyeOff,
 17:   Hash,
 18:   Heart,
 19:   Info,
 20:   Link,
 21:   Lock,
 22:   Map,
 23:   MessageSquare,
 24:   Mic,
 25:   Music,
 26:   Paperclip,
 27:   Phone,
 28:   Pin,
 29:   Plus,
 30:   Save,
 31:   Share,
 32:   Star,
 33:   Tag,
 34:   Trash,
 35:   Upload,
 36:   Download,
 37:   Edit,
 38:   Copy,
 39:   // Development & Tech
 40:   Bot,
 41:   Brain,
 42:   Code,
 43:   Terminal,
 44:   Cpu,
 45:   Database,
 46:   GitBranch,
 47:   Github,
 48:   Globe,
 49:   HardDrive,
 50:   Laptop,
 51:   Monitor,
 52:   Server,
 53:   Wifi,
 54:   Cloud,
 55:   Command,
 56:   FileCode,
 57:   FileJson,
 58:   Folder,
 59:   FolderOpen,
 60:   Bug,
 61:   Coffee,
 62:   // Business & Finance
 63:   Briefcase,
 64:   Building,
 65:   CreditCard,
 66:   DollarSign,
 67:   TrendingUp,
 68:   TrendingDown,
 69:   BarChart,
 70:   PieChart,
 71:   Calculator,
 72:   Receipt,
 73:   Wallet,
 74:   // Creative & Design
 75:   Palette,
 76:   Brush,
 77:   Camera,
 78:   Film,
 79:   Image,
 80:   Layers,
 81:   Layout,
 82:   PenTool,
 83:   Scissors,
 84:   Type,
 85:   Zap,
 86:   Sparkles,
 87:   Wand2,
 88:   // Nature & Science
 89:   Beaker,
 90:   Atom,
 91:   Dna,
 92:   Flame,
 93:   Leaf,
 94:   Mountain,
 95:   Sun,
 96:   Moon,
 97:   CloudRain,
 98:   Snowflake,
 99:   TreePine,
100:   Waves,
101:   Wind,
102:   // Gaming & Entertainment
103:   Gamepad2,
104:   Dice1,
105:   Trophy,
106:   Medal,
107:   Crown,
108:   Rocket,
109:   Target,
110:   Swords,
111:   Shield,
112:   // Communication
113:   Mail,
114:   Send,
115:   MessageCircle,
116:   Video,
117:   Voicemail,
118:   Radio,
119:   Podcast,
120:   Megaphone,
121:   // Miscellaneous
122:   Activity,
123:   Anchor,
124:   Award,
125:   Battery,
126:   Bluetooth,
127:   Compass,
128:   Crosshair,
129:   Flag,
130:   Flashlight,
131:   Gift,
132:   Headphones,
133:   Key,
134:   Lightbulb,
135:   Package,
136:   Puzzle,
137:   Search as SearchIcon,
138:   Smile,
139:   ThumbsUp,
140:   Umbrella,
141:   Watch,
142:   Wrench,
143:   type LucideIcon,
144: } from "lucide-react";
145: import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
146: import { Input } from "@/components/ui/input";
147: import { cn } from "@/lib/utils";
148: 
149: /**
150:  * Icon categories for better organization
151:  */
152: const ICON_CATEGORIES = {
153:   "Interface & Navigation": [
154:     { name: "home", icon: Home },
155:     { name: "menu", icon: Menu },
156:     { name: "settings", icon: Settings },
157:     { name: "user", icon: User },
158:     { name: "users", icon: Users },
159:     { name: "log-out", icon: LogOut },
160:     { name: "bell", icon: Bell },
161:     { name: "bookmark", icon: Bookmark },
162:     { name: "calendar", icon: Calendar },
163:     { name: "clock", icon: Clock },
164:     { name: "eye", icon: Eye },
165:     { name: "eye-off", icon: EyeOff },
166:     { name: "hash", icon: Hash },
167:     { name: "heart", icon: Heart },
168:     { name: "info", icon: Info },
169:     { name: "link", icon: Link },
170:     { name: "lock", icon: Lock },
171:     { name: "map", icon: Map },
172:     { name: "message-square", icon: MessageSquare },
173:     { name: "mic", icon: Mic },
174:     { name: "music", icon: Music },
175:     { name: "paperclip", icon: Paperclip },
176:     { name: "phone", icon: Phone },
177:     { name: "pin", icon: Pin },
178:     { name: "plus", icon: Plus },
179:     { name: "save", icon: Save },
180:     { name: "share", icon: Share },
181:     { name: "star", icon: Star },
182:     { name: "tag", icon: Tag },
183:     { name: "trash", icon: Trash },
184:     { name: "upload", icon: Upload },
185:     { name: "download", icon: Download },
186:     { name: "edit", icon: Edit },
187:     { name: "copy", icon: Copy },
188:   ],
189:   "Development & Tech": [
190:     { name: "bot", icon: Bot },
191:     { name: "brain", icon: Brain },
192:     { name: "code", icon: Code },
193:     { name: "terminal", icon: Terminal },
194:     { name: "cpu", icon: Cpu },
195:     { name: "database", icon: Database },
196:     { name: "git-branch", icon: GitBranch },
197:     { name: "github", icon: Github },
198:     { name: "globe", icon: Globe },
199:     { name: "hard-drive", icon: HardDrive },
200:     { name: "laptop", icon: Laptop },
201:     { name: "monitor", icon: Monitor },
202:     { name: "server", icon: Server },
203:     { name: "wifi", icon: Wifi },
204:     { name: "cloud", icon: Cloud },
205:     { name: "command", icon: Command },
206:     { name: "file-code", icon: FileCode },
207:     { name: "file-json", icon: FileJson },
208:     { name: "folder", icon: Folder },
209:     { name: "folder-open", icon: FolderOpen },
210:     { name: "bug", icon: Bug },
211:     { name: "coffee", icon: Coffee },
212:   ],
213:   "Business & Finance": [
214:     { name: "briefcase", icon: Briefcase },
215:     { name: "building", icon: Building },
216:     { name: "credit-card", icon: CreditCard },
217:     { name: "dollar-sign", icon: DollarSign },
218:     { name: "trending-up", icon: TrendingUp },
219:     { name: "trending-down", icon: TrendingDown },
220:     { name: "bar-chart", icon: BarChart },
221:     { name: "pie-chart", icon: PieChart },
222:     { name: "calculator", icon: Calculator },
223:     { name: "receipt", icon: Receipt },
224:     { name: "wallet", icon: Wallet },
225:   ],
226:   "Creative & Design": [
227:     { name: "palette", icon: Palette },
228:     { name: "brush", icon: Brush },
229:     { name: "camera", icon: Camera },
230:     { name: "film", icon: Film },
231:     { name: "image", icon: Image },
232:     { name: "layers", icon: Layers },
233:     { name: "layout", icon: Layout },
234:     { name: "pen-tool", icon: PenTool },
235:     { name: "scissors", icon: Scissors },
236:     { name: "type", icon: Type },
237:     { name: "zap", icon: Zap },
238:     { name: "sparkles", icon: Sparkles },
239:     { name: "wand-2", icon: Wand2 },
240:   ],
241:   "Nature & Science": [
242:     { name: "beaker", icon: Beaker },
243:     { name: "atom", icon: Atom },
244:     { name: "dna", icon: Dna },
245:     { name: "flame", icon: Flame },
246:     { name: "leaf", icon: Leaf },
247:     { name: "mountain", icon: Mountain },
248:     { name: "sun", icon: Sun },
249:     { name: "moon", icon: Moon },
250:     { name: "cloud-rain", icon: CloudRain },
251:     { name: "snowflake", icon: Snowflake },
252:     { name: "tree-pine", icon: TreePine },
253:     { name: "waves", icon: Waves },
254:     { name: "wind", icon: Wind },
255:   ],
256:   "Gaming & Entertainment": [
257:     { name: "gamepad-2", icon: Gamepad2 },
258:     { name: "dice-1", icon: Dice1 },
259:     { name: "trophy", icon: Trophy },
260:     { name: "medal", icon: Medal },
261:     { name: "crown", icon: Crown },
262:     { name: "rocket", icon: Rocket },
263:     { name: "target", icon: Target },
264:     { name: "swords", icon: Swords },
265:     { name: "shield", icon: Shield },
266:   ],
267:   "Communication": [
268:     { name: "mail", icon: Mail },
269:     { name: "send", icon: Send },
270:     { name: "message-circle", icon: MessageCircle },
271:     { name: "video", icon: Video },
272:     { name: "voicemail", icon: Voicemail },
273:     { name: "radio", icon: Radio },
274:     { name: "podcast", icon: Podcast },
275:     { name: "megaphone", icon: Megaphone },
276:   ],
277:   "Miscellaneous": [
278:     { name: "activity", icon: Activity },
279:     { name: "anchor", icon: Anchor },
280:     { name: "award", icon: Award },
281:     { name: "battery", icon: Battery },
282:     { name: "bluetooth", icon: Bluetooth },
283:     { name: "compass", icon: Compass },
284:     { name: "crosshair", icon: Crosshair },
285:     { name: "flag", icon: Flag },
286:     { name: "flashlight", icon: Flashlight },
287:     { name: "gift", icon: Gift },
288:     { name: "headphones", icon: Headphones },
289:     { name: "key", icon: Key },
290:     { name: "lightbulb", icon: Lightbulb },
291:     { name: "package", icon: Package },
292:     { name: "puzzle", icon: Puzzle },
293:     { name: "search", icon: SearchIcon },
294:     { name: "smile", icon: Smile },
295:     { name: "thumbs-up", icon: ThumbsUp },
296:     { name: "umbrella", icon: Umbrella },
297:     { name: "watch", icon: Watch },
298:     { name: "wrench", icon: Wrench },
299:   ],
300: } as const;
301: 
302: type IconCategory = typeof ICON_CATEGORIES[keyof typeof ICON_CATEGORIES];
303: type IconItem = IconCategory[number];
304: 
305: interface IconPickerProps {
306:   /**
307:    * Currently selected icon name
308:    */
309:   value: string;
310:   /**
311:    * Callback when an icon is selected
312:    */
313:   onSelect: (iconName: string) => void;
314:   /**
315:    * Whether the picker is open
316:    */
317:   isOpen: boolean;
318:   /**
319:    * Callback to close the picker
320:    */
321:   onClose: () => void;
322: }
323: 
324: /**
325:  * Icon picker component with search and categories
326:  * Similar to Notion's icon picker interface
327:  */
328: export const IconPicker: React.FC<IconPickerProps> = ({
329:   value,
330:   onSelect,
331:   isOpen,
332:   onClose,
333: }) => {
334:   const [searchQuery, setSearchQuery] = useState("");
335:   const [hoveredIcon, setHoveredIcon] = useState<string | null>(null);
336: 
337:   // Filter icons based on search query
338:   const filteredCategories = useMemo(() => {
339:     if (!searchQuery.trim()) return ICON_CATEGORIES;
340: 
341:     const query = searchQuery.toLowerCase();
342:     const filtered: Record<string, IconItem[]> = {};
343: 
344:     Object.entries(ICON_CATEGORIES).forEach(([category, icons]) => {
345:       const matchingIcons = icons.filter(({ name }) =>
346:         name.toLowerCase().includes(query)
347:       );
348:       if (matchingIcons.length > 0) {
349:         filtered[category] = matchingIcons;
350:       }
351:     });
352: 
353:     return filtered;
354:   }, [searchQuery]);
355: 
356:   // Get all icons for search
357:   const allIcons = useMemo(() => {
358:     return Object.values(ICON_CATEGORIES).flat();
359:   }, []);
360: 
361:   const handleSelect = (iconName: string) => {
362:     onSelect(iconName);
363:     onClose();
364:     setSearchQuery("");
365:   };
366: 
367:   return (
368:     <Dialog open={isOpen} onOpenChange={onClose}>
369:       <DialogContent className="max-w-2xl max-h-[80vh] p-0">
370:         <DialogHeader className="px-6 py-4 border-b">
371:           <DialogTitle>Choose an icon</DialogTitle>
372:         </DialogHeader>
373: 
374:         {/* Search Bar */}
375:         <div className="px-6 py-3 border-b">
376:           <div className="relative">
377:             <SearchIcon className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
378:             <Input
379:               placeholder="Search icons..."
380:               value={searchQuery}
381:               onChange={(e) => setSearchQuery(e.target.value)}
382:               className="pl-10"
383:               autoFocus
384:             />
385:           </div>
386:         </div>
387: 
388:         {/* Icon Grid */}
389:         <div className="h-[60vh] px-6 py-4 overflow-y-auto">
390:           {Object.keys(filteredCategories).length === 0 ? (
391:             <div className="flex flex-col items-center justify-center h-32 text-center">
392:               <p className="text-sm text-muted-foreground">
393:                 No icons found for "{searchQuery}"
394:               </p>
395:             </div>
396:           ) : (
397:             <div className="space-y-6">
398:               <AnimatePresence mode="wait">
399:                 {Object.entries(filteredCategories).map(([category, icons]) => (
400:                   <motion.div
401:                     key={category}
402:                     initial={{ opacity: 0, y: 10 }}
403:                     animate={{ opacity: 1, y: 0 }}
404:                     exit={{ opacity: 0, y: -10 }}
405:                     transition={{ duration: 0.2 }}
406:                   >
407:                     <h3 className="text-sm font-medium text-muted-foreground mb-3">
408:                       {category}
409:                     </h3>
410:                     <div className="grid grid-cols-10 gap-2">
411:                       {icons.map((item: IconItem) => {
412:                         const Icon = item.icon;
413:                         return (
414:                           <motion.button
415:                             key={item.name}
416:                             whileHover={{ scale: 1.1 }}
417:                             whileTap={{ scale: 0.95 }}
418:                             onClick={() => handleSelect(item.name)}
419:                             onMouseEnter={() => setHoveredIcon(item.name)}
420:                             onMouseLeave={() => setHoveredIcon(null)}
421:                             className={cn(
422:                               "p-2.5 rounded-lg transition-colors relative group",
423:                               "hover:bg-accent hover:text-accent-foreground",
424:                               value === item.name && "bg-primary/10 text-primary"
425:                             )}
426:                           >
427:                             <Icon className="h-5 w-5" />
428:                             {hoveredIcon === item.name && (
429:                               <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 bg-popover text-popover-foreground text-xs rounded shadow-lg whitespace-nowrap z-10">
430:                                 {item.name}
431:                               </div>
432:                             )}
433:                           </motion.button>
434:                         );
435:                       })}
436:                     </div>
437:                   </motion.div>
438:                 ))}
439:               </AnimatePresence>
440:             </div>
441:           )}
442:         </div>
443: 
444:         {/* Footer */}
445:         <div className="px-6 py-3 border-t bg-muted/50">
446:           <p className="text-xs text-muted-foreground text-center">
447:             Click an icon to select • {allIcons.length} icons available
448:           </p>
449:         </div>
450:       </DialogContent>
451:     </Dialog>
452:   );
453: };
454: 
455: // Export all available icon names for type safety
456: export const AVAILABLE_ICONS = Object.values(ICON_CATEGORIES)
457:   .flat()
458:   .map(({ name }) => name);
459: 
460: // Export icon map for easy access
461: export const ICON_MAP = Object.values(ICON_CATEGORIES)
462:   .flat()
463:   .reduce((acc, { name, icon }) => ({ ...acc, [name]: icon }), {} as Record<string, LucideIcon>);
````

## File: src/components/ImagePreview.tsx
````typescript
  1: import React, { useState } from "react";
  2: import { X, Maximize2 } from "lucide-react";
  3: import { cn } from "@/lib/utils";
  4: import { Dialog, DialogContent, DialogTitle } from "@/components/ui/dialog";
  5: import { motion, AnimatePresence } from "framer-motion";
  6: import { convertFileSrc } from "@tauri-apps/api/core";
  7: 
  8: interface ImagePreviewProps {
  9:   /**
 10:    * Array of image file paths to preview
 11:    */
 12:   images: string[];
 13:   /**
 14:    * Callback to remove an image from the preview
 15:    */
 16:   onRemove: (index: number) => void;
 17:   /**
 18:    * Optional className for styling
 19:    */
 20:   className?: string;
 21: }
 22: 
 23: /**
 24:  * ImagePreview component - Shows thumbnail previews of embedded images
 25:  * 
 26:  * Features:
 27:  * - Shows up to 10 image thumbnails in a row
 28:  * - Click on thumbnail to see full-size preview
 29:  * - Hover to show remove button
 30:  * - Smooth animations
 31:  * 
 32:  * @example
 33:  * <ImagePreview 
 34:  *   images={["/path/to/image1.png", "/path/to/image2.jpg"]}
 35:  *   onRemove={(index) => console.log('Remove image at', index)}
 36:  * />
 37:  */
 38: export const ImagePreview: React.FC<ImagePreviewProps> = ({
 39:   images,
 40:   onRemove,
 41:   className,
 42: }) => {
 43:   const [selectedImageIndex, setSelectedImageIndex] = useState<number | null>(null);
 44:   const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);
 45:   const [imageErrors, setImageErrors] = useState<Set<number>>(new Set());
 46: 
 47:   // Limit to 10 images
 48:   const displayImages = images.slice(0, 10);
 49: 
 50:   const handleImageError = (index: number) => {
 51:     setImageErrors(prev => new Set(prev).add(index));
 52:   };
 53: 
 54:   const handleRemove = (e: React.MouseEvent, index: number) => {
 55:     e.stopPropagation();
 56:     onRemove(index);
 57:   };
 58: 
 59:   // Helper to get the image source - handles both file paths and data URLs
 60:   const getImageSrc = (imagePath: string): string => {
 61:     // If it's already a data URL, return as-is
 62:     if (imagePath.startsWith('data:')) {
 63:       return imagePath;
 64:     }
 65:     // Otherwise, convert the file path
 66:     return convertFileSrc(imagePath);
 67:   };
 68: 
 69:   if (displayImages.length === 0) return null;
 70: 
 71:   return (
 72:     <>
 73:       <div className={cn("flex gap-2 p-2 overflow-x-auto", className)}>
 74:         <AnimatePresence>
 75:           {displayImages.map((imagePath, index) => (
 76:             <motion.div
 77:               key={`${imagePath}-${index}`}
 78:               initial={{ opacity: 0, scale: 0.8 }}
 79:               animate={{ opacity: 1, scale: 1 }}
 80:               exit={{ opacity: 0, scale: 0.8 }}
 81:               transition={{ duration: 0.2 }}
 82:               className="relative flex-shrink-0 group"
 83:               onMouseEnter={() => setHoveredIndex(index)}
 84:               onMouseLeave={() => setHoveredIndex(null)}
 85:             >
 86:               <div
 87:                 className="relative w-16 h-16 rounded-md overflow-hidden border border-border cursor-pointer hover:border-primary transition-colors"
 88:                 onClick={() => setSelectedImageIndex(index)}
 89:               >
 90:                 {imageErrors.has(index) ? (
 91:                   <div className="w-full h-full bg-muted flex items-center justify-center">
 92:                     <span className="text-xs text-muted-foreground">Error</span>
 93:                   </div>
 94:                 ) : (
 95:                   <img
 96:                     src={getImageSrc(imagePath)}
 97:                     alt={`Preview ${index + 1}`}
 98:                     className="w-full h-full object-cover"
 99:                     onError={() => handleImageError(index)}
100:                   />
101:                 )}
102:                 
103:                 {/* Hover overlay with maximize icon */}
104:                 <div className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
105:                   <Maximize2 className="h-4 w-4 text-white" />
106:                 </div>
107:               </div>
108: 
109:               {/* Remove button */}
110:               <AnimatePresence>
111:                 {hoveredIndex === index && (
112:                   <motion.button
113:                     initial={{ opacity: 0, scale: 0.8 }}
114:                     animate={{ opacity: 1, scale: 1 }}
115:                     exit={{ opacity: 0, scale: 0.8 }}
116:                     className="absolute -top-1 -right-1 w-5 h-5 bg-destructive text-destructive-foreground rounded-full flex items-center justify-center hover:bg-destructive/90 transition-colors"
117:                     onClick={(e) => handleRemove(e, index)}
118:                   >
119:                     <X className="h-3 w-3" />
120:                   </motion.button>
121:                 )}
122:               </AnimatePresence>
123:             </motion.div>
124:           ))}
125:         </AnimatePresence>
126: 
127:         {images.length > 10 && (
128:           <div className="flex-shrink-0 w-16 h-16 rounded-md border border-border bg-muted flex items-center justify-center">
129:             <span className="text-xs text-muted-foreground">+{images.length - 10}</span>
130:           </div>
131:         )}
132:       </div>
133: 
134:       {/* Full-size preview dialog */}
135:       <Dialog 
136:         open={selectedImageIndex !== null} 
137:         onOpenChange={(open) => !open && setSelectedImageIndex(null)}
138:       >
139:         <DialogContent className="max-w-4xl max-h-[90vh] p-0">
140:           <DialogTitle className="sr-only">Image Preview</DialogTitle>
141:           {selectedImageIndex !== null && (
142:             <div className="relative w-full h-full flex items-center justify-center p-4">
143:               <img
144:                 src={getImageSrc(displayImages[selectedImageIndex])}
145:                 alt={`Full preview ${selectedImageIndex + 1}`}
146:                 className="max-w-full max-h-full object-contain"
147:                 onError={() => handleImageError(selectedImageIndex)}
148:               />
149:               
150:               {/* Navigation buttons if multiple images */}
151:               {displayImages.length > 1 && (
152:                 <>
153:                   <button
154:                     className="absolute left-4 top-1/2 -translate-y-1/2 w-10 h-10 bg-black/50 text-white rounded-full flex items-center justify-center hover:bg-black/70 transition-colors"
155:                     onClick={() => setSelectedImageIndex((prev) => 
156:                       prev !== null ? (prev - 1 + displayImages.length) % displayImages.length : 0
157:                     )}
158:                   >
159:                     ←
160:                   </button>
161:                   <button
162:                     className="absolute right-4 top-1/2 -translate-y-1/2 w-10 h-10 bg-black/50 text-white rounded-full flex items-center justify-center hover:bg-black/70 transition-colors"
163:                     onClick={() => setSelectedImageIndex((prev) => 
164:                       prev !== null ? (prev + 1) % displayImages.length : 0
165:                     )}
166:                   >
167:                     →
168:                   </button>
169:                 </>
170:               )}
171:             </div>
172:           )}
173:         </DialogContent>
174:       </Dialog>
175:     </>
176:   );
177: };
````

## File: src/components/index.ts
````typescript
 1: export * from "./AgentExecutionDemo";
 2: export * from "./AgentRunOutputViewer";
 3: export * from "./StreamMessage";
 4: export * from "./ToolWidgets"; 
 5: export * from "./NFOCredits"; 
 6: export * from "./UsageDashboard";
 7: export * from "./WebviewPreview";
 8: export * from "./ImagePreview";
 9: export * from "./MCPManager";
10: export * from "./MCPServerList";
11: export * from "./MCPAddServer";
12: export * from "./MCPImportExport";
13: export * from "./ClaudeVersionSelector";
14: export * from "./ui/badge";
15: export * from "./ui/button";
16: export * from "./ui/card";
17: export * from "./ui/dialog";
18: export * from "./ui/dropdown-menu";
19: export * from "./ui/input";
20: export * from "./ui/label";
21: export * from "./ui/select";
22: export * from "./ui/switch";
23: export * from "./ui/tabs";
24: export * from "./ui/textarea";
25: export * from "./ui/toast";
26: export * from "./ui/tooltip";
27: export * from "./SlashCommandPicker";
28: export * from "./SlashCommandsManager";
29: export * from "./ui/popover";
30: export * from "./ui/pagination";
31: export * from "./ui/split-pane";
32: export * from "./ui/scroll-area"; 
33: export * from "./RunningClaudeSessions";
````

## File: src/components/MarkdownEditor.tsx
````typescript
  1: import React, { useState, useEffect } from "react";
  2: import MDEditor from "@uiw/react-md-editor";
  3: import { motion } from "framer-motion";
  4: import { ArrowLeft, Save, Loader2 } from "lucide-react";
  5: import { Button } from "@/components/ui/button";
  6: import { Toast, ToastContainer } from "@/components/ui/toast";
  7: import { api } from "@/lib/api";
  8: import { cn } from "@/lib/utils";
  9: 
 10: interface MarkdownEditorProps {
 11:   /**
 12:    * Callback to go back to the main view
 13:    */
 14:   onBack: () => void;
 15:   /**
 16:    * Optional className for styling
 17:    */
 18:   className?: string;
 19: }
 20: 
 21: /**
 22:  * MarkdownEditor component for editing the CLAUDE.md system prompt
 23:  * 
 24:  * @example
 25:  * <MarkdownEditor onBack={() => setView('main')} />
 26:  */
 27: export const MarkdownEditor: React.FC<MarkdownEditorProps> = ({
 28:   onBack,
 29:   className,
 30: }) => {
 31:   const [content, setContent] = useState<string>("");
 32:   const [originalContent, setOriginalContent] = useState<string>("");
 33:   const [loading, setLoading] = useState(true);
 34:   const [saving, setSaving] = useState(false);
 35:   const [error, setError] = useState<string | null>(null);
 36:   const [toast, setToast] = useState<{ message: string; type: "success" | "error" } | null>(null);
 37:   
 38:   const hasChanges = content !== originalContent;
 39:   
 40:   // Load the system prompt on mount
 41:   useEffect(() => {
 42:     loadSystemPrompt();
 43:   }, []);
 44:   
 45:   const loadSystemPrompt = async () => {
 46:     try {
 47:       setLoading(true);
 48:       setError(null);
 49:       const prompt = await api.getSystemPrompt();
 50:       setContent(prompt);
 51:       setOriginalContent(prompt);
 52:     } catch (err) {
 53:       console.error("Failed to load system prompt:", err);
 54:       setError("Failed to load CLAUDE.md file");
 55:     } finally {
 56:       setLoading(false);
 57:     }
 58:   };
 59:   
 60:   const handleSave = async () => {
 61:     try {
 62:       setSaving(true);
 63:       setError(null);
 64:       setToast(null);
 65:       await api.saveSystemPrompt(content);
 66:       setOriginalContent(content);
 67:       setToast({ message: "CLAUDE.md saved successfully", type: "success" });
 68:     } catch (err) {
 69:       console.error("Failed to save system prompt:", err);
 70:       setError("Failed to save CLAUDE.md file");
 71:       setToast({ message: "Failed to save CLAUDE.md", type: "error" });
 72:     } finally {
 73:       setSaving(false);
 74:     }
 75:   };
 76:   
 77:   const handleBack = () => {
 78:     if (hasChanges) {
 79:       const confirmLeave = window.confirm(
 80:         "You have unsaved changes. Are you sure you want to leave?"
 81:       );
 82:       if (!confirmLeave) return;
 83:     }
 84:     onBack();
 85:   };
 86:   
 87:   return (
 88:     <div className={cn("flex flex-col h-full bg-background", className)}>
 89:       <div className="w-full max-w-5xl mx-auto flex flex-col h-full">
 90:         {/* Header */}
 91:         <motion.div
 92:           initial={{ opacity: 0, y: -20 }}
 93:           animate={{ opacity: 1, y: 0 }}
 94:           transition={{ duration: 0.3 }}
 95:           className="flex items-center justify-between p-4 border-b border-border"
 96:         >
 97:           <div className="flex items-center space-x-3">
 98:             <Button
 99:               variant="ghost"
100:               size="icon"
101:               onClick={handleBack}
102:               className="h-8 w-8"
103:             >
104:               <ArrowLeft className="h-4 w-4" />
105:             </Button>
106:             <div>
107:               <h2 className="text-lg font-semibold">CLAUDE.md</h2>
108:               <p className="text-xs text-muted-foreground">
109:                 Edit your Claude Code system prompt
110:               </p>
111:             </div>
112:           </div>
113:           
114:           <Button
115:             onClick={handleSave}
116:             disabled={!hasChanges || saving}
117:             size="sm"
118:           >
119:             {saving ? (
120:               <Loader2 className="mr-2 h-4 w-4 animate-spin" />
121:             ) : (
122:               <Save className="mr-2 h-4 w-4" />
123:             )}
124:             {saving ? "Saving..." : "Save"}
125:           </Button>
126:         </motion.div>
127:         
128:         {/* Error display */}
129:         {error && (
130:           <motion.div
131:             initial={{ opacity: 0 }}
132:             animate={{ opacity: 1 }}
133:             className="mx-4 mt-4 rounded-lg border border-destructive/50 bg-destructive/10 p-3 text-xs text-destructive"
134:           >
135:             {error}
136:           </motion.div>
137:         )}
138:         
139:         {/* Editor */}
140:         <div className="flex-1 p-4 overflow-hidden">
141:           {loading ? (
142:             <div className="flex items-center justify-center h-full">
143:               <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
144:             </div>
145:           ) : (
146:             <div className="h-full rounded-lg border border-border overflow-hidden shadow-sm" data-color-mode="dark">
147:               <MDEditor
148:                 value={content}
149:                 onChange={(val) => setContent(val || "")}
150:                 preview="edit"
151:                 height="100%"
152:                 visibleDragbar={false}
153:               />
154:             </div>
155:           )}
156:         </div>
157:       </div>
158:       
159:       {/* Toast Notification */}
160:       <ToastContainer>
161:         {toast && (
162:           <Toast
163:             message={toast.message}
164:             type={toast.type}
165:             onDismiss={() => setToast(null)}
166:           />
167:         )}
168:       </ToastContainer>
169:     </div>
170:   );
171: };
````

## File: src/components/MCPAddServer.tsx
````typescript
  1: import React, { useState } from "react";
  2: import { Plus, Terminal, Globe, Trash2, Info, Loader2 } from "lucide-react";
  3: import { Button } from "@/components/ui/button";
  4: import { Input } from "@/components/ui/input";
  5: import { Label } from "@/components/ui/label";
  6: import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs";
  7: import { SelectComponent } from "@/components/ui/select";
  8: import { Card } from "@/components/ui/card";
  9: import { api } from "@/lib/api";
 10: import { useTrackEvent } from "@/hooks";
 11: 
 12: interface MCPAddServerProps {
 13:   /**
 14:    * Callback when a server is successfully added
 15:    */
 16:   onServerAdded: () => void;
 17:   /**
 18:    * Callback for error messages
 19:    */
 20:   onError: (message: string) => void;
 21: }
 22: 
 23: interface EnvironmentVariable {
 24:   id: string;
 25:   key: string;
 26:   value: string;
 27: }
 28: 
 29: /**
 30:  * Component for adding new MCP servers
 31:  * Supports both stdio and SSE transport types
 32:  */
 33: export const MCPAddServer: React.FC<MCPAddServerProps> = ({
 34:   onServerAdded,
 35:   onError,
 36: }) => {
 37:   const [transport, setTransport] = useState<"stdio" | "sse">("stdio");
 38:   const [saving, setSaving] = useState(false);
 39:   
 40:   // Analytics tracking
 41:   const trackEvent = useTrackEvent();
 42:   
 43:   // Stdio server state
 44:   const [stdioName, setStdioName] = useState("");
 45:   const [stdioCommand, setStdioCommand] = useState("");
 46:   const [stdioArgs, setStdioArgs] = useState("");
 47:   const [stdioScope, setStdioScope] = useState("local");
 48:   const [stdioEnvVars, setStdioEnvVars] = useState<EnvironmentVariable[]>([]);
 49:   
 50:   // SSE server state
 51:   const [sseName, setSseName] = useState("");
 52:   const [sseUrl, setSseUrl] = useState("");
 53:   const [sseScope, setSseScope] = useState("local");
 54:   const [sseEnvVars, setSseEnvVars] = useState<EnvironmentVariable[]>([]);
 55: 
 56:   /**
 57:    * Adds a new environment variable
 58:    */
 59:   const addEnvVar = (type: "stdio" | "sse") => {
 60:     const newVar: EnvironmentVariable = {
 61:       id: `env-${Date.now()}`,
 62:       key: "",
 63:       value: "",
 64:     };
 65:     
 66:     if (type === "stdio") {
 67:       setStdioEnvVars(prev => [...prev, newVar]);
 68:     } else {
 69:       setSseEnvVars(prev => [...prev, newVar]);
 70:     }
 71:   };
 72: 
 73:   /**
 74:    * Updates an environment variable
 75:    */
 76:   const updateEnvVar = (type: "stdio" | "sse", id: string, field: "key" | "value", value: string) => {
 77:     if (type === "stdio") {
 78:       setStdioEnvVars(prev => prev.map(v => 
 79:         v.id === id ? { ...v, [field]: value } : v
 80:       ));
 81:     } else {
 82:       setSseEnvVars(prev => prev.map(v => 
 83:         v.id === id ? { ...v, [field]: value } : v
 84:       ));
 85:     }
 86:   };
 87: 
 88:   /**
 89:    * Removes an environment variable
 90:    */
 91:   const removeEnvVar = (type: "stdio" | "sse", id: string) => {
 92:     if (type === "stdio") {
 93:       setStdioEnvVars(prev => prev.filter(v => v.id !== id));
 94:     } else {
 95:       setSseEnvVars(prev => prev.filter(v => v.id !== id));
 96:     }
 97:   };
 98: 
 99:   /**
100:    * Validates and adds a stdio server
101:    */
102:   const handleAddStdioServer = async () => {
103:     if (!stdioName.trim()) {
104:       onError("Server name is required");
105:       return;
106:     }
107:     
108:     if (!stdioCommand.trim()) {
109:       onError("Command is required");
110:       return;
111:     }
112:     
113:     try {
114:       setSaving(true);
115:       
116:       // Parse arguments
117:       const args = stdioArgs.trim() ? stdioArgs.split(/\s+/) : [];
118:       
119:       // Convert env vars to object
120:       const env = stdioEnvVars.reduce((acc, { key, value }) => {
121:         if (key.trim() && value.trim()) {
122:           acc[key] = value;
123:         }
124:         return acc;
125:       }, {} as Record<string, string>);
126:       
127:       const result = await api.mcpAdd(
128:         stdioName,
129:         "stdio",
130:         stdioCommand,
131:         args,
132:         env,
133:         undefined,
134:         stdioScope
135:       );
136:       
137:       if (result.success) {
138:         // Track server added
139:         trackEvent.mcpServerAdded({
140:           server_type: "stdio",
141:           configuration_method: "manual"
142:         });
143:         
144:         // Reset form
145:         setStdioName("");
146:         setStdioCommand("");
147:         setStdioArgs("");
148:         setStdioEnvVars([]);
149:         setStdioScope("local");
150:         onServerAdded();
151:       } else {
152:         onError(result.message);
153:       }
154:     } catch (error) {
155:       onError("Failed to add server");
156:       console.error("Failed to add stdio server:", error);
157:     } finally {
158:       setSaving(false);
159:     }
160:   };
161: 
162:   /**
163:    * Validates and adds an SSE server
164:    */
165:   const handleAddSseServer = async () => {
166:     if (!sseName.trim()) {
167:       onError("Server name is required");
168:       return;
169:     }
170:     
171:     if (!sseUrl.trim()) {
172:       onError("URL is required");
173:       return;
174:     }
175:     
176:     try {
177:       setSaving(true);
178:       
179:       // Convert env vars to object
180:       const env = sseEnvVars.reduce((acc, { key, value }) => {
181:         if (key.trim() && value.trim()) {
182:           acc[key] = value;
183:         }
184:         return acc;
185:       }, {} as Record<string, string>);
186:       
187:       const result = await api.mcpAdd(
188:         sseName,
189:         "sse",
190:         undefined,
191:         [],
192:         env,
193:         sseUrl,
194:         sseScope
195:       );
196:       
197:       if (result.success) {
198:         // Track server added
199:         trackEvent.mcpServerAdded({
200:           server_type: "sse",
201:           configuration_method: "manual"
202:         });
203:         
204:         // Reset form
205:         setSseName("");
206:         setSseUrl("");
207:         setSseEnvVars([]);
208:         setSseScope("local");
209:         onServerAdded();
210:       } else {
211:         onError(result.message);
212:       }
213:     } catch (error) {
214:       onError("Failed to add server");
215:       console.error("Failed to add SSE server:", error);
216:     } finally {
217:       setSaving(false);
218:     }
219:   };
220: 
221:   /**
222:    * Renders environment variable inputs
223:    */
224:   const renderEnvVars = (type: "stdio" | "sse", envVars: EnvironmentVariable[]) => {
225:     return (
226:       <div className="space-y-3">
227:         <div className="flex items-center justify-between">
228:           <Label className="text-sm font-medium">Environment Variables</Label>
229:           <Button
230:             variant="outline"
231:             size="sm"
232:             onClick={() => addEnvVar(type)}
233:             className="gap-2"
234:           >
235:             <Plus className="h-3 w-3" />
236:             Add Variable
237:           </Button>
238:         </div>
239:         
240:         {envVars.length > 0 && (
241:           <div className="space-y-2">
242:             {envVars.map((envVar) => (
243:               <div key={envVar.id} className="flex items-center gap-2">
244:                 <Input
245:                   placeholder="KEY"
246:                   value={envVar.key}
247:                   onChange={(e) => updateEnvVar(type, envVar.id, "key", e.target.value)}
248:                   className="flex-1 font-mono text-sm"
249:                 />
250:                 <span className="text-muted-foreground">=</span>
251:                 <Input
252:                   placeholder="value"
253:                   value={envVar.value}
254:                   onChange={(e) => updateEnvVar(type, envVar.id, "value", e.target.value)}
255:                   className="flex-1 font-mono text-sm"
256:                 />
257:                 <Button
258:                   variant="ghost"
259:                   size="icon"
260:                   onClick={() => removeEnvVar(type, envVar.id)}
261:                   className="h-8 w-8 hover:text-destructive"
262:                 >
263:                   <Trash2 className="h-4 w-4" />
264:                 </Button>
265:               </div>
266:             ))}
267:           </div>
268:         )}
269:       </div>
270:     );
271:   };
272: 
273:   return (
274:     <div className="p-6 space-y-6">
275:       <div>
276:         <h3 className="text-base font-semibold">Add MCP Server</h3>
277:         <p className="text-sm text-muted-foreground mt-1">
278:           Configure a new Model Context Protocol server
279:         </p>
280:       </div>
281: 
282:       <Tabs value={transport} onValueChange={(v) => setTransport(v as "stdio" | "sse")}>
283:         <TabsList className="grid w-full grid-cols-2 max-w-sm mb-6">
284:           <TabsTrigger value="stdio" className="gap-2">
285:             <Terminal className="h-4 w-4 text-amber-500" />
286:             Stdio
287:           </TabsTrigger>
288:           <TabsTrigger value="sse" className="gap-2">
289:             <Globe className="h-4 w-4 text-emerald-500" />
290:             SSE
291:           </TabsTrigger>
292:         </TabsList>
293: 
294:         {/* Stdio Server */}
295:         <TabsContent value="stdio" className="space-y-6">
296:           <Card className="p-6 space-y-6">
297:             <div className="space-y-4">
298:               <div className="space-y-2">
299:                 <Label htmlFor="stdio-name">Server Name</Label>
300:                 <Input
301:                   id="stdio-name"
302:                   placeholder="my-server"
303:                   value={stdioName}
304:                   onChange={(e) => setStdioName(e.target.value)}
305:                 />
306:                 <p className="text-xs text-muted-foreground">
307:                   A unique name to identify this server
308:                 </p>
309:               </div>
310: 
311:               <div className="space-y-2">
312:                 <Label htmlFor="stdio-command">Command</Label>
313:                 <Input
314:                   id="stdio-command"
315:                   placeholder="/path/to/server"
316:                   value={stdioCommand}
317:                   onChange={(e) => setStdioCommand(e.target.value)}
318:                   className="font-mono"
319:                 />
320:                 <p className="text-xs text-muted-foreground">
321:                   The command to execute the server
322:                 </p>
323:               </div>
324: 
325:               <div className="space-y-2">
326:                 <Label htmlFor="stdio-args">Arguments (optional)</Label>
327:                 <Input
328:                   id="stdio-args"
329:                   placeholder="arg1 arg2 arg3"
330:                   value={stdioArgs}
331:                   onChange={(e) => setStdioArgs(e.target.value)}
332:                   className="font-mono"
333:                 />
334:                 <p className="text-xs text-muted-foreground">
335:                   Space-separated command arguments
336:                 </p>
337:               </div>
338: 
339:               <div className="space-y-2">
340:                 <Label htmlFor="stdio-scope">Scope</Label>
341:                 <SelectComponent
342:                   value={stdioScope}
343:                   onValueChange={(value: string) => setStdioScope(value)}
344:                   options={[
345:                     { value: "local", label: "Local (this project only)" },
346:                     { value: "project", label: "Project (shared via .mcp.json)" },
347:                     { value: "user", label: "User (all projects)" },
348:                   ]}
349:                 />
350:               </div>
351: 
352:               {renderEnvVars("stdio", stdioEnvVars)}
353:             </div>
354: 
355:             <div className="pt-2">
356:               <Button
357:                 onClick={handleAddStdioServer}
358:                 disabled={saving}
359:                 className="w-full gap-2 bg-primary hover:bg-primary/90"
360:               >
361:                 {saving ? (
362:                   <>
363:                     <Loader2 className="h-4 w-4 animate-spin" />
364:                     Adding Server...
365:                   </>
366:                 ) : (
367:                   <>
368:                     <Plus className="h-4 w-4" />
369:                     Add Stdio Server
370:                   </>
371:                 )}
372:               </Button>
373:             </div>
374:           </Card>
375:         </TabsContent>
376: 
377:         {/* SSE Server */}
378:         <TabsContent value="sse" className="space-y-6">
379:           <Card className="p-6 space-y-6">
380:             <div className="space-y-4">
381:               <div className="space-y-2">
382:                 <Label htmlFor="sse-name">Server Name</Label>
383:                 <Input
384:                   id="sse-name"
385:                   placeholder="sse-server"
386:                   value={sseName}
387:                   onChange={(e) => setSseName(e.target.value)}
388:                 />
389:                 <p className="text-xs text-muted-foreground">
390:                   A unique name to identify this server
391:                 </p>
392:               </div>
393: 
394:               <div className="space-y-2">
395:                 <Label htmlFor="sse-url">URL</Label>
396:                 <Input
397:                   id="sse-url"
398:                   placeholder="https://example.com/sse-endpoint"
399:                   value={sseUrl}
400:                   onChange={(e) => setSseUrl(e.target.value)}
401:                   className="font-mono"
402:                 />
403:                 <p className="text-xs text-muted-foreground">
404:                   The SSE endpoint URL
405:                 </p>
406:               </div>
407: 
408:               <div className="space-y-2">
409:                 <Label htmlFor="sse-scope">Scope</Label>
410:                 <SelectComponent
411:                   value={sseScope}
412:                   onValueChange={(value: string) => setSseScope(value)}
413:                   options={[
414:                     { value: "local", label: "Local (this project only)" },
415:                     { value: "project", label: "Project (shared via .mcp.json)" },
416:                     { value: "user", label: "User (all projects)" },
417:                   ]}
418:                 />
419:               </div>
420: 
421:               {renderEnvVars("sse", sseEnvVars)}
422:             </div>
423: 
424:             <div className="pt-2">
425:               <Button
426:                 onClick={handleAddSseServer}
427:                 disabled={saving}
428:                 className="w-full gap-2 bg-primary hover:bg-primary/90"
429:               >
430:                 {saving ? (
431:                   <>
432:                     <Loader2 className="h-4 w-4 animate-spin" />
433:                     Adding Server...
434:                   </>
435:                 ) : (
436:                   <>
437:                     <Plus className="h-4 w-4" />
438:                     Add SSE Server
439:                   </>
440:                 )}
441:               </Button>
442:             </div>
443:           </Card>
444:         </TabsContent>
445:       </Tabs>
446: 
447:       {/* Example */}
448:       <Card className="p-4 bg-muted/30">
449:         <div className="space-y-3">
450:           <div className="flex items-center gap-2 text-sm font-medium">
451:             <Info className="h-4 w-4 text-primary" />
452:             <span>Example Commands</span>
453:           </div>
454:           <div className="space-y-2 text-xs text-muted-foreground">
455:             <div className="font-mono bg-background p-2 rounded">
456:               <p>• Postgres: /path/to/postgres-mcp-server --connection-string "postgresql://..."</p>
457:               <p>• Weather API: /usr/local/bin/weather-cli --api-key ABC123</p>
458:               <p>• SSE Server: https://api.example.com/mcp/stream</p>
459:             </div>
460:           </div>
461:         </div>
462:       </Card>
463:     </div>
464:   );
465: };
````

## File: src/components/MCPImportExport.tsx
````typescript
  1: import React, { useState } from "react";
  2: import { Download, Upload, FileText, Loader2, Info, Network, Settings2 } from "lucide-react";
  3: import { Button } from "@/components/ui/button";
  4: import { Card } from "@/components/ui/card";
  5: import { Label } from "@/components/ui/label";
  6: import { SelectComponent } from "@/components/ui/select";
  7: import { api } from "@/lib/api";
  8: 
  9: interface MCPImportExportProps {
 10:   /**
 11:    * Callback when import is completed
 12:    */
 13:   onImportCompleted: (imported: number, failed: number) => void;
 14:   /**
 15:    * Callback for error messages
 16:    */
 17:   onError: (message: string) => void;
 18: }
 19: 
 20: /**
 21:  * Component for importing and exporting MCP server configurations
 22:  */
 23: export const MCPImportExport: React.FC<MCPImportExportProps> = ({
 24:   onImportCompleted,
 25:   onError,
 26: }) => {
 27:   const [importingDesktop, setImportingDesktop] = useState(false);
 28:   const [importingJson, setImportingJson] = useState(false);
 29:   const [importScope, setImportScope] = useState("local");
 30: 
 31:   /**
 32:    * Imports servers from Claude Desktop
 33:    */
 34:   const handleImportFromDesktop = async () => {
 35:     try {
 36:       setImportingDesktop(true);
 37:       // Always use "user" scope for Claude Desktop imports (was previously "global")
 38:       const result = await api.mcpAddFromClaudeDesktop("user");
 39:       
 40:       // Show detailed results if available
 41:       if (result.servers && result.servers.length > 0) {
 42:         const successfulServers = result.servers.filter(s => s.success);
 43:         const failedServers = result.servers.filter(s => !s.success);
 44:         
 45:         if (successfulServers.length > 0) {
 46:           const successMessage = `Successfully imported: ${successfulServers.map(s => s.name).join(", ")}`;
 47:           onImportCompleted(result.imported_count, result.failed_count);
 48:           // Show success details
 49:           if (failedServers.length === 0) {
 50:             onError(successMessage);
 51:           }
 52:         }
 53:         
 54:         if (failedServers.length > 0) {
 55:           const failureDetails = failedServers
 56:             .map(s => `${s.name}: ${s.error || "Unknown error"}`)
 57:             .join("\n");
 58:           onError(`Failed to import some servers:\n${failureDetails}`);
 59:         }
 60:       } else {
 61:         onImportCompleted(result.imported_count, result.failed_count);
 62:       }
 63:     } catch (error: any) {
 64:       console.error("Failed to import from Claude Desktop:", error);
 65:       onError(error.toString() || "Failed to import from Claude Desktop");
 66:     } finally {
 67:       setImportingDesktop(false);
 68:     }
 69:   };
 70: 
 71:   /**
 72:    * Handles JSON file import
 73:    */
 74:   const handleJsonFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
 75:     const file = event.target.files?.[0];
 76:     if (!file) return;
 77: 
 78:     try {
 79:       setImportingJson(true);
 80:       const content = await file.text();
 81:       
 82:       // Parse the JSON to validate it
 83:       let jsonData;
 84:       try {
 85:         jsonData = JSON.parse(content);
 86:       } catch (e) {
 87:         onError("Invalid JSON file. Please check the format.");
 88:         return;
 89:       }
 90: 
 91:       // Check if it's a single server or multiple servers
 92:       if (jsonData.mcpServers) {
 93:         // Multiple servers format
 94:         let imported = 0;
 95:         let failed = 0;
 96: 
 97:         for (const [name, config] of Object.entries(jsonData.mcpServers)) {
 98:           try {
 99:             const serverConfig = {
100:               type: "stdio",
101:               command: (config as any).command,
102:               args: (config as any).args || [],
103:               env: (config as any).env || {}
104:             };
105:             
106:             const result = await api.mcpAddJson(name, JSON.stringify(serverConfig), importScope);
107:             if (result.success) {
108:               imported++;
109:             } else {
110:               failed++;
111:             }
112:           } catch (e) {
113:             failed++;
114:           }
115:         }
116:         
117:         onImportCompleted(imported, failed);
118:       } else if (jsonData.type && jsonData.command) {
119:         // Single server format
120:         const name = prompt("Enter a name for this server:");
121:         if (!name) return;
122: 
123:         const result = await api.mcpAddJson(name, content, importScope);
124:         if (result.success) {
125:           onImportCompleted(1, 0);
126:         } else {
127:           onError(result.message);
128:         }
129:       } else {
130:         onError("Unrecognized JSON format. Expected MCP server configuration.");
131:       }
132:     } catch (error) {
133:       console.error("Failed to import JSON:", error);
134:       onError("Failed to import JSON file");
135:     } finally {
136:       setImportingJson(false);
137:       // Reset the input
138:       event.target.value = "";
139:     }
140:   };
141: 
142:   /**
143:    * Handles exporting servers (placeholder)
144:    */
145:   const handleExport = () => {
146:     // TODO: Implement export functionality
147:     onError("Export functionality coming soon!");
148:   };
149: 
150:   /**
151:    * Starts Claude Code as MCP server
152:    */
153:   const handleStartMCPServer = async () => {
154:     try {
155:       await api.mcpServe();
156:       onError("Claude Code MCP server started. You can now connect to it from other applications.");
157:     } catch (error) {
158:       console.error("Failed to start MCP server:", error);
159:       onError("Failed to start Claude Code as MCP server");
160:     }
161:   };
162: 
163:   return (
164:     <div className="p-6 space-y-6">
165:       <div>
166:         <h3 className="text-base font-semibold">Import & Export</h3>
167:         <p className="text-sm text-muted-foreground mt-1">
168:           Import MCP servers from other sources or export your configuration
169:         </p>
170:       </div>
171: 
172:       <div className="space-y-4">
173:         {/* Import Scope Selection */}
174:         <Card className="p-4">
175:           <div className="space-y-3">
176:             <div className="flex items-center gap-2 mb-2">
177:               <Settings2 className="h-4 w-4 text-slate-500" />
178:               <Label className="text-sm font-medium">Import Scope</Label>
179:             </div>
180:             <SelectComponent
181:               value={importScope}
182:               onValueChange={(value: string) => setImportScope(value)}
183:               options={[
184:                 { value: "local", label: "Local (this project only)" },
185:                 { value: "project", label: "Project (shared via .mcp.json)" },
186:                 { value: "user", label: "User (all projects)" },
187:               ]}
188:             />
189:             <p className="text-xs text-muted-foreground">
190:               Choose where to save imported servers from JSON files
191:             </p>
192:           </div>
193:         </Card>
194: 
195:         {/* Import from Claude Desktop */}
196:         <Card className="p-4 hover:bg-accent/5 transition-colors">
197:           <div className="space-y-3">
198:             <div className="flex items-start gap-3">
199:               <div className="p-2.5 bg-blue-500/10 rounded-lg">
200:                 <Download className="h-5 w-5 text-blue-500" />
201:               </div>
202:               <div className="flex-1">
203:                 <h4 className="text-sm font-medium">Import from Claude Desktop</h4>
204:                 <p className="text-xs text-muted-foreground mt-1">
205:                   Automatically imports all MCP servers from Claude Desktop. Installs to user scope (available across all projects).
206:                 </p>
207:               </div>
208:             </div>
209:             <Button
210:               onClick={handleImportFromDesktop}
211:               disabled={importingDesktop}
212:               className="w-full gap-2 bg-primary hover:bg-primary/90"
213:             >
214:               {importingDesktop ? (
215:                 <>
216:                   <Loader2 className="h-4 w-4 animate-spin" />
217:                   Importing...
218:                 </>
219:               ) : (
220:                 <>
221:                   <Download className="h-4 w-4" />
222:                   Import from Claude Desktop
223:                 </>
224:               )}
225:             </Button>
226:           </div>
227:         </Card>
228: 
229:         {/* Import from JSON */}
230:         <Card className="p-4 hover:bg-accent/5 transition-colors">
231:           <div className="space-y-3">
232:             <div className="flex items-start gap-3">
233:               <div className="p-2.5 bg-purple-500/10 rounded-lg">
234:                 <FileText className="h-5 w-5 text-purple-500" />
235:               </div>
236:               <div className="flex-1">
237:                 <h4 className="text-sm font-medium">Import from JSON</h4>
238:                 <p className="text-xs text-muted-foreground mt-1">
239:                   Import server configuration from a JSON file
240:                 </p>
241:               </div>
242:             </div>
243:             <div>
244:               <input
245:                 type="file"
246:                 accept=".json"
247:                 onChange={handleJsonFileSelect}
248:                 disabled={importingJson}
249:                 className="hidden"
250:                 id="json-file-input"
251:               />
252:               <Button
253:                 onClick={() => document.getElementById("json-file-input")?.click()}
254:                 disabled={importingJson}
255:                 className="w-full gap-2"
256:                 variant="outline"
257:               >
258:                 {importingJson ? (
259:                   <>
260:                     <Loader2 className="h-4 w-4 animate-spin" />
261:                     Importing...
262:                   </>
263:                 ) : (
264:                   <>
265:                     <FileText className="h-4 w-4" />
266:                     Choose JSON File
267:                   </>
268:                 )}
269:               </Button>
270:             </div>
271:           </div>
272:         </Card>
273: 
274:         {/* Export (Coming Soon) */}
275:         <Card className="p-4 opacity-60">
276:           <div className="space-y-3">
277:             <div className="flex items-start gap-3">
278:               <div className="p-2.5 bg-muted rounded-lg">
279:                 <Upload className="h-5 w-5 text-muted-foreground" />
280:               </div>
281:               <div className="flex-1">
282:                 <h4 className="text-sm font-medium">Export Configuration</h4>
283:                 <p className="text-xs text-muted-foreground mt-1">
284:                   Export your MCP server configuration
285:                 </p>
286:               </div>
287:             </div>
288:             <Button
289:               onClick={handleExport}
290:               disabled={true}
291:               variant="secondary"
292:               className="w-full gap-2"
293:             >
294:               <Upload className="h-4 w-4" />
295:               Export (Coming Soon)
296:             </Button>
297:           </div>
298:         </Card>
299: 
300:         {/* Serve as MCP */}
301:         <Card className="p-4 border-primary/20 bg-primary/5 hover:bg-primary/10 transition-colors">
302:           <div className="space-y-3">
303:             <div className="flex items-start gap-3">
304:               <div className="p-2.5 bg-green-500/20 rounded-lg">
305:                 <Network className="h-5 w-5 text-green-500" />
306:               </div>
307:               <div className="flex-1">
308:                 <h4 className="text-sm font-medium">Use Claude Code as MCP Server</h4>
309:                 <p className="text-xs text-muted-foreground mt-1">
310:                   Start Claude Code as an MCP server that other applications can connect to
311:                 </p>
312:               </div>
313:             </div>
314:             <Button
315:               onClick={handleStartMCPServer}
316:               variant="outline"
317:               className="w-full gap-2 border-green-500/20 hover:bg-green-500/10 hover:text-green-600 hover:border-green-500/50"
318:             >
319:               <Network className="h-4 w-4" />
320:               Start MCP Server
321:             </Button>
322:           </div>
323:         </Card>
324:       </div>
325: 
326:       {/* Info Box */}
327:       <Card className="p-4 bg-muted/30">
328:         <div className="space-y-3">
329:           <div className="flex items-center gap-2 text-sm font-medium">
330:             <Info className="h-4 w-4 text-primary" />
331:             <span>JSON Format Examples</span>
332:           </div>
333:           <div className="space-y-3 text-xs">
334:             <div>
335:               <p className="font-medium text-muted-foreground mb-1">Single server:</p>
336:               <pre className="bg-background p-3 rounded-lg overflow-x-auto">
337: {`{
338:   "type": "stdio",
339:   "command": "/path/to/server",
340:   "args": ["--arg1", "value"],
341:   "env": { "KEY": "value" }
342: }`}
343:               </pre>
344:             </div>
345:             <div>
346:               <p className="font-medium text-muted-foreground mb-1">Multiple servers (.mcp.json format):</p>
347:               <pre className="bg-background p-3 rounded-lg overflow-x-auto">
348: {`{
349:   "mcpServers": {
350:     "server1": {
351:       "command": "/path/to/server1",
352:       "args": [],
353:       "env": {}
354:     },
355:     "server2": {
356:       "command": "/path/to/server2",
357:       "args": ["--port", "8080"],
358:       "env": { "API_KEY": "..." }
359:     }
360:   }
361: }`}
362:               </pre>
363:             </div>
364:           </div>
365:         </div>
366:       </Card>
367:     </div>
368:   );
369: };
````

## File: src/components/MCPManager.tsx
````typescript
  1: import React, { useState, useEffect } from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import { ArrowLeft, Network, Plus, Download, AlertCircle, Loader2 } from "lucide-react";
  4: import { Button } from "@/components/ui/button";
  5: import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs";
  6: import { Card } from "@/components/ui/card";
  7: import { Toast, ToastContainer } from "@/components/ui/toast";
  8: import { api, type MCPServer } from "@/lib/api";
  9: import { MCPServerList } from "./MCPServerList";
 10: import { MCPAddServer } from "./MCPAddServer";
 11: import { MCPImportExport } from "./MCPImportExport";
 12: 
 13: interface MCPManagerProps {
 14:   /**
 15:    * Callback to go back to the main view
 16:    */
 17:   onBack: () => void;
 18:   /**
 19:    * Optional className for styling
 20:    */
 21:   className?: string;
 22: }
 23: 
 24: /**
 25:  * Main component for managing MCP (Model Context Protocol) servers
 26:  * Provides a comprehensive UI for adding, configuring, and managing MCP servers
 27:  */
 28: export const MCPManager: React.FC<MCPManagerProps> = ({
 29:   onBack,
 30:   className,
 31: }) => {
 32:   const [activeTab, setActiveTab] = useState("servers");
 33:   const [servers, setServers] = useState<MCPServer[]>([]);
 34:   const [loading, setLoading] = useState(true);
 35:   const [error, setError] = useState<string | null>(null);
 36:   const [toast, setToast] = useState<{ message: string; type: "success" | "error" } | null>(null);
 37:   
 38: 
 39:   // Load servers on mount
 40:   useEffect(() => {
 41:     loadServers();
 42:   }, []);
 43: 
 44:   /**
 45:    * Loads all MCP servers
 46:    */
 47:   const loadServers = async () => {
 48:     try {
 49:       setLoading(true);
 50:       setError(null);
 51:       console.log("MCPManager: Loading servers...");
 52:       const serverList = await api.mcpList();
 53:       console.log("MCPManager: Received server list:", serverList);
 54:       console.log("MCPManager: Server count:", serverList.length);
 55:       setServers(serverList);
 56:     } catch (err) {
 57:       console.error("MCPManager: Failed to load MCP servers:", err);
 58:       setError("Failed to load MCP servers. Make sure Claude Code is installed.");
 59:     } finally {
 60:       setLoading(false);
 61:     }
 62:   };
 63: 
 64:   /**
 65:    * Handles server added event
 66:    */
 67:   const handleServerAdded = () => {
 68:     loadServers();
 69:     setToast({ message: "MCP server added successfully!", type: "success" });
 70:     setActiveTab("servers");
 71:   };
 72: 
 73:   /**
 74:    * Handles server removed event
 75:    */
 76:   const handleServerRemoved = (name: string) => {
 77:     setServers(prev => prev.filter(s => s.name !== name));
 78:     setToast({ message: `Server "${name}" removed successfully!`, type: "success" });
 79:   };
 80: 
 81:   /**
 82:    * Handles import completed event
 83:    */
 84:   const handleImportCompleted = (imported: number, failed: number) => {
 85:     loadServers();
 86:     if (failed === 0) {
 87:       setToast({ 
 88:         message: `Successfully imported ${imported} server${imported > 1 ? 's' : ''}!`, 
 89:         type: "success" 
 90:       });
 91:     } else {
 92:       setToast({ 
 93:         message: `Imported ${imported} server${imported > 1 ? 's' : ''}, ${failed} failed`, 
 94:         type: "error" 
 95:       });
 96:     }
 97:   };
 98: 
 99:   return (
100:     <div className={`flex flex-col h-full bg-background text-foreground ${className || ""}`}>
101:       <div className="max-w-5xl mx-auto w-full flex flex-col h-full">
102:         {/* Header */}
103:         <motion.div
104:           initial={{ opacity: 0, y: -20 }}
105:           animate={{ opacity: 1, y: 0 }}
106:           transition={{ duration: 0.3 }}
107:           className="flex items-center justify-between p-4 border-b border-border"
108:         >
109:           <div className="flex items-center gap-3">
110:             <Button
111:               variant="ghost"
112:               size="icon"
113:               onClick={onBack}
114:               className="h-8 w-8"
115:             >
116:               <ArrowLeft className="h-4 w-4" />
117:             </Button>
118:             <div>
119:               <h2 className="text-lg font-semibold flex items-center gap-2">
120:                 <Network className="h-5 w-5 text-blue-500" />
121:                 MCP Servers
122:               </h2>
123:               <p className="text-xs text-muted-foreground">
124:                 Manage Model Context Protocol servers
125:               </p>
126:             </div>
127:           </div>
128:         </motion.div>
129: 
130:         {/* Error Display */}
131:         <AnimatePresence>
132:           {error && (
133:             <motion.div
134:               initial={{ opacity: 0, y: -10 }}
135:               animate={{ opacity: 1, y: 0 }}
136:               exit={{ opacity: 0, y: -10 }}
137:               className="mx-4 mt-4 p-3 rounded-lg bg-destructive/10 border border-destructive/50 flex items-center gap-2 text-sm text-destructive"
138:             >
139:               <AlertCircle className="h-4 w-4" />
140:               {error}
141:             </motion.div>
142:           )}
143:         </AnimatePresence>
144: 
145:         {/* Main Content */}
146:         {loading ? (
147:           <div className="flex-1 flex items-center justify-center">
148:             <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
149:           </div>
150:         ) : (
151:           <div className="flex-1 overflow-y-auto p-4">
152:             <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-6">
153:               <TabsList className="grid w-full max-w-md grid-cols-3">
154:                 <TabsTrigger value="servers" className="gap-2">
155:                   <Network className="h-4 w-4 text-blue-500" />
156:                   Servers
157:                 </TabsTrigger>
158:                 <TabsTrigger value="add" className="gap-2">
159:                   <Plus className="h-4 w-4 text-green-500" />
160:                   Add Server
161:                 </TabsTrigger>
162:                 <TabsTrigger value="import" className="gap-2">
163:                   <Download className="h-4 w-4 text-purple-500" />
164:                   Import/Export
165:                 </TabsTrigger>
166:               </TabsList>
167: 
168:               {/* Servers Tab */}
169:               <TabsContent value="servers" className="mt-6">
170:                 <Card>
171:                   <MCPServerList
172:                     servers={servers}
173:                     loading={false}
174:                     onServerRemoved={handleServerRemoved}
175:                     onRefresh={loadServers}
176:                   />
177:                 </Card>
178:               </TabsContent>
179: 
180:               {/* Add Server Tab */}
181:               <TabsContent value="add" className="mt-6">
182:                 <Card>
183:                   <MCPAddServer
184:                     onServerAdded={handleServerAdded}
185:                     onError={(message: string) => setToast({ message, type: "error" })}
186:                   />
187:                 </Card>
188:               </TabsContent>
189: 
190:               {/* Import/Export Tab */}
191:               <TabsContent value="import" className="mt-6">
192:                 <Card className="overflow-hidden">
193:                   <MCPImportExport
194:                     onImportCompleted={handleImportCompleted}
195:                     onError={(message: string) => setToast({ message, type: "error" })}
196:                   />
197:                 </Card>
198:               </TabsContent>
199:             </Tabs>
200:           </div>
201:         )}
202:       </div>
203: 
204:       {/* Toast Notifications */}
205:       <ToastContainer>
206:         {toast && (
207:           <Toast
208:             message={toast.message}
209:             type={toast.type}
210:             onDismiss={() => setToast(null)}
211:           />
212:         )}
213:       </ToastContainer>
214:     </div>
215:   );
216: };
````

## File: src/components/MCPServerList.tsx
````typescript
  1: import React, { useState } from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import { 
  4:   Network, 
  5:   Globe, 
  6:   Terminal, 
  7:   Trash2, 
  8:   Play, 
  9:   CheckCircle,
 10:   Loader2,
 11:   RefreshCw,
 12:   FolderOpen,
 13:   User,
 14:   FileText,
 15:   ChevronDown,
 16:   ChevronUp,
 17:   Copy
 18: } from "lucide-react";
 19: import { Button } from "@/components/ui/button";
 20: import { Badge } from "@/components/ui/badge";
 21: import { api, type MCPServer } from "@/lib/api";
 22: import { useTrackEvent } from "@/hooks";
 23: 
 24: interface MCPServerListProps {
 25:   /**
 26:    * List of MCP servers to display
 27:    */
 28:   servers: MCPServer[];
 29:   /**
 30:    * Whether the list is loading
 31:    */
 32:   loading: boolean;
 33:   /**
 34:    * Callback when a server is removed
 35:    */
 36:   onServerRemoved: (name: string) => void;
 37:   /**
 38:    * Callback to refresh the server list
 39:    */
 40:   onRefresh: () => void;
 41: }
 42: 
 43: /**
 44:  * Component for displaying a list of MCP servers
 45:  * Shows servers grouped by scope with status indicators
 46:  */
 47: export const MCPServerList: React.FC<MCPServerListProps> = ({
 48:   servers,
 49:   loading,
 50:   onServerRemoved,
 51:   onRefresh,
 52: }) => {
 53:   const [removingServer, setRemovingServer] = useState<string | null>(null);
 54:   const [testingServer, setTestingServer] = useState<string | null>(null);
 55:   const [expandedServers, setExpandedServers] = useState<Set<string>>(new Set());
 56:   const [copiedServer, setCopiedServer] = useState<string | null>(null);
 57:   const [connectedServers] = useState<string[]>([]);
 58:   
 59:   // Analytics tracking
 60:   const trackEvent = useTrackEvent();
 61: 
 62:   // Group servers by scope
 63:   const serversByScope = servers.reduce((acc, server) => {
 64:     const scope = server.scope || "local";
 65:     if (!acc[scope]) acc[scope] = [];
 66:     acc[scope].push(server);
 67:     return acc;
 68:   }, {} as Record<string, MCPServer[]>);
 69: 
 70:   /**
 71:    * Toggles expanded state for a server
 72:    */
 73:   const toggleExpanded = (serverName: string) => {
 74:     setExpandedServers(prev => {
 75:       const next = new Set(prev);
 76:       if (next.has(serverName)) {
 77:         next.delete(serverName);
 78:       } else {
 79:         next.add(serverName);
 80:       }
 81:       return next;
 82:     });
 83:   };
 84: 
 85:   /**
 86:    * Copies command to clipboard
 87:    */
 88:   const copyCommand = async (command: string, serverName: string) => {
 89:     try {
 90:       await navigator.clipboard.writeText(command);
 91:       setCopiedServer(serverName);
 92:       setTimeout(() => setCopiedServer(null), 2000);
 93:     } catch (error) {
 94:       console.error("Failed to copy command:", error);
 95:     }
 96:   };
 97: 
 98:   /**
 99:    * Removes a server
100:    */
101:   const handleRemoveServer = async (name: string) => {
102:     try {
103:       setRemovingServer(name);
104:       
105:       // Check if server was connected
106:       const wasConnected = connectedServers.includes(name);
107:       
108:       await api.mcpRemove(name);
109:       
110:       // Track server removal
111:       trackEvent.mcpServerRemoved({
112:         server_name: name,
113:         was_connected: wasConnected
114:       });
115:       
116:       onServerRemoved(name);
117:     } catch (error) {
118:       console.error("Failed to remove server:", error);
119:     } finally {
120:       setRemovingServer(null);
121:     }
122:   };
123: 
124:   /**
125:    * Tests connection to a server
126:    */
127:   const handleTestConnection = async (name: string) => {
128:     try {
129:       setTestingServer(name);
130:       const result = await api.mcpTestConnection(name);
131:       const server = servers.find(s => s.name === name);
132:       
133:       // Track connection result - result is a string message
134:       trackEvent.mcpServerConnected(name, true, server?.transport || 'unknown');
135:       
136:       // TODO: Show result in a toast or modal
137:       console.log("Test result:", result);
138:     } catch (error) {
139:       console.error("Failed to test connection:", error);
140:       
141:       trackEvent.mcpConnectionError({
142:         server_name: name,
143:         error_type: 'test_failed',
144:         retry_attempt: 0
145:       });
146:     } finally {
147:       setTestingServer(null);
148:     }
149:   };
150: 
151:   /**
152:    * Gets icon for transport type
153:    */
154:   const getTransportIcon = (transport: string) => {
155:     switch (transport) {
156:       case "stdio":
157:         return <Terminal className="h-4 w-4 text-amber-500" />;
158:       case "sse":
159:         return <Globe className="h-4 w-4 text-emerald-500" />;
160:       default:
161:         return <Network className="h-4 w-4 text-blue-500" />;
162:     }
163:   };
164: 
165:   /**
166:    * Gets icon for scope
167:    */
168:   const getScopeIcon = (scope: string) => {
169:     switch (scope) {
170:       case "local":
171:         return <User className="h-3 w-3 text-slate-500" />;
172:       case "project":
173:         return <FolderOpen className="h-3 w-3 text-orange-500" />;
174:       case "user":
175:         return <FileText className="h-3 w-3 text-purple-500" />;
176:       default:
177:         return null;
178:     }
179:   };
180: 
181:   /**
182:    * Gets scope display name
183:    */
184:   const getScopeDisplayName = (scope: string) => {
185:     switch (scope) {
186:       case "local":
187:         return "Local (Project-specific)";
188:       case "project":
189:         return "Project (Shared via .mcp.json)";
190:       case "user":
191:         return "User (All projects)";
192:       default:
193:         return scope;
194:     }
195:   };
196: 
197:   /**
198:    * Renders a single server item
199:    */
200:   const renderServerItem = (server: MCPServer) => {
201:     const isExpanded = expandedServers.has(server.name);
202:     const isCopied = copiedServer === server.name;
203:     
204:     return (
205:       <motion.div
206:         key={server.name}
207:         initial={{ opacity: 0, x: -20 }}
208:         animate={{ opacity: 1, x: 0 }}
209:         exit={{ opacity: 0, x: -20 }}
210:         className="group p-4 rounded-lg border border-border bg-card hover:bg-accent/5 hover:border-primary/20 transition-all overflow-hidden"
211:       >
212:         <div className="space-y-2">
213:           <div className="flex items-start justify-between gap-4">
214:             <div className="flex-1 min-w-0 space-y-1">
215:               <div className="flex items-center gap-2">
216:                 <div className="p-1.5 bg-primary/10 rounded">
217:                   {getTransportIcon(server.transport)}
218:                 </div>
219:                 <h4 className="font-medium truncate">{server.name}</h4>
220:                 {server.status?.running && (
221:                   <Badge variant="outline" className="gap-1 flex-shrink-0 border-green-500/50 text-green-600 bg-green-500/10">
222:                     <CheckCircle className="h-3 w-3" />
223:                     Running
224:                   </Badge>
225:                 )}
226:               </div>
227:               
228:               {server.command && !isExpanded && (
229:                 <div className="flex items-center gap-2">
230:                   <p className="text-xs text-muted-foreground font-mono truncate pl-9 flex-1" title={server.command}>
231:                     {server.command}
232:                   </p>
233:                   <Button
234:                     variant="ghost"
235:                     size="sm"
236:                     onClick={() => toggleExpanded(server.name)}
237:                     className="h-6 px-2 text-xs hover:bg-primary/10"
238:                   >
239:                     <ChevronDown className="h-3 w-3 mr-1" />
240:                     Show full
241:                   </Button>
242:                 </div>
243:               )}
244:               
245:               {server.transport === "sse" && server.url && !isExpanded && (
246:                 <div className="overflow-hidden">
247:                   <p className="text-xs text-muted-foreground font-mono truncate pl-9" title={server.url}>
248:                     {server.url}
249:                   </p>
250:                 </div>
251:               )}
252:               
253:               {Object.keys(server.env).length > 0 && !isExpanded && (
254:                 <div className="flex items-center gap-1 text-xs text-muted-foreground pl-9">
255:                   <span>Environment variables: {Object.keys(server.env).length}</span>
256:                 </div>
257:               )}
258:             </div>
259:             
260:             <div className="flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0">
261:               <Button
262:                 variant="ghost"
263:                 size="sm"
264:                 onClick={() => handleTestConnection(server.name)}
265:                 disabled={testingServer === server.name}
266:                 className="hover:bg-green-500/10 hover:text-green-600"
267:               >
268:                 {testingServer === server.name ? (
269:                   <Loader2 className="h-4 w-4 animate-spin" />
270:                 ) : (
271:                   <Play className="h-4 w-4" />
272:                 )}
273:               </Button>
274:               <Button
275:                 variant="ghost"
276:                 size="sm"
277:                 onClick={() => handleRemoveServer(server.name)}
278:                 disabled={removingServer === server.name}
279:                 className="hover:bg-destructive/10 hover:text-destructive"
280:               >
281:                 {removingServer === server.name ? (
282:                   <Loader2 className="h-4 w-4 animate-spin" />
283:                 ) : (
284:                   <Trash2 className="h-4 w-4" />
285:                 )}
286:               </Button>
287:             </div>
288:           </div>
289:           
290:           {/* Expanded Details */}
291:           {isExpanded && (
292:             <motion.div
293:               initial={{ height: 0, opacity: 0 }}
294:               animate={{ height: "auto", opacity: 1 }}
295:               exit={{ height: 0, opacity: 0 }}
296:               transition={{ duration: 0.2 }}
297:               className="pl-9 space-y-3 pt-2 border-t border-border/50"
298:             >
299:               {server.command && (
300:                 <div className="space-y-1">
301:                   <div className="flex items-center justify-between">
302:                     <p className="text-xs font-medium text-muted-foreground">Command</p>
303:                     <div className="flex items-center gap-1">
304:                       <Button
305:                         variant="ghost"
306:                         size="sm"
307:                         onClick={() => copyCommand(server.command!, server.name)}
308:                         className="h-6 px-2 text-xs hover:bg-primary/10"
309:                       >
310:                         <Copy className="h-3 w-3 mr-1" />
311:                         {isCopied ? "Copied!" : "Copy"}
312:                       </Button>
313:                       <Button
314:                         variant="ghost"
315:                         size="sm"
316:                         onClick={() => toggleExpanded(server.name)}
317:                         className="h-6 px-2 text-xs hover:bg-primary/10"
318:                       >
319:                         <ChevronUp className="h-3 w-3 mr-1" />
320:                         Hide
321:                       </Button>
322:                     </div>
323:                   </div>
324:                   <p className="text-xs font-mono bg-muted/50 p-2 rounded break-all">
325:                     {server.command}
326:                   </p>
327:                 </div>
328:               )}
329:               
330:               {server.args && server.args.length > 0 && (
331:                 <div className="space-y-1">
332:                   <p className="text-xs font-medium text-muted-foreground">Arguments</p>
333:                   <div className="text-xs font-mono bg-muted/50 p-2 rounded space-y-1">
334:                     {server.args.map((arg, idx) => (
335:                       <div key={idx} className="break-all">
336:                         <span className="text-muted-foreground mr-2">[{idx}]</span>
337:                         {arg}
338:                       </div>
339:                     ))}
340:                   </div>
341:                 </div>
342:               )}
343:               
344:               {server.transport === "sse" && server.url && (
345:                 <div className="space-y-1">
346:                   <p className="text-xs font-medium text-muted-foreground">URL</p>
347:                   <p className="text-xs font-mono bg-muted/50 p-2 rounded break-all">
348:                     {server.url}
349:                   </p>
350:                 </div>
351:               )}
352:               
353:               {Object.keys(server.env).length > 0 && (
354:                 <div className="space-y-1">
355:                   <p className="text-xs font-medium text-muted-foreground">Environment Variables</p>
356:                   <div className="text-xs font-mono bg-muted/50 p-2 rounded space-y-1">
357:                     {Object.entries(server.env).map(([key, value]) => (
358:                       <div key={key} className="break-all">
359:                         <span className="text-primary">{key}</span>
360:                         <span className="text-muted-foreground mx-1">=</span>
361:                         <span>{value}</span>
362:                       </div>
363:                     ))}
364:                   </div>
365:                 </div>
366:               )}
367:             </motion.div>
368:           )}
369:         </div>
370:       </motion.div>
371:     );
372:   };
373: 
374:   if (loading) {
375:     return (
376:       <div className="flex items-center justify-center h-64">
377:         <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
378:       </div>
379:     );
380:   }
381: 
382:   return (
383:     <div className="p-6">
384:       {/* Header */}
385:       <div className="flex items-center justify-between mb-6">
386:         <div>
387:           <h3 className="text-base font-semibold">Configured Servers</h3>
388:           <p className="text-sm text-muted-foreground">
389:             {servers.length} server{servers.length !== 1 ? "s" : ""} configured
390:           </p>
391:         </div>
392:         <Button
393:           variant="outline"
394:           size="sm"
395:           onClick={onRefresh}
396:           className="gap-2 hover:bg-primary/10 hover:text-primary hover:border-primary/50"
397:         >
398:           <RefreshCw className="h-4 w-4" />
399:           Refresh
400:         </Button>
401:       </div>
402: 
403:       {/* Server List */}
404:       {servers.length === 0 ? (
405:         <div className="flex flex-col items-center justify-center py-12 text-center">
406:           <div className="p-4 bg-primary/10 rounded-full mb-4">
407:             <Network className="h-12 w-12 text-primary" />
408:           </div>
409:           <p className="text-muted-foreground mb-2 font-medium">No MCP servers configured</p>
410:           <p className="text-sm text-muted-foreground">
411:             Add a server to get started with Model Context Protocol
412:           </p>
413:         </div>
414:       ) : (
415:         <div className="space-y-6">
416:           {Object.entries(serversByScope).map(([scope, scopeServers]) => (
417:             <div key={scope} className="space-y-3">
418:               <div className="flex items-center gap-2 text-sm text-muted-foreground">
419:                 {getScopeIcon(scope)}
420:                 <span className="font-medium">{getScopeDisplayName(scope)}</span>
421:                 <span className="text-muted-foreground/60">({scopeServers.length})</span>
422:               </div>
423:               <AnimatePresence>
424:                 <div className="space-y-2">
425:                   {scopeServers.map(renderServerItem)}
426:                 </div>
427:               </AnimatePresence>
428:             </div>
429:           ))}
430:         </div>
431:       )}
432:     </div>
433:   );
434: };
````

## File: src/components/NFOCredits.tsx
````typescript
  1: import React, { useEffect, useRef, useState } from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import { X, Volume2, VolumeX, Github } from "lucide-react";
  4: import { Card } from "@/components/ui/card";
  5: import { Button } from "@/components/ui/button";
  6: import { openUrl } from "@tauri-apps/plugin-opener";
  7: import asteriskLogo from "@/assets/nfo/asterisk-logo.png";
  8: import keygennMusic from "@/assets/nfo/claudia-nfo.ogg";
  9: 
 10: interface NFOCreditsProps {
 11:   /**
 12:    * Callback when the NFO window is closed
 13:    */
 14:   onClose: () => void;
 15: }
 16: 
 17: /**
 18:  * NFO Credits component - Displays a keygen/crack style credits window
 19:  * with auto-scrolling text, retro fonts, and background music
 20:  * 
 21:  * @example
 22:  * <NFOCredits onClose={() => setShowNFO(false)} />
 23:  */
 24: export const NFOCredits: React.FC<NFOCreditsProps> = ({ onClose }) => {
 25:   const audioRef = useRef<HTMLAudioElement | null>(null);
 26:   const scrollRef = useRef<HTMLDivElement | null>(null);
 27:   const [isMuted, setIsMuted] = useState(false);
 28:   const [scrollPosition, setScrollPosition] = useState(0);
 29:   
 30:   // Initialize and autoplay audio muted then unmute
 31:   useEffect(() => {
 32:     const audio = new Audio(keygennMusic);
 33:     audio.loop = true;
 34:     audio.volume = 0.7;
 35:     // Start muted to satisfy autoplay policy
 36:     audio.muted = true;
 37:     audioRef.current = audio;
 38:     // Attempt to play
 39:     audio.play().then(() => {
 40:       // Unmute after autoplay
 41:       audio.muted = false;
 42:     }).catch(err => {
 43:       console.error("Audio autoplay failed:", err);
 44:     });
 45:     return () => {
 46:       if (audioRef.current) {
 47:         audioRef.current.pause();
 48:         audioRef.current.src = '';
 49:         audioRef.current = null;
 50:       }
 51:     };
 52:   }, []);
 53:   
 54:   // Handle mute toggle
 55:   const toggleMute = () => {
 56:     if (audioRef.current) {
 57:       audioRef.current.muted = !isMuted;
 58:       setIsMuted(!isMuted);
 59:     }
 60:   };
 61:   
 62:   // Start auto-scrolling
 63:   useEffect(() => {
 64:     const scrollInterval = setInterval(() => {
 65:       setScrollPosition(prev => prev + 1);
 66:     }, 30); // Smooth scrolling speed
 67:     
 68:     return () => clearInterval(scrollInterval);
 69:   }, []);
 70:   
 71:   // Apply scroll position
 72:   useEffect(() => {
 73:     if (scrollRef.current) {
 74:       const maxScroll = scrollRef.current.scrollHeight - scrollRef.current.clientHeight;
 75:       if (scrollPosition >= maxScroll) {
 76:         // Reset to beginning when reaching the end
 77:         setScrollPosition(0);
 78:         scrollRef.current.scrollTop = 0;
 79:       } else {
 80:         scrollRef.current.scrollTop = scrollPosition;
 81:       }
 82:     }
 83:   }, [scrollPosition]);
 84:   
 85:   // Credits content
 86:   const creditsContent = [
 87:     { type: "header", text: "CLAUDIA v0.1.0" },
 88:     { type: "subheader", text: "[ A STRATEGIC PROJECT BY ASTERISK ]" },
 89:     { type: "spacer" },
 90:     { type: "section", title: "━━━ CREDITS ━━━" },
 91:     { type: "credit", role: "POWERED BY", name: "Anthropic Claude 4" },
 92:     { type: "credit", role: "CLAUDE CODE", name: "The Ultimate Coding Assistant" },
 93:     { type: "credit", role: "MCP PROTOCOL", name: "Model Context Protocol" },
 94:     { type: "spacer" },
 95:     { type: "section", title: "━━━ DEPENDENCIES ━━━" },
 96:     { type: "credit", role: "RUNTIME", name: "Tauri Framework" },
 97:     { type: "credit", role: "UI FRAMEWORK", name: "React + TypeScript" },
 98:     { type: "credit", role: "STYLING", name: "Tailwind CSS + shadcn/ui" },
 99:     { type: "credit", role: "ANIMATIONS", name: "Framer Motion" },
100:     { type: "credit", role: "BUILD TOOL", name: "Vite" },
101:     { type: "credit", role: "PACKAGE MANAGER", name: "Bun" },
102:     { type: "spacer" },
103:     { type: "section", title: "━━━ SPECIAL THANKS ━━━" },
104:     { type: "text", content: "To the open source community" },
105:     { type: "text", content: "To all the beta testers" },
106:     { type: "text", content: "To everyone who believed in this project" },
107:     { type: "spacer" },
108:     { type: "ascii", content: `
109:      ▄▄▄· .▄▄ · ▄▄▄▄▄▄▄▄ .▄▄▄  ▪  .▄▄ · ▄ •▄ 
110:     ▐█ ▀█ ▐█ ▀. •██  ▀▄.▀·▀▄ █·██ ▐█ ▀. █▌▄▌▪
111:     ▄█▀▀█ ▄▀▀▀█▄ ▐█.▪▐▀▀▪▄▐▀▀▄ ▐█·▄▀▀▀█▄▐▀▀▄·
112:     ▐█ ▪▐▌▐█▄▪▐█ ▐█▌·▐█▄▄▌▐█•█▌▐█▌▐█▄▪▐█▐█.█▌
113:      ▀  ▀  ▀▀▀▀  ▀▀▀  ▀▀▀ .▀  ▀▀▀▀ ▀▀▀▀ ·▀  ▀
114:     ` },
115:     { type: "spacer" },
116:     { type: "text", content: "Remember: Sharing is caring!" },
117:     { type: "text", content: "Support the developers!" },
118:     { type: "spacer" },
119:     { type: "spacer" },
120:     { type: "spacer" },
121:   ];
122:   
123:   return (
124:     <AnimatePresence>
125:       <motion.div
126:         initial={{ opacity: 0 }}
127:         animate={{ opacity: 1 }}
128:         exit={{ opacity: 0 }}
129:         className="fixed inset-0 z-50 flex items-center justify-center"
130:       >
131:         {/* Backdrop with blur */}
132:         <div 
133:           className="absolute inset-0 bg-black/80 backdrop-blur-md"
134:           onClick={onClose}
135:         />
136:         
137:         {/* NFO Window */}
138:         <motion.div
139:           initial={{ scale: 0.8, opacity: 0 }}
140:           animate={{ scale: 1, opacity: 1 }}
141:           exit={{ scale: 0.8, opacity: 0 }}
142:           transition={{ type: "spring", damping: 25, stiffness: 300 }}
143:           className="relative z-10"
144:         >
145:           <Card className="w-[600px] h-[500px] bg-background border-border shadow-2xl overflow-hidden">
146:             {/* Window Header */}
147:             <div className="flex items-center justify-between px-4 py-2 bg-card border-b border-border">
148:               <div className="flex items-center space-x-2">
149:                 <div className="text-sm font-bold tracking-wider font-mono text-foreground">
150:                   CLAUDIA.NFO
151:                 </div>
152:               </div>
153:               <div className="flex items-center space-x-2">
154:                 <Button
155:                   variant="ghost"
156:                   size="sm"
157:                   onClick={async (e) => {
158:                     e.stopPropagation();
159:                     await openUrl("https://github.com/getAsterisk/claudia/issues/new");
160:                   }}
161:                   className="flex items-center gap-1 h-auto px-2 py-1"
162:                   title="File a bug"
163:                 >
164:                   <Github className="h-3 w-3" />
165:                   <span className="text-xs">File a bug</span>
166:                 </Button>
167:                 <Button
168:                   variant="ghost"
169:                   size="sm"
170:                   onClick={(e) => {
171:                     e.stopPropagation();
172:                     toggleMute();
173:                   }}
174:                   className="h-6 w-6 p-0"
175:                 >
176:                   {isMuted ? <VolumeX className="h-4 w-4" /> : <Volume2 className="h-4 w-4" />}
177:                 </Button>
178:                 <Button
179:                   variant="ghost"
180:                   size="sm"
181:                   onClick={(e) => {
182:                     e.stopPropagation();
183:                     onClose();
184:                   }}
185:                   className="h-6 w-6 p-0"
186:                 >
187:                   <X className="h-4 w-4" />
188:                 </Button>
189:               </div>
190:             </div>
191:             
192:             {/* NFO Content */}
193:             <div className="relative h-[calc(100%-40px)] bg-background overflow-hidden">
194:               {/* Asterisk Logo Section (Fixed at top) */}
195:               <div className="absolute top-0 left-0 right-0 bg-background z-10 pb-4 text-center">
196:                 <button
197:                   className="inline-block mt-4 hover:scale-110 transition-transform cursor-pointer"
198:                   onClick={async (e) => {
199:                     e.stopPropagation();
200:                     await openUrl("https://asterisk.so");
201:                   }}
202:                 >
203:                   <img 
204:                     src={asteriskLogo} 
205:                     alt="Asterisk" 
206:                     className="h-20 w-auto mx-auto filter brightness-0 invert opacity-90"
207:                   />
208:                 </button>
209:                 <div className="text-muted-foreground text-sm font-mono mt-2 tracking-wider">
210:                   A strategic project by Asterisk
211:                 </div>
212:               </div>
213:               
214:               {/* Scrolling Credits */}
215:               <div 
216:                 ref={scrollRef}
217:                 className="absolute inset-0 top-32 overflow-hidden"
218:                 style={{ fontFamily: "'Courier New', monospace" }}
219:               >
220:                 <div className="px-8 pb-32">
221:                   {creditsContent.map((item, index) => {
222:                     switch (item.type) {
223:                       case "header":
224:                         return (
225:                           <div 
226:                             key={index} 
227:                             className="text-foreground text-3xl font-bold text-center mb-2 tracking-widest"
228:                           >
229:                             {item.text}
230:                           </div>
231:                         );
232:                       case "subheader":
233:                         return (
234:                           <div 
235:                             key={index} 
236:                             className="text-muted-foreground text-lg text-center mb-8 tracking-wide"
237:                           >
238:                             {item.text}
239:                           </div>
240:                         );
241:                       case "section":
242:                         return (
243:                           <div 
244:                             key={index} 
245:                             className="text-foreground text-xl font-bold text-center my-6 tracking-wider"
246:                           >
247:                             {item.title}
248:                           </div>
249:                         );
250:                       case "credit":
251:                         return (
252:                           <div 
253:                             key={index} 
254:                             className="flex justify-between items-center mb-2 text-foreground"
255:                           >
256:                             <span className="text-sm text-muted-foreground">{item.role}:</span>
257:                             <span className="text-base tracking-wide">{item.name}</span>
258:                           </div>
259:                         );
260:                       case "text":
261:                         return (
262:                           <div 
263:                             key={index} 
264:                             className="text-muted-foreground text-center text-sm mb-2"
265:                           >
266:                             {item.content}
267:                           </div>
268:                         );
269:                       case "ascii":
270:                         return (
271:                           <pre 
272:                             key={index} 
273:                             className="text-foreground text-xs text-center my-6 leading-tight opacity-80"
274:                           >
275:                             {item.content}
276:                           </pre>
277:                         );
278:                       case "spacer":
279:                         return <div key={index} className="h-8" />;
280:                       default:
281:                         return null;
282:                     }
283:                   })}
284:                 </div>
285:               </div>
286:               
287:               {/* Subtle Scanlines Effect */}
288:               <div className="absolute inset-0 pointer-events-none">
289:                 <div className="absolute inset-0 bg-gradient-to-b from-transparent via-foreground/[0.02] to-transparent animate-scanlines" />
290:               </div>
291:             </div>
292:           </Card>
293:         </motion.div>
294:       </motion.div>
295:     </AnimatePresence>
296:   );
297: };
````

## File: src/components/PreviewPromptDialog.tsx
````typescript
  1: import React from "react";
  2: import { motion } from "framer-motion";
  3: import { Globe, ExternalLink } from "lucide-react";
  4: import { Button } from "@/components/ui/button";
  5: import {
  6:   Dialog,
  7:   DialogContent,
  8:   DialogDescription,
  9:   DialogFooter,
 10:   DialogHeader,
 11:   DialogTitle,
 12: } from "@/components/ui/dialog";
 13: 
 14: interface PreviewPromptDialogProps {
 15:   /**
 16:    * Whether the dialog is open
 17:    */
 18:   isOpen: boolean;
 19:   /**
 20:    * The detected URL to preview
 21:    */
 22:   url: string;
 23:   /**
 24:    * Callback when user confirms opening preview
 25:    */
 26:   onConfirm: () => void;
 27:   /**
 28:    * Callback when user cancels
 29:    */
 30:   onCancel: () => void;
 31: }
 32: 
 33: /**
 34:  * Dialog component that prompts the user to open a detected URL in the preview pane
 35:  * 
 36:  * @example
 37:  * <PreviewPromptDialog
 38:  *   isOpen={showPrompt}
 39:  *   url="http://localhost:3000"
 40:  *   onConfirm={() => openPreview(url)}
 41:  *   onCancel={() => setShowPrompt(false)}
 42:  * />
 43:  */
 44: export const PreviewPromptDialog: React.FC<PreviewPromptDialogProps> = ({
 45:   isOpen,
 46:   url,
 47:   onConfirm,
 48:   onCancel,
 49: }) => {
 50:   // Extract domain for display
 51:   const getDomain = (urlString: string) => {
 52:     try {
 53:       const urlObj = new URL(urlString);
 54:       return urlObj.hostname;
 55:     } catch {
 56:       return urlString;
 57:     }
 58:   };
 59: 
 60:   const domain = getDomain(url);
 61:   const isLocalhost = domain.includes('localhost') || domain.includes('127.0.0.1');
 62: 
 63:   return (
 64:     <Dialog open={isOpen} onOpenChange={(open) => !open && onCancel()}>
 65:       <DialogContent className="sm:max-w-[425px]">
 66:         <DialogHeader>
 67:           <DialogTitle className="flex items-center gap-2">
 68:             <Globe className="h-5 w-5 text-primary" />
 69:             Open Preview?
 70:           </DialogTitle>
 71:           <DialogDescription>
 72:             A URL was detected in the terminal output. Would you like to open it in the preview pane?
 73:           </DialogDescription>
 74:         </DialogHeader>
 75:         
 76:         <div className="py-4">
 77:           <div className="rounded-lg border bg-muted/50 p-4">
 78:             <div className="flex items-start gap-3">
 79:               <ExternalLink className={`h-4 w-4 mt-0.5 ${isLocalhost ? 'text-green-500' : 'text-blue-500'}`} />
 80:               <div className="flex-1 min-w-0">
 81:                 <p className="text-sm font-medium">
 82:                   {isLocalhost ? 'Local Development Server' : 'External URL'}
 83:                 </p>
 84:                 <p className="text-xs text-muted-foreground mt-1 break-all">
 85:                   {url}
 86:                 </p>
 87:               </div>
 88:             </div>
 89:           </div>
 90:           
 91:           <motion.div
 92:             initial={{ opacity: 0, y: 10 }}
 93:             animate={{ opacity: 1, y: 0 }}
 94:             transition={{ delay: 0.1 }}
 95:             className="mt-3 text-xs text-muted-foreground"
 96:           >
 97:             The preview will open in a split view on the right side of the screen.
 98:           </motion.div>
 99:         </div>
100:         
101:         <DialogFooter>
102:           <Button variant="outline" onClick={onCancel}>
103:             Cancel
104:           </Button>
105:           <Button onClick={onConfirm} className="gap-2">
106:             <ExternalLink className="h-4 w-4" />
107:             Open Preview
108:           </Button>
109:         </DialogFooter>
110:       </DialogContent>
111:     </Dialog>
112:   );
113: };
````

## File: src/components/ProjectList.tsx
````typescript
  1: import React, { useState } from "react";
  2: import { motion } from "framer-motion";
  3: import { 
  4:   FolderOpen, 
  5:   Calendar, 
  6:   FileText, 
  7:   ChevronRight, 
  8:   Settings,
  9:   MoreVertical
 10: } from "lucide-react";
 11: import { Button } from "@/components/ui/button";
 12: import { Card } from "@/components/ui/card";
 13: import { Badge } from "@/components/ui/badge";
 14: import {
 15:   DropdownMenu,
 16:   DropdownMenuContent,
 17:   DropdownMenuItem,
 18:   DropdownMenuTrigger,
 19: } from "@/components/ui/dropdown-menu";
 20: import type { Project } from "@/lib/api";
 21: import { cn } from "@/lib/utils";
 22: import { formatTimeAgo } from "@/lib/date-utils";
 23: import { Pagination } from "@/components/ui/pagination";
 24: 
 25: interface ProjectListProps {
 26:   /**
 27:    * Array of projects to display
 28:    */
 29:   projects: Project[];
 30:   /**
 31:    * Callback when a project is clicked
 32:    */
 33:   onProjectClick: (project: Project) => void;
 34:   /**
 35:    * Callback when hooks configuration is clicked
 36:    */
 37:   onProjectSettings?: (project: Project) => void;
 38:   /**
 39:    * Whether the list is currently loading
 40:    */
 41:   loading?: boolean;
 42:   /**
 43:    * Optional className for styling
 44:    */
 45:   className?: string;
 46: }
 47: 
 48: const ITEMS_PER_PAGE = 12;
 49: 
 50: /**
 51:  * Extracts the project name from the full path
 52:  */
 53: const getProjectName = (path: string): string => {
 54:   const parts = path.split('/').filter(Boolean);
 55:   return parts[parts.length - 1] || path;
 56: };
 57: 
 58: /**
 59:  * ProjectList component - Displays a paginated list of projects with hover animations
 60:  * 
 61:  * @example
 62:  * <ProjectList
 63:  *   projects={projects}
 64:  *   onProjectClick={(project) => console.log('Selected:', project)}
 65:  * />
 66:  */
 67: export const ProjectList: React.FC<ProjectListProps> = ({
 68:   projects,
 69:   onProjectClick,
 70:   onProjectSettings,
 71:   className,
 72: }) => {
 73:   const [currentPage, setCurrentPage] = useState(1);
 74:   
 75:   // Calculate pagination
 76:   const totalPages = Math.ceil(projects.length / ITEMS_PER_PAGE);
 77:   const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
 78:   const endIndex = startIndex + ITEMS_PER_PAGE;
 79:   const currentProjects = projects.slice(startIndex, endIndex);
 80:   
 81:   // Reset to page 1 if projects change
 82:   React.useEffect(() => {
 83:     setCurrentPage(1);
 84:   }, [projects.length]);
 85:   
 86:   return (
 87:     <div className={cn("space-y-4", className)}>
 88:       <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
 89:         {currentProjects.map((project, index) => (
 90:           <motion.div
 91:             key={project.id}
 92:             initial={{ opacity: 0, y: 20 }}
 93:             animate={{ opacity: 1, y: 0 }}
 94:             transition={{
 95:               duration: 0.3,
 96:               delay: index * 0.05,
 97:               ease: [0.4, 0, 0.2, 1],
 98:             }}
 99:           >
100:             <Card
101:               className="p-4 hover:shadow-md transition-all duration-200 cursor-pointer group h-full"
102:               onClick={() => onProjectClick(project)}
103:             >
104:               <div className="flex flex-col h-full">
105:                 <div className="flex-1">
106:                   <div className="flex items-start justify-between mb-2">
107:                     <div className="flex items-center gap-2 flex-1 min-w-0">
108:                       <FolderOpen className="h-5 w-5 text-primary shrink-0" />
109:                       <h3 className="font-semibold text-base truncate">
110:                         {getProjectName(project.path)}
111:                       </h3>
112:                     </div>
113:                     {project.sessions.length > 0 && (
114:                       <Badge variant="secondary" className="shrink-0 ml-2">
115:                         {project.sessions.length}
116:                       </Badge>
117:                     )}
118:                   </div>
119:                   
120:                   <p className="text-sm text-muted-foreground mb-3 font-mono truncate">
121:                     {project.path}
122:                   </p>
123:                 </div>
124:                 
125:                 <div className="flex items-center justify-between">
126:                   <div className="flex items-center gap-3 text-xs text-muted-foreground">
127:                     <div className="flex items-center gap-1">
128:                       <Calendar className="h-3 w-3" />
129:                       <span>{formatTimeAgo(project.created_at * 1000)}</span>
130:                     </div>
131:                     <div className="flex items-center gap-1">
132:                       <FileText className="h-3 w-3" />
133:                       <span>{project.sessions.length}</span>
134:                     </div>
135:                   </div>
136:                   
137:                   <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
138:                     {onProjectSettings && (
139:                       <DropdownMenu>
140:                         <DropdownMenuTrigger asChild onClick={(e) => e.stopPropagation()}>
141:                           <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
142:                             <MoreVertical className="h-4 w-4" />
143:                           </Button>
144:                         </DropdownMenuTrigger>
145:                         <DropdownMenuContent align="end">
146:                           <DropdownMenuItem
147:                             onClick={(e) => {
148:                               e.stopPropagation();
149:                               onProjectSettings(project);
150:                             }}
151:                           >
152:                             <Settings className="h-4 w-4 mr-2" />
153:                             Hooks
154:                           </DropdownMenuItem>
155:                         </DropdownMenuContent>
156:                       </DropdownMenu>
157:                     )}
158:                     <ChevronRight className="h-4 w-4 text-muted-foreground" />
159:                   </div>
160:                 </div>
161:               </div>
162:             </Card>
163:           </motion.div>
164:         ))}
165:       </div>
166:       
167:       <Pagination
168:         currentPage={currentPage}
169:         totalPages={totalPages}
170:         onPageChange={setCurrentPage}
171:       />
172:     </div>
173:   );
174: };
````

## File: src/components/ProjectSettings.tsx
````typescript
  1: /**
  2:  * ProjectSettings component for managing project-specific hooks configuration
  3:  */
  4: 
  5: import React, { useState, useEffect } from 'react';
  6: import { HooksEditor } from '@/components/HooksEditor';
  7: import { SlashCommandsManager } from '@/components/SlashCommandsManager';
  8: import { api } from '@/lib/api';
  9: import { 
 10:   AlertTriangle, 
 11:   ArrowLeft, 
 12:   Settings,
 13:   FolderOpen,
 14:   GitBranch,
 15:   Shield,
 16:   Command
 17: } from 'lucide-react';
 18: import { Button } from '@/components/ui/button';
 19: import { Card } from '@/components/ui/card';
 20: import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
 21: import { cn } from '@/lib/utils';
 22: import { Toast, ToastContainer } from '@/components/ui/toast';
 23: import type { Project } from '@/lib/api';
 24: 
 25: interface ProjectSettingsProps {
 26:   project: Project;
 27:   onBack: () => void;
 28:   className?: string;
 29: }
 30: 
 31: export const ProjectSettings: React.FC<ProjectSettingsProps> = ({
 32:   project,
 33:   onBack,
 34:   className
 35: }) => {
 36:   const [activeTab, setActiveTab] = useState('commands');
 37:   const [toast, setToast] = useState<{ message: string; type: 'success' | 'error' } | null>(null);
 38:   
 39:   // Other hooks settings
 40:   const [gitIgnoreLocal, setGitIgnoreLocal] = useState(true);
 41: 
 42:   useEffect(() => {
 43:     checkGitIgnore();
 44:   }, [project]);
 45: 
 46:   const checkGitIgnore = async () => {
 47:     try {
 48:       // Check if .claude/settings.local.json is in .gitignore
 49:       const gitignorePath = `${project.path}/.gitignore`;
 50:       const gitignoreContent = await api.readClaudeMdFile(gitignorePath);
 51:       setGitIgnoreLocal(gitignoreContent.includes('.claude/settings.local.json'));
 52:     } catch {
 53:       // .gitignore might not exist
 54:       setGitIgnoreLocal(false);
 55:     }
 56:   };
 57: 
 58:   const addToGitIgnore = async () => {
 59:     try {
 60:       const gitignorePath = `${project.path}/.gitignore`;
 61:       let content = '';
 62:       
 63:       try {
 64:         content = await api.readClaudeMdFile(gitignorePath);
 65:       } catch {
 66:         // File doesn't exist, create it
 67:       }
 68:       
 69:       if (!content.includes('.claude/settings.local.json')) {
 70:         content += '\n# Claude local settings (machine-specific)\n.claude/settings.local.json\n';
 71:         await api.saveClaudeMdFile(gitignorePath, content);
 72:         setGitIgnoreLocal(true);
 73:         setToast({ message: 'Added to .gitignore', type: 'success' });
 74:       }
 75:     } catch (err) {
 76:       console.error('Failed to update .gitignore:', err);
 77:       setToast({ message: 'Failed to update .gitignore', type: 'error' });
 78:     }
 79:   };
 80: 
 81:   return (
 82:     <div className={cn("flex flex-col h-full", className)}>
 83:       {/* Header */}
 84:       <div className="border-b px-6 py-4">
 85:         <div className="flex items-center justify-between">
 86:           <div className="flex items-center gap-4">
 87:             <Button variant="ghost" size="sm" onClick={onBack}>
 88:               <ArrowLeft className="h-4 w-4 mr-2" />
 89:               Back
 90:             </Button>
 91:             <div className="flex items-center gap-2">
 92:               <Settings className="h-5 w-5 text-muted-foreground" />
 93:               <h2 className="text-xl font-semibold">Project Settings</h2>
 94:             </div>
 95:           </div>
 96:         </div>
 97:         
 98:         <div className="mt-4 flex items-center gap-4 text-sm text-muted-foreground">
 99:           <div className="flex items-center gap-2">
100:             <FolderOpen className="h-4 w-4" />
101:             <span className="font-mono">{project.path}</span>
102:           </div>
103:         </div>
104:       </div>
105: 
106:       {/* Content */}
107:       <div className="flex-1 overflow-y-auto">
108:         <div className="p-6">
109:           <Tabs value={activeTab} onValueChange={setActiveTab}>
110:             <TabsList className="mb-6">
111:               <TabsTrigger value="commands" className="gap-2">
112:                 <Command className="h-4 w-4" />
113:                 Slash Commands
114:               </TabsTrigger>
115:               <TabsTrigger value="project" className="gap-2">
116:                 <GitBranch className="h-4 w-4" />
117:                 Project Hooks
118:               </TabsTrigger>
119:               <TabsTrigger value="local" className="gap-2">
120:                 <Shield className="h-4 w-4" />
121:                 Local Hooks
122:               </TabsTrigger>
123:             </TabsList>
124: 
125:             <TabsContent value="commands" className="space-y-6">
126:               <Card className="p-6">
127:                 <div className="space-y-4">
128:                   <div>
129:                     <h3 className="text-lg font-semibold mb-2">Project Slash Commands</h3>
130:                     <p className="text-sm text-muted-foreground mb-4">
131:                       Custom commands that are specific to this project. These commands are stored in
132:                       <code className="mx-1 px-2 py-1 bg-muted rounded text-xs">.claude/slash-commands/</code>
133:                       and can be committed to version control.
134:                     </p>
135:                   </div>
136:                   
137:                   <SlashCommandsManager
138:                     projectPath={project.path}
139:                     scopeFilter="project"
140:                   />
141:                 </div>
142:               </Card>
143:             </TabsContent>
144: 
145:             <TabsContent value="project" className="space-y-6">
146:               <Card className="p-6">
147:                 <div className="space-y-4">
148:                   <div>
149:                     <h3 className="text-lg font-semibold mb-2">Project Hooks</h3>
150:                     <p className="text-sm text-muted-foreground mb-4">
151:                       These hooks apply to all users working on this project. They are stored in
152:                       <code className="mx-1 px-2 py-1 bg-muted rounded text-xs">.claude/settings.json</code>
153:                       and should be committed to version control.
154:                     </p>
155:                   </div>
156:                   
157:                   <HooksEditor
158:                     projectPath={project.path}
159:                     scope="project"
160:                   />
161:                 </div>
162:               </Card>
163:             </TabsContent>
164: 
165:             <TabsContent value="local" className="space-y-6">
166:               <Card className="p-6">
167:                 <div className="space-y-4">
168:                   <div>
169:                     <h3 className="text-lg font-semibold mb-2">Local Hooks</h3>
170:                     <p className="text-sm text-muted-foreground mb-4">
171:                       These hooks only apply to your machine. They are stored in
172:                       <code className="mx-1 px-2 py-1 bg-muted rounded text-xs">.claude/settings.local.json</code>
173:                       and should NOT be committed to version control.
174:                     </p>
175:                     
176:                     {!gitIgnoreLocal && (
177:                       <div className="flex items-center gap-4 p-3 bg-yellow-500/10 rounded-md">
178:                         <AlertTriangle className="h-5 w-5 text-yellow-600" />
179:                         <div className="flex-1">
180:                           <p className="text-sm text-yellow-600">
181:                             Local settings file is not in .gitignore
182:                           </p>
183:                         </div>
184:                         <Button
185:                           size="sm"
186:                           variant="outline"
187:                           onClick={addToGitIgnore}
188:                         >
189:                           Add to .gitignore
190:                         </Button>
191:                       </div>
192:                     )}
193:                   </div>
194:                   
195:                   <HooksEditor
196:                     projectPath={project.path}
197:                     scope="local"
198:                   />
199:                 </div>
200:               </Card>
201:             </TabsContent>
202:           </Tabs>
203:         </div>
204:       </div>
205: 
206:       {/* Toast Container */}
207:       <ToastContainer>
208:         {toast && (
209:           <Toast
210:             message={toast.message}
211:             type={toast.type}
212:             onDismiss={() => setToast(null)}
213:           />
214:         )}
215:       </ToastContainer>
216:     </div>
217:   );
218: };
````

## File: src/components/ProxySettings.tsx
````typescript
  1: import { useState, useEffect } from 'react';
  2: import { invoke } from '@tauri-apps/api/core';
  3: import { Input } from '@/components/ui/input';
  4: import { Label } from '@/components/ui/label';
  5: import { Switch } from '@/components/ui/switch';
  6: 
  7: export interface ProxySettings {
  8:   http_proxy: string | null;
  9:   https_proxy: string | null;
 10:   no_proxy: string | null;
 11:   all_proxy: string | null;
 12:   enabled: boolean;
 13: }
 14: 
 15: interface ProxySettingsProps {
 16:   setToast: (toast: { message: string; type: 'success' | 'error' } | null) => void;
 17:   onChange?: (hasChanges: boolean, getSettings: () => ProxySettings, saveSettings: () => Promise<void>) => void;
 18: }
 19: 
 20: export function ProxySettings({ setToast, onChange }: ProxySettingsProps) {
 21:   const [settings, setSettings] = useState<ProxySettings>({
 22:     http_proxy: null,
 23:     https_proxy: null,
 24:     no_proxy: null,
 25:     all_proxy: null,
 26:     enabled: false,
 27:   });
 28:   const [originalSettings, setOriginalSettings] = useState<ProxySettings>({
 29:     http_proxy: null,
 30:     https_proxy: null,
 31:     no_proxy: null,
 32:     all_proxy: null,
 33:     enabled: false,
 34:   });
 35: 
 36:   useEffect(() => {
 37:     loadSettings();
 38:   }, []);
 39: 
 40:   // Save settings function
 41:   const saveSettings = async () => {
 42:     try {
 43:       await invoke('save_proxy_settings', { settings });
 44:       setOriginalSettings(settings);
 45:       setToast({
 46:         message: 'Proxy settings saved and applied successfully.',
 47:         type: 'success',
 48:       });
 49:     } catch (error) {
 50:       console.error('Failed to save proxy settings:', error);
 51:       setToast({
 52:         message: 'Failed to save proxy settings',
 53:         type: 'error',
 54:       });
 55:       throw error; // Re-throw to let parent handle the error
 56:     }
 57:   };
 58: 
 59:   // Notify parent component of changes
 60:   useEffect(() => {
 61:     if (onChange) {
 62:       const hasChanges = JSON.stringify(settings) !== JSON.stringify(originalSettings);
 63:       onChange(hasChanges, () => settings, saveSettings);
 64:     }
 65:   }, [settings, originalSettings, onChange]);
 66: 
 67:   const loadSettings = async () => {
 68:     try {
 69:       const loadedSettings = await invoke<ProxySettings>('get_proxy_settings');
 70:       setSettings(loadedSettings);
 71:       setOriginalSettings(loadedSettings);
 72:     } catch (error) {
 73:       console.error('Failed to load proxy settings:', error);
 74:       setToast({
 75:         message: 'Failed to load proxy settings',
 76:         type: 'error',
 77:       });
 78:     }
 79:   };
 80: 
 81: 
 82:   const handleInputChange = (field: keyof ProxySettings, value: string) => {
 83:     setSettings(prev => ({
 84:       ...prev,
 85:       [field]: value || null,
 86:     }));
 87:   };
 88: 
 89:   return (
 90:     <div className="space-y-6">
 91:       <div>
 92:         <h3 className="text-lg font-medium">Proxy Settings</h3>
 93:         <p className="text-sm text-muted-foreground">
 94:           Configure proxy settings for Claude API requests
 95:         </p>
 96:       </div>
 97: 
 98:       <div className="space-y-4">
 99:         <div className="flex items-center justify-between">
100:           <div className="space-y-0.5">
101:             <Label htmlFor="proxy-enabled">Enable Proxy</Label>
102:             <p className="text-sm text-muted-foreground">
103:               Use proxy for all Claude API requests
104:             </p>
105:           </div>
106:           <Switch
107:             id="proxy-enabled"
108:             checked={settings.enabled}
109:             onCheckedChange={(checked) => setSettings(prev => ({ ...prev, enabled: checked }))}
110:           />
111:         </div>
112: 
113:         <div className="space-y-4" style={{ opacity: settings.enabled ? 1 : 0.5 }}>
114:           <div className="space-y-2">
115:             <Label htmlFor="http-proxy">HTTP Proxy</Label>
116:             <Input
117:               id="http-proxy"
118:               placeholder="http://proxy.example.com:8080"
119:               value={settings.http_proxy || ''}
120:               onChange={(e) => handleInputChange('http_proxy', e.target.value)}
121:               disabled={!settings.enabled}
122:             />
123:           </div>
124: 
125:           <div className="space-y-2">
126:             <Label htmlFor="https-proxy">HTTPS Proxy</Label>
127:             <Input
128:               id="https-proxy"
129:               placeholder="http://proxy.example.com:8080"
130:               value={settings.https_proxy || ''}
131:               onChange={(e) => handleInputChange('https_proxy', e.target.value)}
132:               disabled={!settings.enabled}
133:             />
134:           </div>
135: 
136:           <div className="space-y-2">
137:             <Label htmlFor="no-proxy">No Proxy</Label>
138:             <Input
139:               id="no-proxy"
140:               placeholder="localhost,127.0.0.1,.example.com"
141:               value={settings.no_proxy || ''}
142:               onChange={(e) => handleInputChange('no_proxy', e.target.value)}
143:               disabled={!settings.enabled}
144:             />
145:             <p className="text-xs text-muted-foreground">
146:               Comma-separated list of hosts that should bypass the proxy
147:             </p>
148:           </div>
149: 
150:           <div className="space-y-2">
151:             <Label htmlFor="all-proxy">All Proxy (Optional)</Label>
152:             <Input
153:               id="all-proxy"
154:               placeholder="socks5://proxy.example.com:1080"
155:               value={settings.all_proxy || ''}
156:               onChange={(e) => handleInputChange('all_proxy', e.target.value)}
157:               disabled={!settings.enabled}
158:             />
159:             <p className="text-xs text-muted-foreground">
160:               Proxy URL to use for all protocols if protocol-specific proxies are not set
161:             </p>
162:           </div>
163:         </div>
164: 
165:       </div>
166:     </div>
167:   );
168: }
````

## File: src/components/RunningClaudeSessions.tsx
````typescript
  1: import React, { useState, useEffect } from "react";
  2: import { motion } from "framer-motion";
  3: import { Play, Loader2, Terminal, AlertCircle } from "lucide-react";
  4: import { Card, CardContent } from "@/components/ui/card";
  5: import { Button } from "@/components/ui/button";
  6: import { api, type ProcessInfo, type Session } from "@/lib/api";
  7: import { cn } from "@/lib/utils";
  8: import { formatISOTimestamp } from "@/lib/date-utils";
  9: 
 10: interface RunningClaudeSessionsProps {
 11:   /**
 12:    * Callback when a running session is clicked to resume
 13:    */
 14:   onSessionClick?: (session: Session) => void;
 15:   /**
 16:    * Optional className for styling
 17:    */
 18:   className?: string;
 19: }
 20: 
 21: /**
 22:  * Component to display currently running Claude sessions
 23:  */
 24: export const RunningClaudeSessions: React.FC<RunningClaudeSessionsProps> = ({
 25:   onSessionClick,
 26:   className,
 27: }) => {
 28:   const [runningSessions, setRunningSessions] = useState<ProcessInfo[]>([]);
 29:   const [loading, setLoading] = useState(true);
 30:   const [error, setError] = useState<string | null>(null);
 31: 
 32:   useEffect(() => {
 33:     loadRunningSessions();
 34:     
 35:     // Poll for updates every 5 seconds
 36:     const interval = setInterval(loadRunningSessions, 5000);
 37:     return () => clearInterval(interval);
 38:   }, []);
 39: 
 40:   const loadRunningSessions = async () => {
 41:     try {
 42:       const sessions = await api.listRunningClaudeSessions();
 43:       setRunningSessions(sessions);
 44:       setError(null);
 45:     } catch (err) {
 46:       console.error("Failed to load running sessions:", err);
 47:       setError("Failed to load running sessions");
 48:     } finally {
 49:       setLoading(false);
 50:     }
 51:   };
 52: 
 53:   const handleResumeSession = (processInfo: ProcessInfo) => {
 54:     // Extract session ID from process type
 55:     if ('ClaudeSession' in processInfo.process_type) {
 56:       const sessionId = processInfo.process_type.ClaudeSession.session_id;
 57:       
 58:       // Create a minimal session object for resumption
 59:       const session: Session = {
 60:         id: sessionId,
 61:         project_id: processInfo.project_path.replace(/[^a-zA-Z0-9]/g, '-'),
 62:         project_path: processInfo.project_path,
 63:         created_at: new Date(processInfo.started_at).getTime() / 1000,
 64:       };
 65:       
 66:       // Emit event to navigate to the session
 67:       const event = new CustomEvent('claude-session-selected', { 
 68:         detail: { session, projectPath: processInfo.project_path } 
 69:       });
 70:       window.dispatchEvent(event);
 71:       
 72:       onSessionClick?.(session);
 73:     }
 74:   };
 75: 
 76:   if (loading && runningSessions.length === 0) {
 77:     return (
 78:       <div className={cn("flex items-center justify-center py-4", className)}>
 79:         <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />
 80:       </div>
 81:     );
 82:   }
 83: 
 84:   if (error) {
 85:     return (
 86:       <div className={cn("flex items-center gap-2 text-destructive text-sm", className)}>
 87:         <AlertCircle className="h-4 w-4" />
 88:         <span>{error}</span>
 89:       </div>
 90:     );
 91:   }
 92: 
 93:   if (runningSessions.length === 0) {
 94:     return null;
 95:   }
 96: 
 97:   return (
 98:     <div className={cn("space-y-3", className)}>
 99:       <div className="flex items-center gap-2">
100:         <div className="flex items-center gap-1">
101:           <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse" />
102:           <h3 className="text-sm font-medium">Active Claude Sessions</h3>
103:         </div>
104:         <span className="text-xs text-muted-foreground">
105:           ({runningSessions.length} running)
106:         </span>
107:       </div>
108: 
109:       <div className="space-y-2">
110:         {runningSessions.map((session) => {
111:           const sessionId = 'ClaudeSession' in session.process_type 
112:             ? session.process_type.ClaudeSession.session_id 
113:             : null;
114:           
115:           if (!sessionId) return null;
116: 
117:           return (
118:             <motion.div
119:               key={session.run_id}
120:               initial={{ opacity: 0, y: 10 }}
121:               animate={{ opacity: 1, y: 0 }}
122:               transition={{ duration: 0.2 }}
123:             >
124:               <Card className="transition-all hover:shadow-md hover:scale-[1.01] cursor-pointer">
125:                 <CardContent 
126:                   className="p-3"
127:                   onClick={() => handleResumeSession(session)}
128:                 >
129:                   <div className="flex items-start justify-between gap-3">
130:                     <div className="flex items-start gap-3 flex-1 min-w-0">
131:                       <Terminal className="h-4 w-4 text-green-600 mt-0.5 flex-shrink-0" />
132:                       <div className="space-y-1 flex-1 min-w-0">
133:                         <div className="flex items-center gap-2">
134:                           <p className="font-mono text-xs text-muted-foreground truncate">
135:                             {sessionId.substring(0, 20)}...
136:                           </p>
137:                           <span className="text-xs text-green-600 font-medium">
138:                             Running
139:                           </span>
140:                         </div>
141:                         
142:                         <p className="text-xs text-muted-foreground truncate">
143:                           {session.project_path}
144:                         </p>
145:                         
146:                         <div className="flex items-center gap-3 text-xs text-muted-foreground">
147:                           <span>Started: {formatISOTimestamp(session.started_at)}</span>
148:                           <span>Model: {session.model}</span>
149:                           {session.task && (
150:                             <span className="truncate max-w-[200px]" title={session.task}>
151:                               Task: {session.task}
152:                             </span>
153:                           )}
154:                         </div>
155:                       </div>
156:                     </div>
157:                     
158:                     <Button
159:                       size="sm"
160:                       variant="ghost"
161:                       className="flex-shrink-0"
162:                     >
163:                       <Play className="h-3 w-3 mr-1" />
164:                       Resume
165:                     </Button>
166:                   </div>
167:                 </CardContent>
168:               </Card>
169:             </motion.div>
170:           );
171:         })}
172:       </div>
173:     </div>
174:   );
175: };
````

## File: src/components/SessionList.optimized.tsx
````typescript
  1: import React, { useMemo, useCallback } from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import { FileText, ArrowLeft, Calendar, Clock } from "lucide-react";
  4: import { Card, CardContent } from "@/components/ui/card";
  5: import { Button } from "@/components/ui/button";
  6: import { Pagination } from "@/components/ui/pagination";
  7: import { ClaudeMemoriesDropdown } from "@/components/ClaudeMemoriesDropdown";
  8: import { cn } from "@/lib/utils";
  9: import { formatUnixTimestamp, formatISOTimestamp } from "@/lib/date-utils";
 10: import { usePagination } from "@/hooks/usePagination";
 11: import type { Session, ClaudeMdFile } from "@/lib/api";
 12: 
 13: interface SessionListProps {
 14:   sessions: Session[];
 15:   projectPath: string;
 16:   onBack: () => void;
 17:   onSessionClick?: (session: Session) => void;
 18:   onEditClaudeFile?: (file: ClaudeMdFile) => void;
 19:   className?: string;
 20: }
 21: 
 22: // Memoized session card component to prevent unnecessary re-renders
 23: const SessionCard = React.memo<{
 24:   session: Session;
 25:   projectPath: string;
 26:   onClick?: () => void;
 27:   onEditClaudeFile?: (file: ClaudeMdFile) => void;
 28: }>(({ session, projectPath, onClick, onEditClaudeFile }) => {
 29:   const formatTime = useCallback((timestamp: string | number | undefined) => {
 30:     if (!timestamp) return "Unknown time";
 31:     
 32:     if (typeof timestamp === "string") {
 33:       return formatISOTimestamp(timestamp);
 34:     } else {
 35:       return formatUnixTimestamp(timestamp);
 36:     }
 37:   }, []);
 38: 
 39:   return (
 40:     <motion.div
 41:       initial={{ opacity: 0, y: 20 }}
 42:       animate={{ opacity: 1, y: 0 }}
 43:       exit={{ opacity: 0, y: -20 }}
 44:       whileHover={{ scale: 1.01 }}
 45:       whileTap={{ scale: 0.99 }}
 46:     >
 47:       <Card 
 48:         className={cn(
 49:           "cursor-pointer transition-all",
 50:           "hover:shadow-lg hover:border-primary/20",
 51:           "bg-card/50 backdrop-blur-sm"
 52:         )}
 53:         onClick={onClick}
 54:       >
 55:         <CardContent className="p-6">
 56:           <div className="flex items-start justify-between">
 57:             <div className="flex-1 space-y-3">
 58:               {/* Session title */}
 59:               <div className="flex items-start gap-3">
 60:                 <FileText className="h-5 w-5 text-primary mt-0.5 flex-shrink-0" />
 61:                 <div className="flex-1 min-w-0">
 62:                   <h3 className="font-semibold text-lg truncate">
 63:                     {`Session ${session.id.slice(0, 8)}`}
 64:                   </h3>
 65:                 </div>
 66:               </div>
 67: 
 68:               {/* Session metadata */}
 69:               <div className="flex flex-wrap gap-4 text-sm text-muted-foreground">
 70:                 <div className="flex items-center gap-1">
 71:                   <Calendar className="h-3.5 w-3.5" />
 72:                   <span>{formatTime(session.created_at)}</span>
 73:                 </div>
 74:                 {session.message_timestamp && (
 75:                   <div className="flex items-center gap-1">
 76:                     <Clock className="h-3.5 w-3.5" />
 77:                     <span>{formatTime(session.message_timestamp)}</span>
 78:                   </div>
 79:                 )}
 80:               </div>
 81: 
 82:               {/* Session ID */}
 83:               <div className="text-xs text-muted-foreground/60 font-mono">
 84:                 ID: {session.id}
 85:               </div>
 86:             </div>
 87: 
 88:             {/* Claude memories dropdown */}
 89:             <div className="ml-4">
 90:               <ClaudeMemoriesDropdown
 91:                 projectPath={projectPath}
 92:                 onEditFile={onEditClaudeFile || (() => {})}
 93:               />
 94:             </div>
 95:           </div>
 96:         </CardContent>
 97:       </Card>
 98:     </motion.div>
 99:   );
100: });
101: 
102: SessionCard.displayName = 'SessionCard';
103: 
104: export const SessionList: React.FC<SessionListProps> = React.memo(({
105:   sessions,
106:   projectPath,
107:   onBack,
108:   onSessionClick,
109:   onEditClaudeFile,
110:   className
111: }) => {
112:   // Sort sessions by created_at in descending order
113:   const sortedSessions = useMemo(() => {
114:     return [...sessions].sort((a, b) => {
115:       const timeA = a.created_at || 0;
116:       const timeB = b.created_at || 0;
117:       return timeB > timeA ? 1 : -1;
118:     });
119:   }, [sessions]);
120: 
121:   // Use custom pagination hook
122:   const {
123:     currentPage,
124:     totalPages,
125:     paginatedData,
126:     goToPage,
127:     canGoNext: _canGoNext,
128:     canGoPrevious: _canGoPrevious
129:   } = usePagination(sortedSessions, {
130:     initialPage: 1,
131:     initialPageSize: 5
132:   });
133: 
134:   const handleSessionClick = useCallback((session: Session) => {
135:     onSessionClick?.(session);
136:   }, [onSessionClick]);
137: 
138:   return (
139:     <div className={cn("space-y-6", className)}>
140:       {/* Header */}
141:       <div className="flex items-center justify-between">
142:         <div className="flex items-center gap-4">
143:           <Button
144:             variant="ghost"
145:             size="icon"
146:             onClick={onBack}
147:             className="h-8 w-8"
148:           >
149:             <ArrowLeft className="h-4 w-4" />
150:           </Button>
151:           <div>
152:             <h2 className="text-2xl font-bold">Sessions</h2>
153:             <p className="text-sm text-muted-foreground">
154:               {projectPath}
155:             </p>
156:           </div>
157:         </div>
158:         <div className="text-sm text-muted-foreground">
159:           {sessions.length} {sessions.length === 1 ? 'session' : 'sessions'}
160:         </div>
161:       </div>
162: 
163:       {/* Sessions list */}
164:       {sessions.length === 0 ? (
165:         <Card className="bg-muted/20">
166:           <CardContent className="p-12 text-center">
167:             <FileText className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
168:             <p className="text-muted-foreground">
169:               No sessions found for this project
170:             </p>
171:           </CardContent>
172:         </Card>
173:       ) : (
174:         <>
175:           <AnimatePresence mode="wait">
176:             <motion.div
177:               key={currentPage}
178:               initial={{ opacity: 0, x: -20 }}
179:               animate={{ opacity: 1, x: 0 }}
180:               exit={{ opacity: 0, x: 20 }}
181:               className="space-y-4"
182:             >
183:               {paginatedData.map((session) => (
184:                 <SessionCard
185:                   key={session.id}
186:                   session={session}
187:                   projectPath={projectPath}
188:                   onClick={() => handleSessionClick(session)}
189:                   onEditClaudeFile={onEditClaudeFile}
190:                 />
191:               ))}
192:             </motion.div>
193:           </AnimatePresence>
194: 
195:           {/* Pagination */}
196:           {totalPages > 1 && (
197:             <div className="flex justify-center">
198:               <Pagination
199:                 currentPage={currentPage}
200:                 totalPages={totalPages}
201:                 onPageChange={goToPage}
202:               />
203:             </div>
204:           )}
205:         </>
206:       )}
207:     </div>
208:   );
209: });
````

## File: src/components/SessionList.tsx
````typescript
  1: import React, { useState } from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import { FileText, ArrowLeft, Calendar, Clock, MessageSquare } from "lucide-react";
  4: import { Card, CardContent } from "@/components/ui/card";
  5: import { Button } from "@/components/ui/button";
  6: import { Pagination } from "@/components/ui/pagination";
  7: import { ClaudeMemoriesDropdown } from "@/components/ClaudeMemoriesDropdown";
  8: import { cn } from "@/lib/utils";
  9: import { formatUnixTimestamp, formatISOTimestamp, truncateText, getFirstLine } from "@/lib/date-utils";
 10: import type { Session, ClaudeMdFile } from "@/lib/api";
 11: 
 12: interface SessionListProps {
 13:   /**
 14:    * Array of sessions to display
 15:    */
 16:   sessions: Session[];
 17:   /**
 18:    * The current project path being viewed
 19:    */
 20:   projectPath: string;
 21:   /**
 22:    * Callback to go back to project list
 23:    */
 24:   onBack: () => void;
 25:   /**
 26:    * Callback when a session is clicked
 27:    */
 28:   onSessionClick?: (session: Session) => void;
 29:   /**
 30:    * Callback when a CLAUDE.md file should be edited
 31:    */
 32:   onEditClaudeFile?: (file: ClaudeMdFile) => void;
 33:   /**
 34:    * Optional className for styling
 35:    */
 36:   className?: string;
 37: }
 38: 
 39: const ITEMS_PER_PAGE = 5;
 40: 
 41: /**
 42:  * SessionList component - Displays paginated sessions for a specific project
 43:  * 
 44:  * @example
 45:  * <SessionList
 46:  *   sessions={sessions}
 47:  *   projectPath="/Users/example/project"
 48:  *   onBack={() => setSelectedProject(null)}
 49:  *   onSessionClick={(session) => console.log('Selected session:', session)}
 50:  * />
 51:  */
 52: export const SessionList: React.FC<SessionListProps> = ({
 53:   sessions,
 54:   projectPath,
 55:   onBack,
 56:   onSessionClick,
 57:   onEditClaudeFile,
 58:   className,
 59: }) => {
 60:   const [currentPage, setCurrentPage] = useState(1);
 61:   
 62:   // Calculate pagination
 63:   const totalPages = Math.ceil(sessions.length / ITEMS_PER_PAGE);
 64:   const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
 65:   const endIndex = startIndex + ITEMS_PER_PAGE;
 66:   const currentSessions = sessions.slice(startIndex, endIndex);
 67:   
 68:   // Reset to page 1 if sessions change
 69:   React.useEffect(() => {
 70:     setCurrentPage(1);
 71:   }, [sessions.length]);
 72:   
 73:   return (
 74:     <div className={cn("space-y-4", className)}>
 75:       <motion.div
 76:         initial={{ opacity: 0, x: -20 }}
 77:         animate={{ opacity: 1, x: 0 }}
 78:         transition={{ duration: 0.3 }}
 79:         className="flex items-center space-x-3"
 80:       >
 81:         <Button
 82:           variant="ghost"
 83:           size="icon"
 84:           onClick={onBack}
 85:           className="h-8 w-8"
 86:         >
 87:           <ArrowLeft className="h-4 w-4" />
 88:         </Button>
 89:         <div className="flex-1 min-w-0">
 90:           <h2 className="text-base font-medium truncate">{projectPath}</h2>
 91:           <p className="text-xs text-muted-foreground">
 92:             {sessions.length} session{sessions.length !== 1 ? 's' : ''}
 93:           </p>
 94:         </div>
 95:       </motion.div>
 96: 
 97:       {/* CLAUDE.md Memories Dropdown */}
 98:       {onEditClaudeFile && (
 99:         <motion.div
100:           initial={{ opacity: 0, y: 10 }}
101:           animate={{ opacity: 1, y: 0 }}
102:           transition={{ duration: 0.3, delay: 0.1 }}
103:         >
104:           <ClaudeMemoriesDropdown
105:             projectPath={projectPath}
106:             onEditFile={onEditClaudeFile}
107:           />
108:         </motion.div>
109:       )}
110: 
111:       <AnimatePresence mode="popLayout">
112:         <div className="space-y-2">
113:           {currentSessions.map((session, index) => (
114:             <motion.div
115:               key={session.id}
116:               initial={{ opacity: 0, y: 20 }}
117:               animate={{ opacity: 1, y: 0 }}
118:               exit={{ opacity: 0, y: -20 }}
119:               transition={{
120:                 duration: 0.3,
121:                 delay: index * 0.05,
122:                 ease: [0.4, 0, 0.2, 1],
123:               }}
124:             >
125:               <Card
126:                 className={cn(
127:                   "transition-all hover:shadow-md hover:scale-[1.01] active:scale-[0.99] cursor-pointer",
128:                   session.todo_data && "border-l-4 border-l-primary"
129:                 )}
130:                 onClick={() => {
131:                   // Emit a special event for Claude Code session navigation
132:                   const event = new CustomEvent('claude-session-selected', { 
133:                     detail: { session, projectPath } 
134:                   });
135:                   window.dispatchEvent(event);
136:                   onSessionClick?.(session);
137:                 }}
138:               >
139:                 <CardContent className="p-3">
140:                   <div className="space-y-2">
141:                     <div className="flex items-start justify-between">
142:                       <div className="flex items-start space-x-3 flex-1 min-w-0">
143:                         <FileText className="h-4 w-4 text-muted-foreground mt-0.5 flex-shrink-0" />
144:                         <div className="space-y-1 flex-1 min-w-0">
145:                           <p className="font-mono text-xs text-muted-foreground">{session.id}</p>
146:                           
147:                           {/* First message preview */}
148:                           {session.first_message && (
149:                             <div className="space-y-1">
150:                               <div className="flex items-center space-x-1 text-xs text-muted-foreground">
151:                                 <MessageSquare className="h-3 w-3" />
152:                                 <span>First message:</span>
153:                               </div>
154:                               <p className="text-xs line-clamp-2 text-foreground/80">
155:                                 {truncateText(getFirstLine(session.first_message), 100)}
156:                               </p>
157:                             </div>
158:                           )}
159:                           
160:                           {/* Metadata */}
161:                           <div className="flex items-center space-x-3 text-xs text-muted-foreground">
162:                             {/* Message timestamp if available, otherwise file creation time */}
163:                             <div className="flex items-center space-x-1">
164:                               <Clock className="h-3 w-3" />
165:                               <span>
166:                                 {session.message_timestamp 
167:                                   ? formatISOTimestamp(session.message_timestamp)
168:                                   : formatUnixTimestamp(session.created_at)
169:                                 }
170:                               </span>
171:                             </div>
172:                             
173:                             {session.todo_data && (
174:                               <div className="flex items-center space-x-1">
175:                                 <Calendar className="h-3 w-3" />
176:                                 <span>Has todo</span>
177:                               </div>
178:                             )}
179:                           </div>
180:                         </div>
181:                       </div>
182:                     </div>
183:                   </div>
184:                 </CardContent>
185:               </Card>
186:             </motion.div>
187:           ))}
188:         </div>
189:       </AnimatePresence>
190:       
191:       <Pagination
192:         currentPage={currentPage}
193:         totalPages={totalPages}
194:         onPageChange={setCurrentPage}
195:       />
196:     </div>
197:   );
198: };
````

## File: src/components/SessionOutputViewer.tsx
````typescript
  1: import { useState, useEffect, useRef, useMemo } from 'react';
  2: import { motion, AnimatePresence } from 'framer-motion';
  3: import { X, Maximize2, Minimize2, Copy, RefreshCw, RotateCcw, ChevronDown } from 'lucide-react';
  4: import { Button } from '@/components/ui/button';
  5: import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
  6: import { Badge } from '@/components/ui/badge';
  7: import { Toast, ToastContainer } from '@/components/ui/toast';
  8: import { Popover } from '@/components/ui/popover';
  9: import { api } from '@/lib/api';
 10: import { useOutputCache } from '@/lib/outputCache';
 11: import type { AgentRun } from '@/lib/api';
 12: import { listen, type UnlistenFn } from '@tauri-apps/api/event';
 13: import { StreamMessage } from './StreamMessage';
 14: import { ErrorBoundary } from './ErrorBoundary';
 15: 
 16: interface SessionOutputViewerProps {
 17:   session: AgentRun;
 18:   onClose: () => void;
 19:   className?: string;
 20: }
 21: 
 22: // Use the same message interface as AgentExecution for consistency
 23: export interface ClaudeStreamMessage {
 24:   type: "system" | "assistant" | "user" | "result";
 25:   subtype?: string;
 26:   message?: {
 27:     content?: any[];
 28:     usage?: {
 29:       input_tokens: number;
 30:       output_tokens: number;
 31:     };
 32:   };
 33:   usage?: {
 34:     input_tokens: number;
 35:     output_tokens: number;
 36:   };
 37:   [key: string]: any;
 38: }
 39: 
 40: export function SessionOutputViewer({ session, onClose, className }: SessionOutputViewerProps) {
 41:   const [messages, setMessages] = useState<ClaudeStreamMessage[]>([]);
 42:   const [rawJsonlOutput, setRawJsonlOutput] = useState<string[]>([]);
 43:   const [loading, setLoading] = useState(false);
 44:   const [isFullscreen, setIsFullscreen] = useState(false);
 45:   const [refreshing, setRefreshing] = useState(false);
 46:   const [toast, setToast] = useState<{ message: string; type: "success" | "error" } | null>(null);
 47:   const [copyPopoverOpen, setCopyPopoverOpen] = useState(false);
 48:   const [hasUserScrolled, setHasUserScrolled] = useState(false);
 49:   
 50:   const scrollAreaRef = useRef<HTMLDivElement>(null);
 51:   const outputEndRef = useRef<HTMLDivElement>(null);
 52:   const fullscreenScrollRef = useRef<HTMLDivElement>(null);
 53:   const fullscreenMessagesEndRef = useRef<HTMLDivElement>(null);
 54:   const unlistenRefs = useRef<UnlistenFn[]>([]);
 55:   const { getCachedOutput, setCachedOutput } = useOutputCache();
 56: 
 57:   // Auto-scroll logic similar to AgentExecution
 58:   const isAtBottom = () => {
 59:     const container = isFullscreen ? fullscreenScrollRef.current : scrollAreaRef.current;
 60:     if (container) {
 61:       const { scrollTop, scrollHeight, clientHeight } = container;
 62:       const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
 63:       return distanceFromBottom < 1;
 64:     }
 65:     return true;
 66:   };
 67: 
 68:   const scrollToBottom = () => {
 69:     if (!hasUserScrolled) {
 70:       const endRef = isFullscreen ? fullscreenMessagesEndRef.current : outputEndRef.current;
 71:       if (endRef) {
 72:         endRef.scrollIntoView({ behavior: 'smooth' });
 73:       }
 74:     }
 75:   };
 76: 
 77:   // Clean up listeners on unmount
 78:   useEffect(() => {
 79:     return () => {
 80:       unlistenRefs.current.forEach(unlisten => unlisten());
 81:     };
 82:   }, []);
 83: 
 84:   // Auto-scroll when messages change
 85:   useEffect(() => {
 86:     const shouldAutoScroll = !hasUserScrolled || isAtBottom();
 87:     if (shouldAutoScroll) {
 88:       scrollToBottom();
 89:     }
 90:   }, [messages, hasUserScrolled, isFullscreen]);
 91: 
 92: 
 93:   const loadOutput = async (skipCache = false) => {
 94:     if (!session.id) return;
 95: 
 96:     try {
 97:       // Check cache first if not skipping cache
 98:       if (!skipCache) {
 99:         const cached = getCachedOutput(session.id);
100:         if (cached) {
101:           const cachedJsonlLines = cached.output.split('\n').filter(line => line.trim());
102:           setRawJsonlOutput(cachedJsonlLines);
103:           setMessages(cached.messages);
104:           // If cache is recent (less than 5 seconds old) and session isn't running, use cache only
105:           if (Date.now() - cached.lastUpdated < 5000 && session.status !== 'running') {
106:             return;
107:           }
108:         }
109:       }
110: 
111:       setLoading(true);
112: 
113:       // If we have a session_id, try to load from JSONL file first
114:       if (session.session_id && session.session_id !== '') {
115:         try {
116:           const history = await api.loadAgentSessionHistory(session.session_id);
117:           
118:           // Convert history to messages format using AgentExecution style
119:           const loadedMessages: ClaudeStreamMessage[] = history.map(entry => ({
120:             ...entry,
121:             type: entry.type || "assistant"
122:           }));
123:           
124:           setMessages(loadedMessages);
125:           setRawJsonlOutput(history.map(h => JSON.stringify(h)));
126:           
127:           // Update cache
128:           setCachedOutput(session.id, {
129:             output: history.map(h => JSON.stringify(h)).join('\n'),
130:             messages: loadedMessages,
131:             lastUpdated: Date.now(),
132:             status: session.status
133:           });
134:           
135:           // Set up live event listeners for running sessions
136:           if (session.status === 'running') {
137:             setupLiveEventListeners();
138:             
139:             try {
140:               await api.streamSessionOutput(session.id);
141:             } catch (streamError) {
142:               console.warn('Failed to start streaming, will poll instead:', streamError);
143:             }
144:           }
145:           
146:           return;
147:         } catch (err) {
148:           console.warn('Failed to load from JSONL, falling back to regular output:', err);
149:         }
150:       }
151: 
152:       // Fallback to the original method if JSONL loading fails or no session_id
153:       const rawOutput = await api.getSessionOutput(session.id);
154:       
155:       // Parse JSONL output into messages using AgentExecution style
156:       const jsonlLines = rawOutput.split('\n').filter(line => line.trim());
157:       setRawJsonlOutput(jsonlLines);
158:       
159:       const parsedMessages: ClaudeStreamMessage[] = [];
160:       for (const line of jsonlLines) {
161:         try {
162:           const message = JSON.parse(line) as ClaudeStreamMessage;
163:           parsedMessages.push(message);
164:         } catch (err) {
165:           console.error("Failed to parse message:", err, line);
166:         }
167:       }
168:       setMessages(parsedMessages);
169:       
170:       // Update cache
171:       setCachedOutput(session.id, {
172:         output: rawOutput,
173:         messages: parsedMessages,
174:         lastUpdated: Date.now(),
175:         status: session.status
176:       });
177:       
178:       // Set up live event listeners for running sessions
179:       if (session.status === 'running') {
180:         setupLiveEventListeners();
181:         
182:         try {
183:           await api.streamSessionOutput(session.id);
184:         } catch (streamError) {
185:           console.warn('Failed to start streaming, will poll instead:', streamError);
186:         }
187:       }
188:     } catch (error) {
189:       console.error('Failed to load session output:', error);
190:       setToast({ message: 'Failed to load session output', type: 'error' });
191:     } finally {
192:       setLoading(false);
193:     }
194:   };
195: 
196:   const setupLiveEventListeners = async () => {
197:     if (!session.id) return;
198:     
199:     try {
200:       // Clean up existing listeners
201:       unlistenRefs.current.forEach(unlisten => unlisten());
202:       unlistenRefs.current = [];
203: 
204:       // Set up live event listeners with run ID isolation
205:       const outputUnlisten = await listen<string>(`agent-output:${session.id}`, (event) => {
206:         try {
207:           // Store raw JSONL
208:           setRawJsonlOutput(prev => [...prev, event.payload]);
209:           
210:           // Parse and display
211:           const message = JSON.parse(event.payload) as ClaudeStreamMessage;
212:           setMessages(prev => [...prev, message]);
213:         } catch (err) {
214:           console.error("Failed to parse message:", err, event.payload);
215:         }
216:       });
217: 
218:       const errorUnlisten = await listen<string>(`agent-error:${session.id}`, (event) => {
219:         console.error("Agent error:", event.payload);
220:         setToast({ message: event.payload, type: 'error' });
221:       });
222: 
223:       const completeUnlisten = await listen<boolean>(`agent-complete:${session.id}`, () => {
224:         setToast({ message: 'Agent execution completed', type: 'success' });
225:         // Don't set status here as the parent component should handle it
226:       });
227: 
228:       const cancelUnlisten = await listen<boolean>(`agent-cancelled:${session.id}`, () => {
229:         setToast({ message: 'Agent execution was cancelled', type: 'error' });
230:       });
231: 
232:       unlistenRefs.current = [outputUnlisten, errorUnlisten, completeUnlisten, cancelUnlisten];
233:     } catch (error) {
234:       console.error('Failed to set up live event listeners:', error);
235:     }
236:   };
237: 
238:   // Copy functionality similar to AgentExecution
239:   const handleCopyAsJsonl = async () => {
240:     const jsonl = rawJsonlOutput.join('\n');
241:     await navigator.clipboard.writeText(jsonl);
242:     setCopyPopoverOpen(false);
243:     setToast({ message: 'Output copied as JSONL', type: 'success' });
244:   };
245: 
246:   const handleCopyAsMarkdown = async () => {
247:     let markdown = `# Agent Session: ${session.agent_name}\n\n`;
248:     markdown += `**Status:** ${session.status}\n`;
249:     if (session.task) markdown += `**Task:** ${session.task}\n`;
250:     if (session.model) markdown += `**Model:** ${session.model}\n`;
251:     markdown += `**Date:** ${new Date().toISOString()}\n\n`;
252:     markdown += `---\n\n`;
253: 
254:     for (const msg of messages) {
255:       if (msg.type === "system" && msg.subtype === "init") {
256:         markdown += `## System Initialization\n\n`;
257:         markdown += `- Session ID: \`${msg.session_id || 'N/A'}\`\n`;
258:         markdown += `- Model: \`${msg.model || 'default'}\`\n`;
259:         if (msg.cwd) markdown += `- Working Directory: \`${msg.cwd}\`\n`;
260:         if (msg.tools?.length) markdown += `- Tools: ${msg.tools.join(', ')}\n`;
261:         markdown += `\n`;
262:       } else if (msg.type === "assistant" && msg.message) {
263:         markdown += `## Assistant\n\n`;
264:         for (const content of msg.message.content || []) {
265:           if (content.type === "text") {
266:             markdown += `${content.text}\n\n`;
267:           } else if (content.type === "tool_use") {
268:             markdown += `### Tool: ${content.name}\n\n`;
269:             markdown += `\`\`\`json\n${JSON.stringify(content.input, null, 2)}\n\`\`\`\n\n`;
270:           }
271:         }
272:         if (msg.message.usage) {
273:           markdown += `*Tokens: ${msg.message.usage.input_tokens} in, ${msg.message.usage.output_tokens} out*\n\n`;
274:         }
275:       } else if (msg.type === "user" && msg.message) {
276:         markdown += `## User\n\n`;
277:         for (const content of msg.message.content || []) {
278:           if (content.type === "text") {
279:             markdown += `${content.text}\n\n`;
280:           } else if (content.type === "tool_result") {
281:             markdown += `### Tool Result\n\n`;
282:             markdown += `\`\`\`\n${content.content}\n\`\`\`\n\n`;
283:           }
284:         }
285:       } else if (msg.type === "result") {
286:         markdown += `## Execution Result\n\n`;
287:         if (msg.result) {
288:           markdown += `${msg.result}\n\n`;
289:         }
290:         if (msg.error) {
291:           markdown += `**Error:** ${msg.error}\n\n`;
292:         }
293:       }
294:     }
295: 
296:     await navigator.clipboard.writeText(markdown);
297:     setCopyPopoverOpen(false);
298:     setToast({ message: 'Output copied as Markdown', type: 'success' });
299:   };
300: 
301: 
302:   const refreshOutput = async () => {
303:     setRefreshing(true);
304:     try {
305:       await loadOutput(true); // Skip cache when manually refreshing
306:       setToast({ message: 'Output refreshed', type: 'success' });
307:     } catch (error) {
308:       console.error('Failed to refresh output:', error);
309:       setToast({ message: 'Failed to refresh output', type: 'error' });
310:     } finally {
311:       setRefreshing(false);
312:     }
313:   };
314: 
315: 
316:   // Load output on mount and check cache first
317:   useEffect(() => {
318:     if (!session.id) return;
319:     
320:     // Check cache immediately for instant display
321:     const cached = getCachedOutput(session.id);
322:     if (cached) {
323:       const cachedJsonlLines = cached.output.split('\n').filter(line => line.trim());
324:       setRawJsonlOutput(cachedJsonlLines);
325:       setMessages(cached.messages);
326:     }
327:     
328:     // Then load fresh data
329:     loadOutput();
330:   }, [session.id]);
331: 
332:   const displayableMessages = useMemo(() => {
333:     return messages.filter((message, index) => {
334:       if (message.isMeta && !message.leafUuid && !message.summary) return false;
335: 
336:       if (message.type === "user" && message.message) {
337:         if (message.isMeta) return false;
338: 
339:         const msg = message.message;
340:         if (!msg.content || (Array.isArray(msg.content) && msg.content.length === 0)) return false;
341: 
342:         if (Array.isArray(msg.content)) {
343:           let hasVisibleContent = false;
344:           for (const content of msg.content) {
345:             if (content.type === "text") { hasVisibleContent = true; break; }
346:             if (content.type === "tool_result") {
347:               let willBeSkipped = false;
348:               if (content.tool_use_id) {
349:                 for (let i = index - 1; i >= 0; i--) {
350:                   const prevMsg = messages[i];
351:                   if (prevMsg.type === 'assistant' && prevMsg.message?.content && Array.isArray(prevMsg.message.content)) {
352:                     const toolUse = prevMsg.message.content.find((c: any) => c.type === 'tool_use' && c.id === content.tool_use_id);
353:                     if (toolUse) {
354:                       const toolName = toolUse.name?.toLowerCase();
355:                       const toolsWithWidgets = ['task','edit','multiedit','todowrite','ls','read','glob','bash','write','grep'];
356:                       if (toolsWithWidgets.includes(toolName) || toolUse.name?.startsWith('mcp__')) {
357:                         willBeSkipped = true;
358:                       }
359:                       break;
360:                     }
361:                   }
362:                 }
363:               }
364:               if (!willBeSkipped) { hasVisibleContent = true; break; }
365:             }
366:           }
367:           if (!hasVisibleContent) return false;
368:         }
369:       }
370:       return true;
371:     });
372:   }, [messages]);
373: 
374:   return (
375:     <>
376:       <motion.div
377:         initial={{ opacity: 0, scale: 0.95 }}
378:         animate={{ opacity: 1, scale: 1 }}
379:         exit={{ opacity: 0, scale: 0.95 }}
380:         transition={{ duration: 0.2 }}
381:         className={`${isFullscreen ? 'fixed inset-0 z-50 bg-background' : ''} ${className}`}
382:       >
383:         <Card className={`h-full ${isFullscreen ? 'rounded-none border-0' : ''}`}>
384:           <CardHeader className="pb-3">
385:             <div className="flex items-center justify-between">
386:               <div className="flex items-center space-x-3">
387:                 <div className="text-2xl">{session.agent_icon}</div>
388:                 <div>
389:                   <CardTitle className="text-base">{session.agent_name} - Output</CardTitle>
390:                   <div className="flex items-center space-x-2 mt-1">
391:                     <Badge variant={session.status === 'running' ? 'default' : 'secondary'}>
392:                       {session.status}
393:                     </Badge>
394:                     {session.status === 'running' && (
395:                       <Badge variant="outline" className="text-xs bg-green-50 text-green-700 border-green-200">
396:                         <div className="w-1.5 h-1.5 bg-green-500 rounded-full animate-pulse mr-1"></div>
397:                         Live
398:                       </Badge>
399:                     )}
400:                     <span className="text-xs text-muted-foreground">
401:                       {messages.length} messages
402:                     </span>
403:                   </div>
404:                 </div>
405:               </div>
406:               <div className="flex items-center space-x-2">
407:                 {messages.length > 0 && (
408:                   <>
409:                     <Button
410:                       variant="outline"
411:                       size="sm"
412:                       onClick={() => setIsFullscreen(!isFullscreen)}
413:                       title="Fullscreen"
414:                     >
415:                       {isFullscreen ? <Minimize2 className="h-4 w-4" /> : <Maximize2 className="h-4 w-4" />}
416:                     </Button>
417:                     <Popover
418:                       trigger={
419:                         <Button
420:                           variant="outline"
421:                           size="sm"
422:                           className="flex items-center gap-2"
423:                         >
424:                           <Copy className="h-4 w-4" />
425:                           Copy Output
426:                           <ChevronDown className="h-3 w-3" />
427:                         </Button>
428:                       }
429:                       content={
430:                         <div className="w-44 p-1">
431:                           <Button
432:                             variant="ghost"
433:                             size="sm"
434:                             className="w-full justify-start"
435:                             onClick={handleCopyAsJsonl}
436:                           >
437:                             Copy as JSONL
438:                           </Button>
439:                           <Button
440:                             variant="ghost"
441:                             size="sm"
442:                             className="w-full justify-start"
443:                             onClick={handleCopyAsMarkdown}
444:                           >
445:                             Copy as Markdown
446:                           </Button>
447:                         </div>
448:                       }
449:                       open={copyPopoverOpen}
450:                       onOpenChange={setCopyPopoverOpen}
451:                       align="end"
452:                     />
453:                   </>
454:                 )}
455:                 <Button
456:                   variant="outline"
457:                   size="sm"
458:                   onClick={refreshOutput}
459:                   disabled={refreshing}
460:                   title="Refresh output"
461:                 >
462:                   <RotateCcw className={`h-4 w-4 ${refreshing ? 'animate-spin' : ''}`} />
463:                 </Button>
464:                 <Button variant="outline" size="sm" onClick={onClose}>
465:                   <X className="h-4 w-4" />
466:                 </Button>
467:               </div>
468:             </div>
469:           </CardHeader>
470:           <CardContent className={`${isFullscreen ? 'h-[calc(100vh-120px)]' : 'h-96'} p-0`}>
471:             {loading ? (
472:               <div className="flex items-center justify-center h-full">
473:                 <div className="flex items-center space-x-2">
474:                   <RefreshCw className="h-4 w-4 animate-spin" />
475:                   <span>Loading output...</span>
476:                 </div>
477:               </div>
478:             ) : (
479:               <div 
480:                 className="h-full overflow-y-auto p-6 space-y-3" 
481:                 ref={scrollAreaRef}
482:                 onScroll={() => {
483:                   // Mark that user has scrolled manually
484:                   if (!hasUserScrolled) {
485:                     setHasUserScrolled(true);
486:                   }
487:                   
488:                   // If user scrolls back to bottom, re-enable auto-scroll
489:                   if (isAtBottom()) {
490:                     setHasUserScrolled(false);
491:                   }
492:                 }}
493:               >
494:                 {messages.length === 0 ? (
495:                   <div className="flex flex-col items-center justify-center h-full text-center">
496:                     {session.status === 'running' ? (
497:                       <>
498:                         <RefreshCw className="h-8 w-8 animate-spin text-muted-foreground mb-2" />
499:                         <p className="text-muted-foreground">Waiting for output...</p>
500:                         <p className="text-xs text-muted-foreground mt-1">
501:                           Agent is running but no output received yet
502:                         </p>
503:                       </>
504:                     ) : (
505:                       <>
506:                         <p className="text-muted-foreground">No output available</p>
507:                         <Button 
508:                           variant="outline" 
509:                           size="sm" 
510:                           onClick={refreshOutput}
511:                           className="mt-2"
512:                           disabled={refreshing}
513:                         >
514:                           {refreshing ? <RefreshCw className="h-4 w-4 animate-spin mr-2" /> : <RotateCcw className="h-4 w-4 mr-2" />}
515:                           Refresh
516:                         </Button>
517:                       </>
518:                     )}
519:                   </div>
520:                 ) : (
521:                   <>
522:                     <AnimatePresence>
523:                       {displayableMessages.map((message: ClaudeStreamMessage, index: number) => (
524:                         <motion.div
525:                           key={index}
526:                           initial={{ opacity: 0, y: 10 }}
527:                           animate={{ opacity: 1, y: 0 }}
528:                           transition={{ duration: 0.2 }}
529:                         >
530:                           <ErrorBoundary>
531:                             <StreamMessage message={message} streamMessages={messages} />
532:                           </ErrorBoundary>
533:                         </motion.div>
534:                       ))}
535:                     </AnimatePresence>
536:                     <div ref={outputEndRef} />
537:                   </>
538:                 )}
539:               </div>
540:             )}
541:           </CardContent>
542:         </Card>
543:       </motion.div>
544: 
545:       {/* Fullscreen Modal */}
546:       {isFullscreen && (
547:         <div className="fixed inset-0 z-50 bg-background flex flex-col">
548:           {/* Modal Header */}
549:           <div className="flex items-center justify-between p-4 border-b border-border">
550:             <div className="flex items-center gap-2">
551:               <div className="text-2xl">{session.agent_icon}</div>
552:               <h2 className="text-lg font-semibold">{session.agent_name} - Output</h2>
553:               {session.status === 'running' && (
554:                 <div className="flex items-center gap-1">
555:                   <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
556:                   <span className="text-xs text-green-600 font-medium">Running</span>
557:                 </div>
558:               )}
559:             </div>
560:             <div className="flex items-center gap-2">
561:               {messages.length > 0 && (
562:                 <Popover
563:                   trigger={
564:                     <Button
565:                       variant="ghost"
566:                       size="sm"
567:                       className="flex items-center gap-2"
568:                     >
569:                       <Copy className="h-4 w-4" />
570:                       Copy Output
571:                       <ChevronDown className="h-3 w-3" />
572:                     </Button>
573:                   }
574:                   content={
575:                     <div className="w-44 p-1">
576:                       <Button
577:                         variant="ghost"
578:                         size="sm"
579:                         className="w-full justify-start"
580:                         onClick={handleCopyAsJsonl}
581:                       >
582:                         Copy as JSONL
583:                       </Button>
584:                       <Button
585:                         variant="ghost"
586:                         size="sm"
587:                         className="w-full justify-start"
588:                         onClick={handleCopyAsMarkdown}
589:                       >
590:                         Copy as Markdown
591:                       </Button>
592:                     </div>
593:                   }
594:                   open={copyPopoverOpen}
595:                   onOpenChange={setCopyPopoverOpen}
596:                   align="end"
597:                 />
598:               )}
599:               <Button
600:                 variant="ghost"
601:                 size="sm"
602:                 onClick={() => setIsFullscreen(false)}
603:                 className="flex items-center gap-2"
604:               >
605:                 <X className="h-4 w-4" />
606:                 Close
607:               </Button>
608:             </div>
609:           </div>
610: 
611:           {/* Modal Content */}
612:           <div className="flex-1 overflow-hidden p-6">
613:             <div 
614:               ref={fullscreenScrollRef}
615:               className="h-full overflow-y-auto space-y-3"
616:               onScroll={() => {
617:                 // Mark that user has scrolled manually
618:                 if (!hasUserScrolled) {
619:                   setHasUserScrolled(true);
620:                 }
621:                 
622:                 // If user scrolls back to bottom, re-enable auto-scroll
623:                 if (isAtBottom()) {
624:                   setHasUserScrolled(false);
625:                 }
626:               }}
627:             >
628:               {messages.length === 0 ? (
629:                 <div className="flex flex-col items-center justify-center h-full text-center">
630:                   {session.status === 'running' ? (
631:                     <>
632:                       <RefreshCw className="h-8 w-8 animate-spin text-muted-foreground mb-2" />
633:                       <p className="text-muted-foreground">Waiting for output...</p>
634:                       <p className="text-xs text-muted-foreground mt-1">
635:                         Agent is running but no output received yet
636:                       </p>
637:                     </>
638:                   ) : (
639:                     <>
640:                       <p className="text-muted-foreground">No output available</p>
641:                     </>
642:                   )}
643:                 </div>
644:               ) : (
645:                 <>
646:                   <AnimatePresence>
647:                     {displayableMessages.map((message: ClaudeStreamMessage, index: number) => (
648:                       <motion.div
649:                         key={index}
650:                         initial={{ opacity: 0, y: 10 }}
651:                         animate={{ opacity: 1, y: 0 }}
652:                         transition={{ duration: 0.2 }}
653:                       >
654:                         <ErrorBoundary>
655:                           <StreamMessage message={message} streamMessages={messages} />
656:                         </ErrorBoundary>
657:                       </motion.div>
658:                     ))}
659:                   </AnimatePresence>
660:                   <div ref={fullscreenMessagesEndRef} />
661:                 </>
662:               )}
663:             </div>
664:           </div>
665:         </div>
666:       )}
667: 
668:       {/* Toast Notification */}
669:       <ToastContainer>
670:         {toast && (
671:           <Toast
672:             message={toast.message}
673:             type={toast.type}
674:             onDismiss={() => setToast(null)}
675:           />
676:         )}
677:       </ToastContainer>
678:     </>
679:   );
680: }
````

## File: src/components/Settings.tsx
````typescript
   1: import React, { useState, useEffect } from "react";
   2: import { motion, AnimatePresence } from "framer-motion";
   3: import { 
   4:   ArrowLeft, 
   5:   Plus, 
   6:   Trash2, 
   7:   Save, 
   8:   AlertCircle,
   9:   Loader2,
  10:   BarChart3,
  11:   Shield,
  12:   Trash,
  13: } from "lucide-react";
  14: import { Button } from "@/components/ui/button";
  15: import { Input } from "@/components/ui/input";
  16: import { Label } from "@/components/ui/label";
  17: import { Switch } from "@/components/ui/switch";
  18: import { Card } from "@/components/ui/card";
  19: import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs";
  20: import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
  21: import { 
  22:   api, 
  23:   type ClaudeSettings,
  24:   type ClaudeInstallation
  25: } from "@/lib/api";
  26: import { cn } from "@/lib/utils";
  27: import { Toast, ToastContainer } from "@/components/ui/toast";
  28: import { ClaudeVersionSelector } from "./ClaudeVersionSelector";
  29: import { StorageTab } from "./StorageTab";
  30: import { HooksEditor } from "./HooksEditor";
  31: import { SlashCommandsManager } from "./SlashCommandsManager";
  32: import { ProxySettings } from "./ProxySettings";
  33: import { AnalyticsConsent } from "./AnalyticsConsent";
  34: import { useTheme, useTrackEvent } from "@/hooks";
  35: import { analytics } from "@/lib/analytics";
  36: 
  37: interface SettingsProps {
  38:   /**
  39:    * Callback to go back to the main view
  40:    */
  41:   onBack: () => void;
  42:   /**
  43:    * Optional className for styling
  44:    */
  45:   className?: string;
  46: }
  47: 
  48: interface PermissionRule {
  49:   id: string;
  50:   value: string;
  51: }
  52: 
  53: interface EnvironmentVariable {
  54:   id: string;
  55:   key: string;
  56:   value: string;
  57: }
  58: 
  59: /**
  60:  * Comprehensive Settings UI for managing Claude Code settings
  61:  * Provides a no-code interface for editing the settings.json file
  62:  */
  63: export const Settings: React.FC<SettingsProps> = ({
  64:   onBack,
  65:   className,
  66: }) => {
  67:   const [settings, setSettings] = useState<ClaudeSettings | null>(null);
  68:   const [loading, setLoading] = useState(true);
  69:   const [saving, setSaving] = useState(false);
  70:   const [error, setError] = useState<string | null>(null);
  71:   const [activeTab, setActiveTab] = useState("general");
  72:   const [currentBinaryPath, setCurrentBinaryPath] = useState<string | null>(null);
  73:   const [selectedInstallation, setSelectedInstallation] = useState<ClaudeInstallation | null>(null);
  74:   const [binaryPathChanged, setBinaryPathChanged] = useState(false);
  75:   const [toast, setToast] = useState<{ message: string; type: 'success' | 'error' } | null>(null);
  76:   
  77:   // Permission rules state
  78:   const [allowRules, setAllowRules] = useState<PermissionRule[]>([]);
  79:   const [denyRules, setDenyRules] = useState<PermissionRule[]>([]);
  80:   
  81:   // Environment variables state
  82:   const [envVars, setEnvVars] = useState<EnvironmentVariable[]>([]);
  83:   
  84:   // Hooks state
  85:   const [userHooksChanged, setUserHooksChanged] = useState(false);
  86:   const getUserHooks = React.useRef<(() => any) | null>(null);
  87:   
  88:   // Theme hook
  89:   const { theme, setTheme, customColors, setCustomColors } = useTheme();
  90:   
  91:   // Proxy state
  92:   const [proxySettingsChanged, setProxySettingsChanged] = useState(false);
  93:   const saveProxySettings = React.useRef<(() => Promise<void>) | null>(null);
  94:   
  95:   // Analytics state
  96:   const [analyticsEnabled, setAnalyticsEnabled] = useState(false);
  97:   const [analyticsConsented, setAnalyticsConsented] = useState(false);
  98:   const [showAnalyticsConsent, setShowAnalyticsConsent] = useState(false);
  99:   const trackEvent = useTrackEvent();
 100:   
 101:   // Load settings on mount
 102:   useEffect(() => {
 103:     loadSettings();
 104:     loadClaudeBinaryPath();
 105:     loadAnalyticsSettings();
 106:   }, []);
 107: 
 108:   /**
 109:    * Loads analytics settings
 110:    */
 111:   const loadAnalyticsSettings = async () => {
 112:     const settings = analytics.getSettings();
 113:     if (settings) {
 114:       setAnalyticsEnabled(settings.enabled);
 115:       setAnalyticsConsented(settings.hasConsented);
 116:     }
 117:   };
 118: 
 119:   /**
 120:    * Loads the current Claude binary path
 121:    */
 122:   const loadClaudeBinaryPath = async () => {
 123:     try {
 124:       const path = await api.getClaudeBinaryPath();
 125:       setCurrentBinaryPath(path);
 126:     } catch (err) {
 127:       console.error("Failed to load Claude binary path:", err);
 128:     }
 129:   };
 130: 
 131:   /**
 132:    * Loads the current Claude settings
 133:    */
 134:   const loadSettings = async () => {
 135:     try {
 136:       setLoading(true);
 137:       setError(null);
 138:       const loadedSettings = await api.getClaudeSettings();
 139:       
 140:       // Ensure loadedSettings is an object
 141:       if (!loadedSettings || typeof loadedSettings !== 'object') {
 142:         console.warn("Loaded settings is not an object:", loadedSettings);
 143:         setSettings({});
 144:         return;
 145:       }
 146:       
 147:       setSettings(loadedSettings);
 148: 
 149:       // Parse permissions
 150:       if (loadedSettings.permissions && typeof loadedSettings.permissions === 'object') {
 151:         if (Array.isArray(loadedSettings.permissions.allow)) {
 152:           setAllowRules(
 153:             loadedSettings.permissions.allow.map((rule: string, index: number) => ({
 154:               id: `allow-${index}`,
 155:               value: rule,
 156:             }))
 157:           );
 158:         }
 159:         if (Array.isArray(loadedSettings.permissions.deny)) {
 160:           setDenyRules(
 161:             loadedSettings.permissions.deny.map((rule: string, index: number) => ({
 162:               id: `deny-${index}`,
 163:               value: rule,
 164:             }))
 165:           );
 166:         }
 167:       }
 168: 
 169:       // Parse environment variables
 170:       if (loadedSettings.env && typeof loadedSettings.env === 'object' && !Array.isArray(loadedSettings.env)) {
 171:         setEnvVars(
 172:           Object.entries(loadedSettings.env).map(([key, value], index) => ({
 173:             id: `env-${index}`,
 174:             key,
 175:             value: value as string,
 176:           }))
 177:         );
 178:       }
 179:     } catch (err) {
 180:       console.error("Failed to load settings:", err);
 181:       setError("Failed to load settings. Please ensure ~/.claude directory exists.");
 182:       setSettings({});
 183:     } finally {
 184:       setLoading(false);
 185:     }
 186:   };
 187: 
 188:   /**
 189:    * Saves the current settings
 190:    */
 191:   const saveSettings = async () => {
 192:     try {
 193:       setSaving(true);
 194:       setError(null);
 195:       setToast(null);
 196: 
 197:       // Build the settings object
 198:       const updatedSettings: ClaudeSettings = {
 199:         ...settings,
 200:         permissions: {
 201:           allow: allowRules.map(rule => rule.value).filter(v => v && String(v).trim()),
 202:           deny: denyRules.map(rule => rule.value).filter(v => v && String(v).trim()),
 203:         },
 204:         env: envVars.reduce((acc, { key, value }) => {
 205:           if (key && String(key).trim() && value && String(value).trim()) {
 206:             acc[key] = String(value);
 207:           }
 208:           return acc;
 209:         }, {} as Record<string, string>),
 210:       };
 211: 
 212:       await api.saveClaudeSettings(updatedSettings);
 213:       setSettings(updatedSettings);
 214: 
 215:       // Save Claude binary path if changed
 216:       if (binaryPathChanged && selectedInstallation) {
 217:         await api.setClaudeBinaryPath(selectedInstallation.path);
 218:         setCurrentBinaryPath(selectedInstallation.path);
 219:         setBinaryPathChanged(false);
 220:       }
 221: 
 222:       // Save user hooks if changed
 223:       if (userHooksChanged && getUserHooks.current) {
 224:         const hooks = getUserHooks.current();
 225:         await api.updateHooksConfig('user', hooks);
 226:         setUserHooksChanged(false);
 227:       }
 228: 
 229:       // Save proxy settings if changed
 230:       if (proxySettingsChanged && saveProxySettings.current) {
 231:         await saveProxySettings.current();
 232:         setProxySettingsChanged(false);
 233:       }
 234: 
 235:       setToast({ message: "Settings saved successfully!", type: "success" });
 236:     } catch (err) {
 237:       console.error("Failed to save settings:", err);
 238:       setError("Failed to save settings.");
 239:       setToast({ message: "Failed to save settings", type: "error" });
 240:     } finally {
 241:       setSaving(false);
 242:     }
 243:   };
 244: 
 245:   /**
 246:    * Updates a simple setting value
 247:    */
 248:   const updateSetting = (key: string, value: any) => {
 249:     setSettings(prev => ({ ...prev, [key]: value }));
 250:   };
 251: 
 252:   /**
 253:    * Adds a new permission rule
 254:    */
 255:   const addPermissionRule = (type: "allow" | "deny") => {
 256:     const newRule: PermissionRule = {
 257:       id: `${type}-${Date.now()}`,
 258:       value: "",
 259:     };
 260:     
 261:     if (type === "allow") {
 262:       setAllowRules(prev => [...prev, newRule]);
 263:     } else {
 264:       setDenyRules(prev => [...prev, newRule]);
 265:     }
 266:   };
 267: 
 268:   /**
 269:    * Updates a permission rule
 270:    */
 271:   const updatePermissionRule = (type: "allow" | "deny", id: string, value: string) => {
 272:     if (type === "allow") {
 273:       setAllowRules(prev => prev.map(rule => 
 274:         rule.id === id ? { ...rule, value } : rule
 275:       ));
 276:     } else {
 277:       setDenyRules(prev => prev.map(rule => 
 278:         rule.id === id ? { ...rule, value } : rule
 279:       ));
 280:     }
 281:   };
 282: 
 283:   /**
 284:    * Removes a permission rule
 285:    */
 286:   const removePermissionRule = (type: "allow" | "deny", id: string) => {
 287:     if (type === "allow") {
 288:       setAllowRules(prev => prev.filter(rule => rule.id !== id));
 289:     } else {
 290:       setDenyRules(prev => prev.filter(rule => rule.id !== id));
 291:     }
 292:   };
 293: 
 294:   /**
 295:    * Adds a new environment variable
 296:    */
 297:   const addEnvVar = () => {
 298:     const newVar: EnvironmentVariable = {
 299:       id: `env-${Date.now()}`,
 300:       key: "",
 301:       value: "",
 302:     };
 303:     setEnvVars(prev => [...prev, newVar]);
 304:   };
 305: 
 306:   /**
 307:    * Updates an environment variable
 308:    */
 309:   const updateEnvVar = (id: string, field: "key" | "value", value: string) => {
 310:     setEnvVars(prev => prev.map(envVar => 
 311:       envVar.id === id ? { ...envVar, [field]: value } : envVar
 312:     ));
 313:   };
 314: 
 315:   /**
 316:    * Removes an environment variable
 317:    */
 318:   const removeEnvVar = (id: string) => {
 319:     setEnvVars(prev => prev.filter(envVar => envVar.id !== id));
 320:   };
 321: 
 322:   /**
 323:    * Handle Claude installation selection
 324:    */
 325:   const handleClaudeInstallationSelect = (installation: ClaudeInstallation) => {
 326:     setSelectedInstallation(installation);
 327:     setBinaryPathChanged(installation.path !== currentBinaryPath);
 328:   };
 329: 
 330:   return (
 331:     <div className={cn("flex flex-col h-full bg-background text-foreground", className)}>
 332:       <div className="max-w-4xl mx-auto w-full flex flex-col h-full">
 333:         {/* Header */}
 334:         <motion.div
 335:           initial={{ opacity: 0, y: -20 }}
 336:           animate={{ opacity: 1, y: 0 }}
 337:           transition={{ duration: 0.3 }}
 338:           className="flex items-center justify-between p-4 border-b border-border"
 339:         >
 340:         <div className="flex items-center gap-3">
 341:         <Button
 342:           variant="ghost"
 343:           size="icon"
 344:           onClick={onBack}
 345:           className="h-8 w-8"
 346:         >
 347:           <ArrowLeft className="h-4 w-4" />
 348:         </Button>
 349:         <div>
 350:           <h2 className="text-lg font-semibold">Settings</h2>
 351:           <p className="text-xs text-muted-foreground">
 352:               Configure Claude Code preferences
 353:           </p>
 354:           </div>
 355:         </div>
 356:         
 357:         <Button
 358:           onClick={saveSettings}
 359:           disabled={saving || loading}
 360:           size="sm"
 361:           className="gap-2 bg-primary hover:bg-primary/90"
 362:         >
 363:           {saving ? (
 364:             <>
 365:               <Loader2 className="h-4 w-4 animate-spin" />
 366:               Saving...
 367:             </>
 368:           ) : (
 369:             <>
 370:               <Save className="h-4 w-4" />
 371:               Save Settings
 372:             </>
 373:           )}
 374:         </Button>
 375:       </motion.div>
 376:       
 377:       {/* Error message */}
 378:       <AnimatePresence>
 379:         {error && (
 380:           <motion.div
 381:             initial={{ opacity: 0, y: -10 }}
 382:             animate={{ opacity: 1, y: 0 }}
 383:             exit={{ opacity: 0, y: -10 }}
 384:             className="mx-4 mt-4 p-3 rounded-lg bg-destructive/10 border border-destructive/50 flex items-center gap-2 text-sm text-destructive"
 385:           >
 386:             <AlertCircle className="h-4 w-4" />
 387:             {error}
 388:           </motion.div>
 389:         )}
 390:       </AnimatePresence>
 391:       
 392:       {/* Content */}
 393:       {loading ? (
 394:         <div className="flex-1 flex items-center justify-center">
 395:           <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
 396:         </div>
 397:       ) : (
 398:         <div className="flex-1 overflow-y-auto p-4">
 399:           <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
 400:             <TabsList className="grid grid-cols-9 w-full">
 401:               <TabsTrigger value="general">General</TabsTrigger>
 402:               <TabsTrigger value="permissions">Permissions</TabsTrigger>
 403:               <TabsTrigger value="environment">Environment</TabsTrigger>
 404:               <TabsTrigger value="advanced">Advanced</TabsTrigger>
 405:               <TabsTrigger value="hooks">Hooks</TabsTrigger>
 406:               <TabsTrigger value="commands">Commands</TabsTrigger>
 407:               <TabsTrigger value="storage">Storage</TabsTrigger>
 408:               <TabsTrigger value="proxy">Proxy</TabsTrigger>
 409:               <TabsTrigger value="analytics">Analytics</TabsTrigger>
 410:             </TabsList>
 411:             
 412:             {/* General Settings */}
 413:             <TabsContent value="general" className="space-y-6">
 414:               <Card className="p-6 space-y-6">
 415:                 <div>
 416:                   <h3 className="text-base font-semibold mb-4">General Settings</h3>
 417:                   
 418:                   <div className="space-y-4">
 419:                     {/* Theme Selector */}
 420:                     <div className="space-y-2">
 421:                       <Label htmlFor="theme">Theme</Label>
 422:                       <Select
 423:                         value={theme}
 424:                         onValueChange={(value) => setTheme(value as any)}
 425:                       >
 426:                         <SelectTrigger id="theme" className="w-full">
 427:                           <SelectValue placeholder="Select a theme" />
 428:                         </SelectTrigger>
 429:                         <SelectContent>
 430:                           <SelectItem value="dark">Dark</SelectItem>
 431:                           <SelectItem value="gray">Gray</SelectItem>
 432:                           <SelectItem value="light">Light</SelectItem>
 433:                           <SelectItem value="custom">Custom</SelectItem>
 434:                         </SelectContent>
 435:                       </Select>
 436:                       <p className="text-xs text-muted-foreground">
 437:                         Choose your preferred color theme for the interface
 438:                       </p>
 439:                     </div>
 440:                     
 441:                     {/* Custom Color Editor */}
 442:                     {theme === 'custom' && (
 443:                       <div className="space-y-4 p-4 border rounded-lg bg-muted/20">
 444:                         <h4 className="text-sm font-medium">Custom Theme Colors</h4>
 445:                         
 446:                         <div className="grid grid-cols-2 gap-4">
 447:                           {/* Background Color */}
 448:                           <div className="space-y-2">
 449:                             <Label htmlFor="color-background" className="text-xs">Background</Label>
 450:                             <div className="flex gap-2">
 451:                               <Input
 452:                                 id="color-background"
 453:                                 type="text"
 454:                                 value={customColors.background}
 455:                                 onChange={(e) => setCustomColors({ background: e.target.value })}
 456:                                 placeholder="oklch(0.12 0.01 240)"
 457:                                 className="font-mono text-xs"
 458:                               />
 459:                               <div 
 460:                                 className="w-10 h-10 rounded border"
 461:                                 style={{ backgroundColor: customColors.background }}
 462:                               />
 463:                             </div>
 464:                           </div>
 465:                           
 466:                           {/* Foreground Color */}
 467:                           <div className="space-y-2">
 468:                             <Label htmlFor="color-foreground" className="text-xs">Foreground</Label>
 469:                             <div className="flex gap-2">
 470:                               <Input
 471:                                 id="color-foreground"
 472:                                 type="text"
 473:                                 value={customColors.foreground}
 474:                                 onChange={(e) => setCustomColors({ foreground: e.target.value })}
 475:                                 placeholder="oklch(0.98 0.01 240)"
 476:                                 className="font-mono text-xs"
 477:                               />
 478:                               <div 
 479:                                 className="w-10 h-10 rounded border"
 480:                                 style={{ backgroundColor: customColors.foreground }}
 481:                               />
 482:                             </div>
 483:                           </div>
 484:                           
 485:                           {/* Primary Color */}
 486:                           <div className="space-y-2">
 487:                             <Label htmlFor="color-primary" className="text-xs">Primary</Label>
 488:                             <div className="flex gap-2">
 489:                               <Input
 490:                                 id="color-primary"
 491:                                 type="text"
 492:                                 value={customColors.primary}
 493:                                 onChange={(e) => setCustomColors({ primary: e.target.value })}
 494:                                 placeholder="oklch(0.98 0.01 240)"
 495:                                 className="font-mono text-xs"
 496:                               />
 497:                               <div 
 498:                                 className="w-10 h-10 rounded border"
 499:                                 style={{ backgroundColor: customColors.primary }}
 500:                               />
 501:                             </div>
 502:                           </div>
 503:                           
 504:                           {/* Card Color */}
 505:                           <div className="space-y-2">
 506:                             <Label htmlFor="color-card" className="text-xs">Card</Label>
 507:                             <div className="flex gap-2">
 508:                               <Input
 509:                                 id="color-card"
 510:                                 type="text"
 511:                                 value={customColors.card}
 512:                                 onChange={(e) => setCustomColors({ card: e.target.value })}
 513:                                 placeholder="oklch(0.14 0.01 240)"
 514:                                 className="font-mono text-xs"
 515:                               />
 516:                               <div 
 517:                                 className="w-10 h-10 rounded border"
 518:                                 style={{ backgroundColor: customColors.card }}
 519:                               />
 520:                             </div>
 521:                           </div>
 522:                           
 523:                           {/* Accent Color */}
 524:                           <div className="space-y-2">
 525:                             <Label htmlFor="color-accent" className="text-xs">Accent</Label>
 526:                             <div className="flex gap-2">
 527:                               <Input
 528:                                 id="color-accent"
 529:                                 type="text"
 530:                                 value={customColors.accent}
 531:                                 onChange={(e) => setCustomColors({ accent: e.target.value })}
 532:                                 placeholder="oklch(0.16 0.01 240)"
 533:                                 className="font-mono text-xs"
 534:                               />
 535:                               <div 
 536:                                 className="w-10 h-10 rounded border"
 537:                                 style={{ backgroundColor: customColors.accent }}
 538:                               />
 539:                             </div>
 540:                           </div>
 541:                           
 542:                           {/* Destructive Color */}
 543:                           <div className="space-y-2">
 544:                             <Label htmlFor="color-destructive" className="text-xs">Destructive</Label>
 545:                             <div className="flex gap-2">
 546:                               <Input
 547:                                 id="color-destructive"
 548:                                 type="text"
 549:                                 value={customColors.destructive}
 550:                                 onChange={(e) => setCustomColors({ destructive: e.target.value })}
 551:                                 placeholder="oklch(0.6 0.2 25)"
 552:                                 className="font-mono text-xs"
 553:                               />
 554:                               <div 
 555:                                 className="w-10 h-10 rounded border"
 556:                                 style={{ backgroundColor: customColors.destructive }}
 557:                               />
 558:                             </div>
 559:                           </div>
 560:                         </div>
 561:                         
 562:                         <p className="text-xs text-muted-foreground">
 563:                           Use CSS color values (hex, rgb, oklch, etc.). Changes apply immediately.
 564:                         </p>
 565:                       </div>
 566:                     )}
 567:                     
 568:                     {/* Include Co-authored By */}
 569:                     <div className="flex items-center justify-between">
 570:                       <div className="space-y-0.5 flex-1">
 571:                         <Label htmlFor="coauthored">Include "Co-authored by Claude"</Label>
 572:                         <p className="text-xs text-muted-foreground">
 573:                           Add Claude attribution to git commits and pull requests
 574:                         </p>
 575:                       </div>
 576:                       <Switch
 577:                         id="coauthored"
 578:                         checked={settings?.includeCoAuthoredBy !== false}
 579:                         onCheckedChange={(checked) => updateSetting("includeCoAuthoredBy", checked)}
 580:                       />
 581:                     </div>
 582:                     
 583:                     {/* Verbose Output */}
 584:                     <div className="flex items-center justify-between">
 585:                       <div className="space-y-0.5 flex-1">
 586:                         <Label htmlFor="verbose">Verbose Output</Label>
 587:                         <p className="text-xs text-muted-foreground">
 588:                           Show full bash and command outputs
 589:                         </p>
 590:                       </div>
 591:                       <Switch
 592:                         id="verbose"
 593:                         checked={settings?.verbose === true}
 594:                         onCheckedChange={(checked) => updateSetting("verbose", checked)}
 595:                       />
 596:                     </div>
 597:                     
 598:                     {/* Cleanup Period */}
 599:                     <div className="space-y-2">
 600:                       <Label htmlFor="cleanup">Chat Transcript Retention (days)</Label>
 601:                       <Input
 602:                         id="cleanup"
 603:                         type="number"
 604:                         min="1"
 605:                         placeholder="30"
 606:                         value={settings?.cleanupPeriodDays || ""}
 607:                         onChange={(e) => {
 608:                           const value = e.target.value ? parseInt(e.target.value) : undefined;
 609:                           updateSetting("cleanupPeriodDays", value);
 610:                         }}
 611:                       />
 612:                       <p className="text-xs text-muted-foreground">
 613:                         How long to retain chat transcripts locally (default: 30 days)
 614:                       </p>
 615:                     </div>
 616:                     
 617:                     {/* Claude Binary Path Selector */}
 618:                     <div className="space-y-4">
 619:                       <div>
 620:                         <Label className="text-sm font-medium mb-2 block">Claude Code Installation</Label>
 621:                         <p className="text-xs text-muted-foreground mb-4">
 622:                           Select which Claude Code installation to use.
 623:                         </p>
 624:                       </div>
 625:                       <ClaudeVersionSelector
 626:                         selectedPath={currentBinaryPath}
 627:                         onSelect={handleClaudeInstallationSelect}
 628:                       />
 629:                       {binaryPathChanged && (
 630:                         <p className="text-xs text-amber-600 dark:text-amber-400">
 631:                           ⚠️ Claude binary path has been changed. Remember to save your settings.
 632:                         </p>
 633:                       )}
 634:                     </div>
 635:                   </div>
 636:                 </div>
 637:               </Card>
 638:             </TabsContent>
 639:             
 640:             {/* Permissions Settings */}
 641:             <TabsContent value="permissions" className="space-y-6">
 642:               <Card className="p-6">
 643:                 <div className="space-y-6">
 644:                   <div>
 645:                     <h3 className="text-base font-semibold mb-2">Permission Rules</h3>
 646:                     <p className="text-sm text-muted-foreground mb-4">
 647:                       Control which tools Claude Code can use without manual approval
 648:                     </p>
 649:                   </div>
 650:                   
 651:                   {/* Allow Rules */}
 652:                   <div className="space-y-3">
 653:                     <div className="flex items-center justify-between">
 654:                       <Label className="text-sm font-medium text-green-500">Allow Rules</Label>
 655:                       <Button
 656:                         variant="outline"
 657:                         size="sm"
 658:                         onClick={() => addPermissionRule("allow")}
 659:                         className="gap-2 hover:border-green-500/50 hover:text-green-500"
 660:                       >
 661:                         <Plus className="h-3 w-3" />
 662:                         Add Rule
 663:                       </Button>
 664:                     </div>
 665:                     <div className="space-y-2">
 666:                       {allowRules.length === 0 ? (
 667:                         <p className="text-xs text-muted-foreground py-2">
 668:                           No allow rules configured. Claude will ask for approval for all tools.
 669:                         </p>
 670:                       ) : (
 671:                         allowRules.map((rule) => (
 672:                           <motion.div
 673:                             key={rule.id}
 674:                             initial={{ opacity: 0, x: -20 }}
 675:                             animate={{ opacity: 1, x: 0 }}
 676:                             className="flex items-center gap-2"
 677:                           >
 678:                             <Input
 679:                               placeholder="e.g., Bash(npm run test:*)"
 680:                               value={rule.value}
 681:                               onChange={(e) => updatePermissionRule("allow", rule.id, e.target.value)}
 682:                               className="flex-1"
 683:                             />
 684:                             <Button
 685:                               variant="ghost"
 686:                               size="icon"
 687:                               onClick={() => removePermissionRule("allow", rule.id)}
 688:                               className="h-8 w-8"
 689:                             >
 690:                               <Trash2 className="h-4 w-4" />
 691:                             </Button>
 692:                           </motion.div>
 693:                         ))
 694:                       )}
 695:                     </div>
 696:                   </div>
 697:                   
 698:                   {/* Deny Rules */}
 699:                   <div className="space-y-3">
 700:                     <div className="flex items-center justify-between">
 701:                       <Label className="text-sm font-medium text-red-500">Deny Rules</Label>
 702:                       <Button
 703:                         variant="outline"
 704:                         size="sm"
 705:                         onClick={() => addPermissionRule("deny")}
 706:                         className="gap-2 hover:border-red-500/50 hover:text-red-500"
 707:                       >
 708:                         <Plus className="h-3 w-3" />
 709:                         Add Rule
 710:                       </Button>
 711:                     </div>
 712:                     <div className="space-y-2">
 713:                       {denyRules.length === 0 ? (
 714:                         <p className="text-xs text-muted-foreground py-2">
 715:                           No deny rules configured.
 716:                         </p>
 717:                       ) : (
 718:                         denyRules.map((rule) => (
 719:                           <motion.div
 720:                             key={rule.id}
 721:                             initial={{ opacity: 0, x: -20 }}
 722:                             animate={{ opacity: 1, x: 0 }}
 723:                             className="flex items-center gap-2"
 724:                           >
 725:                             <Input
 726:                               placeholder="e.g., Bash(curl:*)"
 727:                               value={rule.value}
 728:                               onChange={(e) => updatePermissionRule("deny", rule.id, e.target.value)}
 729:                               className="flex-1"
 730:                             />
 731:                             <Button
 732:                               variant="ghost"
 733:                               size="icon"
 734:                               onClick={() => removePermissionRule("deny", rule.id)}
 735:                               className="h-8 w-8"
 736:                             >
 737:                               <Trash2 className="h-4 w-4" />
 738:                             </Button>
 739:                           </motion.div>
 740:                         ))
 741:                       )}
 742:                     </div>
 743:                   </div>
 744:                   
 745:                   <div className="pt-2 space-y-2">
 746:                     <p className="text-xs text-muted-foreground">
 747:                       <strong>Examples:</strong>
 748:                     </p>
 749:                     <ul className="text-xs text-muted-foreground space-y-1 ml-4">
 750:                       <li>• <code className="px-1 py-0.5 rounded bg-green-500/10 text-green-600 dark:text-green-400">Bash</code> - Allow all bash commands</li>
 751:                       <li>• <code className="px-1 py-0.5 rounded bg-green-500/10 text-green-600 dark:text-green-400">Bash(npm run build)</code> - Allow exact command</li>
 752:                       <li>• <code className="px-1 py-0.5 rounded bg-green-500/10 text-green-600 dark:text-green-400">Bash(npm run test:*)</code> - Allow commands with prefix</li>
 753:                       <li>• <code className="px-1 py-0.5 rounded bg-green-500/10 text-green-600 dark:text-green-400">Read(~/.zshrc)</code> - Allow reading specific file</li>
 754:                       <li>• <code className="px-1 py-0.5 rounded bg-green-500/10 text-green-600 dark:text-green-400">Edit(docs/**)</code> - Allow editing files in docs directory</li>
 755:                     </ul>
 756:                   </div>
 757:                 </div>
 758:               </Card>
 759:             </TabsContent>
 760:             
 761:             {/* Environment Variables */}
 762:             <TabsContent value="environment" className="space-y-6">
 763:               <Card className="p-6">
 764:                 <div className="space-y-6">
 765:                   <div className="flex items-center justify-between">
 766:                     <div>
 767:                       <h3 className="text-base font-semibold">Environment Variables</h3>
 768:                       <p className="text-sm text-muted-foreground mt-1">
 769:                         Environment variables applied to every Claude Code session
 770:                       </p>
 771:                     </div>
 772:                     <Button
 773:                       variant="outline"
 774:                       size="sm"
 775:                       onClick={addEnvVar}
 776:                       className="gap-2"
 777:                     >
 778:                       <Plus className="h-3 w-3" />
 779:                       Add Variable
 780:                     </Button>
 781:                   </div>
 782:                   
 783:                   <div className="space-y-3">
 784:                     {envVars.length === 0 ? (
 785:                       <p className="text-xs text-muted-foreground py-2">
 786:                         No environment variables configured.
 787:                       </p>
 788:                     ) : (
 789:                       envVars.map((envVar) => (
 790:                         <motion.div
 791:                           key={envVar.id}
 792:                           initial={{ opacity: 0, x: -20 }}
 793:                           animate={{ opacity: 1, x: 0 }}
 794:                           className="flex items-center gap-2"
 795:                         >
 796:                           <Input
 797:                             placeholder="KEY"
 798:                             value={envVar.key}
 799:                             onChange={(e) => updateEnvVar(envVar.id, "key", e.target.value)}
 800:                             className="flex-1 font-mono text-sm"
 801:                           />
 802:                           <span className="text-muted-foreground">=</span>
 803:                           <Input
 804:                             placeholder="value"
 805:                             value={envVar.value}
 806:                             onChange={(e) => updateEnvVar(envVar.id, "value", e.target.value)}
 807:                             className="flex-1 font-mono text-sm"
 808:                           />
 809:                           <Button
 810:                             variant="ghost"
 811:                             size="icon"
 812:                             onClick={() => removeEnvVar(envVar.id)}
 813:                             className="h-8 w-8 hover:text-destructive"
 814:                           >
 815:                             <Trash2 className="h-4 w-4" />
 816:                           </Button>
 817:                         </motion.div>
 818:                       ))
 819:                     )}
 820:                   </div>
 821:                   
 822:                   <div className="pt-2 space-y-2">
 823:                     <p className="text-xs text-muted-foreground">
 824:                       <strong>Common variables:</strong>
 825:                     </p>
 826:                     <ul className="text-xs text-muted-foreground space-y-1 ml-4">
 827:                       <li>• <code className="px-1 py-0.5 rounded bg-blue-500/10 text-blue-600 dark:text-blue-400">CLAUDE_CODE_ENABLE_TELEMETRY</code> - Enable/disable telemetry (0 or 1)</li>
 828:                       <li>• <code className="px-1 py-0.5 rounded bg-blue-500/10 text-blue-600 dark:text-blue-400">ANTHROPIC_MODEL</code> - Custom model name</li>
 829:                       <li>• <code className="px-1 py-0.5 rounded bg-blue-500/10 text-blue-600 dark:text-blue-400">DISABLE_COST_WARNINGS</code> - Disable cost warnings (1)</li>
 830:                     </ul>
 831:                   </div>
 832:                 </div>
 833:               </Card>
 834:             </TabsContent>
 835:             {/* Advanced Settings */}
 836:             <TabsContent value="advanced" className="space-y-6">
 837:               <Card className="p-6">
 838:                 <div className="space-y-6">
 839:                   <div>
 840:                     <h3 className="text-base font-semibold mb-4">Advanced Settings</h3>
 841:                     <p className="text-sm text-muted-foreground mb-6">
 842:                       Additional configuration options for advanced users
 843:                     </p>
 844:                   </div>
 845:                   
 846:                   {/* API Key Helper */}
 847:                   <div className="space-y-2">
 848:                     <Label htmlFor="apiKeyHelper">API Key Helper Script</Label>
 849:                     <Input
 850:                       id="apiKeyHelper"
 851:                       placeholder="/path/to/generate_api_key.sh"
 852:                       value={settings?.apiKeyHelper || ""}
 853:                       onChange={(e) => updateSetting("apiKeyHelper", e.target.value || undefined)}
 854:                     />
 855:                     <p className="text-xs text-muted-foreground">
 856:                       Custom script to generate auth values for API requests
 857:                     </p>
 858:                   </div>
 859:                   
 860:                   {/* Raw JSON Editor */}
 861:                   <div className="space-y-2">
 862:                     <Label>Raw Settings (JSON)</Label>
 863:                     <div className="p-3 rounded-md bg-muted font-mono text-xs overflow-x-auto whitespace-pre-wrap">
 864:                       <pre>{JSON.stringify(settings, null, 2)}</pre>
 865:                     </div>
 866:                     <p className="text-xs text-muted-foreground">
 867:                       This shows the raw JSON that will be saved to ~/.claude/settings.json
 868:                     </p>
 869:                   </div>
 870:                 </div>
 871:               </Card>
 872:             </TabsContent>
 873:             
 874:             {/* Hooks Settings */}
 875:             <TabsContent value="hooks" className="space-y-6">
 876:               <Card className="p-6">
 877:                 <div className="space-y-4">
 878:                   <div>
 879:                     <h3 className="text-base font-semibold mb-2">User Hooks</h3>
 880:                     <p className="text-sm text-muted-foreground mb-4">
 881:                       Configure hooks that apply to all Claude Code sessions for your user account.
 882:                       These are stored in <code className="mx-1 px-2 py-1 bg-muted rounded text-xs">~/.claude/settings.json</code>
 883:                     </p>
 884:                   </div>
 885:                   
 886:                   <HooksEditor
 887:                     key={activeTab}
 888:                     scope="user"
 889:                     className="border-0"
 890:                     hideActions={true}
 891:                     onChange={(hasChanges, getHooks) => {
 892:                       setUserHooksChanged(hasChanges);
 893:                       getUserHooks.current = getHooks;
 894:                     }}
 895:                   />
 896:                 </div>
 897:               </Card>
 898:             </TabsContent>
 899:             
 900:             {/* Commands Tab */}
 901:             <TabsContent value="commands">
 902:               <Card className="p-6">
 903:                 <SlashCommandsManager className="p-0" />
 904:               </Card>
 905:             </TabsContent>
 906:             
 907:             {/* Storage Tab */}
 908:             <TabsContent value="storage">
 909:               <StorageTab />
 910:             </TabsContent>
 911:             
 912:             {/* Proxy Settings */}
 913:             <TabsContent value="proxy">
 914:               <Card className="p-6">
 915:                 <ProxySettings 
 916:                   setToast={setToast}
 917:                   onChange={(hasChanges, _getSettings, save) => {
 918:                     setProxySettingsChanged(hasChanges);
 919:                     saveProxySettings.current = save;
 920:                   }}
 921:                 />
 922:               </Card>
 923:             </TabsContent>
 924:             
 925:             {/* Analytics Settings */}
 926:             <TabsContent value="analytics" className="space-y-6">
 927:               <Card className="p-6 space-y-6">
 928:                 <div>
 929:                   <div className="flex items-center gap-3 mb-4">
 930:                     <BarChart3 className="h-5 w-5 text-purple-600 dark:text-purple-400" />
 931:                     <h3 className="text-base font-semibold">Analytics Settings</h3>
 932:                   </div>
 933:                   
 934:                   <div className="space-y-6">
 935:                     {/* Analytics Toggle */}
 936:                     <div className="flex items-center justify-between">
 937:                       <div className="space-y-1">
 938:                         <Label htmlFor="analytics-enabled" className="text-base">Enable Analytics</Label>
 939:                         <p className="text-sm text-muted-foreground">
 940:                           Help improve Claudia by sharing anonymous usage data
 941:                         </p>
 942:                       </div>
 943:                       <Switch
 944:                         id="analytics-enabled"
 945:                         checked={analyticsEnabled}
 946:                         onCheckedChange={async (checked) => {
 947:                           if (checked && !analyticsConsented) {
 948:                             setShowAnalyticsConsent(true);
 949:                           } else if (checked) {
 950:                             await analytics.enable();
 951:                             setAnalyticsEnabled(true);
 952:                             trackEvent.settingsChanged('analytics_enabled', true);
 953:                             setToast({ message: "Analytics enabled", type: "success" });
 954:                           } else {
 955:                             await analytics.disable();
 956:                             setAnalyticsEnabled(false);
 957:                             trackEvent.settingsChanged('analytics_enabled', false);
 958:                             setToast({ message: "Analytics disabled", type: "success" });
 959:                           }
 960:                         }}
 961:                       />
 962:                     </div>
 963:                     
 964:                     {/* Privacy Info */}
 965:                     <div className="rounded-lg border border-blue-200 dark:border-blue-900 bg-blue-50 dark:bg-blue-950/20 p-4">
 966:                       <div className="flex gap-3">
 967:                         <Shield className="h-5 w-5 text-blue-600 dark:text-blue-400 flex-shrink-0 mt-0.5" />
 968:                         <div className="space-y-2">
 969:                           <p className="font-medium text-blue-900 dark:text-blue-100">Your privacy is protected</p>
 970:                           <ul className="text-sm text-blue-800 dark:text-blue-200 space-y-1">
 971:                             <li>• No personal information is collected</li>
 972:                             <li>• No file contents, paths, or project names</li>
 973:                             <li>• All data is anonymous with random IDs</li>
 974:                             <li>• You can disable analytics at any time</li>
 975:                           </ul>
 976:                         </div>
 977:                       </div>
 978:                     </div>
 979:                     
 980:                     {/* Data Collection Info */}
 981:                     {analyticsEnabled && (
 982:                       <div className="space-y-4">
 983:                         <div>
 984:                           <h4 className="text-sm font-medium mb-2">What we collect:</h4>
 985:                           <ul className="text-sm text-muted-foreground space-y-1">
 986:                             <li>• Feature usage patterns</li>
 987:                             <li>• Performance metrics</li>
 988:                             <li>• Error reports (without sensitive data)</li>
 989:                             <li>• Session frequency and duration</li>
 990:                           </ul>
 991:                         </div>
 992:                         
 993:                         {/* Delete Data Button */}
 994:                         <div className="pt-4 border-t">
 995:                           <Button
 996:                             variant="destructive"
 997:                             size="sm"
 998:                             onClick={async () => {
 999:                               await analytics.deleteAllData();
1000:                               setAnalyticsEnabled(false);
1001:                               setAnalyticsConsented(false);
1002:                               setToast({ message: "All analytics data deleted", type: "success" });
1003:                             }}
1004:                           >
1005:                             <Trash className="mr-2 h-4 w-4" />
1006:                             Delete All Analytics Data
1007:                           </Button>
1008:                         </div>
1009:                       </div>
1010:                     )}
1011:                   </div>
1012:                 </div>
1013:               </Card>
1014:             </TabsContent>
1015:           </Tabs>
1016:         </div>
1017:       )}
1018:       </div>
1019:       
1020:       {/* Toast Notification */}
1021:       <ToastContainer>
1022:         {toast && (
1023:           <Toast
1024:             message={toast.message}
1025:             type={toast.type}
1026:             onDismiss={() => setToast(null)}
1027:           />
1028:         )}
1029:       </ToastContainer>
1030:       
1031:       {/* Analytics Consent Dialog */}
1032:       <AnalyticsConsent
1033:         open={showAnalyticsConsent}
1034:         onOpenChange={setShowAnalyticsConsent}
1035:         onComplete={async () => {
1036:           await loadAnalyticsSettings();
1037:           setShowAnalyticsConsent(false);
1038:         }}
1039:       />
1040:     </div>
1041:   );
1042: };
````

## File: src/components/SlashCommandPicker.tsx
````typescript
  1: import React, { useState, useEffect, useRef } from "react";
  2: import { motion } from "framer-motion";
  3: import { Button } from "@/components/ui/button";
  4: import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
  5: import { api } from "@/lib/api";
  6: import { 
  7:   X, 
  8:   Command,
  9:   Search,
 10:   Globe,
 11:   FolderOpen,
 12:   Zap,
 13:   FileCode,
 14:   Terminal,
 15:   AlertCircle,
 16:   User,
 17:   Building2
 18: } from "lucide-react";
 19: import type { SlashCommand } from "@/lib/api";
 20: import { cn } from "@/lib/utils";
 21: import { useTrackEvent, useFeatureAdoptionTracking } from "@/hooks";
 22: 
 23: interface SlashCommandPickerProps {
 24:   /**
 25:    * The project path for loading project-specific commands
 26:    */
 27:   projectPath?: string;
 28:   /**
 29:    * Callback when a command is selected
 30:    */
 31:   onSelect: (command: SlashCommand) => void;
 32:   /**
 33:    * Callback to close the picker
 34:    */
 35:   onClose: () => void;
 36:   /**
 37:    * Initial search query (text after /)
 38:    */
 39:   initialQuery?: string;
 40:   /**
 41:    * Optional className for styling
 42:    */
 43:   className?: string;
 44: }
 45: 
 46: // Get icon for command based on its properties
 47: const getCommandIcon = (command: SlashCommand) => {
 48:   // If it has bash commands, show terminal icon
 49:   if (command.has_bash_commands) return Terminal;
 50:   
 51:   // If it has file references, show file icon
 52:   if (command.has_file_references) return FileCode;
 53:   
 54:   // If it accepts arguments, show zap icon
 55:   if (command.accepts_arguments) return Zap;
 56:   
 57:   // Based on scope
 58:   if (command.scope === "project") return FolderOpen;
 59:   if (command.scope === "user") return Globe;
 60:   
 61:   // Default
 62:   return Command;
 63: };
 64: 
 65: /**
 66:  * SlashCommandPicker component - Autocomplete UI for slash commands
 67:  * 
 68:  * @example
 69:  * <SlashCommandPicker
 70:  *   projectPath="/Users/example/project"
 71:  *   onSelect={(command) => console.log('Selected:', command)}
 72:  *   onClose={() => setShowPicker(false)}
 73:  * />
 74:  */
 75: export const SlashCommandPicker: React.FC<SlashCommandPickerProps> = ({
 76:   projectPath,
 77:   onSelect,
 78:   onClose,
 79:   initialQuery = "",
 80:   className,
 81: }) => {
 82:   const [commands, setCommands] = useState<SlashCommand[]>([]);
 83:   const [filteredCommands, setFilteredCommands] = useState<SlashCommand[]>([]);
 84:   const [isLoading, setIsLoading] = useState(true);
 85:   const [error, setError] = useState<string | null>(null);
 86:   const [selectedIndex, setSelectedIndex] = useState(0);
 87:   const [searchQuery, setSearchQuery] = useState(initialQuery);
 88:   const [activeTab, setActiveTab] = useState<string>("custom");
 89:   
 90:   const commandListRef = useRef<HTMLDivElement>(null);
 91:   
 92:   // Analytics tracking
 93:   const trackEvent = useTrackEvent();
 94:   const slashCommandFeatureTracking = useFeatureAdoptionTracking('slash_commands');
 95:   
 96:   // Load commands on mount or when project path changes
 97:   useEffect(() => {
 98:     loadCommands();
 99:   }, [projectPath]);
100:   
101:   // Filter commands based on search query and active tab
102:   useEffect(() => {
103:     if (!commands.length) {
104:       setFilteredCommands([]);
105:       return;
106:     }
107:     
108:     const query = searchQuery.toLowerCase();
109:     let filteredByTab: SlashCommand[];
110:     
111:     // Filter by active tab
112:     if (activeTab === "default") {
113:       // Show default/built-in commands
114:       filteredByTab = commands.filter(cmd => cmd.scope === "default");
115:     } else {
116:       // Show all custom commands (both user and project)
117:       filteredByTab = commands.filter(cmd => cmd.scope !== "default");
118:     }
119:     
120:     // Then filter by search query
121:     let filtered: SlashCommand[];
122:     if (!query) {
123:       filtered = filteredByTab;
124:     } else {
125:       filtered = filteredByTab.filter(cmd => {
126:         // Match against command name
127:         if (cmd.name.toLowerCase().includes(query)) return true;
128:         
129:         // Match against full command
130:         if (cmd.full_command.toLowerCase().includes(query)) return true;
131:         
132:         // Match against namespace
133:         if (cmd.namespace && cmd.namespace.toLowerCase().includes(query)) return true;
134:         
135:         // Match against description
136:         if (cmd.description && cmd.description.toLowerCase().includes(query)) return true;
137:         
138:         return false;
139:       });
140:       
141:       // Sort by relevance
142:       filtered.sort((a, b) => {
143:         // Exact name match first
144:         const aExact = a.name.toLowerCase() === query;
145:         const bExact = b.name.toLowerCase() === query;
146:         if (aExact && !bExact) return -1;
147:         if (!aExact && bExact) return 1;
148:         
149:         // Then by name starts with
150:         const aStarts = a.name.toLowerCase().startsWith(query);
151:         const bStarts = b.name.toLowerCase().startsWith(query);
152:         if (aStarts && !bStarts) return -1;
153:         if (!aStarts && bStarts) return 1;
154:         
155:         // Then alphabetically
156:         return a.name.localeCompare(b.name);
157:       });
158:     }
159:     
160:     setFilteredCommands(filtered);
161:     
162:     // Reset selected index when filtered list changes
163:     setSelectedIndex(0);
164:   }, [searchQuery, commands, activeTab]);
165:   
166:   // Keyboard navigation
167:   useEffect(() => {
168:     const handleKeyDown = (e: KeyboardEvent) => {
169:       switch (e.key) {
170:         case 'Escape':
171:           e.preventDefault();
172:           onClose();
173:           break;
174:           
175:         case 'Enter':
176:           e.preventDefault();
177:           if (filteredCommands.length > 0 && selectedIndex < filteredCommands.length) {
178:             const command = filteredCommands[selectedIndex];
179:             trackEvent.slashCommandSelected({
180:               command_name: command.name,
181:               selection_method: 'keyboard'
182:             });
183:             slashCommandFeatureTracking.trackUsage();
184:             onSelect(command);
185:           }
186:           break;
187:           
188:         case 'ArrowUp':
189:           e.preventDefault();
190:           setSelectedIndex(prev => Math.max(0, prev - 1));
191:           break;
192:           
193:         case 'ArrowDown':
194:           e.preventDefault();
195:           setSelectedIndex(prev => Math.min(filteredCommands.length - 1, prev + 1));
196:           break;
197:       }
198:     };
199:     
200:     window.addEventListener('keydown', handleKeyDown);
201:     return () => window.removeEventListener('keydown', handleKeyDown);
202:   }, [filteredCommands, selectedIndex, onSelect, onClose]);
203:   
204:   // Scroll selected item into view
205:   useEffect(() => {
206:     if (commandListRef.current) {
207:       const selectedElement = commandListRef.current.querySelector(`[data-index="${selectedIndex}"]`);
208:       if (selectedElement) {
209:         selectedElement.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
210:       }
211:     }
212:   }, [selectedIndex]);
213:   
214:   const loadCommands = async () => {
215:     try {
216:       setIsLoading(true);
217:       setError(null);
218:       
219:       // Always load fresh commands from filesystem
220:       const loadedCommands = await api.slashCommandsList(projectPath);
221:       setCommands(loadedCommands);
222:     } catch (err) {
223:       console.error("Failed to load slash commands:", err);
224:       setError(err instanceof Error ? err.message : 'Failed to load commands');
225:       setCommands([]);
226:     } finally {
227:       setIsLoading(false);
228:     }
229:   };
230:   
231:   const handleCommandClick = (command: SlashCommand) => {
232:     trackEvent.slashCommandSelected({
233:       command_name: command.name,
234:       selection_method: 'click'
235:     });
236:     slashCommandFeatureTracking.trackUsage();
237:     onSelect(command);
238:   };
239:   
240:   // Group commands by scope and namespace for the Custom tab
241:   const groupedCommands = filteredCommands.reduce((acc, cmd) => {
242:     let key: string;
243:     if (cmd.scope === "user") {
244:       key = cmd.namespace ? `User Commands: ${cmd.namespace}` : "User Commands";
245:     } else if (cmd.scope === "project") {
246:       key = cmd.namespace ? `Project Commands: ${cmd.namespace}` : "Project Commands";
247:     } else {
248:       key = cmd.namespace || "Commands";
249:     }
250:     
251:     if (!acc[key]) {
252:       acc[key] = [];
253:     }
254:     acc[key].push(cmd);
255:     return acc;
256:   }, {} as Record<string, SlashCommand[]>);
257:   
258:   // Update search query from parent
259:   useEffect(() => {
260:     setSearchQuery(initialQuery);
261:   }, [initialQuery]);
262:   
263:   return (
264:     <motion.div
265:       initial={{ opacity: 0, scale: 0.95 }}
266:       animate={{ opacity: 1, scale: 1 }}
267:       exit={{ opacity: 0, scale: 0.95 }}
268:       className={cn(
269:         "absolute bottom-full mb-2 left-0 z-50",
270:         "w-[600px] h-[400px]",
271:         "bg-background border border-border rounded-lg shadow-lg",
272:         "flex flex-col overflow-hidden",
273:         className
274:       )}
275:     >
276:       {/* Header */}
277:       <div className="border-b border-border p-3">
278:         <div className="flex items-center justify-between">
279:           <div className="flex items-center gap-2">
280:             <Command className="h-4 w-4 text-muted-foreground" />
281:             <span className="text-sm font-medium">Slash Commands</span>
282:             {searchQuery && (
283:               <span className="text-xs text-muted-foreground">
284:                 Searching: "{searchQuery}"
285:               </span>
286:             )}
287:           </div>
288:           <Button
289:             variant="ghost"
290:             size="icon"
291:             onClick={onClose}
292:             className="h-8 w-8"
293:           >
294:             <X className="h-4 w-4" />
295:           </Button>
296:         </div>
297:         
298:         {/* Tabs */}
299:         <div className="mt-3">
300:           <Tabs value={activeTab} onValueChange={setActiveTab}>
301:             <TabsList className="grid w-full grid-cols-2">
302:               <TabsTrigger value="default">Default</TabsTrigger>
303:               <TabsTrigger value="custom">Custom</TabsTrigger>
304:             </TabsList>
305:           </Tabs>
306:         </div>
307:       </div>
308: 
309:       {/* Command List */}
310:       <div className="flex-1 overflow-y-auto relative">
311:         {isLoading && (
312:           <div className="flex items-center justify-center h-full">
313:             <span className="text-sm text-muted-foreground">Loading commands...</span>
314:           </div>
315:         )}
316: 
317:         {error && (
318:           <div className="flex flex-col items-center justify-center h-full p-4">
319:             <AlertCircle className="h-8 w-8 text-destructive mb-2" />
320:             <span className="text-sm text-destructive text-center">{error}</span>
321:           </div>
322:         )}
323: 
324:         {!isLoading && !error && (
325:           <>
326:             {/* Default Tab Content */}
327:             {activeTab === "default" && (
328:               <>
329:                 {filteredCommands.length === 0 && (
330:                   <div className="flex flex-col items-center justify-center h-full">
331:                     <Command className="h-8 w-8 text-muted-foreground mb-2" />
332:                     <span className="text-sm text-muted-foreground">
333:                       {searchQuery ? 'No commands found' : 'No default commands available'}
334:                     </span>
335:                     {!searchQuery && (
336:                       <p className="text-xs text-muted-foreground mt-2 text-center px-4">
337:                         Default commands are built-in system commands
338:                       </p>
339:                     )}
340:                   </div>
341:                 )}
342: 
343:                 {filteredCommands.length > 0 && (
344:                   <div className="p-2" ref={commandListRef}>
345:                     <div className="space-y-0.5">
346:                       {filteredCommands.map((command, index) => {
347:                         const Icon = getCommandIcon(command);
348:                         const isSelected = index === selectedIndex;
349:                         
350:                         return (
351:                           <button
352:                             key={command.id}
353:                             data-index={index}
354:                             onClick={() => handleCommandClick(command)}
355:                             onMouseEnter={() => setSelectedIndex(index)}
356:                             className={cn(
357:                               "w-full flex items-start gap-3 px-3 py-2 rounded-md",
358:                               "hover:bg-accent transition-colors",
359:                               "text-left",
360:                               isSelected && "bg-accent"
361:                             )}
362:                           >
363:                             <Icon className="h-4 w-4 text-muted-foreground mt-1 flex-shrink-0" />
364:                             <div className="flex-1 overflow-hidden">
365:                               <div className="flex items-center gap-2">
366:                                 <span className="font-medium">
367:                                   {command.full_command}
368:                                 </span>
369:                                 <span className="text-xs text-muted-foreground px-1.5 py-0.5 bg-muted rounded">
370:                                   {command.scope}
371:                                 </span>
372:                               </div>
373:                               {command.description && (
374:                                 <p className="text-xs text-muted-foreground mt-1 leading-relaxed">
375:                                   {command.description}
376:                                 </p>
377:                               )}
378:                             </div>
379:                           </button>
380:                         );
381:                       })}
382:                     </div>
383:                   </div>
384:                 )}
385:               </>
386:             )}
387:             
388:             {/* Custom Tab Content */}
389:             {activeTab === "custom" && (
390:               <>
391:                 {filteredCommands.length === 0 && (
392:                   <div className="flex flex-col items-center justify-center h-full">
393:                     <Search className="h-8 w-8 text-muted-foreground mb-2" />
394:                     <span className="text-sm text-muted-foreground">
395:                       {searchQuery ? 'No commands found' : 'No custom commands available'}
396:                     </span>
397:                     {!searchQuery && (
398:                       <p className="text-xs text-muted-foreground mt-2 text-center px-4">
399:                         Create commands in <code className="px-1">.claude/commands/</code> or <code className="px-1">~/.claude/commands/</code>
400:                       </p>
401:                     )}
402:                   </div>
403:                 )}
404: 
405:                 {filteredCommands.length > 0 && (
406:                   <div className="p-2" ref={commandListRef}>
407:                     {/* If no grouping needed, show flat list */}
408:                     {Object.keys(groupedCommands).length === 1 ? (
409:                       <div className="space-y-0.5">
410:                         {filteredCommands.map((command, index) => {
411:                           const Icon = getCommandIcon(command);
412:                           const isSelected = index === selectedIndex;
413:                           
414:                           return (
415:                             <button
416:                               key={command.id}
417:                               data-index={index}
418:                               onClick={() => handleCommandClick(command)}
419:                               onMouseEnter={() => setSelectedIndex(index)}
420:                               className={cn(
421:                                 "w-full flex items-start gap-3 px-3 py-2 rounded-md",
422:                                 "hover:bg-accent transition-colors",
423:                                 "text-left",
424:                                 isSelected && "bg-accent"
425:                               )}
426:                             >
427:                               <Icon className="h-4 w-4 mt-0.5 flex-shrink-0 text-muted-foreground" />
428:                               
429:                               <div className="flex-1 min-w-0">
430:                                 <div className="flex items-baseline gap-2">
431:                                   <span className="font-mono text-sm text-primary">
432:                                     {command.full_command}
433:                                   </span>
434:                                   {command.accepts_arguments && (
435:                                     <span className="text-xs text-muted-foreground">
436:                                       [args]
437:                                     </span>
438:                                   )}
439:                                 </div>
440:                                 
441:                                 {command.description && (
442:                                   <p className="text-xs text-muted-foreground mt-0.5 truncate">
443:                                     {command.description}
444:                                   </p>
445:                                 )}
446:                                 
447:                                 <div className="flex items-center gap-3 mt-1">
448:                                   {command.allowed_tools.length > 0 && (
449:                                     <span className="text-xs text-muted-foreground">
450:                                       {command.allowed_tools.length} tool{command.allowed_tools.length === 1 ? '' : 's'}
451:                                     </span>
452:                                   )}
453:                                   
454:                                   {command.has_bash_commands && (
455:                                     <span className="text-xs text-blue-600 dark:text-blue-400">
456:                                       Bash
457:                                     </span>
458:                                   )}
459:                                   
460:                                   {command.has_file_references && (
461:                                     <span className="text-xs text-green-600 dark:text-green-400">
462:                                       Files
463:                                     </span>
464:                                   )}
465:                                 </div>
466:                               </div>
467:                             </button>
468:                           );
469:                         })}
470:                       </div>
471:                     ) : (
472:                       // Show grouped by scope/namespace
473:                       <div className="space-y-4">
474:                         {Object.entries(groupedCommands).map(([groupKey, groupCommands]) => (
475:                           <div key={groupKey}>
476:                             <h3 className="text-xs font-medium text-muted-foreground uppercase tracking-wider px-3 mb-1 flex items-center gap-2">
477:                               {groupKey.startsWith("User Commands") && <User className="h-3 w-3" />}
478:                               {groupKey.startsWith("Project Commands") && <Building2 className="h-3 w-3" />}
479:                               {groupKey}
480:                             </h3>
481:                             
482:                             <div className="space-y-0.5">
483:                               {groupCommands.map((command) => {
484:                                 const Icon = getCommandIcon(command);
485:                                 const globalIndex = filteredCommands.indexOf(command);
486:                                 const isSelected = globalIndex === selectedIndex;
487:                                 
488:                                 return (
489:                                   <button
490:                                     key={command.id}
491:                                     data-index={globalIndex}
492:                                     onClick={() => handleCommandClick(command)}
493:                                     onMouseEnter={() => setSelectedIndex(globalIndex)}
494:                                     className={cn(
495:                                       "w-full flex items-start gap-3 px-3 py-2 rounded-md",
496:                                       "hover:bg-accent transition-colors",
497:                                       "text-left",
498:                                       isSelected && "bg-accent"
499:                                     )}
500:                                   >
501:                                     <Icon className="h-4 w-4 mt-0.5 flex-shrink-0 text-muted-foreground" />
502:                                     
503:                                     <div className="flex-1 min-w-0">
504:                                       <div className="flex items-baseline gap-2">
505:                                         <span className="font-mono text-sm text-primary">
506:                                           {command.full_command}
507:                                         </span>
508:                                         {command.accepts_arguments && (
509:                                           <span className="text-xs text-muted-foreground">
510:                                             [args]
511:                                           </span>
512:                                         )}
513:                                       </div>
514:                                       
515:                                       {command.description && (
516:                                         <p className="text-xs text-muted-foreground mt-0.5 truncate">
517:                                           {command.description}
518:                                         </p>
519:                                       )}
520:                                       
521:                                       <div className="flex items-center gap-3 mt-1">
522:                                         {command.allowed_tools.length > 0 && (
523:                                           <span className="text-xs text-muted-foreground">
524:                                             {command.allowed_tools.length} tool{command.allowed_tools.length === 1 ? '' : 's'}
525:                                           </span>
526:                                         )}
527:                                         
528:                                         {command.has_bash_commands && (
529:                                           <span className="text-xs text-blue-600 dark:text-blue-400">
530:                                             Bash
531:                                           </span>
532:                                         )}
533:                                         
534:                                         {command.has_file_references && (
535:                                           <span className="text-xs text-green-600 dark:text-green-400">
536:                                             Files
537:                                           </span>
538:                                         )}
539:                                       </div>
540:                                     </div>
541:                                   </button>
542:                                 );
543:                               })}
544:                             </div>
545:                           </div>
546:                         ))}
547:                       </div>
548:                     )}
549:                   </div>
550:                 )}
551:               </>
552:             )}
553:           </>
554:         )}
555:       </div>
556: 
557:       {/* Footer */}
558:       <div className="border-t border-border p-2">
559:         <p className="text-xs text-muted-foreground text-center">
560:           ↑↓ Navigate • Enter Select • Esc Close
561:         </p>
562:       </div>
563:     </motion.div>
564:   );
565: };
````

## File: src/components/SlashCommandsManager.tsx
````typescript
  1: import React, { useState, useEffect } from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import { 
  4:   Plus, 
  5:   Trash2, 
  6:   Edit,
  7:   Save,
  8:   Command,
  9:   Globe,
 10:   FolderOpen,
 11:   Terminal,
 12:   FileCode,
 13:   Zap,
 14:   Code,
 15:   AlertCircle,
 16:   Loader2,
 17:   Search,
 18:   ChevronDown,
 19:   ChevronRight
 20: } from "lucide-react";
 21: import { Button } from "@/components/ui/button";
 22: import { Input } from "@/components/ui/input";
 23: import { Label } from "@/components/ui/label";
 24: import { Textarea } from "@/components/ui/textarea";
 25: import { Card } from "@/components/ui/card";
 26: import { Badge } from "@/components/ui/badge";
 27: import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
 28: import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog";
 29: import { api, type SlashCommand } from "@/lib/api";
 30: import { cn } from "@/lib/utils";
 31: import { COMMON_TOOL_MATCHERS } from "@/types/hooks";
 32: import { useTrackEvent } from "@/hooks";
 33: 
 34: interface SlashCommandsManagerProps {
 35:   projectPath?: string;
 36:   className?: string;
 37:   scopeFilter?: 'project' | 'user' | 'all';
 38: }
 39: 
 40: interface CommandForm {
 41:   name: string;
 42:   namespace: string;
 43:   content: string;
 44:   description: string;
 45:   allowedTools: string[];
 46:   scope: 'project' | 'user';
 47: }
 48: 
 49: const EXAMPLE_COMMANDS = [
 50:   {
 51:     name: "review",
 52:     description: "Review code for best practices",
 53:     content: "Review the following code for best practices, potential issues, and improvements:\n\n@$ARGUMENTS",
 54:     allowedTools: ["Read", "Grep"]
 55:   },
 56:   {
 57:     name: "explain",
 58:     description: "Explain how something works",
 59:     content: "Explain how $ARGUMENTS works in detail, including its purpose, implementation, and usage examples.",
 60:     allowedTools: ["Read", "Grep", "WebSearch"]
 61:   },
 62:   {
 63:     name: "fix-issue",
 64:     description: "Fix a specific issue",
 65:     content: "Fix issue #$ARGUMENTS following our coding standards and best practices.",
 66:     allowedTools: ["Read", "Edit", "MultiEdit", "Write"]
 67:   },
 68:   {
 69:     name: "test",
 70:     description: "Write tests for code",
 71:     content: "Write comprehensive tests for:\n\n@$ARGUMENTS\n\nInclude unit tests, edge cases, and integration tests where appropriate.",
 72:     allowedTools: ["Read", "Write", "Edit"]
 73:   }
 74: ];
 75: 
 76: // Get icon for command based on its properties
 77: const getCommandIcon = (command: SlashCommand) => {
 78:   if (command.has_bash_commands) return Terminal;
 79:   if (command.has_file_references) return FileCode;
 80:   if (command.accepts_arguments) return Zap;
 81:   if (command.scope === "project") return FolderOpen;
 82:   if (command.scope === "user") return Globe;
 83:   return Command;
 84: };
 85: 
 86: /**
 87:  * SlashCommandsManager component for managing custom slash commands
 88:  * Provides a no-code interface for creating, editing, and deleting commands
 89:  */
 90: export const SlashCommandsManager: React.FC<SlashCommandsManagerProps> = ({
 91:   projectPath,
 92:   className,
 93:   scopeFilter = 'all',
 94: }) => {
 95:   const [commands, setCommands] = useState<SlashCommand[]>([]);
 96:   const [loading, setLoading] = useState(true);
 97:   const [saving, setSaving] = useState(false);
 98:   const [error, setError] = useState<string | null>(null);
 99:   const [searchQuery, setSearchQuery] = useState("");
100:   const [selectedScope, setSelectedScope] = useState<'all' | 'project' | 'user'>(scopeFilter === 'all' ? 'all' : scopeFilter as 'project' | 'user');
101:   const [expandedCommands, setExpandedCommands] = useState<Set<string>>(new Set());
102:   
103:   // Edit dialog state
104:   const [editDialogOpen, setEditDialogOpen] = useState(false);
105:   const [editingCommand, setEditingCommand] = useState<SlashCommand | null>(null);
106:   const [commandForm, setCommandForm] = useState<CommandForm>({
107:     name: "",
108:     namespace: "",
109:     content: "",
110:     description: "",
111:     allowedTools: [],
112:     scope: 'user'
113:   });
114: 
115:   // Delete confirmation dialog state
116:   const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
117:   const [commandToDelete, setCommandToDelete] = useState<SlashCommand | null>(null);
118:   const [deleting, setDeleting] = useState(false);
119:   
120:   // Analytics tracking
121:   const trackEvent = useTrackEvent();
122: 
123:   // Load commands on mount
124:   useEffect(() => {
125:     loadCommands();
126:   }, [projectPath]);
127: 
128:   const loadCommands = async () => {
129:     try {
130:       setLoading(true);
131:       setError(null);
132:       const loadedCommands = await api.slashCommandsList(projectPath);
133:       setCommands(loadedCommands);
134:     } catch (err) {
135:       console.error("Failed to load slash commands:", err);
136:       setError("Failed to load commands");
137:     } finally {
138:       setLoading(false);
139:     }
140:   };
141: 
142:   const handleCreateNew = () => {
143:     setEditingCommand(null);
144:     setCommandForm({
145:       name: "",
146:       namespace: "",
147:       content: "",
148:       description: "",
149:       allowedTools: [],
150:       scope: scopeFilter !== 'all' ? scopeFilter : (projectPath ? 'project' : 'user')
151:     });
152:     setEditDialogOpen(true);
153:   };
154: 
155:   const handleEdit = (command: SlashCommand) => {
156:     setEditingCommand(command);
157:     setCommandForm({
158:       name: command.name,
159:       namespace: command.namespace || "",
160:       content: command.content,
161:       description: command.description || "",
162:       allowedTools: command.allowed_tools,
163:       scope: command.scope as 'project' | 'user'
164:     });
165:     setEditDialogOpen(true);
166:   };
167: 
168:   const handleSave = async () => {
169:     try {
170:       setSaving(true);
171:       setError(null);
172: 
173:       await api.slashCommandSave(
174:         commandForm.scope,
175:         commandForm.name,
176:         commandForm.namespace || undefined,
177:         commandForm.content,
178:         commandForm.description || undefined,
179:         commandForm.allowedTools,
180:         commandForm.scope === 'project' ? projectPath : undefined
181:       );
182:       
183:       // Track command creation
184:       trackEvent.slashCommandCreated({
185:         command_type: editingCommand ? 'custom' : 'custom',
186:         has_parameters: commandForm.content.includes('$ARGUMENTS')
187:       });
188: 
189:       setEditDialogOpen(false);
190:       await loadCommands();
191:     } catch (err) {
192:       console.error("Failed to save command:", err);
193:       setError(err instanceof Error ? err.message : "Failed to save command");
194:     } finally {
195:       setSaving(false);
196:     }
197:   };
198: 
199:   const handleDeleteClick = (command: SlashCommand) => {
200:     setCommandToDelete(command);
201:     setDeleteDialogOpen(true);
202:   };
203: 
204:   const confirmDelete = async () => {
205:     if (!commandToDelete) return;
206: 
207:     try {
208:       setDeleting(true);
209:       setError(null);
210:       await api.slashCommandDelete(commandToDelete.id, projectPath);
211:       setDeleteDialogOpen(false);
212:       setCommandToDelete(null);
213:       await loadCommands();
214:     } catch (err) {
215:       console.error("Failed to delete command:", err);
216:       const errorMessage = err instanceof Error ? err.message : "Failed to delete command";
217:       setError(errorMessage);
218:     } finally {
219:       setDeleting(false);
220:     }
221:   };
222: 
223:   const cancelDelete = () => {
224:     setDeleteDialogOpen(false);
225:     setCommandToDelete(null);
226:   };
227: 
228:   const toggleExpanded = (commandId: string) => {
229:     setExpandedCommands(prev => {
230:       const next = new Set(prev);
231:       if (next.has(commandId)) {
232:         next.delete(commandId);
233:       } else {
234:         next.add(commandId);
235:       }
236:       return next;
237:     });
238:   };
239: 
240:   const handleToolToggle = (tool: string) => {
241:     setCommandForm(prev => ({
242:       ...prev,
243:       allowedTools: prev.allowedTools.includes(tool)
244:         ? prev.allowedTools.filter(t => t !== tool)
245:         : [...prev.allowedTools, tool]
246:     }));
247:   };
248: 
249:   const applyExample = (example: typeof EXAMPLE_COMMANDS[0]) => {
250:     setCommandForm(prev => ({
251:       ...prev,
252:       name: example.name,
253:       description: example.description,
254:       content: example.content,
255:       allowedTools: example.allowedTools
256:     }));
257:   };
258: 
259:   // Filter commands
260:   const filteredCommands = commands.filter(cmd => {
261:     // Hide default commands
262:     if (cmd.scope === 'default') {
263:       return false;
264:     }
265: 
266:     // Apply scopeFilter if set to specific scope
267:     if (scopeFilter !== 'all' && cmd.scope !== scopeFilter) {
268:       return false;
269:     }
270: 
271:     // Scope filter
272:     if (selectedScope !== 'all' && cmd.scope !== selectedScope) {
273:       return false;
274:     }
275: 
276:     // Search filter
277:     if (searchQuery) {
278:       const query = searchQuery.toLowerCase();
279:       return (
280:         cmd.name.toLowerCase().includes(query) ||
281:         cmd.full_command.toLowerCase().includes(query) ||
282:         (cmd.description && cmd.description.toLowerCase().includes(query)) ||
283:         (cmd.namespace && cmd.namespace.toLowerCase().includes(query))
284:       );
285:     }
286: 
287:     return true;
288:   });
289: 
290:   // Group commands by namespace and scope
291:   const groupedCommands = filteredCommands.reduce((acc, cmd) => {
292:     const key = cmd.namespace 
293:       ? `${cmd.namespace} (${cmd.scope})` 
294:       : `${cmd.scope === 'project' ? 'Project' : 'User'} Commands`;
295:     if (!acc[key]) {
296:       acc[key] = [];
297:     }
298:     acc[key].push(cmd);
299:     return acc;
300:   }, {} as Record<string, SlashCommand[]>);
301: 
302:   return (
303:     <div className={cn("space-y-4", className)}>
304:       {/* Header */}
305:       <div className="flex items-center justify-between">
306:         <div>
307:           <h3 className="text-lg font-semibold">
308:             {scopeFilter === 'project' ? 'Project Slash Commands' : 'Slash Commands'}
309:           </h3>
310:           <p className="text-sm text-muted-foreground mt-1">
311:             {scopeFilter === 'project' 
312:               ? 'Create custom commands for this project' 
313:               : 'Create custom commands to streamline your workflow'}
314:           </p>
315:         </div>
316:         <Button onClick={handleCreateNew} size="sm" className="gap-2">
317:           <Plus className="h-4 w-4" />
318:           New Command
319:         </Button>
320:       </div>
321: 
322:       {/* Filters */}
323:       <div className="flex items-center gap-4">
324:         <div className="flex-1">
325:           <div className="relative">
326:             <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
327:             <Input
328:               placeholder="Search commands..."
329:               value={searchQuery}
330:               onChange={(e) => setSearchQuery(e.target.value)}
331:               className="pl-9"
332:             />
333:           </div>
334:         </div>
335:         {scopeFilter === 'all' && (
336:           <Select value={selectedScope} onValueChange={(value: any) => setSelectedScope(value)}>
337:             <SelectTrigger className="w-[150px]">
338:               <SelectValue />
339:             </SelectTrigger>
340:             <SelectContent>
341:               <SelectItem value="all">All Commands</SelectItem>
342:               <SelectItem value="project">Project</SelectItem>
343:               <SelectItem value="user">User</SelectItem>
344:             </SelectContent>
345:           </Select>
346:         )}
347:       </div>
348: 
349:       {/* Error Message */}
350:       {error && (
351:         <div className="flex items-center gap-2 p-3 rounded-lg bg-destructive/10 text-destructive">
352:           <AlertCircle className="h-4 w-4" />
353:           <span className="text-sm">{error}</span>
354:         </div>
355:       )}
356: 
357:       {/* Commands List */}
358:       {loading ? (
359:         <div className="flex items-center justify-center py-8">
360:           <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
361:         </div>
362:       ) : filteredCommands.length === 0 ? (
363:         <Card className="p-8">
364:           <div className="text-center">
365:             <Command className="h-12 w-12 mx-auto text-muted-foreground mb-4" />
366:             <p className="text-sm text-muted-foreground">
367:               {searchQuery 
368:                 ? "No commands found" 
369:                 : scopeFilter === 'project' 
370:                   ? "No project commands created yet" 
371:                   : "No commands created yet"}
372:             </p>
373:             {!searchQuery && (
374:               <Button onClick={handleCreateNew} variant="outline" size="sm" className="mt-4">
375:                 {scopeFilter === 'project' 
376:                   ? "Create your first project command" 
377:                   : "Create your first command"}
378:               </Button>
379:             )}
380:           </div>
381:         </Card>
382:       ) : (
383:         <div className="space-y-4">
384:           {Object.entries(groupedCommands).map(([groupKey, groupCommands]) => (
385:             <Card key={groupKey} className="overflow-hidden">
386:               <div className="p-4 bg-muted/50 border-b">
387:                 <h4 className="text-sm font-medium">
388:                   {groupKey}
389:                 </h4>
390:               </div>
391:               
392:               <div className="divide-y">
393:                 {groupCommands.map((command) => {
394:                   const Icon = getCommandIcon(command);
395:                   const isExpanded = expandedCommands.has(command.id);
396:                   
397:                   return (
398:                     <div key={command.id}>
399:                       <div className="p-4">
400:                         <div className="flex items-start gap-4">
401:                           <Icon className="h-5 w-5 mt-0.5 text-muted-foreground flex-shrink-0" />
402:                           
403:                           <div className="flex-1 min-w-0">
404:                             <div className="flex items-center gap-2 mb-1">
405:                               <code className="text-sm font-mono text-primary">
406:                                 {command.full_command}
407:                               </code>
408:                               {command.accepts_arguments && (
409:                                 <Badge variant="secondary" className="text-xs">
410:                                   Arguments
411:                                 </Badge>
412:                               )}
413:                             </div>
414:                             
415:                             {command.description && (
416:                               <p className="text-sm text-muted-foreground mb-2">
417:                                 {command.description}
418:                               </p>
419:                             )}
420:                             
421:                             <div className="flex items-center gap-4 text-xs">
422:                               {command.allowed_tools.length > 0 && (
423:                                 <span className="text-muted-foreground">
424:                                   {command.allowed_tools.length} tool{command.allowed_tools.length === 1 ? '' : 's'}
425:                                 </span>
426:                               )}
427:                               
428:                               {command.has_bash_commands && (
429:                                 <Badge variant="outline" className="text-xs">
430:                                   Bash
431:                                 </Badge>
432:                               )}
433:                               
434:                               {command.has_file_references && (
435:                                 <Badge variant="outline" className="text-xs">
436:                                   Files
437:                                 </Badge>
438:                               )}
439:                               
440:                               <button
441:                                 onClick={() => toggleExpanded(command.id)}
442:                                 className="flex items-center gap-1 text-muted-foreground hover:text-foreground transition-colors"
443:                               >
444:                                 {isExpanded ? (
445:                                   <>
446:                                     <ChevronDown className="h-3 w-3" />
447:                                     Hide content
448:                                   </>
449:                                 ) : (
450:                                   <>
451:                                     <ChevronRight className="h-3 w-3" />
452:                                     Show content
453:                                   </>
454:                                 )}
455:                               </button>
456:                             </div>
457:                           </div>
458:                           
459:                           <div className="flex items-center gap-2">
460:                             <Button
461:                               variant="ghost"
462:                               size="icon"
463:                               onClick={() => handleEdit(command)}
464:                               className="h-8 w-8"
465:                             >
466:                               <Edit className="h-4 w-4" />
467:                             </Button>
468:                             <Button
469:                               variant="ghost"
470:                               size="icon"
471:                               onClick={() => handleDeleteClick(command)}
472:                               className="h-8 w-8 text-destructive hover:text-destructive"
473:                             >
474:                               <Trash2 className="h-4 w-4" />
475:                             </Button>
476:                           </div>
477:                         </div>
478:                         
479:                         <AnimatePresence>
480:                           {isExpanded && (
481:                             <motion.div
482:                               initial={{ height: 0, opacity: 0 }}
483:                               animate={{ height: "auto", opacity: 1 }}
484:                               exit={{ height: 0, opacity: 0 }}
485:                               transition={{ duration: 0.2 }}
486:                               className="overflow-hidden"
487:                             >
488:                               <div className="mt-4 p-3 bg-muted/50 rounded-md">
489:                                 <pre className="text-xs font-mono whitespace-pre-wrap">
490:                                   {command.content}
491:                                 </pre>
492:                               </div>
493:                             </motion.div>
494:                           )}
495:                         </AnimatePresence>
496:                       </div>
497:                     </div>
498:                   );
499:                 })}
500:               </div>
501:             </Card>
502:           ))}
503:         </div>
504:       )}
505: 
506:       {/* Edit Dialog */}
507:       <Dialog open={editDialogOpen} onOpenChange={setEditDialogOpen}>
508:         <DialogContent className="max-w-2xl">
509:           <DialogHeader>
510:             <DialogTitle>
511:               {editingCommand ? "Edit Command" : "Create New Command"}
512:             </DialogTitle>
513:           </DialogHeader>
514: 
515:           <div className="space-y-4 py-4">
516:             {/* Scope */}
517:             <div className="space-y-2">
518:               <Label>Scope</Label>
519:               <Select 
520:                 value={commandForm.scope} 
521:                 onValueChange={(value: 'project' | 'user') => setCommandForm(prev => ({ ...prev, scope: value }))}
522:                 disabled={scopeFilter !== 'all' || (!projectPath && commandForm.scope === 'project')}
523:               >
524:                 <SelectTrigger>
525:                   <SelectValue />
526:                 </SelectTrigger>
527:                 <SelectContent>
528:                   {(scopeFilter === 'all' || scopeFilter === 'user') && (
529:                     <SelectItem value="user">
530:                       <div className="flex items-center gap-2">
531:                         <Globe className="h-4 w-4" />
532:                         User (Global)
533:                       </div>
534:                     </SelectItem>
535:                   )}
536:                   {(scopeFilter === 'all' || scopeFilter === 'project') && (
537:                     <SelectItem value="project" disabled={!projectPath}>
538:                       <div className="flex items-center gap-2">
539:                         <FolderOpen className="h-4 w-4" />
540:                         Project
541:                       </div>
542:                     </SelectItem>
543:                   )}
544:                 </SelectContent>
545:               </Select>
546:               <p className="text-xs text-muted-foreground">
547:                 {commandForm.scope === 'user' 
548:                   ? "Available across all projects" 
549:                   : "Only available in this project"}
550:               </p>
551:             </div>
552: 
553:             {/* Name and Namespace */}
554:             <div className="grid grid-cols-2 gap-4">
555:               <div className="space-y-2">
556:                 <Label>Command Name*</Label>
557:                 <Input
558:                   placeholder="e.g., review, fix-issue"
559:                   value={commandForm.name}
560:                   onChange={(e) => setCommandForm(prev => ({ ...prev, name: e.target.value }))}
561:                 />
562:               </div>
563:               
564:               <div className="space-y-2">
565:                 <Label>Namespace (Optional)</Label>
566:                 <Input
567:                   placeholder="e.g., frontend, backend"
568:                   value={commandForm.namespace}
569:                   onChange={(e) => setCommandForm(prev => ({ ...prev, namespace: e.target.value }))}
570:                 />
571:               </div>
572:             </div>
573: 
574:             {/* Description */}
575:             <div className="space-y-2">
576:               <Label>Description (Optional)</Label>
577:               <Input
578:                 placeholder="Brief description of what this command does"
579:                 value={commandForm.description}
580:                 onChange={(e) => setCommandForm(prev => ({ ...prev, description: e.target.value }))}
581:               />
582:             </div>
583: 
584:             {/* Content */}
585:             <div className="space-y-2">
586:               <Label>Command Content*</Label>
587:               <Textarea
588:                 placeholder="Enter the prompt content. Use $ARGUMENTS for dynamic values."
589:                 value={commandForm.content}
590:                 onChange={(e) => setCommandForm(prev => ({ ...prev, content: e.target.value }))}
591:                 className="min-h-[150px] font-mono text-sm"
592:               />
593:               <p className="text-xs text-muted-foreground">
594:                 Use <code>$ARGUMENTS</code> for user input, <code>@filename</code> for files, 
595:                 and <code>!`command`</code> for bash commands
596:               </p>
597:             </div>
598: 
599:             {/* Allowed Tools */}
600:             <div className="space-y-2">
601:               <Label>Allowed Tools</Label>
602:               <div className="flex flex-wrap gap-2">
603:                 {COMMON_TOOL_MATCHERS.map((tool) => (
604:                   <Button
605:                     key={tool}
606:                     variant={commandForm.allowedTools.includes(tool) ? "default" : "outline"}
607:                     size="sm"
608:                     onClick={() => handleToolToggle(tool)}
609:                     type="button"
610:                   >
611:                     {tool}
612:                   </Button>
613:                 ))}
614:               </div>
615:               <p className="text-xs text-muted-foreground">
616:                 Select which tools Claude can use with this command
617:               </p>
618:             </div>
619: 
620:             {/* Examples */}
621:             {!editingCommand && (
622:               <div className="space-y-2">
623:                 <Label>Examples</Label>
624:                 <div className="grid grid-cols-2 gap-2">
625:                   {EXAMPLE_COMMANDS.map((example) => (
626:                     <Button
627:                       key={example.name}
628:                       variant="outline"
629:                       size="sm"
630:                       onClick={() => applyExample(example)}
631:                       className="justify-start"
632:                     >
633:                       <Code className="h-4 w-4 mr-2" />
634:                       {example.name}
635:                     </Button>
636:                   ))}
637:                 </div>
638:               </div>
639:             )}
640: 
641:             {/* Preview */}
642:             {commandForm.name && (
643:               <div className="space-y-2">
644:                 <Label>Preview</Label>
645:                 <div className="p-3 bg-muted rounded-md">
646:                   <code className="text-sm">
647:                     /
648:                     {commandForm.namespace && `${commandForm.namespace}:`}
649:                     {commandForm.name}
650:                     {commandForm.content.includes('$ARGUMENTS') && ' [arguments]'}
651:                   </code>
652:                 </div>
653:               </div>
654:             )}
655:           </div>
656: 
657:           <DialogFooter>
658:             <Button variant="outline" onClick={() => setEditDialogOpen(false)}>
659:               Cancel
660:             </Button>
661:             <Button
662:               onClick={handleSave}
663:               disabled={!commandForm.name || !commandForm.content || saving}
664:             >
665:               {saving ? (
666:                 <>
667:                   <Loader2 className="h-4 w-4 mr-2 animate-spin" />
668:                   Saving...
669:                 </>
670:               ) : (
671:                 <>
672:                   <Save className="h-4 w-4 mr-2" />
673:                   Save
674:                 </>
675:               )}
676:             </Button>
677:           </DialogFooter>
678:         </DialogContent>
679:       </Dialog>
680: 
681:       {/* Delete Confirmation Dialog */}
682:       <Dialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
683:         <DialogContent className="max-w-md">
684:           <DialogHeader>
685:             <DialogTitle>Delete Command</DialogTitle>
686:           </DialogHeader>
687: 
688:           <div className="space-y-4 py-4">
689:             <p>Are you sure you want to delete this command?</p>
690:             {commandToDelete && (
691:               <div className="p-3 bg-muted rounded-md">
692:                 <code className="text-sm font-mono">{commandToDelete.full_command}</code>
693:                 {commandToDelete.description && (
694:                   <p className="text-sm text-muted-foreground mt-1">{commandToDelete.description}</p>
695:                 )}
696:               </div>
697:             )}
698:             <p className="text-sm text-muted-foreground">
699:               This action cannot be undone. The command file will be permanently deleted.
700:             </p>
701:           </div>
702: 
703:           <DialogFooter>
704:             <Button variant="outline" onClick={cancelDelete} disabled={deleting}>
705:               Cancel
706:             </Button>
707:             <Button
708:               variant="destructive"
709:               onClick={confirmDelete}
710:               disabled={deleting}
711:             >
712:               {deleting ? (
713:                 <>
714:                   <Loader2 className="h-4 w-4 mr-2 animate-spin" />
715:                   Deleting...
716:                 </>
717:               ) : (
718:                 <>
719:                   <Trash2 className="h-4 w-4 mr-2" />
720:                   Delete
721:                 </>
722:               )}
723:             </Button>
724:           </DialogFooter>
725:         </DialogContent>
726:       </Dialog>
727:     </div>
728:   );
729: };
````

## File: src/components/StorageTab.tsx
````typescript
  1: import React, { useState, useEffect, useCallback } from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import {
  4:   Database,
  5:   Search,
  6:   Plus,
  7:   Edit3,
  8:   Trash2,
  9:   RefreshCw,
 10:   ChevronLeft,
 11:   ChevronRight,
 12:   Terminal,
 13:   AlertTriangle,
 14:   Check,
 15:   X,
 16:   Table,
 17:   Loader2,
 18: } from "lucide-react";
 19: import { Button } from "@/components/ui/button";
 20: import { Input } from "@/components/ui/input";
 21: import { Label } from "@/components/ui/label";
 22: import { Card } from "@/components/ui/card";
 23: import {
 24:   Select,
 25:   SelectContent,
 26:   SelectItem,
 27:   SelectTrigger,
 28:   SelectValue,
 29: } from "@/components/ui/select";
 30: import {
 31:   Dialog,
 32:   DialogContent,
 33:   DialogDescription,
 34:   DialogFooter,
 35:   DialogHeader,
 36:   DialogTitle,
 37: } from "@/components/ui/dialog";
 38: import { Textarea } from "@/components/ui/textarea";
 39: import {
 40:   Tooltip,
 41:   TooltipContent,
 42:   TooltipProvider,
 43:   TooltipTrigger,
 44: } from "@/components/ui/tooltip";
 45: import { api } from "@/lib/api";
 46: import { Toast, ToastContainer } from "./ui/toast";
 47: 
 48: interface TableInfo {
 49:   name: string;
 50:   row_count: number;
 51:   columns: ColumnInfo[];
 52: }
 53: 
 54: interface ColumnInfo {
 55:   cid: number;
 56:   name: string;
 57:   type_name: string;
 58:   notnull: boolean;
 59:   dflt_value: string | null;
 60:   pk: boolean;
 61: }
 62: 
 63: interface TableData {
 64:   table_name: string;
 65:   columns: ColumnInfo[];
 66:   rows: Record<string, any>[];
 67:   total_rows: number;
 68:   page: number;
 69:   page_size: number;
 70:   total_pages: number;
 71: }
 72: 
 73: interface QueryResult {
 74:   columns: string[];
 75:   rows: any[][];
 76:   rows_affected?: number;
 77:   last_insert_rowid?: number;
 78: }
 79: 
 80: /**
 81:  * StorageTab component - A beautiful SQLite database viewer/editor
 82:  */
 83: export const StorageTab: React.FC = () => {
 84:   const [tables, setTables] = useState<TableInfo[]>([]);
 85:   const [selectedTable, setSelectedTable] = useState<string>("");
 86:   const [tableData, setTableData] = useState<TableData | null>(null);
 87:   const [currentPage, setCurrentPage] = useState(1);
 88:   const [pageSize] = useState(25);
 89:   const [searchQuery, setSearchQuery] = useState("");
 90:   const [loading, setLoading] = useState(false);
 91:   const [error, setError] = useState<string | null>(null);
 92: 
 93:   // Dialog states
 94:   const [editingRow, setEditingRow] = useState<Record<string, any> | null>(null);
 95:   const [newRow, setNewRow] = useState<Record<string, any> | null>(null);
 96:   const [deletingRow, setDeletingRow] = useState<Record<string, any> | null>(null);
 97:   const [showResetConfirm, setShowResetConfirm] = useState(false);
 98:   const [showSqlEditor, setShowSqlEditor] = useState(false);
 99:   const [sqlQuery, setSqlQuery] = useState("");
100:   const [sqlResult, setSqlResult] = useState<QueryResult | null>(null);
101:   const [sqlError, setSqlError] = useState<string | null>(null);
102:   const [toast, setToast] = useState<{ message: string; type: "success" | "error" } | null>(null);
103: 
104:   /**
105:    * Load all tables on mount
106:    */
107:   useEffect(() => {
108:     loadTables();
109:   }, []);
110: 
111:   /**
112:    * Load table data when selected table changes
113:    */
114:   useEffect(() => {
115:     if (selectedTable) {
116:       loadTableData(1);
117:     }
118:   }, [selectedTable]);
119: 
120:   /**
121:    * Load all tables from the database
122:    */
123:   const loadTables = async () => {
124:     try {
125:       setLoading(true);
126:       setError(null);
127:       const result = await api.storageListTables();
128:       setTables(result);
129:       if (result.length > 0 && !selectedTable) {
130:         setSelectedTable(result[0].name);
131:       }
132:     } catch (err) {
133:       console.error("Failed to load tables:", err);
134:       setError("Failed to load tables");
135:     } finally {
136:       setLoading(false);
137:     }
138:   };
139: 
140:   /**
141:    * Load data for the selected table
142:    */
143:   const loadTableData = async (page: number, search?: string) => {
144:     if (!selectedTable) return;
145: 
146:     try {
147:       setLoading(true);
148:       setError(null);
149:       const result = await api.storageReadTable(
150:         selectedTable,
151:         page,
152:         pageSize,
153:         search || searchQuery || undefined
154:       );
155:       setTableData(result);
156:       setCurrentPage(page);
157:     } catch (err) {
158:       console.error("Failed to load table data:", err);
159:       setError("Failed to load table data");
160:     } finally {
161:       setLoading(false);
162:     }
163:   };
164: 
165:   /**
166:    * Handle search
167:    */
168:   const handleSearch = useCallback(
169:     (value: string) => {
170:       setSearchQuery(value);
171:       loadTableData(1, value);
172:     },
173:     [selectedTable]
174:   );
175: 
176:   /**
177:    * Get primary key values for a row
178:    */
179:   const getPrimaryKeyValues = (row: Record<string, any>): Record<string, any> => {
180:     if (!tableData) return {};
181:     
182:     const pkColumns = tableData.columns.filter(col => col.pk);
183:     const pkValues: Record<string, any> = {};
184:     
185:     pkColumns.forEach(col => {
186:       pkValues[col.name] = row[col.name];
187:     });
188:     
189:     return pkValues;
190:   };
191: 
192:   /**
193:    * Handle row update
194:    */
195:   const handleUpdateRow = async (updates: Record<string, any>) => {
196:     if (!editingRow || !selectedTable) return;
197: 
198:     try {
199:       setLoading(true);
200:       const pkValues = getPrimaryKeyValues(editingRow);
201:       await api.storageUpdateRow(selectedTable, pkValues, updates);
202:       await loadTableData(currentPage);
203:       setEditingRow(null);
204:     } catch (err) {
205:       console.error("Failed to update row:", err);
206:       setError("Failed to update row");
207:     } finally {
208:       setLoading(false);
209:     }
210:   };
211: 
212:   /**
213:    * Handle row deletion
214:    */
215:   const handleDeleteRow = async () => {
216:     if (!deletingRow || !selectedTable) return;
217: 
218:     try {
219:       setLoading(true);
220:       const pkValues = getPrimaryKeyValues(deletingRow);
221:       await api.storageDeleteRow(selectedTable, pkValues);
222:       await loadTableData(currentPage);
223:       setDeletingRow(null);
224:     } catch (err) {
225:       console.error("Failed to delete row:", err);
226:       setError("Failed to delete row");
227:     } finally {
228:       setLoading(false);
229:     }
230:   };
231: 
232:   /**
233:    * Handle new row insertion
234:    */
235:   const handleInsertRow = async (values: Record<string, any>) => {
236:     if (!selectedTable) return;
237: 
238:     try {
239:       setLoading(true);
240:       await api.storageInsertRow(selectedTable, values);
241:       await loadTableData(currentPage);
242:       setNewRow(null);
243:     } catch (err) {
244:       console.error("Failed to insert row:", err);
245:       setError("Failed to insert row");
246:     } finally {
247:       setLoading(false);
248:     }
249:   };
250: 
251:   /**
252:    * Handle SQL query execution
253:    */
254:   const handleExecuteSql = async () => {
255:     try {
256:       setLoading(true);
257:       setSqlError(null);
258:       const result = await api.storageExecuteSql(sqlQuery);
259:       setSqlResult(result);
260:       
261:       // Refresh tables and data if it was a non-SELECT query
262:       if (result.rows_affected !== undefined) {
263:         await loadTables();
264:         if (selectedTable) {
265:           await loadTableData(currentPage);
266:         }
267:       }
268:     } catch (err) {
269:       console.error("Failed to execute SQL:", err);
270:       setSqlError(err instanceof Error ? err.message : "Failed to execute SQL");
271:     } finally {
272:       setLoading(false);
273:     }
274:   };
275: 
276:   /**
277:    * Handle database reset
278:    */
279:   const handleResetDatabase = async () => {
280:     try {
281:       setLoading(true);
282:       await api.storageResetDatabase();
283:       await loadTables();
284:       setSelectedTable("");
285:       setTableData(null);
286:       setShowResetConfirm(false);
287:       setToast({
288:         message: "Database Reset Complete: The database has been restored to its default state with empty tables (agents, agent_runs, app_settings).",
289:         type: "success",
290:       });
291:     } catch (err) {
292:       console.error("Failed to reset database:", err);
293:       setError("Failed to reset database");
294:       setToast({
295:         message: "Reset Failed: Failed to reset the database. Please try again.",
296:         type: "error",
297:       });
298:     } finally {
299:       setLoading(false);
300:     }
301:   };
302: 
303:   /**
304:    * Format cell value for display
305:    */
306:   const formatCellValue = (value: any, maxLength: number = 100): string => {
307:     if (value === null) return "NULL";
308:     if (value === undefined) return "";
309:     if (typeof value === "boolean") return value ? "true" : "false";
310:     if (typeof value === "object") return JSON.stringify(value);
311:     
312:     const stringValue = String(value);
313:     if (stringValue.length > maxLength) {
314:       return stringValue.substring(0, maxLength) + "...";
315:     }
316:     return stringValue;
317:   };
318: 
319:   /**
320:    * Get input type for column
321:    */
322:   const getInputType = (column: ColumnInfo): string => {
323:     const type = column.type_name.toUpperCase();
324:     if (type.includes("INT")) return "number";
325:     if (type.includes("REAL") || type.includes("FLOAT") || type.includes("DOUBLE")) return "number";
326:     if (type.includes("BOOL")) return "checkbox";
327:     return "text";
328:   };
329: 
330:   return (
331:     <div className="space-y-6">
332:       {/* Header */}
333:       <Card className="p-6">
334:         <div className="space-y-4">
335:           <div className="flex items-center justify-between">
336:             <div className="flex items-center gap-3">
337:               <Database className="h-4 w-4 text-primary" />
338:               <h3 className="text-sm font-semibold">Database Storage</h3>
339:             </div>
340:             <div className="flex items-center gap-2">
341:               <Button
342:                 variant="outline"
343:                 size="sm"
344:                 onClick={() => setShowSqlEditor(true)}
345:                 className="gap-2 h-8 text-xs"
346:               >
347:                 <Terminal className="h-3 w-3" />
348:                 SQL Query
349:               </Button>
350:               <Button
351:                 variant="destructive"
352:                 size="sm"
353:                 onClick={() => setShowResetConfirm(true)}
354:                 className="gap-2 h-8 text-xs"
355:               >
356:                 <RefreshCw className="h-3 w-3" />
357:                 Reset DB
358:               </Button>
359:             </div>
360:           </div>
361: 
362:           {/* Table Selector and Search */}
363:           <div className="flex items-center gap-3">
364:             <Select value={selectedTable} onValueChange={setSelectedTable}>
365:               <SelectTrigger className="w-[200px] h-8 text-xs">
366:                 <SelectValue placeholder="Select a table">
367:                   {selectedTable && (
368:                     <div className="flex items-center gap-2">
369:                       <Table className="h-3 w-3" />
370:                       {selectedTable}
371:                     </div>
372:                   )}
373:                 </SelectValue>
374:               </SelectTrigger>
375:               <SelectContent>
376:                 {tables.map((table) => (
377:                   <SelectItem key={table.name} value={table.name} className="text-xs">
378:                     <div className="flex items-center justify-between w-full">
379:                       <span>{table.name}</span>
380:                       <span className="text-[10px] text-muted-foreground ml-2">
381:                         {table.row_count} rows
382:                       </span>
383:                     </div>
384:                   </SelectItem>
385:                 ))}
386:               </SelectContent>
387:             </Select>
388: 
389:             <div className="flex-1 relative">
390:               <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-3 w-3 text-muted-foreground" />
391:               <Input
392:                 placeholder="Search in table..."
393:                 value={searchQuery}
394:                 onChange={(e) => handleSearch(e.target.value)}
395:                 className="pl-8 h-8 text-xs"
396:               />
397:             </div>
398: 
399:             {tableData && (
400:               <Button
401:                 variant="outline"
402:                 size="sm"
403:                 onClick={() => setNewRow({})}
404:                 className="gap-2 h-8 text-xs"
405:               >
406:                 <Plus className="h-3 w-3" />
407:                 New Row
408:               </Button>
409:             )}
410:           </div>
411:         </div>
412:       </Card>
413: 
414:       {/* Table Data */}
415:       {tableData && (
416:         <Card className="overflow-hidden">
417:           <div className="overflow-x-auto">
418:             <table className="w-full">
419:               <thead>
420:                 <tr className="border-b bg-muted/50">
421:                   {tableData.columns.map((column) => (
422:                     <th
423:                       key={column.name}
424:                       className="px-3 py-2 text-left text-xs font-medium text-muted-foreground"
425:                     >
426:                       <div className="flex items-center gap-1">
427:                         {column.name}
428:                         {column.pk && (
429:                           <span className="text-[10px] text-primary">PK</span>
430:                         )}
431:                       </div>
432:                       <div className="text-[10px] font-normal">
433:                         {column.type_name}
434:                       </div>
435:                     </th>
436:                   ))}
437:                   <th className="px-3 py-2 text-right text-xs font-medium text-muted-foreground">
438:                     Actions
439:                   </th>
440:                 </tr>
441:               </thead>
442:               <tbody>
443:                 <AnimatePresence>
444:                   {tableData.rows.map((row, index) => (
445:                     <motion.tr
446:                       key={index}
447:                       initial={{ opacity: 0 }}
448:                       animate={{ opacity: 1 }}
449:                       exit={{ opacity: 0 }}
450:                       className="border-b hover:bg-muted/25 transition-colors"
451:                     >
452:                       {tableData.columns.map((column) => {
453:                         const value = row[column.name];
454:                         const formattedValue = formatCellValue(value, 50);
455:                         const fullValue = value === null ? "NULL" : 
456:                                         value === undefined ? "" : 
457:                                         typeof value === "object" ? JSON.stringify(value, null, 2) : 
458:                                         String(value);
459:                         const isTruncated = fullValue.length > 50;
460:                         
461:                         return (
462:                           <td
463:                             key={column.name}
464:                             className="px-3 py-2 text-xs font-mono"
465:                           >
466:                             {isTruncated ? (
467:                               <TooltipProvider>
468:                                 <Tooltip>
469:                                   <TooltipTrigger asChild>
470:                                     <span className="cursor-help block truncate max-w-[200px]">
471:                                       {formattedValue}
472:                                     </span>
473:                                   </TooltipTrigger>
474:                                   <TooltipContent 
475:                                     side="bottom" 
476:                                     className="max-w-[500px] max-h-[300px] overflow-auto"
477:                                   >
478:                                     <pre className="text-xs whitespace-pre-wrap">{fullValue}</pre>
479:                                   </TooltipContent>
480:                                 </Tooltip>
481:                               </TooltipProvider>
482:                             ) : (
483:                               <span className="block truncate max-w-[200px]">
484:                                 {formattedValue}
485:                               </span>
486:                             )}
487:                           </td>
488:                         );
489:                       })}
490:                       <td className="px-3 py-2 text-right">
491:                         <div className="flex items-center justify-end gap-1">
492:                           <Button
493:                             variant="ghost"
494:                             size="icon"
495:                             onClick={() => setEditingRow(row)}
496:                             className="h-6 w-6"
497:                           >
498:                             <Edit3 className="h-3 w-3" />
499:                           </Button>
500:                           <Button
501:                             variant="ghost"
502:                             size="icon"
503:                             onClick={() => setDeletingRow(row)}
504:                             className="h-6 w-6 hover:text-destructive"
505:                           >
506:                             <Trash2 className="h-3 w-3" />
507:                           </Button>
508:                         </div>
509:                       </td>
510:                     </motion.tr>
511:                   ))}
512:                 </AnimatePresence>
513:               </tbody>
514:             </table>
515:           </div>
516: 
517:           {/* Pagination */}
518:           {tableData.total_pages > 1 && (
519:             <div className="flex items-center justify-between p-3 border-t">
520:               <div className="text-xs text-muted-foreground">
521:                 Showing {(currentPage - 1) * pageSize + 1} to{" "}
522:                 {Math.min(currentPage * pageSize, tableData.total_rows)} of{" "}
523:                 {tableData.total_rows} rows
524:               </div>
525:               <div className="flex items-center gap-2">
526:                 <Button
527:                   variant="outline"
528:                   size="sm"
529:                   onClick={() => loadTableData(currentPage - 1)}
530:                   disabled={currentPage === 1}
531:                   className="h-7 text-xs"
532:                 >
533:                   <ChevronLeft className="h-3 w-3" />
534:                   Previous
535:                 </Button>
536:                 <div className="text-xs">
537:                   Page {currentPage} of {tableData.total_pages}
538:                 </div>
539:                 <Button
540:                   variant="outline"
541:                   size="sm"
542:                   onClick={() => loadTableData(currentPage + 1)}
543:                   disabled={currentPage === tableData.total_pages}
544:                   className="h-7 text-xs"
545:                 >
546:                   Next
547:                   <ChevronRight className="h-3 w-3" />
548:                 </Button>
549:               </div>
550:             </div>
551:           )}
552:         </Card>
553:       )}
554: 
555:       {/* Loading State */}
556:       {loading && (
557:         <div className="flex items-center justify-center py-12">
558:           <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
559:         </div>
560:       )}
561: 
562:       {/* Error State */}
563:       {error && (
564:         <Card className="p-6 border-destructive/50 bg-destructive/10">
565:           <div className="flex items-center gap-3 text-destructive">
566:             <AlertTriangle className="h-5 w-5" />
567:             <span className="font-medium">{error}</span>
568:           </div>
569:         </Card>
570:       )}
571: 
572:       {/* Edit Row Dialog */}
573:       <Dialog open={!!editingRow} onOpenChange={() => setEditingRow(null)}>
574:         <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto">
575:           <DialogHeader>
576:             <DialogTitle>Edit Row</DialogTitle>
577:             <DialogDescription>
578:               Update the values for this row in the {selectedTable} table.
579:             </DialogDescription>
580:           </DialogHeader>
581:           {editingRow && tableData && (
582:             <div className="space-y-4">
583:               {tableData.columns.map((column) => (
584:                 <div key={column.name} className="space-y-2">
585:                   <Label htmlFor={`edit-${column.name}`}>
586:                     {column.name}
587:                     {column.pk && (
588:                       <span className="text-xs text-muted-foreground ml-2">
589:                         (Primary Key)
590:                       </span>
591:                     )}
592:                   </Label>
593:                   {getInputType(column) === "checkbox" ? (
594:                     <input
595:                       type="checkbox"
596:                       id={`edit-${column.name}`}
597:                       checked={!!editingRow[column.name]}
598:                       onChange={(e) =>
599:                         setEditingRow({
600:                           ...editingRow,
601:                           [column.name]: e.target.checked,
602:                         })
603:                       }
604:                       disabled={column.pk}
605:                       className="h-4 w-4"
606:                     />
607:                   ) : (
608:                     <Input
609:                       id={`edit-${column.name}`}
610:                       type={getInputType(column)}
611:                       value={editingRow[column.name] ?? ""}
612:                       onChange={(e) =>
613:                         setEditingRow({
614:                           ...editingRow,
615:                           [column.name]: e.target.value,
616:                         })
617:                       }
618:                       disabled={column.pk}
619:                       placeholder={column.dflt_value || "NULL"}
620:                     />
621:                   )}
622:                   <p className="text-xs text-muted-foreground">
623:                     Type: {column.type_name}
624:                     {column.notnull && ", NOT NULL"}
625:                     {column.dflt_value && `, Default: ${column.dflt_value}`}
626:                   </p>
627:                 </div>
628:               ))}
629:             </div>
630:           )}
631:           <DialogFooter>
632:             <Button variant="outline" onClick={() => setEditingRow(null)}>
633:               Cancel
634:             </Button>
635:             <Button
636:               onClick={() => handleUpdateRow(editingRow!)}
637:               disabled={loading}
638:             >
639:               {loading ? (
640:                 <Loader2 className="h-4 w-4 animate-spin" />
641:               ) : (
642:                 "Update"
643:               )}
644:             </Button>
645:           </DialogFooter>
646:         </DialogContent>
647:       </Dialog>
648: 
649:       {/* New Row Dialog */}
650:       <Dialog open={!!newRow} onOpenChange={() => setNewRow(null)}>
651:         <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto">
652:           <DialogHeader>
653:             <DialogTitle>New Row</DialogTitle>
654:             <DialogDescription>
655:               Add a new row to the {selectedTable} table.
656:             </DialogDescription>
657:           </DialogHeader>
658:           {newRow && tableData && (
659:             <div className="space-y-4">
660:               {tableData.columns.map((column) => (
661:                 <div key={column.name} className="space-y-2">
662:                   <Label htmlFor={`new-${column.name}`}>
663:                     {column.name}
664:                     {column.notnull && (
665:                       <span className="text-xs text-destructive ml-2">
666:                         (Required)
667:                       </span>
668:                     )}
669:                   </Label>
670:                   {getInputType(column) === "checkbox" ? (
671:                     <input
672:                       type="checkbox"
673:                       id={`new-${column.name}`}
674:                       checked={newRow[column.name] || false}
675:                       onChange={(e) =>
676:                         setNewRow({
677:                           ...newRow,
678:                           [column.name]: e.target.checked,
679:                         })
680:                       }
681:                       className="h-4 w-4"
682:                     />
683:                   ) : (
684:                     <Input
685:                       id={`new-${column.name}`}
686:                       type={getInputType(column)}
687:                       value={newRow[column.name] ?? ""}
688:                       onChange={(e) =>
689:                         setNewRow({
690:                           ...newRow,
691:                           [column.name]: e.target.value,
692:                         })
693:                       }
694:                       placeholder={column.dflt_value || "NULL"}
695:                     />
696:                   )}
697:                   <p className="text-xs text-muted-foreground">
698:                     Type: {column.type_name}
699:                     {column.dflt_value && `, Default: ${column.dflt_value}`}
700:                   </p>
701:                 </div>
702:               ))}
703:             </div>
704:           )}
705:           <DialogFooter>
706:             <Button variant="outline" onClick={() => setNewRow(null)}>
707:               Cancel
708:             </Button>
709:             <Button
710:               onClick={() => handleInsertRow(newRow!)}
711:               disabled={loading}
712:             >
713:               {loading ? (
714:                 <Loader2 className="h-4 w-4 animate-spin" />
715:               ) : (
716:                 "Insert"
717:               )}
718:             </Button>
719:           </DialogFooter>
720:         </DialogContent>
721:       </Dialog>
722: 
723:       {/* Delete Confirmation Dialog */}
724:       <Dialog open={!!deletingRow} onOpenChange={() => setDeletingRow(null)}>
725:         <DialogContent>
726:           <DialogHeader>
727:             <DialogTitle>Delete Row</DialogTitle>
728:             <DialogDescription>
729:               Are you sure you want to delete this row? This action cannot be
730:               undone.
731:             </DialogDescription>
732:           </DialogHeader>
733:           {deletingRow && (
734:             <div className="rounded-md bg-muted p-4">
735:               <pre className="text-xs font-mono overflow-x-auto max-h-[200px] overflow-y-auto">
736:                 {JSON.stringify(
737:                   Object.fromEntries(
738:                     Object.entries(deletingRow).map(([key, value]) => [
739:                       key,
740:                       typeof value === "string" && value.length > 100
741:                         ? value.substring(0, 100) + "..."
742:                         : value
743:                     ])
744:                   ),
745:                   null,
746:                   2
747:                 )}
748:               </pre>
749:             </div>
750:           )}
751:           <DialogFooter>
752:             <Button variant="outline" onClick={() => setDeletingRow(null)}>
753:               Cancel
754:             </Button>
755:             <Button
756:               variant="destructive"
757:               onClick={handleDeleteRow}
758:               disabled={loading}
759:             >
760:               {loading ? (
761:                 <Loader2 className="h-4 w-4 animate-spin" />
762:               ) : (
763:                 "Delete"
764:               )}
765:             </Button>
766:           </DialogFooter>
767:         </DialogContent>
768:       </Dialog>
769: 
770:       {/* Reset Database Confirmation */}
771:       <Dialog open={showResetConfirm} onOpenChange={setShowResetConfirm}>
772:         <DialogContent>
773:           <DialogHeader>
774:             <DialogTitle>Reset Database</DialogTitle>
775:             <DialogDescription>
776:               This will delete all data and recreate the database with its default structure 
777:               (empty tables for agents, agent_runs, and app_settings). The database will be 
778:               restored to the same state as when you first installed the app. This action 
779:               cannot be undone.
780:             </DialogDescription>
781:           </DialogHeader>
782:           <div className="flex items-center gap-3 p-4 rounded-md bg-destructive/10 text-destructive">
783:             <AlertTriangle className="h-5 w-5" />
784:             <span className="text-sm font-medium">
785:               All your agents, runs, and settings will be permanently deleted!
786:             </span>
787:           </div>
788:           <DialogFooter>
789:             <Button
790:               variant="outline"
791:               onClick={() => setShowResetConfirm(false)}
792:             >
793:               Cancel
794:             </Button>
795:             <Button
796:               variant="destructive"
797:               onClick={handleResetDatabase}
798:               disabled={loading}
799:             >
800:               {loading ? (
801:                 <Loader2 className="h-4 w-4 animate-spin" />
802:               ) : (
803:                 "Reset Database"
804:               )}
805:             </Button>
806:           </DialogFooter>
807:         </DialogContent>
808:       </Dialog>
809: 
810:       {/* SQL Query Editor */}
811:       <Dialog open={showSqlEditor} onOpenChange={setShowSqlEditor}>
812:         <DialogContent className="max-w-4xl max-h-[80vh]">
813:           <DialogHeader>
814:             <DialogTitle>SQL Query Editor</DialogTitle>
815:             <DialogDescription>
816:               Execute raw SQL queries on the database. Use with caution.
817:             </DialogDescription>
818:           </DialogHeader>
819:           <div className="space-y-4">
820:             <div className="space-y-2">
821:               <Label htmlFor="sql-query">SQL Query</Label>
822:               <Textarea
823:                 id="sql-query"
824:                 value={sqlQuery}
825:                 onChange={(e) => setSqlQuery(e.target.value)}
826:                 placeholder="SELECT * FROM agents LIMIT 10;"
827:                 className="font-mono text-sm h-32"
828:               />
829:             </div>
830: 
831:             {sqlError && (
832:               <div className="p-3 rounded-md bg-destructive/10 text-destructive text-sm">
833:                 <div className="flex items-center gap-2">
834:                   <X className="h-4 w-4" />
835:                   {sqlError}
836:                 </div>
837:               </div>
838:             )}
839: 
840:             {sqlResult && (
841:               <div className="space-y-2">
842:                 {sqlResult.rows_affected !== undefined ? (
843:                   <div className="p-3 rounded-md bg-green-500/10 text-green-600 dark:text-green-400 text-sm">
844:                     <div className="flex items-center gap-2">
845:                       <Check className="h-4 w-4" />
846:                       Query executed successfully. {sqlResult.rows_affected} rows
847:                       affected.
848:                       {sqlResult.last_insert_rowid && (
849:                         <span>
850:                           Last insert ID: {sqlResult.last_insert_rowid}
851:                         </span>
852:                       )}
853:                     </div>
854:                   </div>
855:                 ) : (
856:                   <div className="border rounded-md overflow-hidden">
857:                     <div className="overflow-x-auto max-h-96">
858:                       <table className="w-full text-xs">
859:                         <thead>
860:                           <tr className="border-b bg-muted/50">
861:                             {sqlResult.columns.map((col, i) => (
862:                               <th
863:                                 key={i}
864:                                 className="px-2 py-1 text-left font-medium"
865:                               >
866:                                 {col}
867:                               </th>
868:                             ))}
869:                           </tr>
870:                         </thead>
871:                         <tbody>
872:                           {sqlResult.rows.map((row, i) => (
873:                             <tr key={i} className="border-b">
874:                               {row.map((cell, j) => {
875:                                 const formattedValue = formatCellValue(cell, 50);
876:                                 const fullValue = cell === null ? "NULL" : 
877:                                                 cell === undefined ? "" : 
878:                                                 typeof cell === "object" ? JSON.stringify(cell, null, 2) : 
879:                                                 String(cell);
880:                                 const isTruncated = fullValue.length > 50;
881:                                 
882:                                 return (
883:                                   <td key={j} className="px-2 py-1 font-mono">
884:                                     {isTruncated ? (
885:                                       <TooltipProvider>
886:                                         <Tooltip>
887:                                           <TooltipTrigger asChild>
888:                                             <span className="cursor-help block truncate max-w-[200px]">
889:                                               {formattedValue}
890:                                             </span>
891:                                           </TooltipTrigger>
892:                                           <TooltipContent 
893:                                             side="bottom" 
894:                                             className="max-w-[500px] max-h-[300px] overflow-auto"
895:                                           >
896:                                             <pre className="text-xs whitespace-pre-wrap">{fullValue}</pre>
897:                                           </TooltipContent>
898:                                         </Tooltip>
899:                                       </TooltipProvider>
900:                                     ) : (
901:                                       <span className="block truncate max-w-[200px]">
902:                                         {formattedValue}
903:                                       </span>
904:                                     )}
905:                                   </td>
906:                                 );
907:                               })}
908:                             </tr>
909:                           ))}
910:                         </tbody>
911:                       </table>
912:                     </div>
913:                   </div>
914:                 )}
915:               </div>
916:             )}
917:           </div>
918:           <DialogFooter>
919:             <Button
920:               variant="outline"
921:               onClick={() => {
922:                 setShowSqlEditor(false);
923:                 setSqlQuery("");
924:                 setSqlResult(null);
925:                 setSqlError(null);
926:               }}
927:             >
928:               Close
929:             </Button>
930:             <Button
931:               onClick={handleExecuteSql}
932:               disabled={loading || !sqlQuery.trim()}
933:             >
934:               {loading ? (
935:                 <Loader2 className="h-4 w-4 animate-spin" />
936:               ) : (
937:                 "Execute"
938:               )}
939:             </Button>
940:           </DialogFooter>
941:         </DialogContent>
942:       </Dialog>
943: 
944:       {/* Toast Notification */}
945:       <ToastContainer>
946:         {toast && (
947:           <Toast
948:             message={toast.message}
949:             type={toast.type}
950:             onDismiss={() => setToast(null)}
951:           />
952:         )}
953:       </ToastContainer>
954:     </div>
955:   );
956: };
````

## File: src/components/StreamMessage.tsx
````typescript
  1: import React, { useState, useEffect } from "react";
  2: import { 
  3:   Terminal, 
  4:   User, 
  5:   Bot, 
  6:   AlertCircle, 
  7:   CheckCircle2
  8: } from "lucide-react";
  9: import { Card, CardContent } from "@/components/ui/card";
 10: import { cn } from "@/lib/utils";
 11: import ReactMarkdown from "react-markdown";
 12: import remarkGfm from "remark-gfm";
 13: import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
 14: import { getClaudeSyntaxTheme } from "@/lib/claudeSyntaxTheme";
 15: import { useTheme } from "@/hooks";
 16: import type { ClaudeStreamMessage } from "./AgentExecution";
 17: import {
 18:   TodoWidget,
 19:   TodoReadWidget,
 20:   LSWidget,
 21:   ReadWidget,
 22:   ReadResultWidget,
 23:   GlobWidget,
 24:   BashWidget,
 25:   WriteWidget,
 26:   GrepWidget,
 27:   EditWidget,
 28:   EditResultWidget,
 29:   MCPWidget,
 30:   CommandWidget,
 31:   CommandOutputWidget,
 32:   SummaryWidget,
 33:   MultiEditWidget,
 34:   MultiEditResultWidget,
 35:   SystemReminderWidget,
 36:   SystemInitializedWidget,
 37:   TaskWidget,
 38:   LSResultWidget,
 39:   ThinkingWidget,
 40:   WebSearchWidget,
 41:   WebFetchWidget
 42: } from "./ToolWidgets";
 43: 
 44: interface StreamMessageProps {
 45:   message: ClaudeStreamMessage;
 46:   className?: string;
 47:   streamMessages: ClaudeStreamMessage[];
 48:   onLinkDetected?: (url: string) => void;
 49: }
 50: 
 51: /**
 52:  * Component to render a single Claude Code stream message
 53:  */
 54: const StreamMessageComponent: React.FC<StreamMessageProps> = ({ message, className, streamMessages, onLinkDetected }) => {
 55:   // State to track tool results mapped by tool call ID
 56:   const [toolResults, setToolResults] = useState<Map<string, any>>(new Map());
 57:   
 58:   // Get current theme
 59:   const { theme } = useTheme();
 60:   const syntaxTheme = getClaudeSyntaxTheme(theme);
 61:   
 62:   // Extract all tool results from stream messages
 63:   useEffect(() => {
 64:     const results = new Map<string, any>();
 65:     
 66:     // Iterate through all messages to find tool results
 67:     streamMessages.forEach(msg => {
 68:       if (msg.type === "user" && msg.message?.content && Array.isArray(msg.message.content)) {
 69:         msg.message.content.forEach((content: any) => {
 70:           if (content.type === "tool_result" && content.tool_use_id) {
 71:             results.set(content.tool_use_id, content);
 72:           }
 73:         });
 74:       }
 75:     });
 76:     
 77:     setToolResults(results);
 78:   }, [streamMessages]);
 79:   
 80:   // Helper to get tool result for a specific tool call ID
 81:   const getToolResult = (toolId: string | undefined): any => {
 82:     if (!toolId) return null;
 83:     return toolResults.get(toolId) || null;
 84:   };
 85:   
 86:   try {
 87:     // Skip rendering for meta messages that don't have meaningful content
 88:     if (message.isMeta && !message.leafUuid && !message.summary) {
 89:       return null;
 90:     }
 91: 
 92:     // Handle summary messages
 93:     if (message.leafUuid && message.summary && (message as any).type === "summary") {
 94:       return <SummaryWidget summary={message.summary} leafUuid={message.leafUuid} />;
 95:     }
 96: 
 97:     // System initialization message
 98:     if (message.type === "system" && message.subtype === "init") {
 99:       return (
100:         <SystemInitializedWidget
101:           sessionId={message.session_id}
102:           model={message.model}
103:           cwd={message.cwd}
104:           tools={message.tools}
105:         />
106:       );
107:     }
108: 
109:     // Assistant message
110:     if (message.type === "assistant" && message.message) {
111:       const msg = message.message;
112:       
113:       let renderedSomething = false;
114:       
115:       const renderedCard = (
116:         <Card className={cn("border-primary/20 bg-primary/5", className)}>
117:           <CardContent className="p-4">
118:             <div className="flex items-start gap-3">
119:               <Bot className="h-5 w-5 text-primary mt-0.5" />
120:               <div className="flex-1 space-y-2 min-w-0">
121:                 {msg.content && Array.isArray(msg.content) && msg.content.map((content: any, idx: number) => {
122:                   // Text content - render as markdown
123:                   if (content.type === "text") {
124:                     // Ensure we have a string to render
125:                     const textContent = typeof content.text === 'string' 
126:                       ? content.text 
127:                       : (content.text?.text || JSON.stringify(content.text || content));
128:                     
129:                     renderedSomething = true;
130:                     return (
131:                       <div key={idx} className="prose prose-sm dark:prose-invert max-w-none">
132:                         <ReactMarkdown
133:                           remarkPlugins={[remarkGfm]}
134:                           components={{
135:                             code({ node, inline, className, children, ...props }: any) {
136:                               const match = /language-(\w+)/.exec(className || '');
137:                               return !inline && match ? (
138:                                 <SyntaxHighlighter
139:                                   style={syntaxTheme}
140:                                   language={match[1]}
141:                                   PreTag="div"
142:                                   {...props}
143:                                 >
144:                                   {String(children).replace(/\n$/, '')}
145:                                 </SyntaxHighlighter>
146:                               ) : (
147:                                 <code className={className} {...props}>
148:                                   {children}
149:                                 </code>
150:                               );
151:                             }
152:                           }}
153:                         >
154:                           {textContent}
155:                         </ReactMarkdown>
156:                       </div>
157:                     );
158:                   }
159:                   
160:                   // Thinking content - render with ThinkingWidget
161:                   if (content.type === "thinking") {
162:                     renderedSomething = true;
163:                     return (
164:                       <div key={idx}>
165:                         <ThinkingWidget 
166:                           thinking={content.thinking || ''} 
167:                           signature={content.signature}
168:                         />
169:                       </div>
170:                     );
171:                   }
172:                   
173:                   // Tool use - render custom widgets based on tool name
174:                   if (content.type === "tool_use") {
175:                     const toolName = content.name?.toLowerCase();
176:                     const input = content.input;
177:                     const toolId = content.id;
178:                     
179:                     // Get the tool result if available
180:                     const toolResult = getToolResult(toolId);
181:                     
182:                     // Function to render the appropriate tool widget
183:                     const renderToolWidget = () => {
184:                       // Task tool - for sub-agent tasks
185:                       if (toolName === "task" && input) {
186:                         renderedSomething = true;
187:                         return <TaskWidget description={input.description} prompt={input.prompt} result={toolResult} />;
188:                       }
189:                       
190:                       // Edit tool
191:                       if (toolName === "edit" && input?.file_path) {
192:                         renderedSomething = true;
193:                         return <EditWidget {...input} result={toolResult} />;
194:                       }
195:                       
196:                       // MultiEdit tool
197:                       if (toolName === "multiedit" && input?.file_path && input?.edits) {
198:                         renderedSomething = true;
199:                         return <MultiEditWidget {...input} result={toolResult} />;
200:                       }
201:                       
202:                       // MCP tools (starting with mcp__)
203:                       if (content.name?.startsWith("mcp__")) {
204:                         renderedSomething = true;
205:                         return <MCPWidget toolName={content.name} input={input} result={toolResult} />;
206:                       }
207:                       
208:                       // TodoWrite tool
209:                       if (toolName === "todowrite" && input?.todos) {
210:                         renderedSomething = true;
211:                         return <TodoWidget todos={input.todos} result={toolResult} />;
212:                       }
213:                       
214:                       // TodoRead tool
215:                       if (toolName === "todoread") {
216:                         renderedSomething = true;
217:                         return <TodoReadWidget todos={input?.todos} result={toolResult} />;
218:                       }
219:                       
220:                       // LS tool
221:                       if (toolName === "ls" && input?.path) {
222:                         renderedSomething = true;
223:                         return <LSWidget path={input.path} result={toolResult} />;
224:                       }
225:                       
226:                       // Read tool
227:                       if (toolName === "read" && input?.file_path) {
228:                         renderedSomething = true;
229:                         return <ReadWidget filePath={input.file_path} result={toolResult} />;
230:                       }
231:                       
232:                       // Glob tool
233:                       if (toolName === "glob" && input?.pattern) {
234:                         renderedSomething = true;
235:                         return <GlobWidget pattern={input.pattern} result={toolResult} />;
236:                       }
237:                       
238:                       // Bash tool
239:                       if (toolName === "bash" && input?.command) {
240:                         renderedSomething = true;
241:                         return <BashWidget command={input.command} description={input.description} result={toolResult} />;
242:                       }
243:                       
244:                       // Write tool
245:                       if (toolName === "write" && input?.file_path && input?.content) {
246:                         renderedSomething = true;
247:                         return <WriteWidget filePath={input.file_path} content={input.content} result={toolResult} />;
248:                       }
249:                       
250:                       // Grep tool
251:                       if (toolName === "grep" && input?.pattern) {
252:                         renderedSomething = true;
253:                         return <GrepWidget pattern={input.pattern} include={input.include} path={input.path} exclude={input.exclude} result={toolResult} />;
254:                       }
255:                       
256:                       // WebSearch tool
257:                       if (toolName === "websearch" && input?.query) {
258:                         renderedSomething = true;
259:                         return <WebSearchWidget query={input.query} result={toolResult} />;
260:                       }
261:                       
262:                       // WebFetch tool
263:                       if (toolName === "webfetch" && input?.url) {
264:                         renderedSomething = true;
265:                         return <WebFetchWidget url={input.url} prompt={input.prompt} result={toolResult} />;
266:                       }
267:                       
268:                       // Default - return null
269:                       return null;
270:                     };
271:                     
272:                     // Render the tool widget
273:                     const widget = renderToolWidget();
274:                     if (widget) {
275:                       renderedSomething = true;
276:                       return <div key={idx}>{widget}</div>;
277:                     }
278:                     
279:                     // Fallback to basic tool display
280:                     renderedSomething = true;
281:                     return (
282:                       <div key={idx} className="space-y-2">
283:                         <div className="flex items-center gap-2">
284:                           <Terminal className="h-4 w-4 text-muted-foreground" />
285:                           <span className="text-sm font-medium">
286:                             Using tool: <code className="font-mono">{content.name}</code>
287:                           </span>
288:                         </div>
289:                         {content.input && (
290:                           <div className="ml-6 p-2 bg-background rounded-md border">
291:                             <pre className="text-xs font-mono overflow-x-auto">
292:                               {JSON.stringify(content.input, null, 2)}
293:                             </pre>
294:                           </div>
295:                         )}
296:                       </div>
297:                     );
298:                   }
299:                   
300:                   return null;
301:                 })}
302:                 
303:                 {msg.usage && (
304:                   <div className="text-xs text-muted-foreground mt-2">
305:                     Tokens: {msg.usage.input_tokens} in, {msg.usage.output_tokens} out
306:                   </div>
307:                 )}
308:               </div>
309:             </div>
310:           </CardContent>
311:         </Card>
312:       );
313:       
314:       if (!renderedSomething) return null;
315:       return renderedCard;
316:     }
317: 
318:     // User message - handle both nested and direct content structures
319:     if (message.type === "user") {
320:       // Don't render meta messages, which are for system use
321:       if (message.isMeta) return null;
322: 
323:       // Handle different message structures
324:       const msg = message.message || message;
325:       
326:       let renderedSomething = false;
327:       
328:       const renderedCard = (
329:         <Card className={cn("border-muted-foreground/20 bg-muted/20", className)}>
330:           <CardContent className="p-4">
331:             <div className="flex items-start gap-3">
332:               <User className="h-5 w-5 text-muted-foreground mt-0.5" />
333:               <div className="flex-1 space-y-2 min-w-0">
334:                 {/* Handle content that is a simple string (e.g. from user commands) */}
335:                 {(typeof msg.content === 'string' || (msg.content && !Array.isArray(msg.content))) && (
336:                   (() => {
337:                     const contentStr = typeof msg.content === 'string' ? msg.content : String(msg.content);
338:                     if (contentStr.trim() === '') return null;
339:                     renderedSomething = true;
340:                     
341:                     // Check if it's a command message
342:                     const commandMatch = contentStr.match(/<command-name>(.+?)<\/command-name>[\s\S]*?<command-message>(.+?)<\/command-message>[\s\S]*?<command-args>(.*?)<\/command-args>/);
343:                     if (commandMatch) {
344:                       const [, commandName, commandMessage, commandArgs] = commandMatch;
345:                       return (
346:                         <CommandWidget 
347:                           commandName={commandName.trim()} 
348:                           commandMessage={commandMessage.trim()}
349:                           commandArgs={commandArgs?.trim()}
350:                         />
351:                       );
352:                     }
353:                     
354:                     // Check if it's command output
355:                     const stdoutMatch = contentStr.match(/<local-command-stdout>([\s\S]*?)<\/local-command-stdout>/);
356:                     if (stdoutMatch) {
357:                       const [, output] = stdoutMatch;
358:                       return <CommandOutputWidget output={output} onLinkDetected={onLinkDetected} />;
359:                     }
360:                     
361:                     // Otherwise render as plain text
362:                     return (
363:                       <div className="text-sm">
364:                         {contentStr}
365:                       </div>
366:                     );
367:                   })()
368:                 )}
369: 
370:                 {/* Handle content that is an array of parts */}
371:                 {Array.isArray(msg.content) && msg.content.map((content: any, idx: number) => {
372:                   // Tool result
373:                   if (content.type === "tool_result") {
374:                     // Skip duplicate tool_result if a dedicated widget is present
375:                     let hasCorrespondingWidget = false;
376:                     if (content.tool_use_id && streamMessages) {
377:                       for (let i = streamMessages.length - 1; i >= 0; i--) {
378:                         const prevMsg = streamMessages[i];
379:                         if (prevMsg.type === 'assistant' && prevMsg.message?.content && Array.isArray(prevMsg.message.content)) {
380:                           const toolUse = prevMsg.message.content.find((c: any) => c.type === 'tool_use' && c.id === content.tool_use_id);
381:                           if (toolUse) {
382:                             const toolName = toolUse.name?.toLowerCase();
383:                             const toolsWithWidgets = ['task','edit','multiedit','todowrite','todoread','ls','read','glob','bash','write','grep','websearch','webfetch'];
384:                             if (toolsWithWidgets.includes(toolName) || toolUse.name?.startsWith('mcp__')) {
385:                               hasCorrespondingWidget = true;
386:                             }
387:                             break;
388:                           }
389:                         }
390:                       }
391:                     }
392: 
393:                     if (hasCorrespondingWidget) {
394:                       return null;
395:                     }
396:                     // Extract the actual content string
397:                     let contentText = '';
398:                     if (typeof content.content === 'string') {
399:                       contentText = content.content;
400:                     } else if (content.content && typeof content.content === 'object') {
401:                       // Handle object with text property
402:                       if (content.content.text) {
403:                         contentText = content.content.text;
404:                       } else if (Array.isArray(content.content)) {
405:                         // Handle array of content blocks
406:                         contentText = content.content
407:                           .map((c: any) => (typeof c === 'string' ? c : c.text || JSON.stringify(c)))
408:                           .join('\n');
409:                       } else {
410:                         // Fallback to JSON stringify
411:                         contentText = JSON.stringify(content.content, null, 2);
412:                       }
413:                     }
414:                     
415:                     // Always show system reminders regardless of widget status
416:                     const reminderMatch = contentText.match(/<system-reminder>(.*?)<\/system-reminder>/s);
417:                     if (reminderMatch) {
418:                       const reminderMessage = reminderMatch[1].trim();
419:                       const beforeReminder = contentText.substring(0, reminderMatch.index || 0).trim();
420:                       const afterReminder = contentText.substring((reminderMatch.index || 0) + reminderMatch[0].length).trim();
421:                       
422:                       renderedSomething = true;
423:                       return (
424:                         <div key={idx} className="space-y-2">
425:                           <div className="flex items-center gap-2">
426:                             <CheckCircle2 className="h-4 w-4 text-green-500" />
427:                             <span className="text-sm font-medium">Tool Result</span>
428:                           </div>
429:                           
430:                           {beforeReminder && (
431:                             <div className="ml-6 p-2 bg-background rounded-md border">
432:                               <pre className="text-xs font-mono overflow-x-auto whitespace-pre-wrap">
433:                                 {beforeReminder}
434:                               </pre>
435:                             </div>
436:                           )}
437:                           
438:                           <div className="ml-6">
439:                             <SystemReminderWidget message={reminderMessage} />
440:                           </div>
441:                           
442:                           {afterReminder && (
443:                             <div className="ml-6 p-2 bg-background rounded-md border">
444:                               <pre className="text-xs font-mono overflow-x-auto whitespace-pre-wrap">
445:                                 {afterReminder}
446:                               </pre>
447:                             </div>
448:                           )}
449:                         </div>
450:                       );
451:                     }
452:                     
453:                     // Check if this is an Edit tool result
454:                     const isEditResult = contentText.includes("has been updated. Here's the result of running `cat -n`");
455:                     
456:                     if (isEditResult) {
457:                       renderedSomething = true;
458:                       return (
459:                         <div key={idx} className="space-y-2">
460:                           <div className="flex items-center gap-2">
461:                             <CheckCircle2 className="h-4 w-4 text-green-500" />
462:                             <span className="text-sm font-medium">Edit Result</span>
463:                           </div>
464:                           <EditResultWidget content={contentText} />
465:                         </div>
466:                       );
467:                     }
468:                     
469:                     // Check if this is a MultiEdit tool result
470:                     const isMultiEditResult = contentText.includes("has been updated with multiple edits") || 
471:                                              contentText.includes("MultiEdit completed successfully") ||
472:                                              contentText.includes("Applied multiple edits to");
473:                     
474:                     if (isMultiEditResult) {
475:                       renderedSomething = true;
476:                       return (
477:                         <div key={idx} className="space-y-2">
478:                           <div className="flex items-center gap-2">
479:                             <CheckCircle2 className="h-4 w-4 text-green-500" />
480:                             <span className="text-sm font-medium">MultiEdit Result</span>
481:                           </div>
482:                           <MultiEditResultWidget content={contentText} />
483:                         </div>
484:                       );
485:                     }
486:                     
487:                     // Check if this is an LS tool result (directory tree structure)
488:                     const isLSResult = (() => {
489:                       if (!content.tool_use_id || typeof contentText !== 'string') return false;
490:                       
491:                       // Check if this result came from an LS tool by looking for the tool call
492:                       let isFromLSTool = false;
493:                       
494:                       // Search in previous assistant messages for the matching tool_use
495:                       if (streamMessages) {
496:                         for (let i = streamMessages.length - 1; i >= 0; i--) {
497:                           const prevMsg = streamMessages[i];
498:                           // Only check assistant messages
499:                           if (prevMsg.type === 'assistant' && prevMsg.message?.content && Array.isArray(prevMsg.message.content)) {
500:                             const toolUse = prevMsg.message.content.find((c: any) => 
501:                               c.type === 'tool_use' && 
502:                               c.id === content.tool_use_id &&
503:                               c.name?.toLowerCase() === 'ls'
504:                             );
505:                             if (toolUse) {
506:                               isFromLSTool = true;
507:                               break;
508:                             }
509:                           }
510:                         }
511:                       }
512:                       
513:                       // Only proceed if this is from an LS tool
514:                       if (!isFromLSTool) return false;
515:                       
516:                       // Additional validation: check for tree structure pattern
517:                       const lines = contentText.split('\n');
518:                       const hasTreeStructure = lines.some(line => /^\s*-\s+/.test(line));
519:                       const hasNoteAtEnd = lines.some(line => line.trim().startsWith('NOTE: do any of the files'));
520:                       
521:                       return hasTreeStructure || hasNoteAtEnd;
522:                     })();
523:                     
524:                     if (isLSResult) {
525:                       renderedSomething = true;
526:                       return (
527:                         <div key={idx} className="space-y-2">
528:                           <div className="flex items-center gap-2">
529:                             <CheckCircle2 className="h-4 w-4 text-green-500" />
530:                             <span className="text-sm font-medium">Directory Contents</span>
531:                           </div>
532:                           <LSResultWidget content={contentText} />
533:                         </div>
534:                       );
535:                     }
536:                     
537:                     // Check if this is a Read tool result (contains line numbers with arrow separator)
538:                     const isReadResult = content.tool_use_id && typeof contentText === 'string' && 
539:                       /^\s*\d+→/.test(contentText);
540:                     
541:                     if (isReadResult) {
542:                       // Try to find the corresponding Read tool call to get the file path
543:                       let filePath: string | undefined;
544:                       
545:                       // Search in previous assistant messages for the matching tool_use
546:                       if (streamMessages) {
547:                         for (let i = streamMessages.length - 1; i >= 0; i--) {
548:                           const prevMsg = streamMessages[i];
549:                           // Only check assistant messages
550:                           if (prevMsg.type === 'assistant' && prevMsg.message?.content && Array.isArray(prevMsg.message.content)) {
551:                             const toolUse = prevMsg.message.content.find((c: any) => 
552:                               c.type === 'tool_use' && 
553:                               c.id === content.tool_use_id &&
554:                               c.name?.toLowerCase() === 'read'
555:                             );
556:                             if (toolUse?.input?.file_path) {
557:                               filePath = toolUse.input.file_path;
558:                               break;
559:                             }
560:                           }
561:                         }
562:                       }
563:                       
564:                       renderedSomething = true;
565:                       return (
566:                         <div key={idx} className="space-y-2">
567:                           <div className="flex items-center gap-2">
568:                             <CheckCircle2 className="h-4 w-4 text-green-500" />
569:                             <span className="text-sm font-medium">Read Result</span>
570:                           </div>
571:                           <ReadResultWidget content={contentText} filePath={filePath} />
572:                         </div>
573:                       );
574:                     }
575:                     
576:                     // Handle empty tool results
577:                     if (!contentText || contentText.trim() === '') {
578:                       renderedSomething = true;
579:                       return (
580:                         <div key={idx} className="space-y-2">
581:                           <div className="flex items-center gap-2">
582:                             <CheckCircle2 className="h-4 w-4 text-green-500" />
583:                             <span className="text-sm font-medium">Tool Result</span>
584:                           </div>
585:                           <div className="ml-6 p-3 bg-muted/50 rounded-md border text-sm text-muted-foreground italic">
586:                             Tool did not return any output
587:                           </div>
588:                         </div>
589:                       );
590:                     }
591:                     
592:                     renderedSomething = true;
593:                     return (
594:                       <div key={idx} className="space-y-2">
595:                         <div className="flex items-center gap-2">
596:                           {content.is_error ? (
597:                             <AlertCircle className="h-4 w-4 text-destructive" />
598:                           ) : (
599:                             <CheckCircle2 className="h-4 w-4 text-green-500" />
600:                           )}
601:                           <span className="text-sm font-medium">Tool Result</span>
602:                         </div>
603:                         <div className="ml-6 p-2 bg-background rounded-md border">
604:                           <pre className="text-xs font-mono overflow-x-auto whitespace-pre-wrap">
605:                             {contentText}
606:                           </pre>
607:                         </div>
608:                       </div>
609:                     );
610:                   }
611:                   
612:                   // Text content
613:                   if (content.type === "text") {
614:                     // Handle both string and object formats
615:                     const textContent = typeof content.text === 'string' 
616:                       ? content.text 
617:                       : (content.text?.text || JSON.stringify(content.text));
618:                     
619:                     renderedSomething = true;
620:                     return (
621:                       <div key={idx} className="text-sm">
622:                         {textContent}
623:                       </div>
624:                     );
625:                   }
626:                   
627:                   return null;
628:                 })}
629:               </div>
630:             </div>
631:           </CardContent>
632:         </Card>
633:       );
634:       if (!renderedSomething) return null;
635:       return renderedCard;
636:     }
637: 
638:     // Result message - render with markdown
639:     if (message.type === "result") {
640:       const isError = message.is_error || message.subtype?.includes("error");
641:       
642:       return (
643:         <Card className={cn(
644:           isError ? "border-destructive/20 bg-destructive/5" : "border-green-500/20 bg-green-500/5",
645:           className
646:         )}>
647:           <CardContent className="p-4">
648:             <div className="flex items-start gap-3">
649:               {isError ? (
650:                 <AlertCircle className="h-5 w-5 text-destructive mt-0.5" />
651:               ) : (
652:                 <CheckCircle2 className="h-5 w-5 text-green-500 mt-0.5" />
653:               )}
654:               <div className="flex-1 space-y-2">
655:                 <h4 className="font-semibold text-sm">
656:                   {isError ? "Execution Failed" : "Execution Complete"}
657:                 </h4>
658:                 
659:                 {message.result && (
660:                   <div className="prose prose-sm dark:prose-invert max-w-none">
661:                     <ReactMarkdown
662:                       remarkPlugins={[remarkGfm]}
663:                       components={{
664:                         code({ node, inline, className, children, ...props }: any) {
665:                           const match = /language-(\w+)/.exec(className || '');
666:                           return !inline && match ? (
667:                             <SyntaxHighlighter
668:                               style={syntaxTheme}
669:                               language={match[1]}
670:                               PreTag="div"
671:                               {...props}
672:                             >
673:                               {String(children).replace(/\n$/, '')}
674:                             </SyntaxHighlighter>
675:                           ) : (
676:                             <code className={className} {...props}>
677:                               {children}
678:                             </code>
679:                           );
680:                         }
681:                       }}
682:                     >
683:                       {message.result}
684:                     </ReactMarkdown>
685:                   </div>
686:                 )}
687:                 
688:                 {message.error && (
689:                   <div className="text-sm text-destructive">{message.error}</div>
690:                 )}
691:                 
692:                 <div className="text-xs text-muted-foreground space-y-1 mt-2">
693:                   {(message.cost_usd !== undefined || message.total_cost_usd !== undefined) && (
694:                     <div>Cost: ${((message.cost_usd || message.total_cost_usd)!).toFixed(4)} USD</div>
695:                   )}
696:                   {message.duration_ms !== undefined && (
697:                     <div>Duration: {(message.duration_ms / 1000).toFixed(2)}s</div>
698:                   )}
699:                   {message.num_turns !== undefined && (
700:                     <div>Turns: {message.num_turns}</div>
701:                   )}
702:                   {message.usage && (
703:                     <div>
704:                       Total tokens: {message.usage.input_tokens + message.usage.output_tokens} 
705:                       ({message.usage.input_tokens} in, {message.usage.output_tokens} out)
706:                     </div>
707:                   )}
708:                 </div>
709:               </div>
710:             </div>
711:           </CardContent>
712:         </Card>
713:       );
714:     }
715: 
716:     // Skip rendering if no meaningful content
717:     return null;
718:   } catch (error) {
719:     // If any error occurs during rendering, show a safe error message
720:     console.error("Error rendering stream message:", error, message);
721:     return (
722:       <Card className={cn("border-destructive/20 bg-destructive/5", className)}>
723:         <CardContent className="p-4">
724:           <div className="flex items-start gap-3">
725:             <AlertCircle className="h-5 w-5 text-destructive mt-0.5" />
726:             <div className="flex-1">
727:               <p className="text-sm font-medium">Error rendering message</p>
728:               <p className="text-xs text-muted-foreground mt-1">
729:                 {error instanceof Error ? error.message : 'Unknown error'}
730:               </p>
731:             </div>
732:           </div>
733:         </CardContent>
734:       </Card>
735:     );
736:   }
737: };
738: 
739: export const StreamMessage = React.memo(StreamMessageComponent);
````

## File: src/components/TabContent.tsx
````typescript
  1: import React, { Suspense, lazy, useEffect } from 'react';
  2: import { motion, AnimatePresence } from 'framer-motion';
  3: import { useTabState } from '@/hooks/useTabState';
  4: import { useScreenTracking } from '@/hooks/useAnalytics';
  5: import { Tab } from '@/contexts/TabContext';
  6: import { Loader2, Plus } from 'lucide-react';
  7: import { api, type Project, type Session, type ClaudeMdFile } from '@/lib/api';
  8: import { ProjectList } from '@/components/ProjectList';
  9: import { SessionList } from '@/components/SessionList';
 10: import { RunningClaudeSessions } from '@/components/RunningClaudeSessions';
 11: import { Button } from '@/components/ui/button';
 12: 
 13: // Lazy load heavy components
 14: const ClaudeCodeSession = lazy(() => import('@/components/ClaudeCodeSession').then(m => ({ default: m.ClaudeCodeSession })));
 15: const AgentRunOutputViewer = lazy(() => import('@/components/AgentRunOutputViewer'));
 16: const AgentExecution = lazy(() => import('@/components/AgentExecution').then(m => ({ default: m.AgentExecution })));
 17: const CreateAgent = lazy(() => import('@/components/CreateAgent').then(m => ({ default: m.CreateAgent })));
 18: const UsageDashboard = lazy(() => import('@/components/UsageDashboard').then(m => ({ default: m.UsageDashboard })));
 19: const MCPManager = lazy(() => import('@/components/MCPManager').then(m => ({ default: m.MCPManager })));
 20: const Settings = lazy(() => import('@/components/Settings').then(m => ({ default: m.Settings })));
 21: const MarkdownEditor = lazy(() => import('@/components/MarkdownEditor').then(m => ({ default: m.MarkdownEditor })));
 22: // const ClaudeFileEditor = lazy(() => import('@/components/ClaudeFileEditor').then(m => ({ default: m.ClaudeFileEditor })));
 23: 
 24: // Import non-lazy components for projects view
 25: 
 26: interface TabPanelProps {
 27:   tab: Tab;
 28:   isActive: boolean;
 29: }
 30: 
 31: const TabPanel: React.FC<TabPanelProps> = ({ tab, isActive }) => {
 32:   const { updateTab, createChatTab } = useTabState();
 33:   const [projects, setProjects] = React.useState<Project[]>([]);
 34:   const [selectedProject, setSelectedProject] = React.useState<Project | null>(null);
 35:   const [sessions, setSessions] = React.useState<Session[]>([]);
 36:   const [loading, setLoading] = React.useState(false);
 37:   
 38:   // Track screen when tab becomes active
 39:   useScreenTracking(isActive ? tab.type : undefined, isActive ? tab.id : undefined);
 40:   const [error, setError] = React.useState<string | null>(null);
 41:   
 42:   // Load projects when tab becomes active and is of type 'projects'
 43:   useEffect(() => {
 44:     if (isActive && tab.type === 'projects') {
 45:       loadProjects();
 46:     }
 47:   }, [isActive, tab.type]);
 48:   
 49:   const loadProjects = async () => {
 50:     try {
 51:       setLoading(true);
 52:       setError(null);
 53:       const projectList = await api.listProjects();
 54:       setProjects(projectList);
 55:     } catch (err) {
 56:       console.error("Failed to load projects:", err);
 57:       setError("Failed to load projects. Please ensure ~/.claude directory exists.");
 58:     } finally {
 59:       setLoading(false);
 60:     }
 61:   };
 62:   
 63:   const handleProjectClick = async (project: Project) => {
 64:     try {
 65:       setLoading(true);
 66:       setError(null);
 67:       const sessionList = await api.getProjectSessions(project.id);
 68:       setSessions(sessionList);
 69:       setSelectedProject(project);
 70:     } catch (err) {
 71:       console.error("Failed to load sessions:", err);
 72:       setError("Failed to load sessions for this project.");
 73:     } finally {
 74:       setLoading(false);
 75:     }
 76:   };
 77:   
 78:   const handleBack = () => {
 79:     setSelectedProject(null);
 80:     setSessions([]);
 81:   };
 82:   
 83:   const handleNewSession = () => {
 84:     // Create a new chat tab
 85:     createChatTab();
 86:   };
 87:   
 88:   // Panel visibility - hide when not active
 89:   const panelVisibilityClass = isActive ? "" : "hidden";
 90:   
 91:   const renderContent = () => {
 92:     switch (tab.type) {
 93:       case 'projects':
 94:         return (
 95:           <div className="h-full overflow-y-auto">
 96:             <div className="container mx-auto p-6">
 97:               {/* Header */}
 98:               <div className="mb-6">
 99:                 <h1 className="text-3xl font-bold tracking-tight">CC Projects</h1>
100:                 <p className="mt-1 text-sm text-muted-foreground">
101:                   Browse your Claude Code sessions
102:                 </p>
103:               </div>
104: 
105:               {/* Error display */}
106:               {error && (
107:                 <motion.div
108:                   initial={{ opacity: 0 }}
109:                   animate={{ opacity: 1 }}
110:                   className="mb-4 rounded-lg border border-destructive/50 bg-destructive/10 p-3 text-xs text-destructive max-w-2xl"
111:                 >
112:                   {error}
113:                 </motion.div>
114:               )}
115: 
116:               {/* Loading state */}
117:               {loading && (
118:                 <div className="flex items-center justify-center py-8">
119:                   <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
120:                 </div>
121:               )}
122: 
123:               {/* Content */}
124:               {!loading && (
125:                 <AnimatePresence mode="wait">
126:                   {selectedProject ? (
127:                     <motion.div
128:                       key="sessions"
129:                       initial={{ opacity: 0, x: 20 }}
130:                       animate={{ opacity: 1, x: 0 }}
131:                       exit={{ opacity: 0, x: -20 }}
132:                       transition={{ duration: 0.3 }}
133:                     >
134:                       <SessionList
135:                         sessions={sessions}
136:                         projectPath={selectedProject.path}
137:                         onBack={handleBack}
138:                         onSessionClick={(session) => {
139:                           // Update tab to show this session
140:                           updateTab(tab.id, {
141:                             type: 'chat',
142:                             title: session.project_path.split('/').pop() || 'Session',
143:                             sessionId: session.id,
144:                             sessionData: session, // Store full session object
145:                             initialProjectPath: session.project_path,
146:                           });
147:                         }}
148:                         onEditClaudeFile={(file: ClaudeMdFile) => {
149:                           // Open CLAUDE.md file in a new tab
150:                           window.dispatchEvent(new CustomEvent('open-claude-file', { 
151:                             detail: { file } 
152:                           }));
153:                         }}
154:                       />
155:                     </motion.div>
156:                   ) : (
157:                     <motion.div
158:                       key="projects"
159:                       initial={{ opacity: 0, x: -20 }}
160:                       animate={{ opacity: 1, x: 0 }}
161:                       exit={{ opacity: 0, x: 20 }}
162:                       transition={{ duration: 0.3 }}
163:                     >
164:                       {/* New session button at the top */}
165:                       <motion.div
166:                         initial={{ opacity: 0, y: 20 }}
167:                         animate={{ opacity: 1, y: 0 }}
168:                         transition={{ duration: 0.5 }}
169:                         className="mb-4"
170:                       >
171:                         <Button
172:                           onClick={handleNewSession}
173:                           size="default"
174:                           className="w-full max-w-md"
175:                         >
176:                           <Plus className="mr-2 h-4 w-4" />
177:                           New Claude Code session
178:                         </Button>
179:                       </motion.div>
180: 
181:                       {/* Running Claude Sessions */}
182:                       <RunningClaudeSessions />
183: 
184:                       {/* Project list */}
185:                       {projects.length > 0 ? (
186:                         <ProjectList
187:                           projects={projects}
188:                           onProjectClick={handleProjectClick}
189:                           onProjectSettings={(project) => {
190:                             // Project settings functionality can be added here if needed
191:                             console.log('Project settings clicked for:', project);
192:                           }}
193:                           loading={loading}
194:                           className="animate-fade-in"
195:                         />
196:                       ) : (
197:                         <div className="py-8 text-center">
198:                           <p className="text-sm text-muted-foreground">
199:                             No projects found in ~/.claude/projects
200:                           </p>
201:                         </div>
202:                       )}
203:                     </motion.div>
204:                   )}
205:                 </AnimatePresence>
206:               )}
207:             </div>
208:           </div>
209:         );
210:       
211:       case 'chat':
212:         return (
213:           <ClaudeCodeSession
214:             session={tab.sessionData} // Pass the full session object if available
215:             initialProjectPath={tab.initialProjectPath || tab.sessionId}
216:             onBack={() => {
217:               // Go back to projects view in the same tab
218:               updateTab(tab.id, {
219:                 type: 'projects',
220:                 title: 'CC Projects',
221:               });
222:             }}
223:           />
224:         );
225:       
226:       case 'agent':
227:         if (!tab.agentRunId) {
228:           return <div className="p-4">No agent run ID specified</div>;
229:         }
230:         return (
231:           <AgentRunOutputViewer
232:             agentRunId={tab.agentRunId}
233:             tabId={tab.id}
234:           />
235:         );
236:       
237:       
238:       case 'usage':
239:         return <UsageDashboard onBack={() => {}} />;
240:       
241:       case 'mcp':
242:         return <MCPManager onBack={() => {}} />;
243:       
244:       case 'settings':
245:         return <Settings onBack={() => {}} />;
246:       
247:       case 'claude-md':
248:         return <MarkdownEditor onBack={() => {}} />;
249:       
250:       case 'claude-file':
251:         if (!tab.claudeFileId) {
252:           return <div className="p-4">No Claude file ID specified</div>;
253:         }
254:         // Note: We need to get the actual file object for ClaudeFileEditor
255:         // For now, returning a placeholder
256:         return <div className="p-4">Claude file editor not yet implemented in tabs</div>;
257:       
258:       case 'agent-execution':
259:         if (!tab.agentData) {
260:           return <div className="p-4">No agent data specified</div>;
261:         }
262:         return (
263:           <AgentExecution
264:             agent={tab.agentData}
265:             onBack={() => {}}
266:           />
267:         );
268:       
269:       case 'create-agent':
270:         return (
271:           <CreateAgent
272:             onAgentCreated={() => {
273:               // Close this tab after agent is created
274:               window.dispatchEvent(new CustomEvent('close-tab', { detail: { tabId: tab.id } }));
275:             }}
276:             onBack={() => {
277:               // Close this tab when back is clicked
278:               window.dispatchEvent(new CustomEvent('close-tab', { detail: { tabId: tab.id } }));
279:             }}
280:           />
281:         );
282:       
283:       case 'import-agent':
284:         // TODO: Implement import agent component
285:         return <div className="p-4">Import agent functionality coming soon...</div>;
286:       
287:       default:
288:         return <div className="p-4">Unknown tab type: {tab.type}</div>;
289:     }
290:   };
291: 
292:   return (
293:     <motion.div
294:       initial={{ opacity: 0, y: 10 }}
295:       animate={{ opacity: 1, y: 0 }}
296:       exit={{ opacity: 0, y: -10 }}
297:       transition={{ duration: 0.2 }}
298:       className={`h-full w-full ${panelVisibilityClass}`}
299:     >
300:       <Suspense
301:         fallback={
302:           <div className="flex items-center justify-center h-full">
303:             <Loader2 className="w-8 h-8 animate-spin text-muted-foreground" />
304:           </div>
305:         }
306:       >
307:         {renderContent()}
308:       </Suspense>
309:     </motion.div>
310:   );
311: };
312: 
313: export const TabContent: React.FC = () => {
314:   const { tabs, activeTabId, createChatTab, findTabBySessionId, createClaudeFileTab, createAgentExecutionTab, createCreateAgentTab, createImportAgentTab, closeTab, updateTab } = useTabState();
315:   
316:   // Listen for events to open sessions in tabs
317:   useEffect(() => {
318:     const handleOpenSessionInTab = (event: CustomEvent) => {
319:       const { session } = event.detail;
320:       
321:       // Check if tab already exists for this session
322:       const existingTab = findTabBySessionId(session.id);
323:       if (existingTab) {
324:         // Update existing tab with session data and switch to it
325:         updateTab(existingTab.id, {
326:           sessionData: session,
327:           title: session.project_path.split('/').pop() || 'Session'
328:         });
329:         window.dispatchEvent(new CustomEvent('switch-to-tab', { detail: { tabId: existingTab.id } }));
330:       } else {
331:         // Create new tab for this session
332:         const projectName = session.project_path.split('/').pop() || 'Session';
333:         const newTabId = createChatTab(session.id, projectName);
334:         // Update the new tab with session data
335:         updateTab(newTabId, {
336:           sessionData: session,
337:           initialProjectPath: session.project_path
338:         });
339:       }
340:     };
341: 
342:     const handleOpenClaudeFile = (event: CustomEvent) => {
343:       const { file } = event.detail;
344:       createClaudeFileTab(file.id, file.name || 'CLAUDE.md');
345:     };
346: 
347:     const handleOpenAgentExecution = (event: CustomEvent) => {
348:       const { agent, tabId } = event.detail;
349:       createAgentExecutionTab(agent, tabId);
350:     };
351: 
352:     const handleOpenCreateAgentTab = () => {
353:       createCreateAgentTab();
354:     };
355: 
356:     const handleOpenImportAgentTab = () => {
357:       createImportAgentTab();
358:     };
359: 
360:     const handleCloseTab = (event: CustomEvent) => {
361:       const { tabId } = event.detail;
362:       closeTab(tabId);
363:     };
364: 
365:     const handleClaudeSessionSelected = (event: CustomEvent) => {
366:       const { session } = event.detail;
367:       // Reuse same logic as handleOpenSessionInTab
368:       const existingTab = findTabBySessionId(session.id);
369:       if (existingTab) {
370:         updateTab(existingTab.id, {
371:           sessionData: session,
372:           title: session.project_path.split('/').pop() || 'Session',
373:         });
374:         window.dispatchEvent(new CustomEvent('switch-to-tab', { detail: { tabId: existingTab.id } }));
375:       } else {
376:         const projectName = session.project_path.split('/').pop() || 'Session';
377:         const newTabId = createChatTab(session.id, projectName);
378:         updateTab(newTabId, {
379:           sessionData: session,
380:           initialProjectPath: session.project_path,
381:         });
382:       }
383:     };
384: 
385:     window.addEventListener('open-session-in-tab', handleOpenSessionInTab as EventListener);
386:     window.addEventListener('open-claude-file', handleOpenClaudeFile as EventListener);
387:     window.addEventListener('open-agent-execution', handleOpenAgentExecution as EventListener);
388:     window.addEventListener('open-create-agent-tab', handleOpenCreateAgentTab);
389:     window.addEventListener('open-import-agent-tab', handleOpenImportAgentTab);
390:     window.addEventListener('close-tab', handleCloseTab as EventListener);
391:     window.addEventListener('claude-session-selected', handleClaudeSessionSelected as EventListener);
392:     return () => {
393:       window.removeEventListener('open-session-in-tab', handleOpenSessionInTab as EventListener);
394:       window.removeEventListener('open-claude-file', handleOpenClaudeFile as EventListener);
395:       window.removeEventListener('open-agent-execution', handleOpenAgentExecution as EventListener);
396:       window.removeEventListener('open-create-agent-tab', handleOpenCreateAgentTab);
397:       window.removeEventListener('open-import-agent-tab', handleOpenImportAgentTab);
398:       window.removeEventListener('close-tab', handleCloseTab as EventListener);
399:       window.removeEventListener('claude-session-selected', handleClaudeSessionSelected as EventListener);
400:     };
401:   }, [createChatTab, findTabBySessionId, createClaudeFileTab, createAgentExecutionTab, createCreateAgentTab, createImportAgentTab, closeTab, updateTab]);
402:   
403:   return (
404:     <div className="flex-1 h-full relative">
405:       <AnimatePresence mode="wait">
406:         {tabs.map((tab) => (
407:           <TabPanel
408:             key={tab.id}
409:             tab={tab}
410:             isActive={tab.id === activeTabId}
411:           />
412:         ))}
413:       </AnimatePresence>
414:       
415:       {tabs.length === 0 && (
416:         <div className="flex items-center justify-center h-full text-muted-foreground">
417:           <div className="text-center">
418:             <p className="text-lg mb-2">No tabs open</p>
419:             <p className="text-sm">Click the + button to start a new chat</p>
420:           </div>
421:         </div>
422:       )}
423:     </div>
424:   );
425: };
426: 
427: export default TabContent;
````

## File: src/components/TabManager.tsx
````typescript
  1: import React, { useState, useRef, useEffect } from 'react';
  2: import { motion, AnimatePresence, Reorder } from 'framer-motion';
  3: import { X, Plus, MessageSquare, Bot, AlertCircle, Loader2, Folder, BarChart, Server, Settings, FileText } from 'lucide-react';
  4: import { useTabState } from '@/hooks/useTabState';
  5: import { Tab, useTabContext } from '@/contexts/TabContext';
  6: import { cn } from '@/lib/utils';
  7: import { useTrackEvent } from '@/hooks';
  8: 
  9: interface TabItemProps {
 10:   tab: Tab;
 11:   isActive: boolean;
 12:   onClose: (id: string) => void;
 13:   onClick: (id: string) => void;
 14:   isDragging?: boolean;
 15:   setDraggedTabId?: (id: string | null) => void;
 16: }
 17: 
 18: const TabItem: React.FC<TabItemProps> = ({ tab, isActive, onClose, onClick, isDragging = false, setDraggedTabId }) => {
 19:   const [isHovered, setIsHovered] = useState(false);
 20:   
 21:   const getIcon = () => {
 22:     switch (tab.type) {
 23:       case 'chat':
 24:         return MessageSquare;
 25:       case 'agent':
 26:         return Bot;
 27:       case 'projects':
 28:         return Folder;
 29:       case 'usage':
 30:         return BarChart;
 31:       case 'mcp':
 32:         return Server;
 33:       case 'settings':
 34:         return Settings;
 35:       case 'claude-md':
 36:       case 'claude-file':
 37:         return FileText;
 38:       case 'agent-execution':
 39:         return Bot;
 40:       case 'create-agent':
 41:         return Plus;
 42:       case 'import-agent':
 43:         return Plus;
 44:       default:
 45:         return MessageSquare;
 46:     }
 47:   };
 48: 
 49:   const getStatusIcon = () => {
 50:     switch (tab.status) {
 51:       case 'running':
 52:         return <Loader2 className="w-3 h-3 animate-spin" />;
 53:       case 'error':
 54:         return <AlertCircle className="w-3 h-3 text-red-500" />;
 55:       default:
 56:         return null;
 57:     }
 58:   };
 59: 
 60:   const Icon = getIcon();
 61:   const statusIcon = getStatusIcon();
 62: 
 63:   return (
 64:     <Reorder.Item
 65:       value={tab}
 66:       id={tab.id}
 67:       dragListener={true}
 68:       transition={{ duration: 0.1 }} // Snappy reorder animation
 69:       className={cn(
 70:         "relative flex items-center gap-2 text-sm cursor-pointer select-none group",
 71:         "transition-colors duration-100 overflow-hidden border-r border-border/20",
 72:         "before:absolute before:bottom-0 before:left-0 before:right-0 before:h-0.5 before:transition-colors before:duration-100",
 73:         isActive
 74:           ? "bg-card text-card-foreground before:bg-primary"
 75:           : "bg-transparent text-muted-foreground hover:bg-muted/40 hover:text-foreground before:bg-transparent",
 76:         isDragging && "bg-card border-primary/50 shadow-sm z-50",
 77:         "min-w-[120px] max-w-[220px] h-8 px-3"
 78:       )}
 79:       onMouseEnter={() => setIsHovered(true)}
 80:       onMouseLeave={() => setIsHovered(false)}
 81:       onClick={() => onClick(tab.id)}
 82:       onDragStart={() => setDraggedTabId?.(tab.id)}
 83:       onDragEnd={() => setDraggedTabId?.(null)}
 84:     >
 85:       {/* Tab Icon */}
 86:       <div className="flex-shrink-0">
 87:         <Icon className="w-4 h-4" />
 88:       </div>
 89:       
 90:       {/* Tab Title */}
 91:       <span className="flex-1 truncate text-xs font-medium min-w-0">
 92:         {tab.title}
 93:       </span>
 94: 
 95:       {/* Status Indicators - always takes up space */}
 96:       <div className="flex items-center gap-1.5 flex-shrink-0 w-6 justify-end">
 97:         {statusIcon && (
 98:           <span className="flex items-center justify-center">
 99:             {statusIcon}
100:           </span>
101:         )}
102: 
103:         {tab.hasUnsavedChanges && !statusIcon && (
104:           <span 
105:             className="w-1.5 h-1.5 bg-primary rounded-full"
106:             title="Unsaved changes"
107:           />
108:         )}
109:       </div>
110: 
111:       {/* Close Button - Always reserves space */}
112:       <button
113:         onClick={(e) => {
114:           e.stopPropagation();
115:           onClose(tab.id);
116:         }}
117:         className={cn(
118:           "flex-shrink-0 w-4 h-4 flex items-center justify-center rounded-sm",
119:           "transition-all duration-100 hover:bg-destructive/20 hover:text-destructive",
120:           "focus:outline-none focus:ring-1 focus:ring-destructive/50",
121:           (isHovered || isActive) ? "opacity-100" : "opacity-0"
122:         )}
123:         title={`Close ${tab.title}`}
124:         tabIndex={-1}
125:       >
126:         <X className="w-3 h-3" />
127:       </button>
128: 
129:     </Reorder.Item>
130:   );
131: };
132: 
133: interface TabManagerProps {
134:   className?: string;
135: }
136: 
137: export const TabManager: React.FC<TabManagerProps> = ({ className }) => {
138:   const {
139:     tabs,
140:     activeTabId,
141:     createChatTab,
142:     createProjectsTab,
143:     closeTab,
144:     switchToTab,
145:     canAddTab
146:   } = useTabState();
147: 
148:   // Access reorderTabs from context
149:   const { reorderTabs } = useTabContext();
150: 
151:   const scrollContainerRef = useRef<HTMLDivElement>(null);
152:   const [showLeftScroll, setShowLeftScroll] = useState(false);
153:   const [showRightScroll, setShowRightScroll] = useState(false);
154:   const [draggedTabId, setDraggedTabId] = useState<string | null>(null);
155:   
156:   // Analytics tracking
157:   const trackEvent = useTrackEvent();
158: 
159:   // Listen for tab switch events
160:   useEffect(() => {
161:     const handleSwitchToTab = (event: CustomEvent) => {
162:       const { tabId } = event.detail;
163:       switchToTab(tabId);
164:     };
165: 
166:     window.addEventListener('switch-to-tab', handleSwitchToTab as EventListener);
167:     return () => {
168:       window.removeEventListener('switch-to-tab', handleSwitchToTab as EventListener);
169:     };
170:   }, [switchToTab]);
171: 
172:   // Listen for keyboard shortcut events
173:   useEffect(() => {
174:     const handleCreateTab = () => {
175:       createChatTab();
176:       trackEvent.tabCreated('chat');
177:     };
178: 
179:     const handleCloseTab = async () => {
180:       if (activeTabId) {
181:         const tab = tabs.find(t => t.id === activeTabId);
182:         if (tab) {
183:           trackEvent.tabClosed(tab.type);
184:         }
185:         await closeTab(activeTabId);
186:       }
187:     };
188: 
189:     const handleNextTab = () => {
190:       const currentIndex = tabs.findIndex(tab => tab.id === activeTabId);
191:       const nextIndex = (currentIndex + 1) % tabs.length;
192:       if (tabs[nextIndex]) {
193:         switchToTab(tabs[nextIndex].id);
194:       }
195:     };
196: 
197:     const handlePreviousTab = () => {
198:       const currentIndex = tabs.findIndex(tab => tab.id === activeTabId);
199:       const previousIndex = currentIndex === 0 ? tabs.length - 1 : currentIndex - 1;
200:       if (tabs[previousIndex]) {
201:         switchToTab(tabs[previousIndex].id);
202:       }
203:     };
204: 
205:     const handleTabByIndex = (event: CustomEvent) => {
206:       const { index } = event.detail;
207:       if (tabs[index]) {
208:         switchToTab(tabs[index].id);
209:       }
210:     };
211: 
212:     window.addEventListener('create-chat-tab', handleCreateTab);
213:     window.addEventListener('close-current-tab', handleCloseTab);
214:     window.addEventListener('switch-to-next-tab', handleNextTab);
215:     window.addEventListener('switch-to-previous-tab', handlePreviousTab);
216:     window.addEventListener('switch-to-tab-by-index', handleTabByIndex as EventListener);
217: 
218:     return () => {
219:       window.removeEventListener('create-chat-tab', handleCreateTab);
220:       window.removeEventListener('close-current-tab', handleCloseTab);
221:       window.removeEventListener('switch-to-next-tab', handleNextTab);
222:       window.removeEventListener('switch-to-previous-tab', handlePreviousTab);
223:       window.removeEventListener('switch-to-tab-by-index', handleTabByIndex as EventListener);
224:     };
225:   }, [tabs, activeTabId, createChatTab, closeTab, switchToTab]);
226: 
227:   // Check scroll buttons visibility
228:   const checkScrollButtons = () => {
229:     const container = scrollContainerRef.current;
230:     if (!container) return;
231: 
232:     const { scrollLeft, scrollWidth, clientWidth } = container;
233:     setShowLeftScroll(scrollLeft > 0);
234:     setShowRightScroll(scrollLeft + clientWidth < scrollWidth - 1);
235:   };
236: 
237:   useEffect(() => {
238:     checkScrollButtons();
239:     const container = scrollContainerRef.current;
240:     if (!container) return;
241: 
242:     container.addEventListener('scroll', checkScrollButtons);
243:     window.addEventListener('resize', checkScrollButtons);
244: 
245:     return () => {
246:       container.removeEventListener('scroll', checkScrollButtons);
247:       window.removeEventListener('resize', checkScrollButtons);
248:     };
249:   }, [tabs]);
250: 
251:   const handleReorder = (newOrder: Tab[]) => {
252:     // Find the positions that changed
253:     const oldOrder = tabs.map(tab => tab.id);
254:     const newOrderIds = newOrder.map(tab => tab.id);
255:     
256:     // Find what moved
257:     const movedTabId = newOrderIds.find((id, index) => oldOrder[index] !== id);
258:     if (!movedTabId) return;
259:     
260:     const oldIndex = oldOrder.indexOf(movedTabId);
261:     const newIndex = newOrderIds.indexOf(movedTabId);
262:     
263:     if (oldIndex !== -1 && newIndex !== -1 && oldIndex !== newIndex) {
264:       // Use the context's reorderTabs function
265:       reorderTabs(oldIndex, newIndex);
266:       // Track the reorder event
267:       trackEvent.featureUsed?.('tab_reorder', 'drag_drop', { 
268:         from_index: oldIndex, 
269:         to_index: newIndex 
270:       });
271:     }
272:   };
273: 
274:   const handleCloseTab = async (id: string) => {
275:     const tab = tabs.find(t => t.id === id);
276:     if (tab) {
277:       trackEvent.tabClosed(tab.type);
278:     }
279:     await closeTab(id);
280:   };
281: 
282:   const handleNewTab = () => {
283:     if (canAddTab()) {
284:       createProjectsTab();
285:       trackEvent.tabCreated('projects');
286:     }
287:   };
288: 
289:   const scrollTabs = (direction: 'left' | 'right') => {
290:     const container = scrollContainerRef.current;
291:     if (!container) return;
292: 
293:     const scrollAmount = 200;
294:     const newScrollLeft = direction === 'left'
295:       ? container.scrollLeft - scrollAmount
296:       : container.scrollLeft + scrollAmount;
297: 
298:     container.scrollTo({
299:       left: newScrollLeft,
300:       behavior: 'smooth'
301:     });
302:   };
303: 
304:   return (
305:     <div className={cn("flex items-stretch bg-muted/15 border-b relative", className)}>
306:       {/* Left fade gradient */}
307:       {showLeftScroll && (
308:         <div className="absolute left-0 top-0 bottom-0 w-8 bg-gradient-to-r from-muted/15 to-transparent pointer-events-none z-10" />
309:       )}
310:       
311:       {/* Left scroll button */}
312:       <AnimatePresence>
313:         {showLeftScroll && (
314:           <motion.button
315:             initial={{ opacity: 0 }}
316:             animate={{ opacity: 1 }}
317:             exit={{ opacity: 0 }}
318:             onClick={() => scrollTabs('left')}
319:             className={cn(
320:               "p-1.5 hover:bg-muted/80 rounded-sm z-20 ml-1",
321:               "transition-colors duration-200 flex items-center justify-center",
322:               "bg-background/80 backdrop-blur-sm shadow-sm border border-border/50"
323:             )}
324:             title="Scroll tabs left"
325:           >
326:             <svg className="w-3.5 h-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor">
327:               <path d="M15 18l-6-6 6-6" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" />
328:             </svg>
329:           </motion.button>
330:         )}
331:       </AnimatePresence>
332: 
333:       {/* Tabs container */}
334:       <div
335:         ref={scrollContainerRef}
336:         className="flex-1 flex overflow-x-auto scrollbar-hide"
337:         style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
338:       >
339:         <Reorder.Group
340:           axis="x"
341:           values={tabs}
342:           onReorder={handleReorder}
343:           className="flex items-stretch h-8"
344:           layoutScroll={false}
345:         >
346:           {tabs.map((tab) => (
347:             <TabItem
348:               key={tab.id}
349:               tab={tab}
350:               isActive={tab.id === activeTabId}
351:               onClose={handleCloseTab}
352:               onClick={switchToTab}
353:               isDragging={draggedTabId === tab.id}
354:               setDraggedTabId={setDraggedTabId}
355:             />
356:           ))}
357:         </Reorder.Group>
358:       </div>
359: 
360:       {/* Right fade gradient */}
361:       {showRightScroll && (
362:         <div className="absolute right-0 top-0 bottom-0 w-8 bg-gradient-to-l from-muted/15 to-transparent pointer-events-none z-10" />
363:       )}
364: 
365:       {/* Right scroll button */}
366:       <AnimatePresence>
367:         {showRightScroll && (
368:           <motion.button
369:             initial={{ opacity: 0 }}
370:             animate={{ opacity: 1 }}
371:             exit={{ opacity: 0 }}
372:             onClick={() => scrollTabs('right')}
373:             className={cn(
374:               "p-1.5 hover:bg-muted/80 rounded-sm z-20 mr-1",
375:               "transition-colors duration-200 flex items-center justify-center",
376:               "bg-background/80 backdrop-blur-sm shadow-sm border border-border/50"
377:             )}
378:             title="Scroll tabs right"
379:           >
380:             <svg className="w-3.5 h-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor">
381:               <path d="M9 18l6-6-6-6" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" />
382:             </svg>
383:           </motion.button>
384:         )}
385:       </AnimatePresence>
386: 
387:       {/* New tab button */}
388:       <button
389:         onClick={handleNewTab}
390:         disabled={!canAddTab()}
391:         className={cn(
392:           "p-2 mx-2 rounded-md transition-all duration-200 flex items-center justify-center",
393:           "border border-border/50 bg-background/50 backdrop-blur-sm",
394:           canAddTab()
395:             ? "hover:bg-muted/80 hover:border-border text-muted-foreground hover:text-foreground hover:shadow-sm"
396:             : "opacity-50 cursor-not-allowed bg-muted/30"
397:         )}
398:         title={canAddTab() ? "Browse projects (Ctrl+T)" : `Maximum tabs reached (${tabs.length}/20)`}
399:       >
400:         <Plus className="w-3.5 h-3.5" />
401:       </button>
402:     </div>
403:   );
404: };
405: 
406: export default TabManager;
````

## File: src/components/TimelineNavigator.tsx
````typescript
  1: import React, { useState, useEffect } from "react";
  2: import { motion } from "framer-motion";
  3: import { 
  4:   GitBranch, 
  5:   Save, 
  6:   RotateCcw, 
  7:   GitFork,
  8:   AlertCircle,
  9:   ChevronDown,
 10:   ChevronRight,
 11:   Hash,
 12:   FileCode,
 13:   Diff
 14: } from "lucide-react";
 15: import { Button } from "@/components/ui/button";
 16: import { Card, CardContent } from "@/components/ui/card";
 17: import { Badge } from "@/components/ui/badge";
 18: import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
 19: import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
 20: import { Input } from "@/components/ui/input";
 21: import { Label } from "@/components/ui/label";
 22: import { api, type Checkpoint, type TimelineNode, type SessionTimeline, type CheckpointDiff } from "@/lib/api";
 23: import { cn } from "@/lib/utils";
 24: import { formatDistanceToNow } from "date-fns";
 25: import { useTrackEvent } from "@/hooks";
 26: 
 27: interface TimelineNavigatorProps {
 28:   sessionId: string;
 29:   projectId: string;
 30:   projectPath: string;
 31:   currentMessageIndex: number;
 32:   onCheckpointSelect: (checkpoint: Checkpoint) => void;
 33:   onFork: (checkpointId: string) => void;
 34:   /**
 35:    * Incrementing value provided by parent to force timeline reload when checkpoints
 36:    * are created elsewhere (e.g., auto-checkpoint after tool execution).
 37:    */
 38:   refreshVersion?: number;
 39:   /**
 40:    * Callback when a new checkpoint is created
 41:    */
 42:   onCheckpointCreated?: () => void;
 43:   className?: string;
 44: }
 45: 
 46: /**
 47:  * Visual timeline navigator for checkpoint management
 48:  */
 49: export const TimelineNavigator: React.FC<TimelineNavigatorProps> = ({
 50:   sessionId,
 51:   projectId,
 52:   projectPath,
 53:   currentMessageIndex,
 54:   onCheckpointSelect,
 55:   onFork,
 56:   refreshVersion = 0,
 57:   onCheckpointCreated,
 58:   className
 59: }) => {
 60:   const [timeline, setTimeline] = useState<SessionTimeline | null>(null);
 61:   const [selectedCheckpoint, setSelectedCheckpoint] = useState<Checkpoint | null>(null);
 62:   const [expandedNodes, setExpandedNodes] = useState<Set<string>>(new Set());
 63:   const [showCreateDialog, setShowCreateDialog] = useState(false);
 64:   const [showDiffDialog, setShowDiffDialog] = useState(false);
 65:   const [checkpointDescription, setCheckpointDescription] = useState("");
 66:   const [isLoading, setIsLoading] = useState(false);
 67:   const [error, setError] = useState<string | null>(null);
 68:   const [diff, setDiff] = useState<CheckpointDiff | null>(null);
 69:   const [compareCheckpoint, setCompareCheckpoint] = useState<Checkpoint | null>(null);
 70:   
 71:   // Analytics tracking
 72:   const trackEvent = useTrackEvent();
 73: 
 74:   // Load timeline on mount and whenever refreshVersion bumps
 75:   useEffect(() => {
 76:     loadTimeline();
 77:   }, [sessionId, projectId, projectPath, refreshVersion]);
 78: 
 79:   const loadTimeline = async () => {
 80:     try {
 81:       setIsLoading(true);
 82:       setError(null);
 83:       const timelineData = await api.getSessionTimeline(sessionId, projectId, projectPath);
 84:       setTimeline(timelineData);
 85:       
 86:       // Auto-expand nodes with current checkpoint
 87:       if (timelineData.currentCheckpointId && timelineData.rootNode) {
 88:         const pathToNode = findPathToCheckpoint(timelineData.rootNode, timelineData.currentCheckpointId);
 89:         setExpandedNodes(new Set(pathToNode));
 90:       }
 91:     } catch (err) {
 92:       console.error("Failed to load timeline:", err);
 93:       setError("Failed to load timeline");
 94:     } finally {
 95:       setIsLoading(false);
 96:     }
 97:   };
 98: 
 99:   const findPathToCheckpoint = (node: TimelineNode, checkpointId: string, path: string[] = []): string[] => {
100:     if (node.checkpoint.id === checkpointId) {
101:       return path;
102:     }
103:     
104:     for (const child of node.children) {
105:       const childPath = findPathToCheckpoint(child, checkpointId, [...path, node.checkpoint.id]);
106:       if (childPath.length > path.length) {
107:         return childPath;
108:       }
109:     }
110:     
111:     return path;
112:   };
113: 
114:   const handleCreateCheckpoint = async () => {
115:     try {
116:       setIsLoading(true);
117:       setError(null);
118:       
119:       const sessionStartTime = Date.now(); // Using current time as we don't have session start time
120:       
121:       await api.createCheckpoint(
122:         sessionId,
123:         projectId,
124:         projectPath,
125:         currentMessageIndex,
126:         checkpointDescription || undefined
127:       );
128:       
129:       // Track checkpoint creation
130:       const checkpointNumber = timeline ? timeline.totalCheckpoints + 1 : 1;
131:       trackEvent.checkpointCreated({
132:         checkpoint_number: checkpointNumber,
133:         session_duration_at_checkpoint: Date.now() - sessionStartTime
134:       });
135:       
136:       // Call parent callback if provided
137:       if (onCheckpointCreated) {
138:         onCheckpointCreated();
139:       }
140:       
141:       setCheckpointDescription("");
142:       setShowCreateDialog(false);
143:       await loadTimeline();
144:     } catch (err) {
145:       console.error("Failed to create checkpoint:", err);
146:       setError("Failed to create checkpoint");
147:     } finally {
148:       setIsLoading(false);
149:     }
150:   };
151: 
152:   const handleRestoreCheckpoint = async (checkpoint: Checkpoint) => {
153:     if (!confirm(`Restore to checkpoint "${checkpoint.description || checkpoint.id.slice(0, 8)}"? Current state will be saved as a new checkpoint.`)) {
154:       return;
155:     }
156: 
157:     try {
158:       setIsLoading(true);
159:       setError(null);
160:       
161:       const checkpointTime = new Date(checkpoint.timestamp).getTime();
162:       const timeSinceCheckpoint = Date.now() - checkpointTime;
163:       
164:       // First create a checkpoint of current state
165:       await api.createCheckpoint(
166:         sessionId,
167:         projectId,
168:         projectPath,
169:         currentMessageIndex,
170:         "Auto-save before restore"
171:       );
172:       
173:       // Then restore
174:       await api.restoreCheckpoint(checkpoint.id, sessionId, projectId, projectPath);
175:       
176:       // Track checkpoint restoration
177:       trackEvent.checkpointRestored({
178:         checkpoint_id: checkpoint.id,
179:         time_since_checkpoint_ms: timeSinceCheckpoint
180:       });
181:       
182:       await loadTimeline();
183:       onCheckpointSelect(checkpoint);
184:     } catch (err) {
185:       console.error("Failed to restore checkpoint:", err);
186:       setError("Failed to restore checkpoint");
187:     } finally {
188:       setIsLoading(false);
189:     }
190:   };
191: 
192:   const handleFork = async (checkpoint: Checkpoint) => {
193:     onFork(checkpoint.id);
194:   };
195: 
196:   const handleCompare = async (checkpoint: Checkpoint) => {
197:     if (!selectedCheckpoint) {
198:       setSelectedCheckpoint(checkpoint);
199:       return;
200:     }
201: 
202:     try {
203:       setIsLoading(true);
204:       setError(null);
205:       
206:       const diffData = await api.getCheckpointDiff(
207:         selectedCheckpoint.id,
208:         checkpoint.id,
209:         sessionId,
210:         projectId
211:       );
212:       
213:       setDiff(diffData);
214:       setCompareCheckpoint(checkpoint);
215:       setShowDiffDialog(true);
216:     } catch (err) {
217:       console.error("Failed to get diff:", err);
218:       setError("Failed to compare checkpoints");
219:     } finally {
220:       setIsLoading(false);
221:     }
222:   };
223: 
224:   const toggleNodeExpansion = (nodeId: string) => {
225:     const newExpanded = new Set(expandedNodes);
226:     if (newExpanded.has(nodeId)) {
227:       newExpanded.delete(nodeId);
228:     } else {
229:       newExpanded.add(nodeId);
230:     }
231:     setExpandedNodes(newExpanded);
232:   };
233: 
234:   const renderTimelineNode = (node: TimelineNode, depth: number = 0) => {
235:     const isExpanded = expandedNodes.has(node.checkpoint.id);
236:     const hasChildren = node.children.length > 0;
237:     const isCurrent = timeline?.currentCheckpointId === node.checkpoint.id;
238:     const isSelected = selectedCheckpoint?.id === node.checkpoint.id;
239: 
240:     return (
241:       <div key={node.checkpoint.id} className="relative">
242:         {/* Connection line */}
243:         {depth > 0 && (
244:           <div 
245:             className="absolute left-0 top-0 w-6 h-6 border-l-2 border-b-2 border-muted-foreground/30"
246:             style={{ 
247:               left: `${(depth - 1) * 24}px`,
248:               borderBottomLeftRadius: '8px'
249:             }}
250:           />
251:         )}
252:         
253:         {/* Node content */}
254:         <motion.div
255:           initial={{ opacity: 0, x: -20 }}
256:           animate={{ opacity: 1, x: 0 }}
257:           transition={{ duration: 0.2, delay: depth * 0.05 }}
258:           className={cn(
259:             "flex items-start gap-2 py-2",
260:             depth > 0 && "ml-6"
261:           )}
262:           style={{ paddingLeft: `${depth * 24}px` }}
263:         >
264:           {/* Expand/collapse button */}
265:           {hasChildren && (
266:             <Button
267:               variant="ghost"
268:               size="icon"
269:               className="h-6 w-6 -ml-1"
270:               onClick={() => toggleNodeExpansion(node.checkpoint.id)}
271:             >
272:               {isExpanded ? (
273:                 <ChevronDown className="h-3 w-3" />
274:               ) : (
275:                 <ChevronRight className="h-3 w-3" />
276:               )}
277:             </Button>
278:           )}
279:           
280:           {/* Checkpoint card */}
281:           <Card 
282:             className={cn(
283:               "flex-1 cursor-pointer transition-all hover:shadow-md",
284:               isCurrent && "border-primary ring-2 ring-primary/20",
285:               isSelected && "border-blue-500 bg-blue-500/5",
286:               !hasChildren && "ml-5"
287:             )}
288:             onClick={() => setSelectedCheckpoint(node.checkpoint)}
289:           >
290:             <CardContent className="p-3">
291:               <div className="flex items-start justify-between gap-2">
292:                 <div className="flex-1 min-w-0">
293:                   <div className="flex items-center gap-2 mb-1">
294:                     {isCurrent && (
295:                       <Badge variant="default" className="text-xs">Current</Badge>
296:                     )}
297:                     <span className="text-xs font-mono text-muted-foreground">
298:                       {node.checkpoint.id.slice(0, 8)}
299:                     </span>
300:                     <span className="text-xs text-muted-foreground">
301:                       {formatDistanceToNow(new Date(node.checkpoint.timestamp), { addSuffix: true })}
302:                     </span>
303:                   </div>
304:                   
305:                   {node.checkpoint.description && (
306:                     <p className="text-sm font-medium mb-1">{node.checkpoint.description}</p>
307:                   )}
308:                   
309:                   <p className="text-xs text-muted-foreground line-clamp-2">
310:                     {node.checkpoint.metadata.userPrompt || "No prompt"}
311:                   </p>
312:                   
313:                   <div className="flex items-center gap-3 mt-2 text-xs text-muted-foreground">
314:                     <span className="flex items-center gap-1">
315:                       <Hash className="h-3 w-3" />
316:                       {node.checkpoint.metadata.totalTokens.toLocaleString()} tokens
317:                     </span>
318:                     <span className="flex items-center gap-1">
319:                       <FileCode className="h-3 w-3" />
320:                       {node.checkpoint.metadata.fileChanges} files
321:                     </span>
322:                   </div>
323:                 </div>
324:                 
325:                 {/* Actions */}
326:                 <div className="flex items-center gap-1">
327:                   <TooltipProvider>
328:                     <Tooltip>
329:                       <TooltipTrigger asChild>
330:                         <Button
331:                           variant="ghost"
332:                           size="icon"
333:                           className="h-7 w-7"
334:                           onClick={(e) => {
335:                             e.stopPropagation();
336:                             handleRestoreCheckpoint(node.checkpoint);
337:                           }}
338:                         >
339:                           <RotateCcw className="h-3 w-3" />
340:                         </Button>
341:                       </TooltipTrigger>
342:                       <TooltipContent>Restore to this checkpoint</TooltipContent>
343:                     </Tooltip>
344:                   </TooltipProvider>
345:                   
346:                   <TooltipProvider>
347:                     <Tooltip>
348:                       <TooltipTrigger asChild>
349:                         <Button
350:                           variant="ghost"
351:                           size="icon"
352:                           className="h-7 w-7"
353:                           onClick={(e) => {
354:                             e.stopPropagation();
355:                             handleFork(node.checkpoint);
356:                           }}
357:                         >
358:                           <GitFork className="h-3 w-3" />
359:                         </Button>
360:                       </TooltipTrigger>
361:                       <TooltipContent>Fork from this checkpoint</TooltipContent>
362:                     </Tooltip>
363:                   </TooltipProvider>
364:                   
365:                   <TooltipProvider>
366:                     <Tooltip>
367:                       <TooltipTrigger asChild>
368:                         <Button
369:                           variant="ghost"
370:                           size="icon"
371:                           className="h-7 w-7"
372:                           onClick={(e) => {
373:                             e.stopPropagation();
374:                             handleCompare(node.checkpoint);
375:                           }}
376:                         >
377:                           <Diff className="h-3 w-3" />
378:                         </Button>
379:                       </TooltipTrigger>
380:                       <TooltipContent>Compare with another checkpoint</TooltipContent>
381:                     </Tooltip>
382:                   </TooltipProvider>
383:                 </div>
384:               </div>
385:             </CardContent>
386:           </Card>
387:         </motion.div>
388:         
389:         {/* Children */}
390:         {isExpanded && hasChildren && (
391:           <div className="relative">
392:             {/* Vertical line for children */}
393:             {node.children.length > 1 && (
394:               <div 
395:                 className="absolute top-0 bottom-0 w-0.5 bg-muted-foreground/30"
396:                 style={{ left: `${(depth + 1) * 24 - 1}px` }}
397:               />
398:             )}
399:             
400:             {node.children.map((child) => 
401:               renderTimelineNode(child, depth + 1)
402:             )}
403:           </div>
404:         )}
405:       </div>
406:     );
407:   };
408: 
409:   return (
410:     <div className={cn("space-y-4", className)}>
411:       {/* Experimental Feature Warning */}
412:       <div className="rounded-lg border border-yellow-500/50 bg-yellow-500/10 p-3">
413:         <div className="flex items-start gap-2">
414:           <AlertCircle className="h-4 w-4 text-yellow-600 mt-0.5" />
415:           <div className="text-xs">
416:             <p className="font-medium text-yellow-600">Experimental Feature</p>
417:             <p className="text-yellow-600/80">
418:               Checkpointing may affect directory structure or cause data loss. Use with caution.
419:             </p>
420:           </div>
421:         </div>
422:       </div>
423:       
424:       {/* Header */}
425:       <div className="flex items-center justify-between">
426:         <div className="flex items-center gap-2">
427:           <GitBranch className="h-5 w-5 text-muted-foreground" />
428:           <h3 className="text-sm font-medium">Timeline</h3>
429:           {timeline && (
430:             <Badge variant="outline" className="text-xs">
431:               {timeline.totalCheckpoints} checkpoints
432:             </Badge>
433:           )}
434:         </div>
435:         
436:         <Button
437:           size="sm"
438:           variant="default"
439:           onClick={() => setShowCreateDialog(true)}
440:           disabled={isLoading}
441:         >
442:           <Save className="h-3 w-3 mr-1" />
443:           Checkpoint
444:         </Button>
445:       </div>
446:       
447:       {/* Error display */}
448:       {error && (
449:         <div className="flex items-center gap-2 text-xs text-destructive">
450:           <AlertCircle className="h-3 w-3" />
451:           {error}
452:         </div>
453:       )}
454:       
455:       {/* Timeline tree */}
456:       {timeline?.rootNode ? (
457:         <div className="relative overflow-x-auto">
458:           {renderTimelineNode(timeline.rootNode)}
459:         </div>
460:       ) : (
461:         <div className="text-center py-8 text-sm text-muted-foreground">
462:           {isLoading ? "Loading timeline..." : "No checkpoints yet"}
463:         </div>
464:       )}
465:       
466:       {/* Create checkpoint dialog */}
467:       <Dialog open={showCreateDialog} onOpenChange={setShowCreateDialog}>
468:         <DialogContent>
469:           <DialogHeader>
470:             <DialogTitle>Create Checkpoint</DialogTitle>
471:             <DialogDescription>
472:               Save the current state of your session with an optional description.
473:             </DialogDescription>
474:           </DialogHeader>
475:           
476:           <div className="space-y-4 py-4">
477:             <div className="space-y-2">
478:               <Label htmlFor="description">Description (optional)</Label>
479:               <Input
480:                 id="description"
481:                 placeholder="e.g., Before major refactoring"
482:                 value={checkpointDescription}
483:                 onChange={(e) => setCheckpointDescription(e.target.value)}
484:                 onKeyPress={(e) => {
485:                   if (e.key === "Enter" && !isLoading) {
486:                     handleCreateCheckpoint();
487:                   }
488:                 }}
489:               />
490:             </div>
491:           </div>
492:           
493:           <DialogFooter>
494:             <Button
495:               variant="outline"
496:               onClick={() => setShowCreateDialog(false)}
497:               disabled={isLoading}
498:             >
499:               Cancel
500:             </Button>
501:             <Button
502:               onClick={handleCreateCheckpoint}
503:               disabled={isLoading}
504:             >
505:               Create Checkpoint
506:             </Button>
507:           </DialogFooter>
508:         </DialogContent>
509:       </Dialog>
510:       
511:       {/* Diff dialog */}
512:       <Dialog open={showDiffDialog} onOpenChange={setShowDiffDialog}>
513:         <DialogContent className="max-w-3xl">
514:           <DialogHeader>
515:             <DialogTitle>Checkpoint Comparison</DialogTitle>
516:             <DialogDescription>
517:               Changes between "{selectedCheckpoint?.description || selectedCheckpoint?.id.slice(0, 8)}" 
518:               and "{compareCheckpoint?.description || compareCheckpoint?.id.slice(0, 8)}"
519:             </DialogDescription>
520:           </DialogHeader>
521:           
522:           {diff && (
523:             <div className="space-y-4 py-4 max-h-[60vh] overflow-y-auto">
524:               {/* Summary */}
525:               <div className="grid grid-cols-3 gap-4">
526:                 <Card>
527:                   <CardContent className="p-3">
528:                     <div className="text-xs text-muted-foreground">Modified Files</div>
529:                     <div className="text-2xl font-bold">{diff.modifiedFiles.length}</div>
530:                   </CardContent>
531:                 </Card>
532:                 <Card>
533:                   <CardContent className="p-3">
534:                     <div className="text-xs text-muted-foreground">Added Files</div>
535:                     <div className="text-2xl font-bold text-green-600">{diff.addedFiles.length}</div>
536:                   </CardContent>
537:                 </Card>
538:                 <Card>
539:                   <CardContent className="p-3">
540:                     <div className="text-xs text-muted-foreground">Deleted Files</div>
541:                     <div className="text-2xl font-bold text-red-600">{diff.deletedFiles.length}</div>
542:                   </CardContent>
543:                 </Card>
544:               </div>
545:               
546:               {/* Token delta */}
547:               <div className="flex items-center justify-center">
548:                 <Badge variant={diff.tokenDelta > 0 ? "default" : "secondary"}>
549:                   {diff.tokenDelta > 0 ? "+" : ""}{diff.tokenDelta.toLocaleString()} tokens
550:                 </Badge>
551:               </div>
552:               
553:               {/* File lists */}
554:               {diff.modifiedFiles.length > 0 && (
555:                 <div>
556:                   <h4 className="text-sm font-medium mb-2">Modified Files</h4>
557:                   <div className="space-y-1">
558:                     {diff.modifiedFiles.map((file) => (
559:                       <div key={file.path} className="flex items-center justify-between text-xs">
560:                         <span className="font-mono">{file.path}</span>
561:                         <div className="flex items-center gap-2 text-xs">
562:                           <span className="text-green-600">+{file.additions}</span>
563:                           <span className="text-red-600">-{file.deletions}</span>
564:                         </div>
565:                       </div>
566:                     ))}
567:                   </div>
568:                 </div>
569:               )}
570:               
571:               {diff.addedFiles.length > 0 && (
572:                 <div>
573:                   <h4 className="text-sm font-medium mb-2">Added Files</h4>
574:                   <div className="space-y-1">
575:                     {diff.addedFiles.map((file) => (
576:                       <div key={file} className="text-xs font-mono text-green-600">
577:                         + {file}
578:                       </div>
579:                     ))}
580:                   </div>
581:                 </div>
582:               )}
583:               
584:               {diff.deletedFiles.length > 0 && (
585:                 <div>
586:                   <h4 className="text-sm font-medium mb-2">Deleted Files</h4>
587:                   <div className="space-y-1">
588:                     {diff.deletedFiles.map((file) => (
589:                       <div key={file} className="text-xs font-mono text-red-600">
590:                         - {file}
591:                       </div>
592:                     ))}
593:                   </div>
594:                 </div>
595:               )}
596:             </div>
597:           )}
598:           
599:           <DialogFooter>
600:             <Button
601:               variant="outline"
602:               onClick={() => {
603:                 setShowDiffDialog(false);
604:                 setDiff(null);
605:                 setCompareCheckpoint(null);
606:               }}
607:             >
608:               Close
609:             </Button>
610:           </DialogFooter>
611:         </DialogContent>
612:       </Dialog>
613:     </div>
614:   );
615: };
````

## File: src/components/TokenCounter.tsx
````typescript
 1: import React from "react";
 2: import { motion } from "framer-motion";
 3: import { Hash } from "lucide-react";
 4: import { cn } from "@/lib/utils";
 5: 
 6: interface TokenCounterProps {
 7:   /**
 8:    * Total number of tokens
 9:    */
10:   tokens: number;
11:   /**
12:    * Whether to show the counter
13:    */
14:   show?: boolean;
15:   /**
16:    * Optional className for styling
17:    */
18:   className?: string;
19: }
20: 
21: /**
22:  * TokenCounter component - Displays a floating token count
23:  * 
24:  * @example
25:  * <TokenCounter tokens={1234} show={true} />
26:  */
27: export const TokenCounter: React.FC<TokenCounterProps> = ({
28:   tokens,
29:   show = true,
30:   className,
31: }) => {
32:   if (!show || tokens === 0) return null;
33: 
34:   return (
35:     <motion.div
36:       initial={{ opacity: 0, scale: 0.8 }}
37:       animate={{ opacity: 1, scale: 1 }}
38:       exit={{ opacity: 0, scale: 0.8 }}
39:       className={cn(
40:         "fixed bottom-20 right-4 z-30",
41:         "bg-background/90 backdrop-blur-sm",
42:         "border border-border rounded-full",
43:         "px-3 py-1.5 shadow-lg",
44:         className
45:       )}
46:     >
47:       <div className="flex items-center gap-1.5 text-xs">
48:         <Hash className="h-3 w-3 text-muted-foreground" />
49:         <span className="font-mono">{tokens.toLocaleString()}</span>
50:         <span className="text-muted-foreground">tokens</span>
51:       </div>
52:     </motion.div>
53:   );
54: };
````

## File: src/components/ToolWidgets.new.tsx
````typescript
1: // This file re-exports all widgets from the widgets directory
2: // It maintains backward compatibility with the original ToolWidgets.tsx
3: 
4: export * from './widgets';
````

## File: src/components/ToolWidgets.tsx
````typescript
   1: import React, { useState } from "react";
   2: import { 
   3:   CheckCircle2, 
   4:   Circle, 
   5:   Clock,
   6:   FolderOpen,
   7:   FileText,
   8:   Search,
   9:   Terminal,
  10:   FileEdit,
  11:   Code,
  12:   ChevronRight,
  13:   Maximize2,
  14:   GitBranch,
  15:   X,
  16:   Info,
  17:   AlertCircle,
  18:   Settings,
  19:   Fingerprint,
  20:   Cpu,
  21:   FolderSearch,
  22:   List,
  23:   LogOut,
  24:   Edit3,
  25:   FilePlus,
  26:   Book,
  27:   BookOpen,
  28:   Globe,
  29:   ListChecks,
  30:   ListPlus,
  31:   Globe2,
  32:   Package,
  33:   ChevronDown,
  34:   Package2,
  35:   Wrench,
  36:   CheckSquare,
  37:   type LucideIcon,
  38:   Sparkles,
  39:   Bot,
  40:   Zap,
  41:   FileCode,
  42:   Folder,
  43:   ChevronUp,
  44:   BarChart3,
  45:   Download,
  46:   LayoutGrid,
  47:   LayoutList,
  48:   Activity,
  49:   Hash,
  50: } from "lucide-react";
  51: import { Badge } from "@/components/ui/badge";
  52: import { cn } from "@/lib/utils";
  53: import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
  54: import { getClaudeSyntaxTheme } from "@/lib/claudeSyntaxTheme";
  55: import { useTheme } from "@/hooks";
  56: import { Button } from "@/components/ui/button";
  57: import { createPortal } from "react-dom";
  58: import * as Diff from 'diff';
  59: import { Card, CardContent } from "@/components/ui/card";
  60: import { detectLinks, makeLinksClickable } from "@/lib/linkDetector";
  61: import ReactMarkdown from "react-markdown";
  62: import { open } from "@tauri-apps/plugin-shell";
  63: import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
  64: import { Input } from "@/components/ui/input";
  65: import { motion, AnimatePresence } from "framer-motion";
  66: 
  67: /**
  68:  * Widget for TodoWrite tool - displays a beautiful TODO list
  69:  */
  70: export const TodoWidget: React.FC<{ todos: any[]; result?: any }> = ({ todos, result: _result }) => {
  71:   const statusIcons = {
  72:     completed: <CheckCircle2 className="h-4 w-4 text-green-500" />,
  73:     in_progress: <Clock className="h-4 w-4 text-blue-500 animate-pulse" />,
  74:     pending: <Circle className="h-4 w-4 text-muted-foreground" />
  75:   };
  76: 
  77:   const priorityColors = {
  78:     high: "bg-red-500/10 text-red-500 border-red-500/20",
  79:     medium: "bg-yellow-500/10 text-yellow-500 border-yellow-500/20",
  80:     low: "bg-green-500/10 text-green-500 border-green-500/20"
  81:   };
  82: 
  83:   return (
  84:     <div className="space-y-2">
  85:       <div className="flex items-center gap-2 mb-3">
  86:         <FileEdit className="h-4 w-4 text-primary" />
  87:         <span className="text-sm font-medium">Todo List</span>
  88:       </div>
  89:       <div className="space-y-2">
  90:         {todos.map((todo, idx) => (
  91:           <div
  92:             key={todo.id || idx}
  93:             className={cn(
  94:               "flex items-start gap-3 p-3 rounded-lg border bg-card/50",
  95:               todo.status === "completed" && "opacity-60"
  96:             )}
  97:           >
  98:             <div className="mt-0.5">
  99:               {statusIcons[todo.status as keyof typeof statusIcons] || statusIcons.pending}
 100:             </div>
 101:             <div className="flex-1 space-y-1">
 102:               <p className={cn(
 103:                 "text-sm",
 104:                 todo.status === "completed" && "line-through"
 105:               )}>
 106:                 {todo.content}
 107:               </p>
 108:               {todo.priority && (
 109:                 <Badge 
 110:                   variant="outline" 
 111:                   className={cn("text-xs", priorityColors[todo.priority as keyof typeof priorityColors])}
 112:                 >
 113:                   {todo.priority}
 114:                 </Badge>
 115:               )}
 116:             </div>
 117:           </div>
 118:         ))}
 119:       </div>
 120:     </div>
 121:   );
 122: };
 123: 
 124: /**
 125:  * Widget for LS (List Directory) tool
 126:  */
 127: export const LSWidget: React.FC<{ path: string; result?: any }> = ({ path, result }) => {
 128:   // If we have a result, show it using the LSResultWidget
 129:   if (result) {
 130:     let resultContent = '';
 131:     if (typeof result.content === 'string') {
 132:       resultContent = result.content;
 133:     } else if (result.content && typeof result.content === 'object') {
 134:       if (result.content.text) {
 135:         resultContent = result.content.text;
 136:       } else if (Array.isArray(result.content)) {
 137:         resultContent = result.content
 138:           .map((c: any) => (typeof c === 'string' ? c : c.text || JSON.stringify(c)))
 139:           .join('\n');
 140:       } else {
 141:         resultContent = JSON.stringify(result.content, null, 2);
 142:       }
 143:     }
 144:     
 145:     return (
 146:       <div className="space-y-2">
 147:         <div className="flex items-center gap-2 p-3 rounded-lg bg-muted/50">
 148:           <FolderOpen className="h-4 w-4 text-primary" />
 149:           <span className="text-sm">Directory contents for:</span>
 150:           <code className="text-sm font-mono bg-background px-2 py-0.5 rounded">
 151:             {path}
 152:           </code>
 153:         </div>
 154:         {resultContent && <LSResultWidget content={resultContent} />}
 155:       </div>
 156:     );
 157:   }
 158:   
 159:   return (
 160:     <div className="flex items-center gap-2 p-3 rounded-lg bg-muted/50">
 161:       <FolderOpen className="h-4 w-4 text-primary" />
 162:       <span className="text-sm">Listing directory:</span>
 163:       <code className="text-sm font-mono bg-background px-2 py-0.5 rounded">
 164:         {path}
 165:       </code>
 166:       {!result && (
 167:         <div className="ml-auto flex items-center gap-1 text-xs text-muted-foreground">
 168:           <div className="h-2 w-2 bg-blue-500 rounded-full animate-pulse" />
 169:           <span>Loading...</span>
 170:         </div>
 171:       )}
 172:     </div>
 173:   );
 174: };
 175: 
 176: /**
 177:  * Widget for LS tool result - displays directory tree structure
 178:  */
 179: export const LSResultWidget: React.FC<{ content: string }> = ({ content }) => {
 180:   const [expandedDirs, setExpandedDirs] = useState<Set<string>>(new Set());
 181:   
 182:   // Parse the directory tree structure
 183:   const parseDirectoryTree = (rawContent: string) => {
 184:     const lines = rawContent.split('\n');
 185:     const entries: Array<{
 186:       path: string;
 187:       name: string;
 188:       type: 'file' | 'directory';
 189:       level: number;
 190:     }> = [];
 191:     
 192:     let currentPath: string[] = [];
 193:     
 194:     for (const line of lines) {
 195:       // Skip NOTE section and everything after it
 196:       if (line.startsWith('NOTE:')) {
 197:         break;
 198:       }
 199:       
 200:       // Skip empty lines
 201:       if (!line.trim()) continue;
 202:       
 203:       // Calculate indentation level
 204:       const indent = line.match(/^(\s*)/)?.[1] || '';
 205:       const level = Math.floor(indent.length / 2);
 206:       
 207:       // Extract the entry name
 208:       const entryMatch = line.match(/^\s*-\s+(.+?)(\/$)?$/);
 209:       if (!entryMatch) continue;
 210:       
 211:       const fullName = entryMatch[1];
 212:       const isDirectory = line.trim().endsWith('/');
 213:       const name = isDirectory ? fullName : fullName;
 214:       
 215:       // Update current path based on level
 216:       currentPath = currentPath.slice(0, level);
 217:       currentPath.push(name);
 218:       
 219:       entries.push({
 220:         path: currentPath.join('/'),
 221:         name,
 222:         type: isDirectory ? 'directory' : 'file',
 223:         level,
 224:       });
 225:     }
 226:     
 227:     return entries;
 228:   };
 229:   
 230:   const entries = parseDirectoryTree(content);
 231:   
 232:   const toggleDirectory = (path: string) => {
 233:     setExpandedDirs(prev => {
 234:       const next = new Set(prev);
 235:       if (next.has(path)) {
 236:         next.delete(path);
 237:       } else {
 238:         next.add(path);
 239:       }
 240:       return next;
 241:     });
 242:   };
 243:   
 244:   // Group entries by parent for collapsible display
 245:   const getChildren = (parentPath: string, parentLevel: number) => {
 246:     return entries.filter(e => {
 247:       if (e.level !== parentLevel + 1) return false;
 248:       const parentParts = parentPath.split('/').filter(Boolean);
 249:       const entryParts = e.path.split('/').filter(Boolean);
 250:       
 251:       // Check if this entry is a direct child of the parent
 252:       if (entryParts.length !== parentParts.length + 1) return false;
 253:       
 254:       // Check if all parent parts match
 255:       for (let i = 0; i < parentParts.length; i++) {
 256:         if (parentParts[i] !== entryParts[i]) return false;
 257:       }
 258:       
 259:       return true;
 260:     });
 261:   };
 262:   
 263:   const renderEntry = (entry: typeof entries[0], isRoot = false) => {
 264:     const hasChildren = entry.type === 'directory' && 
 265:       entries.some(e => e.path.startsWith(entry.path + '/') && e.level === entry.level + 1);
 266:     const isExpanded = expandedDirs.has(entry.path) || isRoot;
 267:     
 268:     const getIcon = () => {
 269:       if (entry.type === 'directory') {
 270:         return isExpanded ? 
 271:           <FolderOpen className="h-3.5 w-3.5 text-blue-500" /> : 
 272:           <Folder className="h-3.5 w-3.5 text-blue-500" />;
 273:       }
 274:       
 275:       // File type icons based on extension
 276:       const ext = entry.name.split('.').pop()?.toLowerCase();
 277:       switch (ext) {
 278:         case 'rs':
 279:           return <FileCode className="h-3.5 w-3.5 text-orange-500" />;
 280:         case 'toml':
 281:         case 'yaml':
 282:         case 'yml':
 283:         case 'json':
 284:           return <FileText className="h-3.5 w-3.5 text-yellow-500" />;
 285:         case 'md':
 286:           return <FileText className="h-3.5 w-3.5 text-blue-400" />;
 287:         case 'js':
 288:         case 'jsx':
 289:         case 'ts':
 290:         case 'tsx':
 291:           return <FileCode className="h-3.5 w-3.5 text-yellow-400" />;
 292:         case 'py':
 293:           return <FileCode className="h-3.5 w-3.5 text-blue-500" />;
 294:         case 'go':
 295:           return <FileCode className="h-3.5 w-3.5 text-cyan-500" />;
 296:         case 'sh':
 297:         case 'bash':
 298:           return <Terminal className="h-3.5 w-3.5 text-green-500" />;
 299:         default:
 300:           return <FileText className="h-3.5 w-3.5 text-muted-foreground" />;
 301:       }
 302:     };
 303:     
 304:     return (
 305:       <div key={entry.path}>
 306:         <div 
 307:           className={cn(
 308:             "flex items-center gap-2 py-1 px-2 rounded hover:bg-muted/50 transition-colors cursor-pointer",
 309:             !isRoot && "ml-4"
 310:           )}
 311:           onClick={() => entry.type === 'directory' && hasChildren && toggleDirectory(entry.path)}
 312:         >
 313:           {entry.type === 'directory' && hasChildren && (
 314:             <ChevronRight className={cn(
 315:               "h-3 w-3 text-muted-foreground transition-transform",
 316:               isExpanded && "rotate-90"
 317:             )} />
 318:           )}
 319:           {(!hasChildren || entry.type !== 'directory') && (
 320:             <div className="w-3" />
 321:           )}
 322:           {getIcon()}
 323:           <span className="text-sm font-mono">{entry.name}</span>
 324:         </div>
 325:         
 326:         {entry.type === 'directory' && hasChildren && isExpanded && (
 327:           <div className="ml-2">
 328:             {getChildren(entry.path, entry.level).map(child => renderEntry(child))}
 329:           </div>
 330:         )}
 331:       </div>
 332:     );
 333:   };
 334:   
 335:   // Get root entries
 336:   const rootEntries = entries.filter(e => e.level === 0);
 337:   
 338:   return (
 339:     <div className="rounded-lg border bg-muted/20 p-3">
 340:       <div className="space-y-1">
 341:         {rootEntries.map(entry => renderEntry(entry, true))}
 342:       </div>
 343:     </div>
 344:   );
 345: };
 346: 
 347: /**
 348:  * Widget for Read tool
 349:  */
 350: export const ReadWidget: React.FC<{ filePath: string; result?: any }> = ({ filePath, result }) => {
 351:   // If we have a result, show it using the ReadResultWidget
 352:   if (result) {
 353:     let resultContent = '';
 354:     if (typeof result.content === 'string') {
 355:       resultContent = result.content;
 356:     } else if (result.content && typeof result.content === 'object') {
 357:       if (result.content.text) {
 358:         resultContent = result.content.text;
 359:       } else if (Array.isArray(result.content)) {
 360:         resultContent = result.content
 361:           .map((c: any) => (typeof c === 'string' ? c : c.text || JSON.stringify(c)))
 362:           .join('\n');
 363:       } else {
 364:         resultContent = JSON.stringify(result.content, null, 2);
 365:       }
 366:     }
 367:     
 368:     return (
 369:       <div className="space-y-2">
 370:         <div className="flex items-center gap-2 p-3 rounded-lg bg-muted/50">
 371:           <FileText className="h-4 w-4 text-primary" />
 372:           <span className="text-sm">File content:</span>
 373:           <code className="text-sm font-mono bg-background px-2 py-0.5 rounded flex-1 truncate">
 374:             {filePath}
 375:           </code>
 376:         </div>
 377:         {resultContent && <ReadResultWidget content={resultContent} filePath={filePath} />}
 378:       </div>
 379:     );
 380:   }
 381:   
 382:   return (
 383:     <div className="flex items-center gap-2 p-3 rounded-lg bg-muted/50">
 384:       <FileText className="h-4 w-4 text-primary" />
 385:       <span className="text-sm">Reading file:</span>
 386:       <code className="text-sm font-mono bg-background px-2 py-0.5 rounded flex-1 truncate">
 387:         {filePath}
 388:       </code>
 389:       {!result && (
 390:         <div className="ml-auto flex items-center gap-1 text-xs text-muted-foreground">
 391:           <div className="h-2 w-2 bg-blue-500 rounded-full animate-pulse" />
 392:           <span>Loading...</span>
 393:         </div>
 394:       )}
 395:     </div>
 396:   );
 397: };
 398: 
 399: /**
 400:  * Widget for Read tool result - shows file content with line numbers
 401:  */
 402: export const ReadResultWidget: React.FC<{ content: string; filePath?: string }> = ({ content, filePath }) => {
 403:   const [isExpanded, setIsExpanded] = useState(false);
 404:   const { theme } = useTheme();
 405:   const syntaxTheme = getClaudeSyntaxTheme(theme);
 406:   
 407:   // Extract file extension for syntax highlighting
 408:   const getLanguage = (path?: string) => {
 409:     if (!path) return "text";
 410:     const ext = path.split('.').pop()?.toLowerCase();
 411:     const languageMap: Record<string, string> = {
 412:       ts: "typescript",
 413:       tsx: "tsx",
 414:       js: "javascript",
 415:       jsx: "jsx",
 416:       py: "python",
 417:       rs: "rust",
 418:       go: "go",
 419:       java: "java",
 420:       cpp: "cpp",
 421:       c: "c",
 422:       cs: "csharp",
 423:       php: "php",
 424:       rb: "ruby",
 425:       swift: "swift",
 426:       kt: "kotlin",
 427:       scala: "scala",
 428:       sh: "bash",
 429:       bash: "bash",
 430:       zsh: "bash",
 431:       yaml: "yaml",
 432:       yml: "yaml",
 433:       json: "json",
 434:       xml: "xml",
 435:       html: "html",
 436:       css: "css",
 437:       scss: "scss",
 438:       sass: "sass",
 439:       less: "less",
 440:       sql: "sql",
 441:       md: "markdown",
 442:       toml: "ini",
 443:       ini: "ini",
 444:       dockerfile: "dockerfile",
 445:       makefile: "makefile"
 446:     };
 447:     return languageMap[ext || ""] || "text";
 448:   };
 449: 
 450:   // Parse content to separate line numbers from code
 451:   const parseContent = (rawContent: string) => {
 452:     const lines = rawContent.split('\n');
 453:     const codeLines: string[] = [];
 454:     let minLineNumber = Infinity;
 455: 
 456:     // First, determine if the content is likely a numbered list from the 'read' tool.
 457:     // It is if more than half the non-empty lines match the expected format.
 458:     const nonEmptyLines = lines.filter(line => line.trim() !== '');
 459:     if (nonEmptyLines.length === 0) {
 460:       return { codeContent: rawContent, startLineNumber: 1 };
 461:     }
 462:     const parsableLines = nonEmptyLines.filter(line => /^\s*\d+→/.test(line)).length;
 463:     const isLikelyNumbered = (parsableLines / nonEmptyLines.length) > 0.5;
 464: 
 465:     if (!isLikelyNumbered) {
 466:       return { codeContent: rawContent, startLineNumber: 1 };
 467:     }
 468:     
 469:     // If it's a numbered list, parse it strictly.
 470:     for (const line of lines) {
 471:       // Remove leading whitespace before parsing
 472:       const trimmedLine = line.trimStart();
 473:       const match = trimmedLine.match(/^(\d+)→(.*)$/);
 474:       if (match) {
 475:         const lineNum = parseInt(match[1], 10);
 476:         if (minLineNumber === Infinity) {
 477:           minLineNumber = lineNum;
 478:         }
 479:         // Preserve the code content exactly as it appears after the arrow
 480:         codeLines.push(match[2]);
 481:       } else if (line.trim() === '') {
 482:         // Preserve empty lines
 483:         codeLines.push('');
 484:       } else {
 485:         // If a line in a numbered block does not match, it's a formatting anomaly.
 486:         // Render it as a blank line to avoid showing the raw, un-parsed string.
 487:         codeLines.push('');
 488:       }
 489:     }
 490:     
 491:     // Remove trailing empty lines
 492:     while (codeLines.length > 0 && codeLines[codeLines.length - 1] === '') {
 493:       codeLines.pop();
 494:     }
 495:     
 496:     return {
 497:       codeContent: codeLines.join('\n'),
 498:       startLineNumber: minLineNumber === Infinity ? 1 : minLineNumber
 499:     };
 500:   };
 501: 
 502:   const language = getLanguage(filePath);
 503:   const { codeContent, startLineNumber } = parseContent(content);
 504:   const lineCount = content.split('\n').filter(line => line.trim()).length;
 505:   const isLargeFile = lineCount > 20;
 506: 
 507:   return (
 508:     <div className="rounded-lg overflow-hidden border bg-zinc-950 w-full">
 509:       <div className="px-4 py-2 border-b bg-zinc-900/50 flex items-center justify-between">
 510:         <div className="flex items-center gap-2">
 511:           <FileText className="h-3.5 w-3.5 text-muted-foreground" />
 512:           <span className="text-xs font-mono text-muted-foreground">
 513:             {filePath || "File content"}
 514:           </span>
 515:           {isLargeFile && (
 516:             <span className="text-xs text-muted-foreground">
 517:               ({lineCount} lines)
 518:             </span>
 519:           )}
 520:         </div>
 521:         {isLargeFile && (
 522:           <button
 523:             onClick={() => setIsExpanded(!isExpanded)}
 524:             className="flex items-center gap-1 text-xs text-muted-foreground hover:text-foreground transition-colors"
 525:           >
 526:             <ChevronRight className={cn("h-3 w-3 transition-transform", isExpanded && "rotate-90")} />
 527:             {isExpanded ? "Collapse" : "Expand"}
 528:           </button>
 529:         )}
 530:       </div>
 531:       
 532:       {(!isLargeFile || isExpanded) && (
 533:         <div className="relative overflow-x-auto">
 534:           <SyntaxHighlighter
 535:             language={language}
 536:             style={syntaxTheme}
 537:             showLineNumbers
 538:             startingLineNumber={startLineNumber}
 539:             wrapLongLines={false}
 540:             customStyle={{
 541:               margin: 0,
 542:               background: 'transparent',
 543:               lineHeight: '1.6'
 544:             }}
 545:             codeTagProps={{
 546:               style: {
 547:                 fontSize: '0.75rem'
 548:               }
 549:             }}
 550:             lineNumberStyle={{
 551:               minWidth: "3.5rem",
 552:               paddingRight: "1rem",
 553:               textAlign: "right",
 554:               opacity: 0.5,
 555:             }}
 556:           >
 557:             {codeContent}
 558:           </SyntaxHighlighter>
 559:         </div>
 560:       )}
 561:       
 562:       {isLargeFile && !isExpanded && (
 563:         <div className="px-4 py-3 text-xs text-muted-foreground text-center bg-zinc-900/30">
 564:           Click "Expand" to view the full file
 565:         </div>
 566:       )}
 567:     </div>
 568:   );
 569: };
 570: 
 571: /**
 572:  * Widget for Glob tool
 573:  */
 574: export const GlobWidget: React.FC<{ pattern: string; result?: any }> = ({ pattern, result }) => {
 575:   // Extract result content if available
 576:   let resultContent = '';
 577:   let isError = false;
 578:   
 579:   if (result) {
 580:     isError = result.is_error || false;
 581:     if (typeof result.content === 'string') {
 582:       resultContent = result.content;
 583:     } else if (result.content && typeof result.content === 'object') {
 584:       if (result.content.text) {
 585:         resultContent = result.content.text;
 586:       } else if (Array.isArray(result.content)) {
 587:         resultContent = result.content
 588:           .map((c: any) => (typeof c === 'string' ? c : c.text || JSON.stringify(c)))
 589:           .join('\n');
 590:       } else {
 591:         resultContent = JSON.stringify(result.content, null, 2);
 592:       }
 593:     }
 594:   }
 595:   
 596:   return (
 597:     <div className="space-y-2">
 598:       <div className="flex items-center gap-2 p-3 rounded-lg bg-muted/50">
 599:         <Search className="h-4 w-4 text-primary" />
 600:         <span className="text-sm">Searching for pattern:</span>
 601:         <code className="text-sm font-mono bg-background px-2 py-0.5 rounded">
 602:           {pattern}
 603:         </code>
 604:         {!result && (
 605:           <div className="ml-auto flex items-center gap-1 text-xs text-muted-foreground">
 606:             <div className="h-2 w-2 bg-blue-500 rounded-full animate-pulse" />
 607:             <span>Searching...</span>
 608:           </div>
 609:         )}
 610:       </div>
 611:       
 612:       {/* Show result if available */}
 613:       {result && (
 614:         <div className={cn(
 615:           "p-3 rounded-md border text-xs font-mono whitespace-pre-wrap overflow-x-auto",
 616:           isError 
 617:             ? "border-red-500/20 bg-red-500/5 text-red-400" 
 618:             : "border-green-500/20 bg-green-500/5 text-green-300"
 619:         )}>
 620:           {resultContent || (isError ? "Search failed" : "No matches found")}
 621:         </div>
 622:       )}
 623:     </div>
 624:   );
 625: };
 626: 
 627: /**
 628:  * Widget for Bash tool
 629:  */
 630: export const BashWidget: React.FC<{ 
 631:   command: string; 
 632:   description?: string;
 633:   result?: any;
 634: }> = ({ command, description, result }) => {
 635:   // Extract result content if available
 636:   let resultContent = '';
 637:   let isError = false;
 638:   
 639:   if (result) {
 640:     isError = result.is_error || false;
 641:     if (typeof result.content === 'string') {
 642:       resultContent = result.content;
 643:     } else if (result.content && typeof result.content === 'object') {
 644:       if (result.content.text) {
 645:         resultContent = result.content.text;
 646:       } else if (Array.isArray(result.content)) {
 647:         resultContent = result.content
 648:           .map((c: any) => (typeof c === 'string' ? c : c.text || JSON.stringify(c)))
 649:           .join('\n');
 650:       } else {
 651:         resultContent = JSON.stringify(result.content, null, 2);
 652:       }
 653:     }
 654:   }
 655:   
 656:   return (
 657:     <div className="rounded-lg border bg-zinc-950 overflow-hidden">
 658:       <div className="px-4 py-2 bg-zinc-900/50 flex items-center gap-2 border-b">
 659:         <Terminal className="h-3.5 w-3.5 text-green-500" />
 660:         <span className="text-xs font-mono text-muted-foreground">Terminal</span>
 661:         {description && (
 662:           <>
 663:             <ChevronRight className="h-3 w-3 text-muted-foreground" />
 664:             <span className="text-xs text-muted-foreground">{description}</span>
 665:           </>
 666:         )}
 667:         {/* Show loading indicator when no result yet */}
 668:         {!result && (
 669:           <div className="ml-auto flex items-center gap-1 text-xs text-muted-foreground">
 670:             <div className="h-2 w-2 bg-green-500 rounded-full animate-pulse" />
 671:             <span>Running...</span>
 672:           </div>
 673:         )}
 674:       </div>
 675:       <div className="p-4 space-y-3">
 676:         <code className="text-xs font-mono text-green-400 block">
 677:           $ {command}
 678:         </code>
 679:         
 680:         {/* Show result if available */}
 681:         {result && (
 682:           <div className={cn(
 683:             "mt-3 p-3 rounded-md border text-xs font-mono whitespace-pre-wrap overflow-x-auto",
 684:             isError 
 685:               ? "border-red-500/20 bg-red-500/5 text-red-400" 
 686:               : "border-green-500/20 bg-green-500/5 text-green-300"
 687:           )}>
 688:             {resultContent || (isError ? "Command failed" : "Command completed")}
 689:           </div>
 690:         )}
 691:       </div>
 692:     </div>
 693:   );
 694: };
 695: 
 696: /**
 697:  * Widget for Write tool
 698:  */
 699: export const WriteWidget: React.FC<{ filePath: string; content: string; result?: any }> = ({ filePath, content, result: _result }) => {
 700:   const [isMaximized, setIsMaximized] = useState(false);
 701:   const { theme } = useTheme();
 702:   const syntaxTheme = getClaudeSyntaxTheme(theme);
 703:   
 704:   // Extract file extension for syntax highlighting
 705:   const getLanguage = (path: string) => {
 706:     const ext = path.split('.').pop()?.toLowerCase();
 707:     const languageMap: Record<string, string> = {
 708:       ts: "typescript",
 709:       tsx: "tsx",
 710:       js: "javascript",
 711:       jsx: "jsx",
 712:       py: "python",
 713:       rs: "rust",
 714:       go: "go",
 715:       java: "java",
 716:       cpp: "cpp",
 717:       c: "c",
 718:       cs: "csharp",
 719:       php: "php",
 720:       rb: "ruby",
 721:       swift: "swift",
 722:       kt: "kotlin",
 723:       scala: "scala",
 724:       sh: "bash",
 725:       bash: "bash",
 726:       zsh: "bash",
 727:       yaml: "yaml",
 728:       yml: "yaml",
 729:       json: "json",
 730:       xml: "xml",
 731:       html: "html",
 732:       css: "css",
 733:       scss: "scss",
 734:       sass: "sass",
 735:       less: "less",
 736:       sql: "sql",
 737:       md: "markdown",
 738:       toml: "ini",
 739:       ini: "ini",
 740:       dockerfile: "dockerfile",
 741:       makefile: "makefile"
 742:     };
 743:     return languageMap[ext || ""] || "text";
 744:   };
 745: 
 746:   const language = getLanguage(filePath);
 747:   const isLargeContent = content.length > 1000;
 748:   const displayContent = isLargeContent ? content.substring(0, 1000) + "\n..." : content;
 749: 
 750:   // Maximized view as a modal
 751:   const MaximizedView = () => {
 752:     if (!isMaximized) return null;
 753:     
 754:     return createPortal(
 755:       <div className="fixed inset-0 z-50 flex items-center justify-center">
 756:         {/* Backdrop with blur */}
 757:         <div 
 758:           className="absolute inset-0 bg-black/60 backdrop-blur-sm"
 759:           onClick={() => setIsMaximized(false)}
 760:         />
 761:         
 762:         {/* Modal content */}
 763:         <div className="relative w-[90vw] h-[90vh] max-w-7xl bg-zinc-950 rounded-lg border shadow-2xl overflow-hidden flex flex-col">
 764:           {/* Header */}
 765:           <div className="px-6 py-4 border-b bg-zinc-950 flex items-center justify-between">
 766:             <div className="flex items-center gap-3">
 767:               <FileText className="h-4 w-4 text-muted-foreground" />
 768:               <span className="text-sm font-mono text-muted-foreground">{filePath}</span>
 769:             </div>
 770:             <Button 
 771:               variant="ghost" 
 772:               size="icon" 
 773:               className="h-8 w-8"
 774:               onClick={() => setIsMaximized(false)}
 775:             >
 776:               <X className="h-4 w-4" />
 777:             </Button>
 778:           </div>
 779:           
 780:           {/* Code content */}
 781:           <div className="flex-1 overflow-auto">
 782:             <SyntaxHighlighter
 783:               language={language}
 784:               style={syntaxTheme}
 785:               customStyle={{
 786:                 margin: 0,
 787:                 padding: '1.5rem',
 788:                 background: 'transparent',
 789:                 fontSize: '0.75rem',
 790:                 lineHeight: '1.5',
 791:                 height: '100%'
 792:               }}
 793:               showLineNumbers
 794:             >
 795:               {content}
 796:             </SyntaxHighlighter>
 797:           </div>
 798:         </div>
 799:       </div>,
 800:       document.body
 801:     );
 802:   };
 803: 
 804:   const CodePreview = ({ codeContent, truncated }: { codeContent: string; truncated: boolean }) => (
 805:     <div 
 806:       className="rounded-lg border bg-zinc-950 overflow-hidden w-full"
 807:       style={{ 
 808:         height: truncated ? '440px' : 'auto', 
 809:         maxHeight: truncated ? '440px' : undefined,
 810:         display: 'flex', 
 811:         flexDirection: 'column' 
 812:       }}
 813:     >
 814:       <div className="px-4 py-2 border-b bg-zinc-950 flex items-center justify-between sticky top-0 z-10">
 815:         <span className="text-xs font-mono text-muted-foreground">Preview</span>
 816:         {isLargeContent && truncated && (
 817:           <div className="flex items-center gap-2">
 818:             <Badge variant="outline" className="text-xs whitespace-nowrap">
 819:               Truncated to 1000 chars
 820:             </Badge>
 821:             <Button 
 822:               variant="ghost" 
 823:               size="icon" 
 824:               className="h-6 w-6"
 825:               onClick={() => setIsMaximized(true)}
 826:             >
 827:               <Maximize2 className="h-3 w-3" />
 828:             </Button>
 829:           </div>
 830:         )}
 831:       </div>
 832:       <div className="overflow-auto flex-1">
 833:         <SyntaxHighlighter
 834:           language={language}
 835:           style={syntaxTheme}
 836:           customStyle={{
 837:             margin: 0,
 838:             padding: '1rem',
 839:             background: 'transparent',
 840:             fontSize: '0.75rem',
 841:             lineHeight: '1.5',
 842:             overflowX: 'auto'
 843:           }}
 844:           wrapLongLines={false}
 845:         >
 846:           {codeContent}
 847:         </SyntaxHighlighter>
 848:       </div>
 849:     </div>
 850:   );
 851: 
 852:   return (
 853:     <div className="space-y-2">
 854:       <div className="flex items-center gap-2 p-3 rounded-lg bg-muted/50">
 855:         <FileEdit className="h-4 w-4 text-primary" />
 856:         <span className="text-sm">Writing to file:</span>
 857:         <code className="text-sm font-mono bg-background px-2 py-0.5 rounded flex-1 truncate">
 858:           {filePath}
 859:         </code>
 860:       </div>
 861:       <CodePreview codeContent={displayContent} truncated={true} />
 862:       <MaximizedView />
 863:     </div>
 864:   );
 865: };
 866: 
 867: /**
 868:  * Widget for Grep tool
 869:  */
 870: export const GrepWidget: React.FC<{ 
 871:   pattern: string; 
 872:   include?: string; 
 873:   path?: string;
 874:   exclude?: string;
 875:   result?: any;
 876: }> = ({ pattern, include, path, exclude, result }) => {
 877:   const [isExpanded, setIsExpanded] = useState(true);
 878:   
 879:   // Extract result content if available
 880:   let resultContent = '';
 881:   let isError = false;
 882:   
 883:   if (result) {
 884:     isError = result.is_error || false;
 885:     if (typeof result.content === 'string') {
 886:       resultContent = result.content;
 887:     } else if (result.content && typeof result.content === 'object') {
 888:       if (result.content.text) {
 889:         resultContent = result.content.text;
 890:       } else if (Array.isArray(result.content)) {
 891:         resultContent = result.content
 892:           .map((c: any) => (typeof c === 'string' ? c : c.text || JSON.stringify(c)))
 893:           .join('\n');
 894:       } else {
 895:         resultContent = JSON.stringify(result.content, null, 2);
 896:       }
 897:     }
 898:   }
 899:   
 900:   // Parse grep results to extract file paths and matches
 901:   const parseGrepResults = (content: string) => {
 902:     const lines = content.split('\n').filter(line => line.trim());
 903:     const results: Array<{
 904:       file: string;
 905:       lineNumber: number;
 906:       content: string;
 907:     }> = [];
 908:     
 909:     lines.forEach(line => {
 910:       // Common grep output format: filename:lineNumber:content
 911:       const match = line.match(/^(.+?):(\d+):(.*)$/);
 912:       if (match) {
 913:         results.push({
 914:           file: match[1],
 915:           lineNumber: parseInt(match[2], 10),
 916:           content: match[3]
 917:         });
 918:       }
 919:     });
 920:     
 921:     return results;
 922:   };
 923:   
 924:   const grepResults = result && !isError ? parseGrepResults(resultContent) : [];
 925:   
 926:   return (
 927:     <div className="space-y-2">
 928:       <div className="flex items-center gap-2 p-3 rounded-lg bg-gradient-to-r from-emerald-500/10 to-teal-500/10 border border-emerald-500/20">
 929:         <Search className="h-4 w-4 text-emerald-500" />
 930:         <span className="text-sm font-medium">Searching with grep</span>
 931:         {!result && (
 932:           <div className="ml-auto flex items-center gap-1 text-xs text-muted-foreground">
 933:             <div className="h-2 w-2 bg-emerald-500 rounded-full animate-pulse" />
 934:             <span>Searching...</span>
 935:           </div>
 936:         )}
 937:       </div>
 938:       
 939:       {/* Search Parameters */}
 940:       <div className="rounded-lg border bg-muted/20 p-3 space-y-2">
 941:         <div className="grid gap-2">
 942:           {/* Pattern with regex highlighting */}
 943:           <div className="flex items-start gap-3">
 944:             <div className="flex items-center gap-1.5 min-w-[80px]">
 945:               <Code className="h-3 w-3 text-emerald-500" />
 946:               <span className="text-xs font-medium text-muted-foreground">Pattern</span>
 947:             </div>
 948:             <code className="flex-1 font-mono text-sm bg-emerald-500/10 border border-emerald-500/20 px-3 py-1.5 rounded-md text-emerald-600 dark:text-emerald-400">
 949:               {pattern}
 950:             </code>
 951:           </div>
 952:           
 953:           {/* Path */}
 954:           {path && (
 955:             <div className="flex items-start gap-3">
 956:               <div className="flex items-center gap-1.5 min-w-[80px]">
 957:                 <FolderOpen className="h-3 w-3 text-muted-foreground" />
 958:                 <span className="text-xs font-medium text-muted-foreground">Path</span>
 959:               </div>
 960:               <code className="flex-1 font-mono text-xs bg-muted px-2 py-1 rounded truncate">
 961:                 {path}
 962:               </code>
 963:             </div>
 964:           )}
 965:           
 966:           {/* Include/Exclude patterns in a row */}
 967:           {(include || exclude) && (
 968:             <div className="flex gap-4">
 969:               {include && (
 970:                 <div className="flex items-center gap-2 flex-1">
 971:                   <div className="flex items-center gap-1.5">
 972:                     <FilePlus className="h-3 w-3 text-green-500" />
 973:                     <span className="text-xs font-medium text-muted-foreground">Include</span>
 974:                   </div>
 975:                   <code className="font-mono text-xs bg-green-500/10 border border-green-500/20 px-2 py-0.5 rounded text-green-600 dark:text-green-400">
 976:                     {include}
 977:                   </code>
 978:                 </div>
 979:               )}
 980:               
 981:               {exclude && (
 982:                 <div className="flex items-center gap-2 flex-1">
 983:                   <div className="flex items-center gap-1.5">
 984:                     <X className="h-3 w-3 text-red-500" />
 985:                     <span className="text-xs font-medium text-muted-foreground">Exclude</span>
 986:                   </div>
 987:                   <code className="font-mono text-xs bg-red-500/10 border border-red-500/20 px-2 py-0.5 rounded text-red-600 dark:text-red-400">
 988:                     {exclude}
 989:                   </code>
 990:                 </div>
 991:               )}
 992:             </div>
 993:           )}
 994:         </div>
 995:       </div>
 996:       
 997:       {/* Results */}
 998:       {result && (
 999:         <div className="space-y-2">
1000:           {isError ? (
1001:             <div className="flex items-center gap-3 p-4 rounded-lg bg-red-500/10 border border-red-500/20">
1002:               <AlertCircle className="h-5 w-5 text-red-500 flex-shrink-0" />
1003:               <div className="text-sm text-red-600 dark:text-red-400">
1004:                 {resultContent || "Search failed"}
1005:               </div>
1006:             </div>
1007:           ) : grepResults.length > 0 ? (
1008:             <>
1009:               <button
1010:                 onClick={() => setIsExpanded(!isExpanded)}
1011:                 className="flex items-center gap-2 text-sm font-medium text-muted-foreground hover:text-foreground transition-colors"
1012:               >
1013:                 {isExpanded ? (
1014:                   <ChevronDown className="h-3.5 w-3.5" />
1015:                 ) : (
1016:                   <ChevronRight className="h-3.5 w-3.5" />
1017:                 )}
1018:                 <span>{grepResults.length} matches found</span>
1019:               </button>
1020:               
1021:               {isExpanded && (
1022:                 <div className="rounded-lg border bg-zinc-950 overflow-hidden">
1023:                   <div className="max-h-[400px] overflow-y-auto">
1024:                     {grepResults.map((match, idx) => {
1025:                       const fileName = match.file.split('/').pop() || match.file;
1026:                       const dirPath = match.file.substring(0, match.file.lastIndexOf('/'));
1027:                       
1028:                       return (
1029:                         <div 
1030:                           key={idx} 
1031:                           className={cn(
1032:                             "flex items-start gap-3 p-3 border-b border-zinc-800 hover:bg-zinc-900/50 transition-colors",
1033:                             idx === grepResults.length - 1 && "border-b-0"
1034:                           )}
1035:                         >
1036:                           <div className="flex items-center gap-2 min-w-[60px]">
1037:                             <FileText className="h-3.5 w-3.5 text-emerald-500" />
1038:                             <span className="text-xs font-mono text-emerald-400">
1039:                               {match.lineNumber}
1040:                             </span>
1041:                           </div>
1042:                           
1043:                           <div className="flex-1 space-y-1 min-w-0">
1044:                             <div className="flex items-center gap-2">
1045:                               <span className="text-xs font-medium text-blue-400 truncate">
1046:                                 {fileName}
1047:                               </span>
1048:                               {dirPath && (
1049:                                 <span className="text-xs text-muted-foreground truncate">
1050:                                   {dirPath}
1051:                                 </span>
1052:                               )}
1053:                             </div>
1054:                             <code className="text-xs font-mono text-zinc-300 block whitespace-pre-wrap break-all">
1055:                               {match.content.trim()}
1056:                             </code>
1057:                           </div>
1058:                         </div>
1059:                       );
1060:                     })}
1061:                   </div>
1062:                 </div>
1063:               )}
1064:             </>
1065:           ) : (
1066:             <div className="flex items-center gap-3 p-4 rounded-lg bg-amber-500/10 border border-amber-500/20">
1067:               <Info className="h-5 w-5 text-amber-500 flex-shrink-0" />
1068:               <div className="text-sm text-amber-600 dark:text-amber-400">
1069:                 No matches found for the given pattern.
1070:               </div>
1071:             </div>
1072:           )}
1073:         </div>
1074:       )}
1075:     </div>
1076:   );
1077: };
1078: 
1079: const getLanguage = (path: string) => {
1080:   const ext = path.split('.').pop()?.toLowerCase();
1081:   const languageMap: Record<string, string> = {
1082:     ts: "typescript",
1083:     tsx: "tsx",
1084:     js: "javascript",
1085:     jsx: "jsx",
1086:     py: "python",
1087:     rs: "rust",
1088:     go: "go",
1089:     java: "java",
1090:     cpp: "cpp",
1091:     c: "c",
1092:     cs: "csharp",
1093:     php: "php",
1094:     rb: "ruby",
1095:     swift: "swift",
1096:     kt: "kotlin",
1097:     scala: "scala",
1098:     sh: "bash",
1099:     bash: "bash",
1100:     zsh: "bash",
1101:     yaml: "yaml",
1102:     yml: "yaml",
1103:     json: "json",
1104:     xml: "xml",
1105:     html: "html",
1106:     css: "css",
1107:     scss: "scss",
1108:     sass: "sass",
1109:     less: "less",
1110:     sql: "sql",
1111:     md: "markdown",
1112:     toml: "ini",
1113:     ini: "ini",
1114:     dockerfile: "dockerfile",
1115:     makefile: "makefile"
1116:   };
1117:   return languageMap[ext || ""] || "text";
1118: };
1119: 
1120: /**
1121:  * Widget for Edit tool - shows the edit operation
1122:  */
1123: export const EditWidget: React.FC<{ 
1124:   file_path: string; 
1125:   old_string: string; 
1126:   new_string: string;
1127:   result?: any;
1128: }> = ({ file_path, old_string, new_string, result: _result }) => {
1129:   const { theme } = useTheme();
1130:   const syntaxTheme = getClaudeSyntaxTheme(theme);
1131: 
1132:   const diffResult = Diff.diffLines(old_string || '', new_string || '', { 
1133:     newlineIsToken: true,
1134:     ignoreWhitespace: false 
1135:   });
1136:   const language = getLanguage(file_path);
1137: 
1138:   return (
1139:     <div className="space-y-2">
1140:       <div className="flex items-center gap-2 mb-2">
1141:         <FileEdit className="h-4 w-4 text-primary" />
1142:         <span className="text-sm font-medium">Applying Edit to:</span>
1143:         <code className="text-sm font-mono bg-background px-2 py-0.5 rounded flex-1 truncate">
1144:           {file_path}
1145:         </code>
1146:       </div>
1147: 
1148:       <div className="rounded-lg border bg-zinc-950 overflow-hidden text-xs font-mono">
1149:         <div className="max-h-[440px] overflow-y-auto overflow-x-auto">
1150:           {diffResult.map((part, index) => {
1151:             const partClass = part.added 
1152:               ? 'bg-green-950/20' 
1153:               : part.removed 
1154:               ? 'bg-red-950/20'
1155:               : '';
1156:             
1157:             if (!part.added && !part.removed && part.count && part.count > 8) {
1158:               return (
1159:                 <div key={index} className="px-4 py-1 bg-zinc-900 border-y border-zinc-800 text-center text-zinc-500 text-xs">
1160:                   ... {part.count} unchanged lines ...
1161:                 </div>
1162:               );
1163:             }
1164:             
1165:             const value = part.value.endsWith('\n') ? part.value.slice(0, -1) : part.value;
1166: 
1167:             return (
1168:               <div key={index} className={cn(partClass, "flex")}>
1169:                 <div className="w-8 select-none text-center flex-shrink-0">
1170:                   {part.added ? <span className="text-green-400">+</span> : part.removed ? <span className="text-red-400">-</span> : null}
1171:                 </div>
1172:                 <div className="flex-1">
1173:                   <SyntaxHighlighter
1174:                     language={language}
1175:                     style={syntaxTheme}
1176:                     PreTag="div"
1177:                     wrapLongLines={false}
1178:                     customStyle={{
1179:                       margin: 0,
1180:                       padding: 0,
1181:                       background: 'transparent',
1182:                     }}
1183:                     codeTagProps={{
1184:                       style: {
1185:                         fontSize: '0.75rem',
1186:                         lineHeight: '1.6',
1187:                       }
1188:                     }}
1189:                   >
1190:                     {value}
1191:                   </SyntaxHighlighter>
1192:                 </div>
1193:               </div>
1194:             );
1195:           })}
1196:         </div>
1197:       </div>
1198:     </div>
1199:   );
1200: };
1201: 
1202: /**
1203:  * Widget for Edit tool result - shows a diff view
1204:  */
1205: export const EditResultWidget: React.FC<{ content: string }> = ({ content }) => {
1206:   const { theme } = useTheme();
1207:   const syntaxTheme = getClaudeSyntaxTheme(theme);
1208:   
1209:   // Parse the content to extract file path and code snippet
1210:   const lines = content.split('\n');
1211:   let filePath = '';
1212:   const codeLines: { lineNumber: string; code: string }[] = [];
1213:   let inCodeBlock = false;
1214:   
1215:   for (const rawLine of lines) {
1216:     const line = rawLine.replace(/\r$/, '');
1217:     if (line.includes('The file') && line.includes('has been updated')) {
1218:       const match = line.match(/The file (.+) has been updated/);
1219:       if (match) {
1220:         filePath = match[1];
1221:       }
1222:     } else if (/^\s*\d+/.test(line)) {
1223:       inCodeBlock = true;
1224:       const lineMatch = line.match(/^\s*(\d+)\t?(.*)$/);
1225:       if (lineMatch) {
1226:         const [, lineNum, codePart] = lineMatch;
1227:         codeLines.push({
1228:           lineNumber: lineNum,
1229:           code: codePart,
1230:         });
1231:       }
1232:     } else if (inCodeBlock) {
1233:       // Allow non-numbered lines inside a code block (for empty lines)
1234:       codeLines.push({ lineNumber: '', code: line });
1235:     }
1236:   }
1237: 
1238:   const codeContent = codeLines.map(l => l.code).join('\n');
1239:   const firstNumberedLine = codeLines.find(l => l.lineNumber !== '');
1240:   const startLineNumber = firstNumberedLine ? parseInt(firstNumberedLine.lineNumber) : 1;
1241:   const language = getLanguage(filePath);
1242: 
1243:   return (
1244:     <div className="rounded-lg border bg-zinc-950 overflow-hidden">
1245:       <div className="px-4 py-2 border-b bg-emerald-950/30 flex items-center gap-2">
1246:         <GitBranch className="h-3.5 w-3.5 text-emerald-500" />
1247:         <span className="text-xs font-mono text-emerald-400">Edit Result</span>
1248:         {filePath && (
1249:           <>
1250:             <ChevronRight className="h-3 w-3 text-muted-foreground" />
1251:             <span className="text-xs font-mono text-muted-foreground">{filePath}</span>
1252:           </>
1253:         )}
1254:       </div>
1255:       <div className="overflow-x-auto max-h-[440px]">
1256:         <SyntaxHighlighter
1257:           language={language}
1258:           style={syntaxTheme}
1259:           showLineNumbers
1260:           startingLineNumber={startLineNumber}
1261:           wrapLongLines={false}
1262:           customStyle={{
1263:             margin: 0,
1264:             background: 'transparent',
1265:             lineHeight: '1.6'
1266:           }}
1267:           codeTagProps={{
1268:             style: {
1269:               fontSize: '0.75rem'
1270:             }
1271:           }}
1272:           lineNumberStyle={{
1273:             minWidth: "3.5rem",
1274:             paddingRight: "1rem",
1275:             textAlign: "right",
1276:             opacity: 0.5,
1277:           }}
1278:         >
1279:           {codeContent}
1280:         </SyntaxHighlighter>
1281:       </div>
1282:     </div>
1283:   );
1284: };
1285: 
1286: /**
1287:  * Widget for MCP (Model Context Protocol) tools
1288:  */
1289: export const MCPWidget: React.FC<{ 
1290:   toolName: string; 
1291:   input?: any;
1292:   result?: any;
1293: }> = ({ toolName, input, result: _result }) => {
1294:   const [isExpanded, setIsExpanded] = useState(false);
1295:   const { theme } = useTheme();
1296:   const syntaxTheme = getClaudeSyntaxTheme(theme);
1297:   
1298:   // Parse the tool name to extract components
1299:   // Format: mcp__namespace__method
1300:   const parts = toolName.split('__');
1301:   const namespace = parts[1] || '';
1302:   const method = parts[2] || '';
1303:   
1304:   // Format namespace for display (handle kebab-case and snake_case)
1305:   const formatNamespace = (ns: string) => {
1306:     return ns
1307:       .replace(/-/g, ' ')
1308:       .replace(/_/g, ' ')
1309:       .split(' ')
1310:       .map(word => word.charAt(0).toUpperCase() + word.slice(1))
1311:       .join(' ');
1312:   };
1313:   
1314:   // Format method name
1315:   const formatMethod = (m: string) => {
1316:     return m
1317:       .replace(/_/g, ' ')
1318:       .split(' ')
1319:       .map(word => word.charAt(0).toUpperCase() + word.slice(1))
1320:       .join(' ');
1321:   };
1322:   
1323:   const hasInput = input && Object.keys(input).length > 0;
1324:   const inputString = hasInput ? JSON.stringify(input, null, 2) : '';
1325:   const isLargeInput = inputString.length > 200;
1326:   
1327:   // Count tokens approximation (very rough estimate)
1328:   const estimateTokens = (str: string) => {
1329:     // Rough approximation: ~4 characters per token
1330:     return Math.ceil(str.length / 4);
1331:   };
1332:   
1333:   const inputTokens = hasInput ? estimateTokens(inputString) : 0;
1334: 
1335:   return (
1336:     <div className="rounded-lg border border-violet-500/20 bg-gradient-to-br from-violet-500/5 to-purple-500/5 overflow-hidden">
1337:       {/* Header */}
1338:       <div className="px-4 py-3 bg-gradient-to-r from-violet-500/10 to-purple-500/10 border-b border-violet-500/20">
1339:         <div className="flex items-center justify-between">
1340:           <div className="flex items-center gap-2">
1341:             <div className="relative">
1342:               <Package2 className="h-4 w-4 text-violet-500" />
1343:               <Sparkles className="h-2.5 w-2.5 text-violet-400 absolute -top-1 -right-1" />
1344:             </div>
1345:             <span className="text-sm font-medium text-violet-600 dark:text-violet-400">MCP Tool</span>
1346:           </div>
1347:           {hasInput && (
1348:             <div className="flex items-center gap-2">
1349:               <Badge 
1350:                 variant="outline" 
1351:                 className="text-xs border-violet-500/30 text-violet-600 dark:text-violet-400"
1352:               >
1353:                 ~{inputTokens} tokens
1354:               </Badge>
1355:               {isLargeInput && (
1356:                 <button
1357:                   onClick={() => setIsExpanded(!isExpanded)}
1358:                   className="text-violet-500 hover:text-violet-600 transition-colors"
1359:                 >
1360:                   {isExpanded ? (
1361:                     <ChevronUp className="h-3.5 w-3.5" />
1362:                   ) : (
1363:                     <ChevronDown className="h-3.5 w-3.5" />
1364:                   )}
1365:                 </button>
1366:               )}
1367:             </div>
1368:           )}
1369:         </div>
1370:       </div>
1371:       
1372:       {/* Tool Path */}
1373:       <div className="px-4 py-3 space-y-3">
1374:         <div className="flex items-center gap-2 text-sm">
1375:           <span className="text-violet-500 font-medium">MCP</span>
1376:           <ChevronRight className="h-3.5 w-3.5 text-muted-foreground" />
1377:           <span className="text-purple-600 dark:text-purple-400 font-medium">
1378:             {formatNamespace(namespace)}
1379:           </span>
1380:           <ChevronRight className="h-3.5 w-3.5 text-muted-foreground" />
1381:           <div className="flex items-center gap-1.5">
1382:             <Zap className="h-3.5 w-3.5 text-violet-500" />
1383:             <code className="text-sm font-mono font-semibold text-foreground">
1384:               {formatMethod(method)}
1385:               <span className="text-muted-foreground">()</span>
1386:             </code>
1387:           </div>
1388:         </div>
1389:         
1390:         {/* Input Parameters */}
1391:         {hasInput && (
1392:           <div className={cn(
1393:             "transition-all duration-200",
1394:             !isExpanded && isLargeInput && "max-h-[200px]"
1395:           )}>
1396:             <div className="relative">
1397:               <div className={cn(
1398:                 "rounded-lg border bg-zinc-950/50 overflow-hidden",
1399:                 !isExpanded && isLargeInput && "max-h-[200px]"
1400:               )}>
1401:                 <div className="px-3 py-2 border-b bg-zinc-900/50 flex items-center gap-2">
1402:                   <Code className="h-3 w-3 text-violet-500" />
1403:                   <span className="text-xs font-mono text-muted-foreground">Parameters</span>
1404:                 </div>
1405:                 <div className={cn(
1406:                   "overflow-auto",
1407:                   !isExpanded && isLargeInput && "max-h-[150px]"
1408:                 )}>
1409:                   <SyntaxHighlighter
1410:                     language="json"
1411:                     style={syntaxTheme}
1412:                     customStyle={{
1413:                       margin: 0,
1414:                       padding: '0.75rem',
1415:                       background: 'transparent',
1416:                       fontSize: '0.75rem',
1417:                       lineHeight: '1.5',
1418:                     }}
1419:                     wrapLongLines={false}
1420:                   >
1421:                     {inputString}
1422:                   </SyntaxHighlighter>
1423:                 </div>
1424:               </div>
1425:               
1426:               {/* Gradient fade for collapsed view */}
1427:               {!isExpanded && isLargeInput && (
1428:                 <div className="absolute bottom-0 left-0 right-0 h-12 bg-gradient-to-t from-zinc-950/80 to-transparent pointer-events-none" />
1429:               )}
1430:             </div>
1431:             
1432:             {/* Expand hint */}
1433:             {!isExpanded && isLargeInput && (
1434:               <div className="text-center mt-2">
1435:                 <button
1436:                   onClick={() => setIsExpanded(true)}
1437:                   className="text-xs text-violet-500 hover:text-violet-600 transition-colors inline-flex items-center gap-1"
1438:                 >
1439:                   <ChevronDown className="h-3 w-3" />
1440:                   Show full parameters
1441:                 </button>
1442:               </div>
1443:             )}
1444:           </div>
1445:         )}
1446:         
1447:         {/* No input message */}
1448:         {!hasInput && (
1449:           <div className="text-xs text-muted-foreground italic px-2">
1450:             No parameters required
1451:           </div>
1452:         )}
1453:       </div>
1454:     </div>
1455:   );
1456: };
1457: 
1458: /**
1459:  * Widget for user commands (e.g., model, clear)
1460:  */
1461: export const CommandWidget: React.FC<{ 
1462:   commandName: string;
1463:   commandMessage: string;
1464:   commandArgs?: string;
1465: }> = ({ commandName, commandMessage, commandArgs }) => {
1466:   return (
1467:     <div className="rounded-lg border bg-zinc-950/50 overflow-hidden">
1468:       <div className="px-4 py-2 border-b bg-zinc-900/50 flex items-center gap-2">
1469:         <Terminal className="h-3.5 w-3.5 text-blue-500" />
1470:         <span className="text-xs font-mono text-blue-400">Command</span>
1471:       </div>
1472:       <div className="p-3 space-y-1">
1473:         <div className="flex items-center gap-2">
1474:           <span className="text-xs text-muted-foreground">$</span>
1475:           <code className="text-sm font-mono text-foreground">{commandName}</code>
1476:           {commandArgs && (
1477:             <code className="text-sm font-mono text-muted-foreground">{commandArgs}</code>
1478:           )}
1479:         </div>
1480:         {commandMessage && commandMessage !== commandName && (
1481:           <div className="text-xs text-muted-foreground ml-4">{commandMessage}</div>
1482:         )}
1483:       </div>
1484:     </div>
1485:   );
1486: };
1487: 
1488: /**
1489:  * Widget for command output/stdout
1490:  */
1491: export const CommandOutputWidget: React.FC<{ 
1492:   output: string;
1493:   onLinkDetected?: (url: string) => void;
1494: }> = ({ output, onLinkDetected }) => {
1495:   // Check for links on mount and when output changes
1496:   React.useEffect(() => {
1497:     if (output && onLinkDetected) {
1498:       const links = detectLinks(output);
1499:       if (links.length > 0) {
1500:         // Notify about the first detected link
1501:         onLinkDetected(links[0].fullUrl);
1502:       }
1503:     }
1504:   }, [output, onLinkDetected]);
1505: 
1506:   // Parse ANSI codes for basic styling
1507:   const parseAnsiToReact = (text: string) => {
1508:     // Simple ANSI parsing - handles bold (\u001b[1m) and reset (\u001b[22m)
1509:     const parts = text.split(/(\u001b\[\d+m)/);
1510:     let isBold = false;
1511:     const elements: React.ReactNode[] = [];
1512:     
1513:     parts.forEach((part, idx) => {
1514:       if (part === '\u001b[1m') {
1515:         isBold = true;
1516:         return;
1517:       } else if (part === '\u001b[22m') {
1518:         isBold = false;
1519:         return;
1520:       } else if (part.match(/\u001b\[\d+m/)) {
1521:         // Ignore other ANSI codes for now
1522:         return;
1523:       }
1524:       
1525:       if (!part) return;
1526:       
1527:       // Make links clickable within this part
1528:       const linkElements = makeLinksClickable(part, (url) => {
1529:         onLinkDetected?.(url);
1530:       });
1531:       
1532:       if (isBold) {
1533:         elements.push(
1534:           <span key={idx} className="font-bold">
1535:             {linkElements}
1536:         </span>
1537:       );
1538:       } else {
1539:         elements.push(...linkElements);
1540:       }
1541:     });
1542:     
1543:     return elements;
1544:   };
1545: 
1546:   return (
1547:     <div className="rounded-lg border bg-zinc-950/50 overflow-hidden">
1548:       <div className="px-4 py-2 bg-zinc-900/50 flex items-center gap-2">
1549:         <ChevronRight className="h-3 w-3 text-green-500" />
1550:         <span className="text-xs font-mono text-green-400">Output</span>
1551:       </div>
1552:       <div className="p-3">
1553:         <pre className="text-sm font-mono text-zinc-300 whitespace-pre-wrap">
1554:           {output ? parseAnsiToReact(output) : <span className="text-zinc-500 italic">No output</span>}
1555:         </pre>
1556:       </div>
1557:     </div>
1558:   );
1559: };
1560: 
1561: /**
1562:  * Widget for AI-generated summaries
1563:  */
1564: export const SummaryWidget: React.FC<{ 
1565:   summary: string;
1566:   leafUuid?: string;
1567: }> = ({ summary, leafUuid }) => {
1568:   return (
1569:     <div className="rounded-lg border border-blue-500/20 bg-blue-500/5 overflow-hidden">
1570:       <div className="px-4 py-3 flex items-start gap-3">
1571:         <div className="mt-0.5">
1572:           <div className="h-8 w-8 rounded-full bg-blue-500/10 flex items-center justify-center">
1573:             <Info className="h-4 w-4 text-blue-500" />
1574:           </div>
1575:         </div>
1576:         <div className="flex-1 space-y-1">
1577:           <div className="text-xs font-medium text-blue-600 dark:text-blue-400">AI Summary</div>
1578:           <p className="text-sm text-foreground">{summary}</p>
1579:           {leafUuid && (
1580:             <div className="text-xs text-muted-foreground mt-2">
1581:               ID: <code className="font-mono">{leafUuid.slice(0, 8)}...</code>
1582:             </div>
1583:           )}
1584:         </div>
1585:       </div>
1586:     </div>
1587:   );
1588: };
1589: 
1590: /**
1591:  * Widget for displaying MultiEdit tool usage
1592:  */
1593: export const MultiEditWidget: React.FC<{
1594:   file_path: string;
1595:   edits: Array<{ old_string: string; new_string: string }>;
1596:   result?: any;
1597: }> = ({ file_path, edits, result: _result }) => {
1598:   const [isExpanded, setIsExpanded] = useState(false);
1599:   const language = getLanguage(file_path);
1600:   const { theme } = useTheme();
1601:   const syntaxTheme = getClaudeSyntaxTheme(theme);
1602:   
1603:   return (
1604:     <div className="space-y-2">
1605:       <div className="flex items-center gap-2 mb-2">
1606:         <FileEdit className="h-4 w-4 text-muted-foreground" />
1607:         <span className="text-sm font-medium">Using tool: MultiEdit</span>
1608:       </div>
1609:       <div className="ml-6 space-y-2">
1610:         <div className="flex items-center gap-2">
1611:           <FileText className="h-3 w-3 text-blue-500" />
1612:           <code className="text-xs font-mono text-blue-500">{file_path}</code>
1613:         </div>
1614:         
1615:         <div className="space-y-1">
1616:           <button
1617:             onClick={() => setIsExpanded(!isExpanded)}
1618:             className="flex items-center gap-1 text-xs text-muted-foreground hover:text-foreground transition-colors"
1619:           >
1620:             <ChevronRight className={cn("h-3 w-3 transition-transform", isExpanded && "rotate-90")} />
1621:             {edits.length} edit{edits.length !== 1 ? 's' : ''}
1622:           </button>
1623:           
1624:           {isExpanded && (
1625:             <div className="space-y-3 mt-3">
1626:               {edits.map((edit, index) => {
1627:                 const diffResult = Diff.diffLines(edit.old_string || '', edit.new_string || '', { 
1628:                   newlineIsToken: true,
1629:                   ignoreWhitespace: false 
1630:                 });
1631:                 
1632:                 return (
1633:                   <div key={index} className="space-y-1">
1634:                     <div className="text-xs font-medium text-muted-foreground">Edit {index + 1}</div>
1635:                     <div className="rounded-lg border bg-zinc-950 overflow-hidden text-xs font-mono">
1636:                       <div className="max-h-[300px] overflow-y-auto overflow-x-auto">
1637:                         {diffResult.map((part, partIndex) => {
1638:                           const partClass = part.added 
1639:                             ? 'bg-green-950/20' 
1640:                             : part.removed 
1641:                             ? 'bg-red-950/20'
1642:                             : '';
1643:                           
1644:                           if (!part.added && !part.removed && part.count && part.count > 8) {
1645:                             return (
1646:                               <div key={partIndex} className="px-4 py-1 bg-zinc-900 border-y border-zinc-800 text-center text-zinc-500 text-xs">
1647:                                 ... {part.count} unchanged lines ...
1648:                               </div>
1649:                             );
1650:                           }
1651:                           
1652:                           const value = part.value.endsWith('\n') ? part.value.slice(0, -1) : part.value;
1653: 
1654:                           return (
1655:                             <div key={partIndex} className={cn(partClass, "flex")}>
1656:                               <div className="w-8 select-none text-center flex-shrink-0">
1657:                                 {part.added ? <span className="text-green-400">+</span> : part.removed ? <span className="text-red-400">-</span> : null}
1658:                               </div>
1659:                               <div className="flex-1">
1660:                                 <SyntaxHighlighter
1661:                                   language={language}
1662:                                   style={syntaxTheme}
1663:                                   PreTag="div"
1664:                                   wrapLongLines={false}
1665:                                   customStyle={{
1666:                                     margin: 0,
1667:                                     padding: 0,
1668:                                     background: 'transparent',
1669:                                   }}
1670:                                   codeTagProps={{
1671:                                     style: {
1672:                                       fontSize: '0.75rem',
1673:                                       lineHeight: '1.6',
1674:                                     }
1675:                                   }}
1676:                                 >
1677:                                   {value}
1678:                                 </SyntaxHighlighter>
1679:                               </div>
1680:                             </div>
1681:                           );
1682:                         })}
1683:                       </div>
1684:                     </div>
1685:                   </div>
1686:                 );
1687:               })}
1688:             </div>
1689:           )}
1690:         </div>
1691:       </div>
1692:     </div>
1693:   );
1694: };
1695: 
1696: /**
1697:  * Widget for displaying MultiEdit tool results with diffs
1698:  */
1699: export const MultiEditResultWidget: React.FC<{ 
1700:   content: string;
1701:   edits?: Array<{ old_string: string; new_string: string }>;
1702: }> = ({ content, edits }) => {
1703:   // If we have the edits array, show a nice diff view
1704:   if (edits && edits.length > 0) {
1705:     return (
1706:       <div className="space-y-3">
1707:         <div className="flex items-center gap-2 px-3 py-2 bg-green-500/10 rounded-t-md border-b border-green-500/20">
1708:           <GitBranch className="h-4 w-4 text-green-500" />
1709:           <span className="text-sm font-medium text-green-600 dark:text-green-400">
1710:             {edits.length} Changes Applied
1711:           </span>
1712:         </div>
1713:         
1714:         <div className="space-y-4">
1715:           {edits.map((edit, index) => {
1716:             // Split the strings into lines for diff display
1717:             const oldLines = edit.old_string.split('\n');
1718:             const newLines = edit.new_string.split('\n');
1719:             
1720:             return (
1721:               <div key={index} className="border border-border/50 rounded-md overflow-hidden">
1722:                 <div className="px-3 py-1 bg-muted/50 border-b border-border/50">
1723:                   <span className="text-xs font-medium text-muted-foreground">Change {index + 1}</span>
1724:                 </div>
1725:                 
1726:                 <div className="font-mono text-xs">
1727:                   {/* Show removed lines */}
1728:                   {oldLines.map((line, lineIndex) => (
1729:                     <div
1730:                       key={`old-${lineIndex}`}
1731:                       className="flex bg-red-500/10 border-l-4 border-red-500"
1732:                     >
1733:                       <span className="w-12 px-2 py-1 text-red-600 dark:text-red-400 select-none text-right bg-red-500/10">
1734:                         -{lineIndex + 1}
1735:                       </span>
1736:                       <pre className="flex-1 px-3 py-1 text-red-700 dark:text-red-300 overflow-x-auto">
1737:                         <code>{line || ' '}</code>
1738:                       </pre>
1739:                     </div>
1740:                   ))}
1741:                   
1742:                   {/* Show added lines */}
1743:                   {newLines.map((line, lineIndex) => (
1744:                     <div
1745:                       key={`new-${lineIndex}`}
1746:                       className="flex bg-green-500/10 border-l-4 border-green-500"
1747:                     >
1748:                       <span className="w-12 px-2 py-1 text-green-600 dark:text-green-400 select-none text-right bg-green-500/10">
1749:                         +{lineIndex + 1}
1750:                       </span>
1751:                       <pre className="flex-1 px-3 py-1 text-green-700 dark:text-green-300 overflow-x-auto">
1752:                         <code>{line || ' '}</code>
1753:                       </pre>
1754:                     </div>
1755:                   ))}
1756:                 </div>
1757:               </div>
1758:             );
1759:           })}
1760:         </div>
1761:       </div>
1762:     );
1763:   }
1764:   
1765:   // Fallback to simple content display
1766:   return (
1767:     <div className="p-3 bg-muted/50 rounded-md border">
1768:       <pre className="text-xs font-mono whitespace-pre-wrap">{content}</pre>
1769:     </div>
1770:   );
1771: };
1772: 
1773: /**
1774:  * Widget for displaying system reminders (instead of raw XML)
1775:  */
1776: export const SystemReminderWidget: React.FC<{ message: string }> = ({ message }) => {
1777:   // Extract icon based on message content
1778:   let icon = <Info className="h-4 w-4" />;
1779:   let colorClass = "border-blue-500/20 bg-blue-500/5 text-blue-600";
1780:   
1781:   if (message.toLowerCase().includes("warning")) {
1782:     icon = <AlertCircle className="h-4 w-4" />;
1783:     colorClass = "border-yellow-500/20 bg-yellow-500/5 text-yellow-600";
1784:   } else if (message.toLowerCase().includes("error")) {
1785:     icon = <AlertCircle className="h-4 w-4" />;
1786:     colorClass = "border-destructive/20 bg-destructive/5 text-destructive";
1787:   }
1788:   
1789:   return (
1790:     <div className={cn("flex items-start gap-2 p-3 rounded-md border", colorClass)}>
1791:       <div className="mt-0.5">{icon}</div>
1792:       <div className="flex-1 text-sm">{message}</div>
1793:     </div>
1794:   );
1795: };
1796: 
1797: /**
1798:  * Widget for displaying system initialization information in a visually appealing way
1799:  * Separates regular tools from MCP tools and provides icons for each tool type
1800:  */
1801: export const SystemInitializedWidget: React.FC<{
1802:   sessionId?: string;
1803:   model?: string;
1804:   cwd?: string;
1805:   tools?: string[];
1806: }> = ({ sessionId, model, cwd, tools = [] }) => {
1807:   const [mcpExpanded, setMcpExpanded] = useState(false);
1808:   
1809:   // Separate regular tools from MCP tools
1810:   const regularTools = tools.filter(tool => !tool.startsWith('mcp__'));
1811:   const mcpTools = tools.filter(tool => tool.startsWith('mcp__'));
1812:   
1813:   // Tool icon mapping for regular tools
1814:   const toolIcons: Record<string, LucideIcon> = {
1815:     'task': CheckSquare,
1816:     'bash': Terminal,
1817:     'glob': FolderSearch,
1818:     'grep': Search,
1819:     'ls': List,
1820:     'exit_plan_mode': LogOut,
1821:     'read': FileText,
1822:     'edit': Edit3,
1823:     'multiedit': Edit3,
1824:     'write': FilePlus,
1825:     'notebookread': Book,
1826:     'notebookedit': BookOpen,
1827:     'webfetch': Globe,
1828:     'todoread': ListChecks,
1829:     'todowrite': ListPlus,
1830:     'websearch': Globe2,
1831:   };
1832:   
1833:   // Get icon for a tool, fallback to Wrench
1834:   const getToolIcon = (toolName: string) => {
1835:     const normalizedName = toolName.toLowerCase();
1836:     return toolIcons[normalizedName] || Wrench;
1837:   };
1838:   
1839:   // Format MCP tool name (remove mcp__ prefix and format underscores)
1840:   const formatMcpToolName = (toolName: string) => {
1841:     // Remove mcp__ prefix
1842:     const withoutPrefix = toolName.replace(/^mcp__/, '');
1843:     // Split by double underscores first (provider separator)
1844:     const parts = withoutPrefix.split('__');
1845:     if (parts.length >= 2) {
1846:       // Format provider name and method name separately
1847:       const provider = parts[0].replace(/_/g, ' ').replace(/-/g, ' ')
1848:         .split(' ')
1849:         .map(word => word.charAt(0).toUpperCase() + word.slice(1))
1850:         .join(' ');
1851:       const method = parts.slice(1).join('__').replace(/_/g, ' ')
1852:         .split(' ')
1853:         .map(word => word.charAt(0).toUpperCase() + word.slice(1))
1854:         .join(' ');
1855:       return { provider, method };
1856:     }
1857:     // Fallback formatting
1858:     return {
1859:       provider: 'MCP',
1860:       method: withoutPrefix.replace(/_/g, ' ')
1861:         .split(' ')
1862:         .map(word => word.charAt(0).toUpperCase() + word.slice(1))
1863:         .join(' ')
1864:     };
1865:   };
1866:   
1867:   // Group MCP tools by provider
1868:   const mcpToolsByProvider = mcpTools.reduce((acc, tool) => {
1869:     const { provider } = formatMcpToolName(tool);
1870:     if (!acc[provider]) {
1871:       acc[provider] = [];
1872:     }
1873:     acc[provider].push(tool);
1874:     return acc;
1875:   }, {} as Record<string, string[]>);
1876:   
1877:   return (
1878:     <Card className="border-blue-500/20 bg-blue-500/5">
1879:       <CardContent className="p-4">
1880:         <div className="flex items-start gap-3">
1881:           <Settings className="h-5 w-5 text-blue-500 mt-0.5" />
1882:           <div className="flex-1 space-y-4">
1883:             <h4 className="font-semibold text-sm">System Initialized</h4>
1884:             
1885:             {/* Session Info */}
1886:             <div className="space-y-2">
1887:               {sessionId && (
1888:                 <div className="flex items-center gap-2 text-xs">
1889:                   <Fingerprint className="h-3.5 w-3.5 text-muted-foreground" />
1890:                   <span className="text-muted-foreground">Session ID:</span>
1891:                   <code className="font-mono text-xs bg-muted px-1.5 py-0.5 rounded">
1892:                     {sessionId}
1893:                   </code>
1894:                 </div>
1895:               )}
1896:               
1897:               {model && (
1898:                 <div className="flex items-center gap-2 text-xs">
1899:                   <Cpu className="h-3.5 w-3.5 text-muted-foreground" />
1900:                   <span className="text-muted-foreground">Model:</span>
1901:                   <code className="font-mono text-xs bg-muted px-1.5 py-0.5 rounded">
1902:                     {model}
1903:                   </code>
1904:                 </div>
1905:               )}
1906:               
1907:               {cwd && (
1908:                 <div className="flex items-center gap-2 text-xs">
1909:                   <FolderOpen className="h-3.5 w-3.5 text-muted-foreground" />
1910:                   <span className="text-muted-foreground">Working Directory:</span>
1911:                   <code className="font-mono text-xs bg-muted px-1.5 py-0.5 rounded break-all">
1912:                     {cwd}
1913:                   </code>
1914:                 </div>
1915:               )}
1916:             </div>
1917:             
1918:             {/* Regular Tools */}
1919:             {regularTools.length > 0 && (
1920:               <div className="space-y-2">
1921:                 <div className="flex items-center gap-2">
1922:                   <Wrench className="h-3.5 w-3.5 text-muted-foreground" />
1923:                   <span className="text-xs font-medium text-muted-foreground">
1924:                     Available Tools ({regularTools.length})
1925:                   </span>
1926:                 </div>
1927:                 <div className="flex flex-wrap gap-1.5">
1928:                   {regularTools.map((tool, idx) => {
1929:                     const Icon = getToolIcon(tool);
1930:                     return (
1931:                       <Badge 
1932:                         key={idx} 
1933:                         variant="secondary" 
1934:                         className="text-xs py-0.5 px-2 flex items-center gap-1"
1935:                       >
1936:                         <Icon className="h-3 w-3" />
1937:                         {tool}
1938:                       </Badge>
1939:                     );
1940:                   })}
1941:                 </div>
1942:               </div>
1943:             )}
1944:             
1945:             {/* MCP Tools */}
1946:             {mcpTools.length > 0 && (
1947:               <div className="space-y-2">
1948:                 <button
1949:                   onClick={() => setMcpExpanded(!mcpExpanded)}
1950:                   className="flex items-center gap-2 text-xs font-medium text-muted-foreground hover:text-foreground transition-colors"
1951:                 >
1952:                   <Package className="h-3.5 w-3.5" />
1953:                   <span>MCP Services ({mcpTools.length})</span>
1954:                   <ChevronDown className={cn(
1955:                     "h-3 w-3 transition-transform",
1956:                     mcpExpanded && "rotate-180"
1957:                   )} />
1958:                 </button>
1959:                 
1960:                 {mcpExpanded && (
1961:                   <div className="ml-5 space-y-3">
1962:                     {Object.entries(mcpToolsByProvider).map(([provider, providerTools]) => (
1963:                       <div key={provider} className="space-y-1.5">
1964:                         <div className="flex items-center gap-1.5 text-xs text-muted-foreground">
1965:                           <Package2 className="h-3 w-3" />
1966:                           <span className="font-medium">{provider}</span>
1967:                           <span className="text-muted-foreground/60">({providerTools.length})</span>
1968:                         </div>
1969:                         <div className="ml-4 flex flex-wrap gap-1">
1970:                           {providerTools.map((tool, idx) => {
1971:                             const { method } = formatMcpToolName(tool);
1972:                             return (
1973:                               <Badge 
1974:                                 key={idx} 
1975:                                 variant="outline" 
1976:                                 className="text-xs py-0 px-1.5 font-normal"
1977:                               >
1978:                                 {method}
1979:                               </Badge>
1980:                             );
1981:                           })}
1982:                         </div>
1983:                       </div>
1984:                     ))}
1985:                   </div>
1986:                 )}
1987:               </div>
1988:             )}
1989:             
1990:             {/* Show message if no tools */}
1991:             {tools.length === 0 && (
1992:               <div className="text-xs text-muted-foreground italic">
1993:                 No tools available
1994:               </div>
1995:             )}
1996:           </div>
1997:         </div>
1998:       </CardContent>
1999:     </Card>
2000:   );
2001: };
2002: 
2003: /**
2004:  * Widget for Task tool - displays sub-agent task information
2005:  */
2006: export const TaskWidget: React.FC<{ 
2007:   description?: string; 
2008:   prompt?: string;
2009:   result?: any;
2010: }> = ({ description, prompt, result: _result }) => {
2011:   const [isExpanded, setIsExpanded] = useState(false);
2012:   
2013:   return (
2014:     <div className="space-y-2">
2015:       <div className="flex items-center gap-2 mb-2">
2016:         <div className="relative">
2017:           <Bot className="h-4 w-4 text-purple-500" />
2018:           <Sparkles className="h-2.5 w-2.5 text-purple-400 absolute -top-1 -right-1" />
2019:         </div>
2020:         <span className="text-sm font-medium">Spawning Sub-Agent Task</span>
2021:       </div>
2022:       
2023:       <div className="ml-6 space-y-3">
2024:         {description && (
2025:           <div className="rounded-lg border border-purple-500/20 bg-purple-500/5 p-3">
2026:             <div className="flex items-center gap-2 mb-1">
2027:               <Zap className="h-3.5 w-3.5 text-purple-500" />
2028:               <span className="text-xs font-medium text-purple-600 dark:text-purple-400">Task Description</span>
2029:             </div>
2030:             <p className="text-sm text-foreground ml-5">{description}</p>
2031:           </div>
2032:         )}
2033:         
2034:         {prompt && (
2035:           <div className="space-y-2">
2036:             <button
2037:               onClick={() => setIsExpanded(!isExpanded)}
2038:               className="flex items-center gap-1.5 text-xs font-medium text-muted-foreground hover:text-foreground transition-colors"
2039:             >
2040:               <ChevronRight className={cn("h-3 w-3 transition-transform", isExpanded && "rotate-90")} />
2041:               <span>Task Instructions</span>
2042:             </button>
2043:             
2044:             {isExpanded && (
2045:               <div className="rounded-lg border bg-muted/30 p-3">
2046:                 <pre className="text-xs font-mono text-muted-foreground whitespace-pre-wrap">
2047:                   {prompt}
2048:                 </pre>
2049:               </div>
2050:             )}
2051:           </div>
2052:         )}
2053:       </div>
2054:     </div>
2055:   );
2056: };
2057: 
2058: /**
2059:  * Widget for WebSearch tool - displays web search query and results
2060:  */
2061: export const WebSearchWidget: React.FC<{ 
2062:   query: string; 
2063:   result?: any;
2064: }> = ({ query, result }) => {
2065:   const [expandedSections, setExpandedSections] = useState<Set<number>>(new Set());
2066:   
2067:   // Parse the result to extract all links sections and build a structured representation
2068:   const parseSearchResult = (resultContent: string) => {
2069:     const sections: Array<{
2070:       type: 'text' | 'links';
2071:       content: string | Array<{ title: string; url: string }>;
2072:     }> = [];
2073:     
2074:     // Split by "Links: [" to find all link sections
2075:     const parts = resultContent.split(/Links:\s*\[/);
2076:     
2077:     // First part is always text (or empty)
2078:     if (parts[0]) {
2079:       sections.push({ type: 'text', content: parts[0].trim() });
2080:     }
2081:     
2082:     // Process each links section
2083:     parts.slice(1).forEach(part => {
2084:       try {
2085:         // Find the closing bracket
2086:         const closingIndex = part.indexOf(']');
2087:         if (closingIndex === -1) return;
2088:         
2089:         const linksJson = '[' + part.substring(0, closingIndex + 1);
2090:         const remainingText = part.substring(closingIndex + 1).trim();
2091:         
2092:         // Parse the JSON array
2093:         const links = JSON.parse(linksJson);
2094:         sections.push({ type: 'links', content: links });
2095:         
2096:         // Add any remaining text
2097:         if (remainingText) {
2098:           sections.push({ type: 'text', content: remainingText });
2099:         }
2100:       } catch (e) {
2101:         // If parsing fails, treat it as text
2102:         sections.push({ type: 'text', content: 'Links: [' + part });
2103:       }
2104:     });
2105:     
2106:     return sections;
2107:   };
2108:   
2109:   const toggleSection = (index: number) => {
2110:     const newExpanded = new Set(expandedSections);
2111:     if (newExpanded.has(index)) {
2112:       newExpanded.delete(index);
2113:     } else {
2114:       newExpanded.add(index);
2115:     }
2116:     setExpandedSections(newExpanded);
2117:   };
2118:   
2119:   // Extract result content if available
2120:   let searchResults: {
2121:     sections: Array<{
2122:       type: 'text' | 'links';
2123:       content: string | Array<{ title: string; url: string }>;
2124:     }>;
2125:     noResults: boolean;
2126:   } = { sections: [], noResults: false };
2127:   
2128:   if (result) {
2129:     let resultContent = '';
2130:     if (typeof result.content === 'string') {
2131:       resultContent = result.content;
2132:     } else if (result.content && typeof result.content === 'object') {
2133:       if (result.content.text) {
2134:         resultContent = result.content.text;
2135:       } else if (Array.isArray(result.content)) {
2136:         resultContent = result.content
2137:           .map((c: any) => (typeof c === 'string' ? c : c.text || JSON.stringify(c)))
2138:           .join('\n');
2139:       } else {
2140:         resultContent = JSON.stringify(result.content, null, 2);
2141:       }
2142:     }
2143:     
2144:     searchResults.noResults = resultContent.toLowerCase().includes('no links found') || 
2145:                                resultContent.toLowerCase().includes('no results');
2146:     searchResults.sections = parseSearchResult(resultContent);
2147:   }
2148:   
2149:   const handleLinkClick = async (url: string) => {
2150:     try {
2151:       await open(url);
2152:     } catch (error) {
2153:       console.error('Failed to open URL:', error);
2154:     }
2155:   };
2156:   
2157:   return (
2158:     <div className="flex flex-col gap-2">
2159:       {/* Subtle Search Query Header */}
2160:       <div className="flex items-center gap-2 px-3 py-2 rounded-lg bg-blue-500/5 border border-blue-500/10">
2161:         <Globe className="h-4 w-4 text-blue-500/70" />
2162:         <span className="text-xs font-medium uppercase tracking-wider text-blue-600/70 dark:text-blue-400/70">Web Search</span>
2163:         <span className="text-sm text-muted-foreground/80 flex-1 truncate">{query}</span>
2164:       </div>
2165:       
2166:       {/* Results */}
2167:       {result && (
2168:         <div className="rounded-lg border bg-background/50 backdrop-blur-sm overflow-hidden">
2169:           {!searchResults.sections.length ? (
2170:             <div className="px-3 py-2 flex items-center gap-2 text-muted-foreground">
2171:               <div className="animate-pulse flex items-center gap-1">
2172:                 <div className="h-1 w-1 bg-blue-500 rounded-full animate-bounce [animation-delay:-0.3s]"></div>
2173:                 <div className="h-1 w-1 bg-blue-500 rounded-full animate-bounce [animation-delay:-0.15s]"></div>
2174:                 <div className="h-1 w-1 bg-blue-500 rounded-full animate-bounce"></div>
2175:               </div>
2176:               <span className="text-sm">Searching...</span>
2177:             </div>
2178:           ) : searchResults.noResults ? (
2179:             <div className="px-3 py-2">
2180:               <div className="flex items-center gap-2 text-muted-foreground">
2181:                 <AlertCircle className="h-4 w-4" />
2182:                 <span className="text-sm">No results found</span>
2183:               </div>
2184:             </div>
2185:           ) : (
2186:             <div className="p-3 space-y-3">
2187:               {searchResults.sections.map((section, idx) => {
2188:                 if (section.type === 'text') {
2189:                   return (
2190:                     <div key={idx} className="prose prose-sm dark:prose-invert max-w-none">
2191:                       <ReactMarkdown>{section.content as string}</ReactMarkdown>
2192:                     </div>
2193:                   );
2194:                 } else if (section.type === 'links' && Array.isArray(section.content)) {
2195:                   const links = section.content;
2196:                   const isExpanded = expandedSections.has(idx);
2197:                   
2198:                   return (
2199:                     <div key={idx} className="space-y-1.5">
2200:                       {/* Toggle Button */}
2201:                       <button
2202:                         onClick={() => toggleSection(idx)}
2203:                         className="flex items-center gap-1.5 text-sm text-muted-foreground hover:text-foreground transition-colors"
2204:                       >
2205:                         {isExpanded ? (
2206:                           <ChevronDown className="h-3 w-3" />
2207:                         ) : (
2208:                           <ChevronRight className="h-3 w-3" />
2209:                         )}
2210:                         <span>{links.length} result{links.length !== 1 ? 's' : ''}</span>
2211:                       </button>
2212:                       
2213:                       {/* Links Display */}
2214:                       {isExpanded ? (
2215:                         /* Expanded Card View */
2216:                         <div className="grid gap-1.5 ml-4">
2217:                           {links.map((link, linkIdx) => (
2218:                             <button
2219:                               key={linkIdx}
2220:                               onClick={() => handleLinkClick(link.url)}
2221:                               className="group flex flex-col gap-0.5 p-2.5 rounded-md border bg-card/30 hover:bg-card/50 hover:border-blue-500/30 transition-all text-left"
2222:                             >
2223:                               <div className="flex items-start gap-2">
2224:                                 <Globe2 className="h-3.5 w-3.5 text-blue-500/70 mt-0.5 flex-shrink-0" />
2225:                                 <div className="flex-1 min-w-0">
2226:                                   <div className="text-sm font-medium group-hover:text-blue-500 transition-colors line-clamp-2">
2227:                                     {link.title}
2228:                                   </div>
2229:                                   <div className="text-xs text-muted-foreground mt-0.5 truncate">
2230:                                     {link.url}
2231:                                   </div>
2232:                                 </div>
2233:                               </div>
2234:                             </button>
2235:                           ))}
2236:                         </div>
2237:                       ) : (
2238:                         /* Collapsed Pills View */
2239:                         <div className="flex flex-wrap gap-1.5 ml-4">
2240:                           {links.map((link, linkIdx) => (
2241:                             <button
2242:                               key={linkIdx}
2243:                               onClick={(e) => {
2244:                                 e.stopPropagation();
2245:                                 handleLinkClick(link.url);
2246:                               }}
2247:                               className="group inline-flex items-center gap-1 px-2.5 py-1 rounded-full text-xs font-medium bg-blue-500/5 hover:bg-blue-500/10 border border-blue-500/10 hover:border-blue-500/20 transition-all"
2248:                             >
2249:                               <Globe2 className="h-3 w-3 text-blue-500/70" />
2250:                               <span className="truncate max-w-[180px] text-foreground/70 group-hover:text-foreground/90">
2251:                                 {link.title}
2252:                               </span>
2253:                             </button>
2254:                           ))}
2255:                         </div>
2256:                       )}
2257:                     </div>
2258:                   );
2259:                 }
2260:                 return null;
2261:               })}
2262:             </div>
2263:           )}
2264:         </div>
2265:       )}
2266:     </div>
2267:   );
2268: };
2269: 
2270: /**
2271:  * Widget for displaying AI thinking/reasoning content
2272:  * Collapsible and closed by default
2273:  */
2274: export const ThinkingWidget: React.FC<{ 
2275:   thinking: string;
2276:   signature?: string;
2277: }> = ({ thinking }) => {
2278:   const [isExpanded, setIsExpanded] = useState(false);
2279:   
2280:   // Strip whitespace from thinking content
2281:   const trimmedThinking = thinking.trim();
2282:   
2283:   return (
2284:     <div className="rounded-lg border border-gray-500/20 bg-gray-500/5 overflow-hidden">
2285:       <button
2286:         onClick={() => setIsExpanded(!isExpanded)}
2287:         className="w-full px-4 py-3 flex items-center justify-between hover:bg-gray-500/10 transition-colors"
2288:       >
2289:         <div className="flex items-center gap-2">
2290:           <div className="relative">
2291:             <Bot className="h-4 w-4 text-gray-500" />
2292:             <Sparkles className="h-2.5 w-2.5 text-gray-400 absolute -top-1 -right-1 animate-pulse" />
2293:           </div>
2294:           <span className="text-sm font-medium text-gray-600 dark:text-gray-400 italic">
2295:             Thinking...
2296:           </span>
2297:         </div>
2298:         <ChevronRight className={cn(
2299:           "h-4 w-4 text-gray-500 transition-transform",
2300:           isExpanded && "rotate-90"
2301:         )} />
2302:       </button>
2303:       
2304:       {isExpanded && (
2305:         <div className="px-4 pb-4 pt-2 border-t border-gray-500/20">
2306:           <pre className="text-xs font-mono text-gray-600 dark:text-gray-400 whitespace-pre-wrap bg-gray-500/5 p-3 rounded-lg italic">
2307:             {trimmedThinking}
2308:           </pre>
2309:         </div>
2310:       )}
2311:     </div>
2312:   );
2313: };
2314: 
2315: /**
2316:  * Widget for WebFetch tool - displays URL fetching with optional prompts
2317:  */
2318: export const WebFetchWidget: React.FC<{ 
2319:   url: string;
2320:   prompt?: string;
2321:   result?: any;
2322: }> = ({ url, prompt, result }) => {
2323:   const [isExpanded, setIsExpanded] = useState(false);
2324:   const [showFullContent, setShowFullContent] = useState(false);
2325:   
2326:   // Extract result content if available
2327:   let fetchedContent = '';
2328:   let isLoading = !result;
2329:   let hasError = false;
2330:   
2331:   if (result) {
2332:     if (typeof result.content === 'string') {
2333:       fetchedContent = result.content;
2334:     } else if (result.content && typeof result.content === 'object') {
2335:       if (result.content.text) {
2336:         fetchedContent = result.content.text;
2337:       } else if (Array.isArray(result.content)) {
2338:         fetchedContent = result.content
2339:           .map((c: any) => (typeof c === 'string' ? c : c.text || JSON.stringify(c)))
2340:           .join('\n');
2341:       } else {
2342:         fetchedContent = JSON.stringify(result.content, null, 2);
2343:       }
2344:     }
2345:     
2346:     // Check if there's an error
2347:     hasError = result.is_error || 
2348:                fetchedContent.toLowerCase().includes('error') ||
2349:                fetchedContent.toLowerCase().includes('failed');
2350:   }
2351:   
2352:   // Truncate content for preview
2353:   const maxPreviewLength = 500;
2354:   const isTruncated = fetchedContent.length > maxPreviewLength;
2355:   const previewContent = isTruncated && !showFullContent
2356:     ? fetchedContent.substring(0, maxPreviewLength) + '...'
2357:     : fetchedContent;
2358:   
2359:   // Extract domain from URL for display
2360:   const getDomain = (urlString: string) => {
2361:     try {
2362:       const urlObj = new URL(urlString);
2363:       return urlObj.hostname;
2364:     } catch {
2365:       return urlString;
2366:     }
2367:   };
2368:   
2369:   const handleUrlClick = async () => {
2370:     try {
2371:       await open(url);
2372:     } catch (error) {
2373:       console.error('Failed to open URL:', error);
2374:     }
2375:   };
2376:   
2377:   return (
2378:     <div className="flex flex-col gap-2">
2379:       {/* Header with URL and optional prompt */}
2380:       <div className="space-y-2">
2381:         {/* URL Display */}
2382:         <div className="flex items-center gap-2 px-3 py-2 rounded-lg bg-purple-500/5 border border-purple-500/10">
2383:           <Globe className="h-4 w-4 text-purple-500/70" />
2384:           <span className="text-xs font-medium uppercase tracking-wider text-purple-600/70 dark:text-purple-400/70">Fetching</span>
2385:           <button
2386:             onClick={handleUrlClick}
2387:             className="text-sm text-foreground/80 hover:text-foreground flex-1 truncate text-left hover:underline decoration-purple-500/50"
2388:           >
2389:             {url}
2390:           </button>
2391:         </div>
2392:         
2393:         {/* Prompt Display */}
2394:         {prompt && (
2395:           <div className="ml-6 space-y-1">
2396:             <button
2397:               onClick={() => setIsExpanded(!isExpanded)}
2398:               className="flex items-center gap-1.5 text-xs font-medium text-muted-foreground hover:text-foreground transition-colors"
2399:             >
2400:               <ChevronRight className={cn("h-3 w-3 transition-transform", isExpanded && "rotate-90")} />
2401:               <Info className="h-3 w-3" />
2402:               <span>Analysis Prompt</span>
2403:             </button>
2404:             
2405:             {isExpanded && (
2406:               <div className="rounded-lg border bg-muted/30 p-3 ml-4">
2407:                 <p className="text-sm text-foreground/90">
2408:                   {prompt}
2409:                 </p>
2410:               </div>
2411:             )}
2412:           </div>
2413:         )}
2414:       </div>
2415:       
2416:       {/* Results */}
2417:       {isLoading ? (
2418:         <div className="rounded-lg border bg-background/50 backdrop-blur-sm overflow-hidden">
2419:           <div className="px-3 py-2 flex items-center gap-2 text-muted-foreground">
2420:             <div className="animate-pulse flex items-center gap-1">
2421:               <div className="h-1 w-1 bg-purple-500 rounded-full animate-bounce [animation-delay:-0.3s]"></div>
2422:               <div className="h-1 w-1 bg-purple-500 rounded-full animate-bounce [animation-delay:-0.15s]"></div>
2423:               <div className="h-1 w-1 bg-purple-500 rounded-full animate-bounce"></div>
2424:             </div>
2425:             <span className="text-sm">Fetching content from {getDomain(url)}...</span>
2426:           </div>
2427:         </div>
2428:       ) : fetchedContent ? (
2429:         <div className="rounded-lg border bg-background/50 backdrop-blur-sm overflow-hidden">
2430:           {hasError ? (
2431:             <div className="px-3 py-2">
2432:               <div className="flex items-center gap-2 text-destructive">
2433:                 <AlertCircle className="h-4 w-4" />
2434:                 <span className="text-sm font-medium">Failed to fetch content</span>
2435:               </div>
2436:               <pre className="mt-2 text-xs font-mono text-muted-foreground whitespace-pre-wrap">
2437:                 {fetchedContent}
2438:               </pre>
2439:             </div>
2440:           ) : (
2441:             <div className="p-3 space-y-2">
2442:               {/* Content Header */}
2443:               <div className="flex items-center justify-between">
2444:                 <div className="flex items-center gap-2 text-sm text-muted-foreground">
2445:                   <FileText className="h-3.5 w-3.5" />
2446:                   <span>Content from {getDomain(url)}</span>
2447:                 </div>
2448:                 {isTruncated && (
2449:                   <button
2450:                     onClick={() => setShowFullContent(!showFullContent)}
2451:                     className="text-xs text-purple-500 hover:text-purple-600 transition-colors flex items-center gap-1"
2452:                   >
2453:                     {showFullContent ? (
2454:                       <>
2455:                         <ChevronUp className="h-3 w-3" />
2456:                         Show less
2457:                       </>
2458:                     ) : (
2459:                       <>
2460:                         <ChevronDown className="h-3 w-3" />
2461:                         Show full content
2462:                       </>
2463:                     )}
2464:                   </button>
2465:                 )}
2466:               </div>
2467:               
2468:               {/* Fetched Content */}
2469:               <div className="relative">
2470:                 <div className={cn(
2471:                   "rounded-lg bg-muted/30 p-3 overflow-hidden",
2472:                   !showFullContent && isTruncated && "max-h-[300px]"
2473:                 )}>
2474:                   <pre className="text-sm font-mono text-foreground/90 whitespace-pre-wrap">
2475:                     {previewContent}
2476:                   </pre>
2477:                   {!showFullContent && isTruncated && (
2478:                     <div className="absolute bottom-0 left-0 right-0 h-20 bg-gradient-to-t from-muted/30 to-transparent pointer-events-none" />
2479:                   )}
2480:                 </div>
2481:               </div>
2482:             </div>
2483:           )}
2484:         </div>
2485:       ) : (
2486:         <div className="rounded-lg border bg-background/50 backdrop-blur-sm overflow-hidden">
2487:           <div className="px-3 py-2">
2488:             <div className="flex items-center gap-2 text-muted-foreground">
2489:               <Info className="h-4 w-4" />
2490:               <span className="text-sm">No content returned</span>
2491:             </div>
2492:           </div>
2493:         </div>
2494:       )}
2495:     </div>
2496:   );
2497: };
2498: 
2499: /**
2500:  * Widget for TodoRead tool - displays todos with advanced viewing capabilities
2501:  */
2502: export const TodoReadWidget: React.FC<{ todos?: any[]; result?: any }> = ({ todos: inputTodos, result }) => {
2503:   // Extract todos from result if not directly provided
2504:   let todos: any[] = inputTodos || [];
2505:   if (!todos.length && result) {
2506:     if (typeof result === 'object' && Array.isArray(result.todos)) {
2507:       todos = result.todos;
2508:     } else if (typeof result.content === 'string') {
2509:       try {
2510:         const parsed = JSON.parse(result.content);
2511:         if (Array.isArray(parsed)) todos = parsed;
2512:         else if (parsed.todos) todos = parsed.todos;
2513:       } catch (e) {
2514:         // Not JSON, ignore
2515:       }
2516:     }
2517:   }
2518: 
2519:   const [searchQuery, setSearchQuery] = useState("");
2520:   const [statusFilter, setStatusFilter] = useState<string>("all");
2521:   const [viewMode, setViewMode] = useState<"list" | "board" | "timeline" | "stats">("list");
2522:   const [expandedTodos, setExpandedTodos] = useState<Set<string>>(new Set());
2523: 
2524:   // Status icons and colors
2525:   const statusConfig = {
2526:     completed: {
2527:       icon: <CheckCircle2 className="h-4 w-4" />,
2528:       color: "text-green-500",
2529:       bgColor: "bg-green-500/10",
2530:       borderColor: "border-green-500/20",
2531:       label: "Completed"
2532:     },
2533:     in_progress: {
2534:       icon: <Clock className="h-4 w-4 animate-pulse" />,
2535:       color: "text-blue-500",
2536:       bgColor: "bg-blue-500/10",
2537:       borderColor: "border-blue-500/20",
2538:       label: "In Progress"
2539:     },
2540:     pending: {
2541:       icon: <Circle className="h-4 w-4" />,
2542:       color: "text-muted-foreground",
2543:       bgColor: "bg-muted/50",
2544:       borderColor: "border-muted",
2545:       label: "Pending"
2546:     },
2547:     cancelled: {
2548:       icon: <X className="h-4 w-4" />,
2549:       color: "text-red-500",
2550:       bgColor: "bg-red-500/10",
2551:       borderColor: "border-red-500/20",
2552:       label: "Cancelled"
2553:     }
2554:   };
2555: 
2556:   // Filter todos based on search and status
2557:   const filteredTodos = todos.filter(todo => {
2558:     const matchesSearch = !searchQuery || 
2559:       todo.content.toLowerCase().includes(searchQuery.toLowerCase()) ||
2560:       (todo.id && todo.id.toLowerCase().includes(searchQuery.toLowerCase()));
2561:     
2562:     const matchesStatus = statusFilter === "all" || todo.status === statusFilter;
2563:     
2564:     return matchesSearch && matchesStatus;
2565:   });
2566: 
2567:   // Calculate statistics
2568:   const stats = {
2569:     total: todos.length,
2570:     completed: todos.filter(t => t.status === "completed").length,
2571:     inProgress: todos.filter(t => t.status === "in_progress").length,
2572:     pending: todos.filter(t => t.status === "pending").length,
2573:     cancelled: todos.filter(t => t.status === "cancelled").length,
2574:     completionRate: todos.length > 0 
2575:       ? Math.round((todos.filter(t => t.status === "completed").length / todos.length) * 100)
2576:       : 0
2577:   };
2578: 
2579:   // Group todos by status for board view
2580:   const todosByStatus = {
2581:     pending: filteredTodos.filter(t => t.status === "pending"),
2582:     in_progress: filteredTodos.filter(t => t.status === "in_progress"),
2583:     completed: filteredTodos.filter(t => t.status === "completed"),
2584:     cancelled: filteredTodos.filter(t => t.status === "cancelled")
2585:   };
2586: 
2587:   // Toggle expanded state for a todo
2588:   const toggleExpanded = (todoId: string) => {
2589:     setExpandedTodos(prev => {
2590:       const next = new Set(prev);
2591:       if (next.has(todoId)) {
2592:         next.delete(todoId);
2593:       } else {
2594:         next.add(todoId);
2595:       }
2596:       return next;
2597:     });
2598:   };
2599: 
2600:   // Export todos as JSON
2601:   const exportAsJson = () => {
2602:     const dataStr = JSON.stringify(todos, null, 2);
2603:     const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
2604:     const exportFileDefaultName = 'todos.json';
2605:     const linkElement = document.createElement('a');
2606:     linkElement.setAttribute('href', dataUri);
2607:     linkElement.setAttribute('download', exportFileDefaultName);
2608:     linkElement.click();
2609:   };
2610: 
2611:   // Export todos as Markdown
2612:   const exportAsMarkdown = () => {
2613:     let markdown = "# Todo List\n\n";
2614:     markdown += `**Total**: ${stats.total} | **Completed**: ${stats.completed} | **In Progress**: ${stats.inProgress} | **Pending**: ${stats.pending}\n\n`;
2615:     
2616:     const statusGroups = ["pending", "in_progress", "completed", "cancelled"];
2617:     statusGroups.forEach(status => {
2618:       const todosInStatus = todos.filter(t => t.status === status);
2619:       if (todosInStatus.length > 0) {
2620:         markdown += `## ${statusConfig[status as keyof typeof statusConfig]?.label || status}\n\n`;
2621:         todosInStatus.forEach(todo => {
2622:           const checkbox = todo.status === "completed" ? "[x]" : "[ ]";
2623:           markdown += `- ${checkbox} ${todo.content}${todo.id ? ` (${todo.id})` : ""}\n`;
2624:           if (todo.dependencies?.length > 0) {
2625:             markdown += `  - Dependencies: ${todo.dependencies.join(", ")}\n`;
2626:           }
2627:         });
2628:         markdown += "\n";
2629:       }
2630:     });
2631:     
2632:     const dataUri = 'data:text/markdown;charset=utf-8,'+ encodeURIComponent(markdown);
2633:     const linkElement = document.createElement('a');
2634:     linkElement.setAttribute('href', dataUri);
2635:     linkElement.setAttribute('download', 'todos.md');
2636:     linkElement.click();
2637:   };
2638: 
2639:   // Render todo card
2640:   const TodoCard = ({ todo, isExpanded }: { todo: any; isExpanded: boolean }) => {
2641:     const config = statusConfig[todo.status as keyof typeof statusConfig] || statusConfig.pending;
2642:     
2643:     return (
2644:       <motion.div
2645:         layout
2646:         initial={{ opacity: 0, y: 20 }}
2647:         animate={{ opacity: 1, y: 0 }}
2648:         exit={{ opacity: 0, y: -20 }}
2649:         className={cn(
2650:           "group rounded-lg border p-4 transition-all hover:shadow-md cursor-pointer",
2651:           config.bgColor,
2652:           config.borderColor,
2653:           todo.status === "completed" && "opacity-75"
2654:         )}
2655:         onClick={() => todo.id && toggleExpanded(todo.id)}
2656:       >
2657:         <div className="flex items-start gap-3">
2658:           <div className={cn("mt-0.5", config.color)}>
2659:             {config.icon}
2660:           </div>
2661:           <div className="flex-1 space-y-2">
2662:             <p className={cn(
2663:               "text-sm",
2664:               todo.status === "completed" && "line-through"
2665:             )}>
2666:               {todo.content}
2667:             </p>
2668:             
2669:             {/* Todo metadata */}
2670:             <div className="flex flex-wrap items-center gap-2 text-xs text-muted-foreground">
2671:               {todo.id && (
2672:                 <div className="flex items-center gap-1">
2673:                   <Hash className="h-3 w-3" />
2674:                   <span className="font-mono">{todo.id}</span>
2675:                 </div>
2676:               )}
2677:               {todo.dependencies?.length > 0 && (
2678:                 <div className="flex items-center gap-1">
2679:                   <GitBranch className="h-3 w-3" />
2680:                   <span>{todo.dependencies.length} deps</span>
2681:                 </div>
2682:               )}
2683:             </div>
2684:             
2685:             {/* Expanded details */}
2686:             <AnimatePresence>
2687:               {isExpanded && todo.dependencies?.length > 0 && (
2688:                 <motion.div
2689:                   initial={{ height: 0, opacity: 0 }}
2690:                   animate={{ height: "auto", opacity: 1 }}
2691:                   exit={{ height: 0, opacity: 0 }}
2692:                   className="overflow-hidden"
2693:                 >
2694:                   <div className="pt-2 mt-2 border-t space-y-1">
2695:                     <span className="text-xs font-medium text-muted-foreground">Dependencies:</span>
2696:                     <div className="flex flex-wrap gap-1">
2697:                       {todo.dependencies.map((dep: string) => (
2698:                         <Badge
2699:                           key={dep}
2700:                           variant="outline"
2701:                           className="text-xs font-mono"
2702:                         >
2703:                           {dep}
2704:                         </Badge>
2705:                       ))}
2706:                     </div>
2707:                   </div>
2708:                 </motion.div>
2709:               )}
2710:             </AnimatePresence>
2711:           </div>
2712:         </div>
2713:       </motion.div>
2714:     );
2715:   };
2716: 
2717:   // Render statistics view
2718:   const StatsView = () => (
2719:     <div className="space-y-4">
2720:       {/* Overall Progress */}
2721:       <Card className="p-4">
2722:         <div className="flex items-center justify-between mb-3">
2723:           <h4 className="text-sm font-medium">Overall Progress</h4>
2724:           <span className="text-2xl font-bold text-primary">{stats.completionRate}%</span>
2725:         </div>
2726:         <div className="w-full bg-muted rounded-full h-3 overflow-hidden">
2727:           <motion.div
2728:             initial={{ width: 0 }}
2729:             animate={{ width: `${stats.completionRate}%` }}
2730:             transition={{ duration: 0.5, ease: "easeOut" }}
2731:             className="h-full bg-gradient-to-r from-primary to-primary/80"
2732:           />
2733:         </div>
2734:       </Card>
2735: 
2736:       {/* Status Breakdown */}
2737:       <div className="grid grid-cols-2 gap-3">
2738:         {Object.entries(statusConfig).map(([status, config]) => {
2739:           const count = stats[status as keyof typeof stats] || 0;
2740:           const percentage = stats.total > 0 ? Math.round((count / stats.total) * 100) : 0;
2741:           
2742:           return (
2743:             <Card key={status} className={cn("p-4", config.bgColor)}>
2744:               <div className="flex items-center gap-3">
2745:                 <div className={config.color}>{config.icon}</div>
2746:                 <div className="flex-1">
2747:                   <p className="text-xs text-muted-foreground">{config.label}</p>
2748:                   <p className="text-lg font-semibold">{count}</p>
2749:                   <p className="text-xs text-muted-foreground">{percentage}%</p>
2750:                 </div>
2751:               </div>
2752:             </Card>
2753:           );
2754:         })}
2755:       </div>
2756: 
2757:       {/* Activity Chart */}
2758:       <Card className="p-4">
2759:         <div className="flex items-center gap-2 mb-3">
2760:           <Activity className="h-4 w-4 text-primary" />
2761:           <h4 className="text-sm font-medium">Activity Overview</h4>
2762:         </div>
2763:         <div className="space-y-2">
2764:           {Object.entries(statusConfig).map(([status, config]) => {
2765:             const count = stats[status as keyof typeof stats] || 0;
2766:             const percentage = stats.total > 0 ? (count / stats.total) * 100 : 0;
2767:             
2768:             return (
2769:               <div key={status} className="flex items-center gap-3">
2770:                 <span className="text-xs w-20 text-right">{config.label}</span>
2771:                 <div className="flex-1 bg-muted rounded-full h-2 overflow-hidden">
2772:                   <motion.div
2773:                     initial={{ width: 0 }}
2774:                     animate={{ width: `${percentage}%` }}
2775:                     transition={{ duration: 0.5, delay: 0.1 }}
2776:                     className={cn("h-full", config.bgColor)}
2777:                   />
2778:                 </div>
2779:                 <span className="text-xs w-12 text-left">{count}</span>
2780:               </div>
2781:             );
2782:           })}
2783:         </div>
2784:       </Card>
2785:     </div>
2786:   );
2787: 
2788:   // Render board view
2789:   const BoardView = () => (
2790:     <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
2791:       {Object.entries(todosByStatus).map(([status, todos]) => {
2792:         const config = statusConfig[status as keyof typeof statusConfig];
2793:         
2794:         return (
2795:           <div key={status} className="space-y-3">
2796:             <div className="flex items-center gap-2 pb-2 border-b">
2797:               <div className={config.color}>{config.icon}</div>
2798:               <h3 className="text-sm font-medium">{config.label}</h3>
2799:               <Badge variant="secondary" className="ml-auto text-xs">
2800:                 {todos.length}
2801:               </Badge>
2802:             </div>
2803:             <div className="space-y-2">
2804:               {todos.map(todo => (
2805:                 <TodoCard 
2806:                   key={todo.id || todos.indexOf(todo)} 
2807:                   todo={todo} 
2808:                   isExpanded={expandedTodos.has(todo.id)}
2809:                 />
2810:               ))}
2811:               {todos.length === 0 && (
2812:                 <p className="text-xs text-muted-foreground text-center py-4">
2813:                   No todos
2814:                 </p>
2815:               )}
2816:             </div>
2817:           </div>
2818:         );
2819:       })}
2820:     </div>
2821:   );
2822: 
2823:   // Render timeline view
2824:   const TimelineView = () => {
2825:     // Group todos by their dependencies to create a timeline
2826:     const rootTodos = todos.filter(t => !t.dependencies || t.dependencies.length === 0);
2827:     const rendered = new Set<string>();
2828:     
2829:     const renderTodoWithDependents = (todo: any, level = 0) => {
2830:       if (rendered.has(todo.id)) return null;
2831:       rendered.add(todo.id);
2832:       
2833:       const dependents = todos.filter(t => 
2834:         t.dependencies?.includes(todo.id) && !rendered.has(t.id)
2835:       );
2836:       
2837:       return (
2838:         <div key={todo.id} className="relative">
2839:           {level > 0 && (
2840:             <div className="absolute left-6 top-0 w-px h-6 bg-border" />
2841:           )}
2842:           <div className={cn("flex gap-4", level > 0 && "ml-12")}>
2843:             <div className="relative">
2844:               <div className={cn(
2845:                 "w-3 h-3 rounded-full border-2 bg-background",
2846:                 statusConfig[todo.status as keyof typeof statusConfig]?.borderColor
2847:               )} />
2848:               {dependents.length > 0 && (
2849:                 <div className="absolute left-1/2 top-3 w-px h-full bg-border -translate-x-1/2" />
2850:               )}
2851:             </div>
2852:             <div className="flex-1 pb-6">
2853:               <TodoCard 
2854:                 todo={todo} 
2855:                 isExpanded={expandedTodos.has(todo.id)}
2856:               />
2857:             </div>
2858:           </div>
2859:           {dependents.map(dep => renderTodoWithDependents(dep, level + 1))}
2860:         </div>
2861:       );
2862:     };
2863:     
2864:     return (
2865:       <div className="space-y-4">
2866:         {rootTodos.map(todo => renderTodoWithDependents(todo))}
2867:         {todos.filter(t => !rendered.has(t.id)).map(todo => renderTodoWithDependents(todo))}
2868:       </div>
2869:     );
2870:   };
2871: 
2872:   return (
2873:     <div className="space-y-4">
2874:       {/* Header */}
2875:       <div className="flex items-center justify-between">
2876:         <div className="flex items-center gap-3">
2877:           <ListChecks className="h-5 w-5 text-primary" />
2878:           <div>
2879:             <h3 className="text-sm font-medium">Todo Overview</h3>
2880:             <p className="text-xs text-muted-foreground">
2881:               {stats.total} total • {stats.completed} completed • {stats.completionRate}% done
2882:             </p>
2883:           </div>
2884:         </div>
2885:         
2886:         {/* Export Options */}
2887:         <div className="flex items-center gap-2">
2888:           <Button
2889:             size="sm"
2890:             variant="outline"
2891:             className="h-7 text-xs"
2892:             onClick={exportAsJson}
2893:           >
2894:             <Download className="h-3 w-3 mr-1" />
2895:             JSON
2896:           </Button>
2897:           <Button
2898:             size="sm"
2899:             variant="outline"
2900:             className="h-7 text-xs"
2901:             onClick={exportAsMarkdown}
2902:           >
2903:             <Download className="h-3 w-3 mr-1" />
2904:             Markdown
2905:           </Button>
2906:         </div>
2907:       </div>
2908: 
2909:       {/* Search and Filters */}
2910:       <div className="flex flex-col sm:flex-row gap-2">
2911:         <div className="relative flex-1">
2912:           <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
2913:           <Input
2914:             type="text"
2915:             placeholder="Search todos..."
2916:             value={searchQuery}
2917:             onChange={(e) => setSearchQuery(e.target.value)}
2918:             className="pl-9 h-9"
2919:           />
2920:         </div>
2921:         
2922:         <div className="flex gap-2">
2923:           <div className="flex gap-1 p-1 bg-muted rounded-md">
2924:             {["all", "pending", "in_progress", "completed", "cancelled"].map(status => (
2925:               <Button
2926:                 key={status}
2927:                 size="sm"
2928:                 variant={statusFilter === status ? "default" : "ghost"}
2929:                 className="h-7 px-2 text-xs"
2930:                 onClick={() => setStatusFilter(status)}
2931:               >
2932:                 {status === "all" ? "All" : statusConfig[status as keyof typeof statusConfig]?.label}
2933:                 {status === "all" && (
2934:                   <Badge variant="secondary" className="ml-1 h-4 px-1 text-xs">
2935:                     {stats.total}
2936:                   </Badge>
2937:                 )}
2938:               </Button>
2939:             ))}
2940:           </div>
2941:         </div>
2942:       </div>
2943: 
2944:       {/* View Mode Tabs */}
2945:       <Tabs value={viewMode} onValueChange={(v) => setViewMode(v as typeof viewMode)}>
2946:         <TabsList className="grid w-full grid-cols-4">
2947:           <TabsTrigger value="list" className="text-xs">
2948:             <LayoutList className="h-4 w-4 mr-1" />
2949:             List
2950:           </TabsTrigger>
2951:           <TabsTrigger value="board" className="text-xs">
2952:             <LayoutGrid className="h-4 w-4 mr-1" />
2953:             Board
2954:           </TabsTrigger>
2955:           <TabsTrigger value="timeline" className="text-xs">
2956:             <GitBranch className="h-4 w-4 mr-1" />
2957:             Timeline
2958:           </TabsTrigger>
2959:           <TabsTrigger value="stats" className="text-xs">
2960:             <BarChart3 className="h-4 w-4 mr-1" />
2961:             Stats
2962:           </TabsTrigger>
2963:         </TabsList>
2964: 
2965:         <TabsContent value="list" className="mt-4">
2966:           <div className="space-y-2">
2967:             <AnimatePresence mode="popLayout">
2968:               {filteredTodos.map(todo => (
2969:                 <TodoCard 
2970:                   key={todo.id || filteredTodos.indexOf(todo)} 
2971:                   todo={todo} 
2972:                   isExpanded={expandedTodos.has(todo.id)}
2973:                 />
2974:               ))}
2975:             </AnimatePresence>
2976:             {filteredTodos.length === 0 && (
2977:               <div className="text-center py-8 text-sm text-muted-foreground">
2978:                 {searchQuery || statusFilter !== "all" 
2979:                   ? "No todos match your filters" 
2980:                   : "No todos available"}
2981:               </div>
2982:             )}
2983:           </div>
2984:         </TabsContent>
2985: 
2986:         <TabsContent value="board" className="mt-4">
2987:           <BoardView />
2988:         </TabsContent>
2989: 
2990:         <TabsContent value="timeline" className="mt-4">
2991:           <TimelineView />
2992:         </TabsContent>
2993: 
2994:         <TabsContent value="stats" className="mt-4">
2995:           <StatsView />
2996:         </TabsContent>
2997:       </Tabs>
2998:     </div>
2999:   );
3000: };
````

## File: src/components/Topbar.tsx
````typescript
  1: import React, { useEffect, useState } from "react";
  2: import { motion } from "framer-motion";
  3: import { Circle, FileText, Settings, ExternalLink, BarChart3, Network, Info, Bot } from "lucide-react";
  4: import { Button } from "@/components/ui/button";
  5: import { Popover } from "@/components/ui/popover";
  6: import { api, type ClaudeVersionStatus } from "@/lib/api";
  7: import { cn } from "@/lib/utils";
  8: 
  9: interface TopbarProps {
 10:   /**
 11:    * Callback when CLAUDE.md is clicked
 12:    */
 13:   onClaudeClick: () => void;
 14:   /**
 15:    * Callback when Settings is clicked
 16:    */
 17:   onSettingsClick: () => void;
 18:   /**
 19:    * Callback when Usage Dashboard is clicked
 20:    */
 21:   onUsageClick: () => void;
 22:   /**
 23:    * Callback when MCP is clicked
 24:    */
 25:   onMCPClick: () => void;
 26:   /**
 27:    * Callback when Info is clicked
 28:    */
 29:   onInfoClick: () => void;
 30:   /**
 31:    * Callback when Agents is clicked
 32:    */
 33:   onAgentsClick?: () => void;
 34:   /**
 35:    * Optional className for styling
 36:    */
 37:   className?: string;
 38: }
 39: 
 40: /**
 41:  * Topbar component with status indicator and navigation buttons
 42:  * 
 43:  * @example
 44:  * <Topbar
 45:  *   onClaudeClick={() => setView('editor')}
 46:  *   onSettingsClick={() => setView('settings')}
 47:  *   onUsageClick={() => setView('usage-dashboard')}
 48:  *   onMCPClick={() => setView('mcp')}
 49:  * />
 50:  */
 51: export const Topbar: React.FC<TopbarProps> = ({
 52:   onClaudeClick,
 53:   onSettingsClick,
 54:   onUsageClick,
 55:   onMCPClick,
 56:   onInfoClick,
 57:   onAgentsClick,
 58:   className,
 59: }) => {
 60:   const [versionStatus, setVersionStatus] = useState<ClaudeVersionStatus | null>(null);
 61:   const [checking, setChecking] = useState(true);
 62:   
 63:   // Check Claude version on mount
 64:   useEffect(() => {
 65:     checkVersion();
 66:   }, []);
 67:   
 68:   const checkVersion = async () => {
 69:     try {
 70:       setChecking(true);
 71:       const status = await api.checkClaudeVersion();
 72:       setVersionStatus(status);
 73:       
 74:       // If Claude is not installed and the error indicates it wasn't found
 75:       if (!status.is_installed && status.output.includes("No such file or directory")) {
 76:         // Emit an event that can be caught by the parent
 77:         window.dispatchEvent(new CustomEvent('claude-not-found'));
 78:       }
 79:     } catch (err) {
 80:       console.error("Failed to check Claude version:", err);
 81:       setVersionStatus({
 82:         is_installed: false,
 83:         output: "Failed to check version",
 84:       });
 85:     } finally {
 86:       setChecking(false);
 87:     }
 88:   };
 89:   
 90:   const StatusIndicator = () => {
 91:     if (checking) {
 92:       return (
 93:         <div className="flex items-center space-x-2 text-xs">
 94:           <Circle className="h-3 w-3 animate-pulse text-muted-foreground" />
 95:           <span className="text-muted-foreground">Checking...</span>
 96:         </div>
 97:       );
 98:     }
 99:     
100:     if (!versionStatus) return null;
101:     
102:     const statusContent = (
103:       <Button
104:         variant="ghost"
105:         size="sm"
106:         className="h-auto py-1 px-2 hover:bg-accent"
107:         onClick={onSettingsClick}
108:       >
109:         <div className="flex items-center space-x-2 text-xs">
110:           <Circle
111:             className={cn(
112:               "h-3 w-3",
113:               versionStatus.is_installed 
114:                 ? "fill-green-500 text-green-500" 
115:                 : "fill-red-500 text-red-500"
116:             )}
117:           />
118:           <span>
119:             {versionStatus.is_installed && versionStatus.version
120:               ? `Claude Code v${versionStatus.version}`
121:               : "Claude Code"}
122:           </span>
123:         </div>
124:       </Button>
125:     );
126:     
127:     if (!versionStatus.is_installed) {
128:       return (
129:         <Popover
130:           trigger={statusContent}
131:           content={
132:             <div className="space-y-3 max-w-xs">
133:               <p className="text-sm font-medium">Claude Code not found</p>
134:               <div className="rounded-md bg-muted p-3">
135:                 <pre className="text-xs font-mono whitespace-pre-wrap">
136:                   {versionStatus.output}
137:                 </pre>
138:               </div>
139:               <Button
140:                 variant="outline"
141:                 size="sm"
142:                 className="w-full"
143:                 onClick={onSettingsClick}
144:               >
145:                 Select Claude Installation
146:               </Button>
147:               <a
148:                 href="https://www.anthropic.com/claude-code"
149:                 target="_blank"
150:                 rel="noopener noreferrer"
151:                 className="flex items-center space-x-1 text-xs text-primary hover:underline"
152:               >
153:                 <span>Install Claude Code</span>
154:                 <ExternalLink className="h-3 w-3" />
155:               </a>
156:             </div>
157:           }
158:           align="start"
159:         />
160:       );
161:     }
162:     
163:     return statusContent;
164:   };
165:   
166:   return (
167:     <motion.div
168:       initial={{ opacity: 0, y: -20 }}
169:       animate={{ opacity: 1, y: 0 }}
170:       transition={{ duration: 0.3 }}
171:       className={cn(
172:         "flex items-center justify-between px-4 py-3 border-b border-border bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60",
173:         className
174:       )}
175:     >
176:       {/* Status Indicator */}
177:       <StatusIndicator />
178:       
179:       {/* Action Buttons */}
180:       <div className="flex items-center space-x-2">
181:         {onAgentsClick && (
182:           <Button
183:             variant="ghost"
184:             size="sm"
185:             onClick={onAgentsClick}
186:             className="text-xs"
187:           >
188:             <Bot className="mr-2 h-3 w-3" />
189:             Agents
190:           </Button>
191:         )}
192:         
193:         <Button
194:           variant="ghost"
195:           size="sm"
196:           onClick={onUsageClick}
197:           className="text-xs"
198:         >
199:           <BarChart3 className="mr-2 h-3 w-3" />
200:           Usage Dashboard
201:         </Button>
202:         
203:         <Button
204:           variant="ghost"
205:           size="sm"
206:           onClick={onClaudeClick}
207:           className="text-xs"
208:         >
209:           <FileText className="mr-2 h-3 w-3" />
210:           CLAUDE.md
211:         </Button>
212:         
213:         <Button
214:           variant="ghost"
215:           size="sm"
216:           onClick={onMCPClick}
217:           className="text-xs"
218:         >
219:           <Network className="mr-2 h-3 w-3" />
220:           MCP
221:         </Button>
222:         
223:         <Button
224:           variant="ghost"
225:           size="sm"
226:           onClick={onSettingsClick}
227:           className="text-xs"
228:         >
229:           <Settings className="mr-2 h-3 w-3" />
230:           Settings
231:         </Button>
232:         
233:         <Button
234:           variant="ghost"
235:           size="icon"
236:           onClick={onInfoClick}
237:           className="h-8 w-8"
238:           title="About"
239:         >
240:           <Info className="h-4 w-4" />
241:         </Button>
242:       </div>
243:     </motion.div>
244:   );
245: };
````

## File: src/components/UsageDashboard.tsx
````typescript
  1: import React, { useState, useEffect } from "react";
  2: import { motion } from "framer-motion";
  3: import { Button } from "@/components/ui/button";
  4: import { Card } from "@/components/ui/card";
  5: import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
  6: import { Badge } from "@/components/ui/badge";
  7: import { api, type UsageStats, type ProjectUsage } from "@/lib/api";
  8: import { 
  9:   ArrowLeft, 
 10:   TrendingUp, 
 11:   Calendar, 
 12:   Filter,
 13:   Loader2,
 14:   DollarSign,
 15:   Activity,
 16:   FileText,
 17:   Briefcase
 18: } from "lucide-react";
 19: import { cn } from "@/lib/utils";
 20: 
 21: interface UsageDashboardProps {
 22:   /**
 23:    * Callback when back button is clicked
 24:    */
 25:   onBack: () => void;
 26: }
 27: 
 28: /**
 29:  * UsageDashboard component - Displays Claude API usage statistics and costs
 30:  * 
 31:  * @example
 32:  * <UsageDashboard onBack={() => setView('welcome')} />
 33:  */
 34: export const UsageDashboard: React.FC<UsageDashboardProps> = ({ onBack }) => {
 35:   const [loading, setLoading] = useState(true);
 36:   const [error, setError] = useState<string | null>(null);
 37:   const [stats, setStats] = useState<UsageStats | null>(null);
 38:   const [sessionStats, setSessionStats] = useState<ProjectUsage[] | null>(null);
 39:   const [selectedDateRange, setSelectedDateRange] = useState<"all" | "7d" | "30d">("all");
 40:   const [activeTab, setActiveTab] = useState("overview");
 41: 
 42:   useEffect(() => {
 43:     loadUsageStats();
 44:   }, [selectedDateRange]);
 45: 
 46:   const loadUsageStats = async () => {
 47:     try {
 48:       setLoading(true);
 49:       setError(null);
 50: 
 51:       let statsData: UsageStats;
 52:       let sessionData: ProjectUsage[];
 53:       
 54:       if (selectedDateRange === "all") {
 55:         statsData = await api.getUsageStats();
 56:         sessionData = await api.getSessionStats();
 57:       } else {
 58:         const endDate = new Date();
 59:         const startDate = new Date();
 60:         const days = selectedDateRange === "7d" ? 7 : 30;
 61:         startDate.setDate(startDate.getDate() - days);
 62:         
 63:         const formatDateForApi = (date: Date) => {
 64:             const year = date.getFullYear();
 65:             const month = String(date.getMonth() + 1).padStart(2, '0');
 66:             const day = String(date.getDate()).padStart(2, '0');
 67:             return `${year}${month}${day}`;
 68:         }
 69: 
 70:         statsData = await api.getUsageByDateRange(
 71:           startDate.toISOString(),
 72:           endDate.toISOString()
 73:         );
 74:         sessionData = await api.getSessionStats(
 75:             formatDateForApi(startDate),
 76:             formatDateForApi(endDate),
 77:             'desc'
 78:         );
 79:       }
 80:       
 81:       setStats(statsData);
 82:       setSessionStats(sessionData);
 83:     } catch (err) {
 84:       console.error("Failed to load usage stats:", err);
 85:       setError("Failed to load usage statistics. Please try again.");
 86:     } finally {
 87:       setLoading(false);
 88:     }
 89:   };
 90: 
 91:   const formatCurrency = (amount: number): string => {
 92:     return new Intl.NumberFormat('en-US', {
 93:       style: 'currency',
 94:       currency: 'USD',
 95:       minimumFractionDigits: 2,
 96:       maximumFractionDigits: 4
 97:     }).format(amount);
 98:   };
 99: 
100:   const formatNumber = (num: number): string => {
101:     return new Intl.NumberFormat('en-US').format(num);
102:   };
103: 
104:   const formatTokens = (num: number): string => {
105:     if (num >= 1_000_000) {
106:       return `${(num / 1_000_000).toFixed(2)}M`;
107:     } else if (num >= 1_000) {
108:       return `${(num / 1_000).toFixed(1)}K`;
109:     }
110:     return formatNumber(num);
111:   };
112: 
113:   const getModelDisplayName = (model: string): string => {
114:     const modelMap: Record<string, string> = {
115:       "claude-4-opus": "Opus 4",
116:       "claude-4-sonnet": "Sonnet 4",
117:       "claude-3.5-sonnet": "Sonnet 3.5",
118:       "claude-3-opus": "Opus 3",
119:     };
120:     return modelMap[model] || model;
121:   };
122: 
123:   const getModelColor = (model: string): string => {
124:     if (model.includes("opus")) return "text-purple-500";
125:     if (model.includes("sonnet")) return "text-blue-500";
126:     return "text-gray-500";
127:   };
128: 
129:   return (
130:     <div className="flex-1 flex flex-col overflow-hidden">
131:       {/* Header */}
132:       <motion.div
133:         initial={{ opacity: 0, y: -20 }}
134:         animate={{ opacity: 1, y: 0 }}
135:         transition={{ duration: 0.3 }}
136:         className="border-b border-border bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60"
137:       >
138:         <div className="flex items-center justify-between px-4 py-3">
139:           <div className="flex items-center space-x-4">
140:             <Button
141:               variant="ghost"
142:               size="icon"
143:               onClick={onBack}
144:               className="h-8 w-8"
145:             >
146:               <ArrowLeft className="h-4 w-4" />
147:             </Button>
148:             <div>
149:               <h1 className="text-lg font-semibold">Usage Dashboard</h1>
150:               <p className="text-xs text-muted-foreground">
151:                 Track your Claude Code usage and costs
152:               </p>
153:             </div>
154:           </div>
155:           
156:           {/* Date Range Filter */}
157:           <div className="flex items-center space-x-2">
158:             <Filter className="h-4 w-4 text-muted-foreground" />
159:             <div className="flex space-x-1">
160:               {(["all", "30d", "7d"] as const).map((range) => (
161:                 <Button
162:                   key={range}
163:                   variant={selectedDateRange === range ? "default" : "ghost"}
164:                   size="sm"
165:                   onClick={() => setSelectedDateRange(range)}
166:                   className="text-xs"
167:                 >
168:                   {range === "all" ? "All Time" : range === "7d" ? "Last 7 Days" : "Last 30 Days"}
169:                 </Button>
170:               ))}
171:             </div>
172:           </div>
173:         </div>
174:       </motion.div>
175: 
176:       {/* Main Content */}
177:       <div className="flex-1 overflow-auto p-4">
178:         {loading ? (
179:           <div className="flex items-center justify-center h-full">
180:             <div className="text-center">
181:               <Loader2 className="h-8 w-8 animate-spin text-muted-foreground mx-auto mb-4" />
182:               <p className="text-sm text-muted-foreground">Loading usage statistics...</p>
183:             </div>
184:           </div>
185:         ) : error ? (
186:           <div className="flex items-center justify-center h-full">
187:             <div className="text-center max-w-md">
188:               <p className="text-sm text-destructive mb-4">{error}</p>
189:               <Button onClick={loadUsageStats} size="sm">
190:                 Try Again
191:               </Button>
192:             </div>
193:           </div>
194:         ) : stats ? (
195:           <motion.div
196:             initial={{ opacity: 0 }}
197:             animate={{ opacity: 1 }}
198:             transition={{ duration: 0.3 }}
199:             className="max-w-6xl mx-auto space-y-6"
200:           >
201:             {/* Summary Cards */}
202:             <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
203:               {/* Total Cost Card */}
204:               <Card className="p-4 shimmer-hover">
205:                 <div className="flex items-center justify-between">
206:                   <div>
207:                     <p className="text-xs text-muted-foreground">Total Cost</p>
208:                     <p className="text-2xl font-bold mt-1">
209:                       {formatCurrency(stats.total_cost)}
210:                     </p>
211:                   </div>
212:                   <DollarSign className="h-8 w-8 text-muted-foreground/20 rotating-symbol" />
213:                 </div>
214:               </Card>
215: 
216:               {/* Total Sessions Card */}
217:               <Card className="p-4 shimmer-hover">
218:                 <div className="flex items-center justify-between">
219:                   <div>
220:                     <p className="text-xs text-muted-foreground">Total Sessions</p>
221:                     <p className="text-2xl font-bold mt-1">
222:                       {formatNumber(stats.total_sessions)}
223:                     </p>
224:                   </div>
225:                   <FileText className="h-8 w-8 text-muted-foreground/20 rotating-symbol" />
226:                 </div>
227:               </Card>
228: 
229:               {/* Total Tokens Card */}
230:               <Card className="p-4 shimmer-hover">
231:                 <div className="flex items-center justify-between">
232:                   <div>
233:                     <p className="text-xs text-muted-foreground">Total Tokens</p>
234:                     <p className="text-2xl font-bold mt-1">
235:                       {formatTokens(stats.total_tokens)}
236:                     </p>
237:                   </div>
238:                   <Activity className="h-8 w-8 text-muted-foreground/20 rotating-symbol" />
239:                 </div>
240:               </Card>
241: 
242:               {/* Average Cost per Session Card */}
243:               <Card className="p-4 shimmer-hover">
244:                 <div className="flex items-center justify-between">
245:                   <div>
246:                     <p className="text-xs text-muted-foreground">Avg Cost/Session</p>
247:                     <p className="text-2xl font-bold mt-1">
248:                       {formatCurrency(
249:                         stats.total_sessions > 0 
250:                           ? stats.total_cost / stats.total_sessions 
251:                           : 0
252:                       )}
253:                     </p>
254:                   </div>
255:                   <TrendingUp className="h-8 w-8 text-muted-foreground/20 rotating-symbol" />
256:                 </div>
257:               </Card>
258:             </div>
259: 
260:             {/* Tabs for different views */}
261:             <Tabs value={activeTab} onValueChange={setActiveTab}>
262:               <TabsList className="grid w-full grid-cols-5">
263:                 <TabsTrigger value="overview">Overview</TabsTrigger>
264:                 <TabsTrigger value="models">By Model</TabsTrigger>
265:                 <TabsTrigger value="projects">By Project</TabsTrigger>
266:                 <TabsTrigger value="sessions">By Session</TabsTrigger>
267:                 <TabsTrigger value="timeline">Timeline</TabsTrigger>
268:               </TabsList>
269: 
270:               {/* Overview Tab */}
271:               <TabsContent value="overview" className="space-y-4">
272:                 <Card className="p-6">
273:                   <h3 className="text-sm font-semibold mb-4">Token Breakdown</h3>
274:                   <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
275:                     <div>
276:                       <p className="text-xs text-muted-foreground">Input Tokens</p>
277:                       <p className="text-lg font-semibold">{formatTokens(stats.total_input_tokens)}</p>
278:                     </div>
279:                     <div>
280:                       <p className="text-xs text-muted-foreground">Output Tokens</p>
281:                       <p className="text-lg font-semibold">{formatTokens(stats.total_output_tokens)}</p>
282:                     </div>
283:                     <div>
284:                       <p className="text-xs text-muted-foreground">Cache Write</p>
285:                       <p className="text-lg font-semibold">{formatTokens(stats.total_cache_creation_tokens)}</p>
286:                     </div>
287:                     <div>
288:                       <p className="text-xs text-muted-foreground">Cache Read</p>
289:                       <p className="text-lg font-semibold">{formatTokens(stats.total_cache_read_tokens)}</p>
290:                     </div>
291:                   </div>
292:                 </Card>
293: 
294:                 {/* Quick Stats */}
295:                 <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
296:                   <Card className="p-6">
297:                     <h3 className="text-sm font-semibold mb-4">Most Used Models</h3>
298:                     <div className="space-y-3">
299:                       {stats.by_model.slice(0, 3).map((model) => (
300:                         <div key={model.model} className="flex items-center justify-between">
301:                           <div className="flex items-center space-x-2">
302:                             <Badge variant="outline" className={cn("text-xs", getModelColor(model.model))}>
303:                               {getModelDisplayName(model.model)}
304:                             </Badge>
305:                             <span className="text-xs text-muted-foreground">
306:                               {model.session_count} sessions
307:                             </span>
308:                           </div>
309:                           <span className="text-sm font-medium">
310:                             {formatCurrency(model.total_cost)}
311:                           </span>
312:                         </div>
313:                       ))}
314:                     </div>
315:                   </Card>
316: 
317:                   <Card className="p-6">
318:                     <h3 className="text-sm font-semibold mb-4">Top Projects</h3>
319:                     <div className="space-y-3">
320:                       {stats.by_project.slice(0, 3).map((project) => (
321:                         <div key={project.project_path} className="flex items-center justify-between">
322:                           <div className="flex flex-col">
323:                             <span className="text-sm font-medium truncate max-w-[200px]" title={project.project_path}>
324:                               {project.project_path}
325:                             </span>
326:                             <span className="text-xs text-muted-foreground">
327:                               {project.session_count} sessions
328:                             </span>
329:                           </div>
330:                           <span className="text-sm font-medium">
331:                             {formatCurrency(project.total_cost)}
332:                           </span>
333:                         </div>
334:                       ))}
335:                     </div>
336:                   </Card>
337:                 </div>
338:               </TabsContent>
339: 
340:               {/* Models Tab */}
341:               <TabsContent value="models">
342:                 <Card className="p-6">
343:                   <h3 className="text-sm font-semibold mb-4">Usage by Model</h3>
344:                   <div className="space-y-4">
345:                     {stats.by_model.map((model) => (
346:                       <div key={model.model} className="space-y-2">
347:                         <div className="flex items-center justify-between">
348:                           <div className="flex items-center space-x-3">
349:                             <Badge 
350:                               variant="outline" 
351:                               className={cn("text-xs", getModelColor(model.model))}
352:                             >
353:                               {getModelDisplayName(model.model)}
354:                             </Badge>
355:                             <span className="text-sm text-muted-foreground">
356:                               {model.session_count} sessions
357:                             </span>
358:                           </div>
359:                           <span className="text-sm font-semibold">
360:                             {formatCurrency(model.total_cost)}
361:                           </span>
362:                         </div>
363:                         <div className="grid grid-cols-4 gap-2 text-xs">
364:                           <div>
365:                             <span className="text-muted-foreground">Input: </span>
366:                             <span className="font-medium">{formatTokens(model.input_tokens)}</span>
367:                           </div>
368:                           <div>
369:                             <span className="text-muted-foreground">Output: </span>
370:                             <span className="font-medium">{formatTokens(model.output_tokens)}</span>
371:                           </div>
372:                           <div>
373:                             <span className="text-muted-foreground">Cache W: </span>
374:                             <span className="font-medium">{formatTokens(model.cache_creation_tokens)}</span>
375:                           </div>
376:                           <div>
377:                             <span className="text-muted-foreground">Cache R: </span>
378:                             <span className="font-medium">{formatTokens(model.cache_read_tokens)}</span>
379:                           </div>
380:                         </div>
381:                       </div>
382:                     ))}
383:                   </div>
384:                 </Card>
385:               </TabsContent>
386: 
387:               {/* Projects Tab */}
388:               <TabsContent value="projects">
389:                 <Card className="p-6">
390:                   <h3 className="text-sm font-semibold mb-4">Usage by Project</h3>
391:                   <div className="space-y-3">
392:                     {stats.by_project.map((project) => (
393:                       <div key={project.project_path} className="flex items-center justify-between py-2 border-b border-border last:border-0">
394:                         <div className="flex flex-col truncate">
395:                           <span className="text-sm font-medium truncate" title={project.project_path}>
396:                             {project.project_path}
397:                           </span>
398:                           <div className="flex items-center space-x-3 mt-1">
399:                             <span className="text-xs text-muted-foreground">
400:                               {project.session_count} sessions
401:                             </span>
402:                             <span className="text-xs text-muted-foreground">
403:                               {formatTokens(project.total_tokens)} tokens
404:                             </span>
405:                           </div>
406:                         </div>
407:                         <div className="text-right">
408:                           <p className="text-sm font-semibold">{formatCurrency(project.total_cost)}</p>
409:                           <p className="text-xs text-muted-foreground">
410:                             {formatCurrency(project.total_cost / project.session_count)}/session
411:                           </p>
412:                         </div>
413:                       </div>
414:                     ))}
415:                   </div>
416:                 </Card>
417:               </TabsContent>
418: 
419:               {/* Sessions Tab */}
420:               <TabsContent value="sessions">
421:                   <Card className="p-6">
422:                       <h3 className="text-sm font-semibold mb-4">Usage by Session</h3>
423:                       <div className="space-y-3">
424:                           {sessionStats?.map((session) => (
425:                               <div key={`${session.project_path}-${session.project_name}`} className="flex items-center justify-between py-2 border-b border-border last:border-0">
426:                                   <div className="flex flex-col">
427:                                       <div className="flex items-center space-x-2">
428:                                         <Briefcase className="h-4 w-4 text-muted-foreground" />
429:                                         <span className="text-xs font-mono text-muted-foreground truncate max-w-[200px]" title={session.project_path}>
430:                                             {session.project_path.split('/').slice(-2).join('/')}
431:                                         </span>
432:                                       </div>
433:                                       <span className="text-sm font-medium mt-1">
434:                                           {session.project_name}
435:                                       </span>
436:                                   </div>
437:                                   <div className="text-right">
438:                                       <p className="text-sm font-semibold">{formatCurrency(session.total_cost)}</p>
439:                                       <p className="text-xs text-muted-foreground">
440:                                           {new Date(session.last_used).toLocaleDateString()}
441:                                       </p>
442:                                   </div>
443:                               </div>
444:                           ))}
445:                       </div>
446:                   </Card>
447:               </TabsContent>
448: 
449:               {/* Timeline Tab */}
450:               <TabsContent value="timeline">
451:                 <Card className="p-6">
452:                   <h3 className="text-sm font-semibold mb-6 flex items-center space-x-2">
453:                     <Calendar className="h-4 w-4" />
454:                     <span>Daily Usage</span>
455:                   </h3>
456:                   {stats.by_date.length > 0 ? (() => {
457:                     const maxCost = Math.max(...stats.by_date.map(d => d.total_cost), 0);
458:                     const halfMaxCost = maxCost / 2;
459: 
460:                     return (
461:                       <div className="relative pl-8 pr-4">
462:                         {/* Y-axis labels */}
463:                         <div className="absolute left-0 top-0 bottom-8 flex flex-col justify-between text-xs text-muted-foreground">
464:                           <span>{formatCurrency(maxCost)}</span>
465:                           <span>{formatCurrency(halfMaxCost)}</span>
466:                           <span>{formatCurrency(0)}</span>
467:                         </div>
468:                         
469:                         {/* Chart container */}
470:                         <div className="flex items-end space-x-2 h-64 border-l border-b border-border pl-4">
471:                           {stats.by_date.slice().reverse().map((day) => {
472:                             const heightPercent = maxCost > 0 ? (day.total_cost / maxCost) * 100 : 0;
473:                             const date = new Date(day.date.replace(/-/g, '/'));
474:                             const formattedDate = date.toLocaleDateString('en-US', {
475:                               weekday: 'short',
476:                               month: 'short',
477:                               day: 'numeric'
478:                             });
479:                             
480:                             return (
481:                               <div key={day.date} className="flex-1 h-full flex flex-col items-center justify-end group relative">
482:                                 {/* Tooltip */}
483:                                 <div className="absolute bottom-full mb-2 left-1/2 transform -translate-x-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-10">
484:                                   <div className="bg-background border border-border rounded-lg shadow-lg p-3 whitespace-nowrap">
485:                                     <p className="text-sm font-semibold">{formattedDate}</p>
486:                                     <p className="text-sm text-muted-foreground mt-1">
487:                                       Cost: {formatCurrency(day.total_cost)}
488:                                     </p>
489:                                     <p className="text-xs text-muted-foreground">
490:                                       {formatTokens(day.total_tokens)} tokens
491:                                     </p>
492:                                     <p className="text-xs text-muted-foreground">
493:                                       {day.models_used.length} model{day.models_used.length !== 1 ? 's' : ''}
494:                                     </p>
495:                                   </div>
496:                                   <div className="absolute top-full left-1/2 transform -translate-x-1/2 -mt-1">
497:                                     <div className="border-4 border-transparent border-t-border"></div>
498:                                   </div>
499:                                 </div>
500:                                 
501:                                 {/* Bar */}
502:                                 <div 
503:                                   className="w-full bg-[#d97757] hover:opacity-80 transition-opacity rounded-t cursor-pointer"
504:                                   style={{ height: `${heightPercent}%` }}
505:                                 />
506:                                 
507:                                 {/* X-axis label – absolutely positioned below the bar so it doesn't affect bar height */}
508:                                 <div
509:                                   className="absolute left-1/2 top-full mt-1 -translate-x-1/2 text-xs text-muted-foreground -rotate-45 origin-top-left whitespace-nowrap pointer-events-none"
510:                                 >
511:                                   {date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}
512:                                 </div>
513:                               </div>
514:                             );
515:                           })}
516:                         </div>
517:                         
518:                         {/* X-axis label */}
519:                         <div className="mt-8 text-center text-xs text-muted-foreground">
520:                           Daily Usage Over Time
521:                         </div>
522:                       </div>
523:                     )
524:                   })() : (
525:                     <div className="text-center py-8 text-sm text-muted-foreground">
526:                       No usage data available for the selected period
527:                     </div>
528:                   )}
529:                 </Card>
530:               </TabsContent>
531:             </Tabs>
532:           </motion.div>
533:         ) : null}
534:       </div>
535:     </div>
536:   );
537: };
````

## File: src/components/WebviewPreview.tsx
````typescript
  1: import React, { useState, useRef, useEffect } from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import {
  4:   ArrowLeft,
  5:   ArrowRight,
  6:   RefreshCw,
  7:   X,
  8:   Minimize2,
  9:   Maximize2,
 10:   Loader2,
 11:   AlertCircle,
 12:   Globe,
 13:   Home,
 14: } from "lucide-react";
 15: import { Button } from "@/components/ui/button";
 16: import { Input } from "@/components/ui/input";
 17: import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
 18: import { cn } from "@/lib/utils";
 19: 
 20: interface WebviewPreviewProps {
 21:   /**
 22:    * Initial URL to load
 23:    */
 24:   initialUrl: string;
 25:   /**
 26:    * Callback when close is clicked
 27:    */
 28:   onClose: () => void;
 29:   /**
 30:    * Whether the webview is maximized
 31:    */
 32:   isMaximized?: boolean;
 33:   /**
 34:    * Callback when maximize/minimize is clicked
 35:    */
 36:   onToggleMaximize?: () => void;
 37:   /**
 38:    * Callback when URL changes
 39:    */
 40:   onUrlChange?: (url: string) => void;
 41:   /**
 42:    * Optional className for styling
 43:    */
 44:   className?: string;
 45: }
 46: 
 47: /**
 48:  * WebviewPreview component - Browser-like webview with navigation controls
 49:  * 
 50:  * @example
 51:  * <WebviewPreview
 52:  *   initialUrl="http://localhost:3000"
 53:  *   onClose={() => setShowPreview(false)}
 54:  * />
 55:  */
 56: const WebviewPreviewComponent: React.FC<WebviewPreviewProps> = ({
 57:   initialUrl,
 58:   onClose,
 59:   isMaximized = false,
 60:   onToggleMaximize,
 61:   onUrlChange,
 62:   className,
 63: }) => {
 64:   const [currentUrl, setCurrentUrl] = useState(initialUrl);
 65:   const [inputUrl, setInputUrl] = useState(initialUrl);
 66:   const [isLoading, setIsLoading] = useState(false);
 67:   const [hasError, setHasError] = useState(false);
 68:   const [errorMessage, setErrorMessage] = useState("");
 69:   // TODO: These will be implemented with actual webview navigation
 70:   // const [canGoBack, setCanGoBack] = useState(false);
 71:   // const [canGoForward, setCanGoForward] = useState(false);
 72:   
 73:   // TODO: These will be used for actual Tauri webview implementation
 74:   // const webviewRef = useRef<WebviewWindow | null>(null);
 75:   const iframeRef = useRef<HTMLIFrameElement>(null);
 76:   const containerRef = useRef<HTMLDivElement>(null);
 77:   const contentRef = useRef<HTMLDivElement>(null);
 78:   // const previewId = useRef(`preview-${Date.now()}`);
 79: 
 80:   // Handle ESC key to exit full screen
 81:   useEffect(() => {
 82:     const handleKeyDown = (e: KeyboardEvent) => {
 83:       if (e.key === 'Escape' && isMaximized && onToggleMaximize) {
 84:         onToggleMaximize();
 85:       }
 86:     };
 87: 
 88:     document.addEventListener('keydown', handleKeyDown);
 89:     return () => document.removeEventListener('keydown', handleKeyDown);
 90:   }, [isMaximized, onToggleMaximize]);
 91: 
 92:   // Debug: Log initial URL on mount
 93:   useEffect(() => {
 94:     console.log('[WebviewPreview] Component mounted with initialUrl:', initialUrl, 'isMaximized:', isMaximized);
 95:   }, []);
 96: 
 97:   // Focus management for full screen mode
 98:   useEffect(() => {
 99:     if (isMaximized && containerRef.current) {
100:       containerRef.current.focus();
101:     }
102:   }, [isMaximized]);
103: 
104:   // For now, we'll use an iframe as a placeholder
105:   // In the full implementation, this would create a Tauri webview window
106:   useEffect(() => {
107:     if (currentUrl) {
108:       // This is where we'd create the actual webview
109:       // For now, using iframe for demonstration
110:       setIsLoading(true);
111:       setHasError(false);
112:       
113:       // Simulate loading
114:       const timer = setTimeout(() => {
115:         setIsLoading(false);
116:       }, 1000);
117: 
118:       return () => clearTimeout(timer);
119:     }
120:   }, [currentUrl]);
121: 
122:   const navigate = (url: string) => {
123:     try {
124:       // Validate URL
125:       const urlObj = new URL(url.startsWith('http') ? url : `https://${url}`);
126:       const finalUrl = urlObj.href;
127:       
128:       console.log('[WebviewPreview] Navigating to:', finalUrl);
129:       setCurrentUrl(finalUrl);
130:       setInputUrl(finalUrl);
131:       setHasError(false);
132:       onUrlChange?.(finalUrl);
133:     } catch (err) {
134:       setHasError(true);
135:       setErrorMessage("Invalid URL");
136:     }
137:   };
138: 
139:   const handleNavigate = () => {
140:     if (inputUrl.trim()) {
141:       navigate(inputUrl);
142:     }
143:   };
144: 
145:   const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
146:     if (e.key === 'Enter') {
147:       handleNavigate();
148:     }
149:   };
150: 
151:   const handleGoBack = () => {
152:     // In real implementation, this would call webview.goBack()
153:     console.log("Go back");
154:   };
155: 
156:   const handleGoForward = () => {
157:     // In real implementation, this would call webview.goForward()
158:     console.log("Go forward");
159:   };
160: 
161:   const handleRefresh = () => {
162:     setIsLoading(true);
163:     // In real implementation, this would call webview.reload()
164:     setTimeout(() => setIsLoading(false), 1000);
165:   };
166: 
167:   const handleGoHome = () => {
168:     navigate(initialUrl);
169:   };
170: 
171:   return (
172:     <div 
173:       ref={containerRef}
174:       className={cn("flex flex-col h-full bg-background border-l", className)}
175:       tabIndex={-1}
176:       role="region"
177:       aria-label="Web preview"
178:     >
179:       {/* Browser Top Bar */}
180:       <div className="border-b bg-muted/30 flex-shrink-0">
181:         {/* Title Bar */}
182:         <div className="flex items-center justify-between px-3 py-2 border-b">
183:           <div className="flex items-center gap-2">
184:             <Globe className="h-4 w-4 text-muted-foreground" />
185:             <span className="text-sm font-medium">Preview</span>
186:             {isLoading && (
187:               <Loader2 className="h-3 w-3 animate-spin text-muted-foreground" />
188:             )}
189:           </div>
190:           
191:           <div className="flex items-center gap-1">
192:             {onToggleMaximize && (
193:               <TooltipProvider>
194:                 <Tooltip>
195:                   <TooltipTrigger asChild>
196:                     <Button
197:                       variant="ghost"
198:                       size="icon"
199:                       onClick={onToggleMaximize}
200:                       className="h-7 w-7"
201:                     >
202:                       {isMaximized ? (
203:                         <Minimize2 className="h-3.5 w-3.5" />
204:                       ) : (
205:                         <Maximize2 className="h-3.5 w-3.5" />
206:                       )}
207:                     </Button>
208:                   </TooltipTrigger>
209:                   <TooltipContent>
210:                     {isMaximized ? "Exit full screen (ESC)" : "Enter full screen"}
211:                   </TooltipContent>
212:                 </Tooltip>
213:               </TooltipProvider>
214:             )}
215:             <Button
216:               variant="ghost"
217:               size="icon"
218:               onClick={onClose}
219:               className="h-7 w-7 hover:bg-destructive/10 hover:text-destructive"
220:             >
221:               <X className="h-3.5 w-3.5" />
222:             </Button>
223:           </div>
224:         </div>
225:         
226:         {/* Navigation Bar */}
227:         <div className="flex items-center gap-2 px-3 py-2">
228:           {/* Navigation Buttons */}
229:           <div className="flex items-center gap-1">
230:             <Button
231:               variant="ghost"
232:               size="icon"
233:               onClick={handleGoBack}
234:               disabled={true} // TODO: Enable when implementing actual navigation
235:               className="h-8 w-8"
236:             >
237:               <ArrowLeft className="h-4 w-4" />
238:             </Button>
239:             <Button
240:               variant="ghost"
241:               size="icon"
242:               onClick={handleGoForward}
243:               disabled={true} // TODO: Enable when implementing actual navigation
244:               className="h-8 w-8"
245:             >
246:               <ArrowRight className="h-4 w-4" />
247:             </Button>
248:             <Button
249:               variant="ghost"
250:               size="icon"
251:               onClick={handleRefresh}
252:               disabled={isLoading}
253:               className="h-8 w-8"
254:             >
255:               <RefreshCw className={cn("h-4 w-4", isLoading && "animate-spin")} />
256:             </Button>
257:             <Button
258:               variant="ghost"
259:               size="icon"
260:               onClick={handleGoHome}
261:               className="h-8 w-8"
262:             >
263:               <Home className="h-4 w-4" />
264:             </Button>
265:           </div>
266:           
267:           {/* URL Bar */}
268:           <div className="flex-1 relative">
269:             <Input
270:               value={inputUrl}
271:               onChange={(e) => setInputUrl(e.target.value)}
272:               onKeyDown={handleKeyDown}
273:               placeholder="Enter URL..."
274:               className="pr-10 h-8 text-sm font-mono"
275:             />
276:             {inputUrl !== currentUrl && (
277:               <Button
278:                 variant="ghost"
279:                 size="icon"
280:                 onClick={handleNavigate}
281:                 className="absolute right-1 top-1 h-6 w-6"
282:               >
283:                 <ArrowRight className="h-3 w-3" />
284:               </Button>
285:             )}
286:           </div>
287:         </div>
288:       </div>
289:       
290:       {/* Webview Content */}
291:       <div className="flex-1 relative bg-background" ref={contentRef}>
292:         {/* Loading Overlay */}
293:         <AnimatePresence>
294:           {isLoading && (
295:             <motion.div
296:               initial={{ opacity: 0 }}
297:               animate={{ opacity: 1 }}
298:               exit={{ opacity: 0 }}
299:               className="absolute inset-0 bg-background/80 backdrop-blur-sm z-10 flex items-center justify-center"
300:             >
301:               <div className="flex flex-col items-center gap-3">
302:                 <Loader2 className="h-8 w-8 animate-spin text-primary" />
303:                 <p className="text-sm text-muted-foreground">Loading preview...</p>
304:               </div>
305:             </motion.div>
306:           )}
307:         </AnimatePresence>
308:         
309:         {/* Error State */}
310:         {hasError ? (
311:           <div className="flex flex-col items-center justify-center h-full p-8">
312:             <AlertCircle className="h-12 w-12 text-destructive mb-4" />
313:             <h3 className="text-lg font-semibold mb-2">Failed to load preview</h3>
314:             <p className="text-sm text-muted-foreground text-center mb-4">
315:               {errorMessage || "The page could not be loaded. Please check the URL and try again."}
316:             </p>
317:             <Button onClick={handleRefresh} variant="outline" size="sm">
318:               Try Again
319:             </Button>
320:           </div>
321:         ) : currentUrl ? (
322:           // Placeholder iframe - in real implementation, this would be a Tauri webview
323:           <iframe
324:             ref={iframeRef}
325:             src={currentUrl}
326:             className="absolute inset-0 w-full h-full border-0"
327:             title="Preview"
328:             sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox"
329:             onLoad={() => setIsLoading(false)}
330:             onError={() => {
331:               setHasError(true);
332:               setIsLoading(false);
333:             }}
334:           />
335:         ) : (
336:           // Empty state when no URL is provided
337:           <div className="flex flex-col items-center justify-center h-full p-8 text-foreground">
338:             <Globe className="h-16 w-16 text-muted-foreground/50 mb-6" />
339:             <h3 className="text-xl font-semibold mb-3">Enter a URL to preview</h3>
340:             <p className="text-sm text-muted-foreground text-center mb-6 max-w-md">
341:               Enter a URL in the address bar above to preview a website.
342:             </p>
343:             <div className="flex items-center gap-2 text-sm text-muted-foreground">
344:               <span>Try entering</span>
345:               <code className="px-2 py-1 bg-muted/50 text-foreground rounded font-mono text-xs">localhost:3000</code>
346:               <span>or any other URL</span>
347:             </div>
348:           </div>
349:         )}
350:       </div>
351:     </div>
352:   );
353: };
354: 
355: export const WebviewPreview = React.memo(WebviewPreviewComponent);
````

## File: src/contexts/TabContext.tsx
````typescript
  1: import React, { createContext, useState, useContext, useCallback, useEffect } from 'react';
  2: 
  3: export interface Tab {
  4:   id: string;
  5:   type: 'chat' | 'agent' | 'projects' | 'usage' | 'mcp' | 'settings' | 'claude-md' | 'claude-file' | 'agent-execution' | 'create-agent' | 'import-agent';
  6:   title: string;
  7:   sessionId?: string;  // for chat tabs
  8:   sessionData?: any; // for chat tabs - stores full session object
  9:   agentRunId?: string; // for agent tabs
 10:   agentData?: any; // for agent-execution tabs
 11:   claudeFileId?: string; // for claude-file tabs
 12:   initialProjectPath?: string; // for chat tabs
 13:   status: 'active' | 'idle' | 'running' | 'complete' | 'error';
 14:   hasUnsavedChanges: boolean;
 15:   order: number;
 16:   icon?: string;
 17:   createdAt: Date;
 18:   updatedAt: Date;
 19: }
 20: 
 21: interface TabContextType {
 22:   tabs: Tab[];
 23:   activeTabId: string | null;
 24:   addTab: (tab: Omit<Tab, 'id' | 'order' | 'createdAt' | 'updatedAt'>) => string;
 25:   removeTab: (id: string) => void;
 26:   updateTab: (id: string, updates: Partial<Tab>) => void;
 27:   setActiveTab: (id: string) => void;
 28:   reorderTabs: (startIndex: number, endIndex: number) => void;
 29:   getTabById: (id: string) => Tab | undefined;
 30:   closeAllTabs: () => void;
 31:   getTabsByType: (type: 'chat' | 'agent') => Tab[];
 32: }
 33: 
 34: const TabContext = createContext<TabContextType | undefined>(undefined);
 35: 
 36: // const STORAGE_KEY = 'claudia_tabs'; // No longer needed - persistence disabled
 37: const MAX_TABS = 20;
 38: 
 39: export const TabProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
 40:   const [tabs, setTabs] = useState<Tab[]>([]);
 41:   const [activeTabId, setActiveTabId] = useState<string | null>(null);
 42: 
 43:   // Always start with a fresh CC Projects tab
 44:   useEffect(() => {
 45:     // Create default projects tab
 46:     const defaultTab: Tab = {
 47:       id: generateTabId(),
 48:       type: 'projects',
 49:       title: 'CC Projects',
 50:       status: 'idle',
 51:       hasUnsavedChanges: false,
 52:       order: 0,
 53:       createdAt: new Date(),
 54:       updatedAt: new Date()
 55:     };
 56:     setTabs([defaultTab]);
 57:     setActiveTabId(defaultTab.id);
 58:   }, []);
 59: 
 60:   // Tab persistence disabled - no longer saving to localStorage
 61:   // useEffect(() => {
 62:   //   if (tabs.length > 0) {
 63:   //     const tabsToSave = tabs.map(tab => ({
 64:   //       ...tab,
 65:   //       createdAt: tab.createdAt.toISOString(),
 66:   //       updatedAt: tab.updatedAt.toISOString()
 67:   //     }));
 68:   //     localStorage.setItem(STORAGE_KEY, JSON.stringify(tabsToSave));
 69:   //   }
 70:   // }, [tabs]);
 71: 
 72:   const generateTabId = () => {
 73:     return `tab-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
 74:   };
 75: 
 76:   const addTab = useCallback((tabData: Omit<Tab, 'id' | 'order' | 'createdAt' | 'updatedAt'>): string => {
 77:     if (tabs.length >= MAX_TABS) {
 78:       throw new Error(`Maximum number of tabs (${MAX_TABS}) reached`);
 79:     }
 80: 
 81:     const newTab: Tab = {
 82:       ...tabData,
 83:       id: generateTabId(),
 84:       order: tabs.length,
 85:       createdAt: new Date(),
 86:       updatedAt: new Date()
 87:     };
 88: 
 89:     setTabs(prevTabs => [...prevTabs, newTab]);
 90:     setActiveTabId(newTab.id);
 91:     return newTab.id;
 92:   }, [tabs.length]);
 93: 
 94:   const removeTab = useCallback((id: string) => {
 95:     setTabs(prevTabs => {
 96:       const filteredTabs = prevTabs.filter(tab => tab.id !== id);
 97:       
 98:       // Reorder remaining tabs
 99:       const reorderedTabs = filteredTabs.map((tab, index) => ({
100:         ...tab,
101:         order: index
102:       }));
103: 
104:       // Update active tab if necessary
105:       if (activeTabId === id && reorderedTabs.length > 0) {
106:         const removedTabIndex = prevTabs.findIndex(tab => tab.id === id);
107:         const newActiveIndex = Math.min(removedTabIndex, reorderedTabs.length - 1);
108:         setActiveTabId(reorderedTabs[newActiveIndex].id);
109:       } else if (reorderedTabs.length === 0) {
110:         setActiveTabId(null);
111:       }
112: 
113:       return reorderedTabs;
114:     });
115:   }, [activeTabId]);
116: 
117:   const updateTab = useCallback((id: string, updates: Partial<Tab>) => {
118:     setTabs(prevTabs => 
119:       prevTabs.map(tab => 
120:         tab.id === id 
121:           ? { ...tab, ...updates, updatedAt: new Date() }
122:           : tab
123:       )
124:     );
125:   }, []);
126: 
127:   const setActiveTab = useCallback((id: string) => {
128:     if (tabs.find(tab => tab.id === id)) {
129:       setActiveTabId(id);
130:     }
131:   }, [tabs]);
132: 
133:   const reorderTabs = useCallback((startIndex: number, endIndex: number) => {
134:     setTabs(prevTabs => {
135:       const newTabs = [...prevTabs];
136:       const [removed] = newTabs.splice(startIndex, 1);
137:       newTabs.splice(endIndex, 0, removed);
138:       
139:       // Update order property
140:       return newTabs.map((tab, index) => ({
141:         ...tab,
142:         order: index
143:       }));
144:     });
145:   }, []);
146: 
147:   const getTabById = useCallback((id: string): Tab | undefined => {
148:     return tabs.find(tab => tab.id === id);
149:   }, [tabs]);
150: 
151:   const closeAllTabs = useCallback(() => {
152:     setTabs([]);
153:     setActiveTabId(null);
154:     // localStorage.removeItem(STORAGE_KEY); // Persistence disabled
155:   }, []);
156: 
157:   const getTabsByType = useCallback((type: 'chat' | 'agent'): Tab[] => {
158:     return tabs.filter(tab => tab.type === type);
159:   }, [tabs]);
160: 
161:   const value: TabContextType = {
162:     tabs,
163:     activeTabId,
164:     addTab,
165:     removeTab,
166:     updateTab,
167:     setActiveTab,
168:     reorderTabs,
169:     getTabById,
170:     closeAllTabs,
171:     getTabsByType
172:   };
173: 
174:   return (
175:     <TabContext.Provider value={value}>
176:       {children}
177:     </TabContext.Provider>
178:   );
179: };
180: 
181: export const useTabContext = () => {
182:   const context = useContext(TabContext);
183:   if (!context) {
184:     throw new Error('useTabContext must be used within a TabProvider');
185:   }
186:   return context;
187: };
````

## File: src/contexts/ThemeContext.tsx
````typescript
  1: import React, { createContext, useState, useContext, useCallback, useEffect } from 'react';
  2: import { api } from '../lib/api';
  3: 
  4: export type ThemeMode = 'dark' | 'gray' | 'light' | 'custom';
  5: 
  6: export interface CustomThemeColors {
  7:   background: string;
  8:   foreground: string;
  9:   card: string;
 10:   cardForeground: string;
 11:   primary: string;
 12:   primaryForeground: string;
 13:   secondary: string;
 14:   secondaryForeground: string;
 15:   muted: string;
 16:   mutedForeground: string;
 17:   accent: string;
 18:   accentForeground: string;
 19:   destructive: string;
 20:   destructiveForeground: string;
 21:   border: string;
 22:   input: string;
 23:   ring: string;
 24: }
 25: 
 26: interface ThemeContextType {
 27:   theme: ThemeMode;
 28:   customColors: CustomThemeColors;
 29:   setTheme: (theme: ThemeMode) => Promise<void>;
 30:   setCustomColors: (colors: Partial<CustomThemeColors>) => Promise<void>;
 31:   isLoading: boolean;
 32: }
 33: 
 34: const ThemeContext = createContext<ThemeContextType | undefined>(undefined);
 35: 
 36: const THEME_STORAGE_KEY = 'theme_preference';
 37: const CUSTOM_COLORS_STORAGE_KEY = 'theme_custom_colors';
 38: 
 39: // Default custom theme colors (based on current dark theme)
 40: const DEFAULT_CUSTOM_COLORS: CustomThemeColors = {
 41:   background: 'oklch(0.12 0.01 240)',
 42:   foreground: 'oklch(0.98 0.01 240)',
 43:   card: 'oklch(0.14 0.01 240)',
 44:   cardForeground: 'oklch(0.98 0.01 240)',
 45:   primary: 'oklch(0.98 0.01 240)',
 46:   primaryForeground: 'oklch(0.12 0.01 240)',
 47:   secondary: 'oklch(0.16 0.01 240)',
 48:   secondaryForeground: 'oklch(0.98 0.01 240)',
 49:   muted: 'oklch(0.16 0.01 240)',
 50:   mutedForeground: 'oklch(0.65 0.01 240)',
 51:   accent: 'oklch(0.16 0.01 240)',
 52:   accentForeground: 'oklch(0.98 0.01 240)',
 53:   destructive: 'oklch(0.6 0.2 25)',
 54:   destructiveForeground: 'oklch(0.98 0.01 240)',
 55:   border: 'oklch(0.16 0.01 240)',
 56:   input: 'oklch(0.16 0.01 240)',
 57:   ring: 'oklch(0.98 0.01 240)',
 58: };
 59: 
 60: export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
 61:   const [theme, setThemeState] = useState<ThemeMode>('dark');
 62:   const [customColors, setCustomColorsState] = useState<CustomThemeColors>(DEFAULT_CUSTOM_COLORS);
 63:   const [isLoading, setIsLoading] = useState(true);
 64: 
 65:   // Load theme preference and custom colors from storage
 66:   useEffect(() => {
 67:     const loadTheme = async () => {
 68:       try {
 69:         // Load theme preference
 70:         const savedTheme = await api.getSetting(THEME_STORAGE_KEY);
 71:         
 72:         if (savedTheme) {
 73:           const themeMode = savedTheme as ThemeMode;
 74:           setThemeState(themeMode);
 75:           applyTheme(themeMode, customColors);
 76:         }
 77: 
 78:         // Load custom colors
 79:         const savedColors = await api.getSetting(CUSTOM_COLORS_STORAGE_KEY);
 80:         
 81:         if (savedColors) {
 82:           const colors = JSON.parse(savedColors) as CustomThemeColors;
 83:           setCustomColorsState(colors);
 84:           if (theme === 'custom') {
 85:             applyTheme('custom', colors);
 86:           }
 87:         }
 88:       } catch (error) {
 89:         console.error('Failed to load theme settings:', error);
 90:       } finally {
 91:         setIsLoading(false);
 92:       }
 93:     };
 94: 
 95:     loadTheme();
 96:   }, []);
 97: 
 98:   // Apply theme to document
 99:   const applyTheme = useCallback((themeMode: ThemeMode, colors: CustomThemeColors) => {
100:     const root = document.documentElement;
101:     
102:     // Remove all theme classes
103:     root.classList.remove('theme-dark', 'theme-gray', 'theme-light', 'theme-custom');
104:     
105:     // Add new theme class
106:     root.classList.add(`theme-${themeMode}`);
107:     
108:     // If custom theme, apply custom colors as CSS variables
109:     if (themeMode === 'custom') {
110:       Object.entries(colors).forEach(([key, value]) => {
111:         const cssVarName = `--color-${key.replace(/([A-Z])/g, '-$1').toLowerCase()}`;
112:         root.style.setProperty(cssVarName, value);
113:       });
114:     } else {
115:       // Clear custom CSS variables when not using custom theme
116:       Object.keys(colors).forEach((key) => {
117:         const cssVarName = `--color-${key.replace(/([A-Z])/g, '-$1').toLowerCase()}`;
118:         root.style.removeProperty(cssVarName);
119:       });
120:     }
121:   }, []);
122: 
123:   const setTheme = useCallback(async (newTheme: ThemeMode) => {
124:     try {
125:       setIsLoading(true);
126:       
127:       // Apply theme immediately
128:       setThemeState(newTheme);
129:       applyTheme(newTheme, customColors);
130:       
131:       // Save to storage
132:       await api.saveSetting(THEME_STORAGE_KEY, newTheme);
133:     } catch (error) {
134:       console.error('Failed to save theme preference:', error);
135:     } finally {
136:       setIsLoading(false);
137:     }
138:   }, [customColors, applyTheme]);
139: 
140:   const setCustomColors = useCallback(async (colors: Partial<CustomThemeColors>) => {
141:     try {
142:       setIsLoading(true);
143:       
144:       const newColors = { ...customColors, ...colors };
145:       setCustomColorsState(newColors);
146:       
147:       // Apply immediately if custom theme is active
148:       if (theme === 'custom') {
149:         applyTheme('custom', newColors);
150:       }
151:       
152:       // Save to storage
153:       await api.saveSetting(CUSTOM_COLORS_STORAGE_KEY, JSON.stringify(newColors));
154:     } catch (error) {
155:       console.error('Failed to save custom colors:', error);
156:     } finally {
157:       setIsLoading(false);
158:     }
159:   }, [theme, customColors, applyTheme]);
160: 
161:   const value: ThemeContextType = {
162:     theme,
163:     customColors,
164:     setTheme,
165:     setCustomColors,
166:     isLoading,
167:   };
168: 
169:   return (
170:     <ThemeContext.Provider value={value}>
171:       {children}
172:     </ThemeContext.Provider>
173:   );
174: };
175: 
176: export const useThemeContext = () => {
177:   const context = useContext(ThemeContext);
178:   if (!context) {
179:     throw new Error('useThemeContext must be used within a ThemeProvider');
180:   }
181:   return context;
182: };
````

## File: src/hooks/index.ts
````typescript
 1: // Export all custom hooks from a single entry point
 2: export { useLoadingState } from './useLoadingState';
 3: export { useDebounce, useDebouncedCallback } from './useDebounce';
 4: export { useApiCall } from './useApiCall';
 5: export { usePagination } from './usePagination';
 6: export { useTheme } from './useTheme';
 7: export { 
 8:   useAnalytics, 
 9:   useTrackEvent, 
10:   usePageView, 
11:   useAppLifecycle,
12:   useComponentMetrics,
13:   useInteractionTracking,
14:   useScreenTracking,
15:   useFeatureExperiment,
16:   usePathTracking,
17:   useFeatureAdoptionTracking,
18:   useWorkflowTracking,
19:   useAIInteractionTracking,
20:   useNetworkPerformanceTracking
21: } from './useAnalytics';
22: export { 
23:   usePerformanceMonitor, 
24:   useAsyncPerformanceTracker 
25: } from './usePerformanceMonitor';
26: export { TAB_SCREEN_NAMES } from './useAnalytics';
````

## File: src/hooks/useAnalytics.ts
````typescript
  1: import { useCallback, useEffect, useRef } from 'react';
  2: import { analytics, ANALYTICS_EVENTS, eventBuilders } from '@/lib/analytics';
  3: import type { EventName } from '@/lib/analytics/types';
  4: 
  5: // Screen name mapping for tab types
  6: const TAB_SCREEN_NAMES: Record<string, string> = {
  7:   'chat': 'chat_session',
  8:   'agent': 'agent_view',
  9:   'projects': 'projects_list',
 10:   'usage': 'usage_dashboard',
 11:   'mcp': 'mcp_manager',
 12:   'settings': 'settings',
 13:   'claude-md': 'markdown_editor',
 14:   'claude-file': 'file_editor',
 15:   'agent-execution': 'agent_execution',
 16:   'create-agent': 'create_agent',
 17:   'import-agent': 'import_agent',
 18: };
 19: 
 20: interface UseAnalyticsReturn {
 21:   track: (eventName: EventName | string, properties?: Record<string, any>) => void;
 22:   trackEvent: ReturnType<typeof useTrackEvent>;
 23:   isEnabled: boolean;
 24:   hasConsented: boolean;
 25: }
 26: 
 27: export function useAnalytics(): UseAnalyticsReturn {
 28:   const isEnabled = analytics.isEnabled();
 29:   const hasConsented = analytics.hasConsented();
 30:   
 31:   const track = useCallback((eventName: EventName | string, properties?: Record<string, any>) => {
 32:     analytics.track(eventName, properties);
 33:   }, []);
 34:   
 35:   const trackEvent = useTrackEvent();
 36:   
 37:   return {
 38:     track,
 39:     trackEvent,
 40:     isEnabled,
 41:     hasConsented,
 42:   };
 43: }
 44: 
 45: export function useTrackEvent() {
 46:   return {
 47:     // Session events
 48:     sessionCreated: (model: string, source?: string) => {
 49:       const event = eventBuilders.session({ model, source });
 50:       analytics.track(event.event, event.properties);
 51:     },
 52:     
 53:     sessionCompleted: () => {
 54:       analytics.track(ANALYTICS_EVENTS.SESSION_COMPLETED);
 55:     },
 56:     
 57:     sessionResumed: (checkpointId: string) => {
 58:       const event = eventBuilders.session({ resumed: true, checkpoint_id: checkpointId });
 59:       analytics.track(ANALYTICS_EVENTS.SESSION_RESUMED, event.properties);
 60:     },
 61:     
 62:     // Feature usage
 63:     featureUsed: (feature: string, subfeature?: string, metadata?: Record<string, any>) => {
 64:       const event = eventBuilders.feature(feature, subfeature, metadata);
 65:       analytics.track(event.event, event.properties);
 66:     },
 67:     
 68:     // Model selection
 69:     modelSelected: (newModel: string, previousModel?: string, source?: string) => {
 70:       const event = eventBuilders.model(newModel, previousModel, source);
 71:       analytics.track(event.event, event.properties);
 72:     },
 73:     
 74:     // Tab events
 75:     tabCreated: (tabType: string) => {
 76:       analytics.track(ANALYTICS_EVENTS.TAB_CREATED, { tab_type: tabType });
 77:     },
 78:     
 79:     tabClosed: (tabType: string) => {
 80:       analytics.track(ANALYTICS_EVENTS.TAB_CLOSED, { tab_type: tabType });
 81:     },
 82:     
 83:     // File operations
 84:     fileOpened: (fileType: string) => {
 85:       analytics.track(ANALYTICS_EVENTS.FILE_OPENED, { file_type: fileType });
 86:     },
 87:     
 88:     fileEdited: (fileType: string) => {
 89:       analytics.track(ANALYTICS_EVENTS.FILE_EDITED, { file_type: fileType });
 90:     },
 91:     
 92:     fileSaved: (fileType: string) => {
 93:       analytics.track(ANALYTICS_EVENTS.FILE_SAVED, { file_type: fileType });
 94:     },
 95:     
 96:     // Agent execution
 97:     agentExecuted: (agentType: string, success: boolean, agentName?: string, durationMs?: number) => {
 98:       const event = eventBuilders.agent(agentType, success, agentName, durationMs);
 99:       analytics.track(event.event, event.properties);
100:     },
101:     
102:     // MCP events
103:     mcpServerConnected: (serverName: string, success: boolean, serverType?: string) => {
104:       const event = eventBuilders.mcp(serverName, success, serverType);
105:       analytics.track(event.event, event.properties);
106:     },
107:     
108:     mcpServerDisconnected: (serverName: string) => {
109:       analytics.track(ANALYTICS_EVENTS.MCP_SERVER_DISCONNECTED, { server_name: serverName });
110:     },
111:     
112:     // Slash commands
113:     slashCommandUsed: (command: string, success: boolean) => {
114:       const event = eventBuilders.slashCommand(command, success);
115:       analytics.track(event.event, event.properties);
116:     },
117:     
118:     // Settings
119:     settingsChanged: (setting: string, value: any) => {
120:       analytics.track(ANALYTICS_EVENTS.SETTINGS_CHANGED, { setting, value });
121:     },
122:     
123:     // Errors
124:     errorOccurred: (errorType: string, errorCode?: string, context?: string) => {
125:       const event = eventBuilders.error(errorType, errorCode, context);
126:       analytics.track(event.event, event.properties);
127:     },
128:     
129:     // Performance
130:     performanceMetrics: (metrics: Record<string, number>) => {
131:       const event = eventBuilders.performance(metrics);
132:       analytics.track(event.event, event.properties);
133:     },
134:     
135:     // Claude Code Session events
136:     promptSubmitted: (props: Parameters<typeof eventBuilders.promptSubmitted>[0]) => {
137:       const event = eventBuilders.promptSubmitted(props);
138:       analytics.track(event.event, event.properties);
139:     },
140:     
141:     sessionStopped: (props: Parameters<typeof eventBuilders.sessionStopped>[0]) => {
142:       const event = eventBuilders.sessionStopped(props);
143:       analytics.track(event.event, event.properties);
144:     },
145:     
146:     enhancedSessionStopped: (props: Parameters<typeof eventBuilders.enhancedSessionStopped>[0]) => {
147:       const event = eventBuilders.enhancedSessionStopped(props);
148:       analytics.track(event.event, event.properties);
149:     },
150:     
151:     checkpointCreated: (props: Parameters<typeof eventBuilders.checkpointCreated>[0]) => {
152:       const event = eventBuilders.checkpointCreated(props);
153:       analytics.track(event.event, event.properties);
154:     },
155:     
156:     checkpointRestored: (props: Parameters<typeof eventBuilders.checkpointRestored>[0]) => {
157:       const event = eventBuilders.checkpointRestored(props);
158:       analytics.track(event.event, event.properties);
159:     },
160:     
161:     toolExecuted: (props: Parameters<typeof eventBuilders.toolExecuted>[0]) => {
162:       const event = eventBuilders.toolExecuted(props);
163:       analytics.track(event.event, event.properties);
164:     },
165:     
166:     // Enhanced Agent events
167:     agentStarted: (props: Parameters<typeof eventBuilders.agentStarted>[0]) => {
168:       const event = eventBuilders.agentStarted(props);
169:       analytics.track(event.event, event.properties);
170:     },
171:     
172:     agentProgress: (props: Parameters<typeof eventBuilders.agentProgress>[0]) => {
173:       const event = eventBuilders.agentProgress(props);
174:       analytics.track(event.event, event.properties);
175:     },
176:     
177:     agentError: (props: Parameters<typeof eventBuilders.agentError>[0]) => {
178:       const event = eventBuilders.agentError(props);
179:       analytics.track(event.event, event.properties);
180:     },
181:     
182:     // MCP events
183:     mcpServerAdded: (props: Parameters<typeof eventBuilders.mcpServerAdded>[0]) => {
184:       const event = eventBuilders.mcpServerAdded(props);
185:       analytics.track(event.event, event.properties);
186:     },
187:     
188:     mcpServerRemoved: (props: Parameters<typeof eventBuilders.mcpServerRemoved>[0]) => {
189:       const event = eventBuilders.mcpServerRemoved(props);
190:       analytics.track(event.event, event.properties);
191:     },
192:     
193:     mcpToolInvoked: (props: Parameters<typeof eventBuilders.mcpToolInvoked>[0]) => {
194:       const event = eventBuilders.mcpToolInvoked(props);
195:       analytics.track(event.event, event.properties);
196:     },
197:     
198:     mcpConnectionError: (props: Parameters<typeof eventBuilders.mcpConnectionError>[0]) => {
199:       const event = eventBuilders.mcpConnectionError(props);
200:       analytics.track(event.event, event.properties);
201:     },
202:     
203:     // Slash Command events
204:     slashCommandSelected: (props: Parameters<typeof eventBuilders.slashCommandSelected>[0]) => {
205:       const event = eventBuilders.slashCommandSelected(props);
206:       analytics.track(event.event, event.properties);
207:     },
208:     
209:     slashCommandExecuted: (props: Parameters<typeof eventBuilders.slashCommandExecuted>[0]) => {
210:       const event = eventBuilders.slashCommandExecuted(props);
211:       analytics.track(event.event, event.properties);
212:     },
213:     
214:     slashCommandCreated: (props: Parameters<typeof eventBuilders.slashCommandCreated>[0]) => {
215:       const event = eventBuilders.slashCommandCreated(props);
216:       analytics.track(event.event, event.properties);
217:     },
218:     
219:     // Error and Performance events
220:     apiError: (props: Parameters<typeof eventBuilders.apiError>[0]) => {
221:       const event = eventBuilders.apiError(props);
222:       analytics.track(event.event, event.properties);
223:     },
224:     
225:     uiError: (props: Parameters<typeof eventBuilders.uiError>[0]) => {
226:       const event = eventBuilders.uiError(props);
227:       analytics.track(event.event, event.properties);
228:     },
229:     
230:     performanceBottleneck: (props: Parameters<typeof eventBuilders.performanceBottleneck>[0]) => {
231:       const event = eventBuilders.performanceBottleneck(props);
232:       analytics.track(event.event, event.properties);
233:     },
234:     
235:     memoryWarning: (props: Parameters<typeof eventBuilders.memoryWarning>[0]) => {
236:       const event = eventBuilders.memoryWarning(props);
237:       analytics.track(event.event, event.properties);
238:     },
239:     
240:     // User journey events
241:     journeyMilestone: (props: Parameters<typeof eventBuilders.journeyMilestone>[0]) => {
242:       const event = eventBuilders.journeyMilestone(props);
243:       analytics.track(event.event, event.properties);
244:     },
245:     
246:     // Enhanced tracking methods
247:     enhancedPromptSubmitted: (props: Parameters<typeof eventBuilders.enhancedPromptSubmitted>[0]) => {
248:       const event = eventBuilders.enhancedPromptSubmitted(props);
249:       analytics.track(event.event, event.properties);
250:     },
251:     
252:     enhancedToolExecuted: (props: Parameters<typeof eventBuilders.enhancedToolExecuted>[0]) => {
253:       const event = eventBuilders.enhancedToolExecuted(props);
254:       analytics.track(event.event, event.properties);
255:     },
256:     
257:     enhancedError: (props: Parameters<typeof eventBuilders.enhancedError>[0]) => {
258:       const event = eventBuilders.enhancedError(props);
259:       analytics.track(event.event, event.properties);
260:     },
261:     
262:     // Session engagement
263:     sessionEngagement: (props: Parameters<typeof eventBuilders.sessionEngagement>[0]) => {
264:       const event = eventBuilders.sessionEngagement(props);
265:       analytics.track(event.event, event.properties);
266:     },
267:     
268:     // Feature discovery and adoption
269:     featureDiscovered: (props: Parameters<typeof eventBuilders.featureDiscovered>[0]) => {
270:       const event = eventBuilders.featureDiscovered(props);
271:       analytics.track(event.event, event.properties);
272:     },
273:     
274:     featureAdopted: (props: Parameters<typeof eventBuilders.featureAdopted>[0]) => {
275:       const event = eventBuilders.featureAdopted(props);
276:       analytics.track(event.event, event.properties);
277:     },
278:     
279:     featureCombination: (props: Parameters<typeof eventBuilders.featureCombination>[0]) => {
280:       const event = eventBuilders.featureCombination(props);
281:       analytics.track(event.event, event.properties);
282:     },
283:     
284:     // Quality metrics
285:     outputRegenerated: (props: Parameters<typeof eventBuilders.outputRegenerated>[0]) => {
286:       const event = eventBuilders.outputRegenerated(props);
287:       analytics.track(event.event, event.properties);
288:     },
289:     
290:     conversationAbandoned: (reason: string, messagesCount: number) => {
291:       const event = eventBuilders.conversationAbandoned(reason, messagesCount);
292:       analytics.track(event.event, event.properties);
293:     },
294:     
295:     suggestionAccepted: (props: Parameters<typeof eventBuilders.suggestionAccepted>[0]) => {
296:       const event = eventBuilders.suggestionAccepted(props);
297:       analytics.track(event.event, event.properties);
298:     },
299:     
300:     suggestionRejected: (props: Parameters<typeof eventBuilders.suggestionRejected>[0]) => {
301:       const event = eventBuilders.suggestionRejected(props);
302:       analytics.track(event.event, event.properties);
303:     },
304:     
305:     // AI interactions
306:     aiInteraction: (props: Parameters<typeof eventBuilders.aiInteraction>[0]) => {
307:       const event = eventBuilders.aiInteraction(props);
308:       analytics.track(event.event, event.properties);
309:     },
310:     
311:     promptPattern: (props: Parameters<typeof eventBuilders.promptPattern>[0]) => {
312:       const event = eventBuilders.promptPattern(props);
313:       analytics.track(event.event, event.properties);
314:     },
315:     
316:     // Workflow tracking
317:     workflowStarted: (props: Parameters<typeof eventBuilders.workflowStarted>[0]) => {
318:       const event = eventBuilders.workflowStarted(props);
319:       analytics.track(event.event, event.properties);
320:     },
321:     
322:     workflowCompleted: (props: Parameters<typeof eventBuilders.workflowCompleted>[0]) => {
323:       const event = eventBuilders.workflowCompleted(props);
324:       analytics.track(event.event, event.properties);
325:     },
326:     
327:     workflowAbandoned: (props: Parameters<typeof eventBuilders.workflowAbandoned>[0]) => {
328:       const event = eventBuilders.workflowAbandoned(props);
329:       analytics.track(event.event, event.properties);
330:     },
331:     
332:     // Network performance
333:     networkPerformance: (props: Parameters<typeof eventBuilders.networkPerformance>[0]) => {
334:       const event = eventBuilders.networkPerformance(props);
335:       analytics.track(event.event, event.properties);
336:     },
337:     
338:     networkFailure: (props: Parameters<typeof eventBuilders.networkFailure>[0]) => {
339:       const event = eventBuilders.networkFailure(props);
340:       analytics.track(event.event, event.properties);
341:     },
342:     
343:     // Resource usage (direct methods)
344:     resourceUsageHigh: (props: Parameters<typeof eventBuilders.resourceUsageHigh>[0]) => {
345:       const event = eventBuilders.resourceUsageHigh(props);
346:       analytics.track(event.event, event.properties);
347:     },
348:     
349:     resourceUsageSampled: (props: Parameters<typeof eventBuilders.resourceUsageSampled>[0]) => {
350:       const event = eventBuilders.resourceUsageSampled(props);
351:       analytics.track(event.event, event.properties);
352:     },
353:   };
354: }
355: 
356: export function usePageView(pageName: string, properties?: Record<string, any>) {
357:   const hasTracked = useRef(false);
358:   
359:   useEffect(() => {
360:     if (!hasTracked.current && analytics.isEnabled()) {
361:       analytics.track('$pageview', {
362:         page_name: pageName,
363:         ...properties,
364:       });
365:       hasTracked.current = true;
366:     }
367:   }, [pageName, properties]);
368: }
369: 
370: export function useAppLifecycle() {
371:   useEffect(() => {
372:     // Track app start
373:     analytics.track(ANALYTICS_EVENTS.APP_STARTED);
374:     
375:     // Track app close
376:     const handleUnload = () => {
377:       analytics.track(ANALYTICS_EVENTS.APP_CLOSED);
378:       analytics.shutdown();
379:     };
380:     
381:     window.addEventListener('beforeunload', handleUnload);
382:     return () => window.removeEventListener('beforeunload', handleUnload);
383:   }, []);
384: }
385: 
386: // Hook for tracking component-specific metrics
387: export function useComponentMetrics(componentName: string) {
388:   const mountTime = useRef(Date.now());
389:   const renderCount = useRef(0);
390:   
391:   useEffect(() => {
392:     renderCount.current += 1;
393:   });
394:   
395:   useEffect(() => {
396:     return () => {
397:       // Track component unmount metrics
398:       const lifetime = Date.now() - mountTime.current;
399:       analytics.track('component_metrics', {
400:         component: componentName,
401:         lifetime_ms: lifetime,
402:         render_count: renderCount.current,
403:       });
404:     };
405:   }, [componentName]);
406: }
407: 
408: // Hook for tracking user interactions
409: export function useInteractionTracking(interactionType: string) {
410:   return useCallback((details?: Record<string, any>) => {
411:     analytics.track('user_interaction', {
412:       interaction_type: interactionType,
413:       ...details,
414:     });
415:   }, [interactionType]);
416: }
417: 
418: // Hook for tracking screen changes
419: export function useScreenTracking(tabType?: string, tabId?: string) {
420:   useEffect(() => {
421:     if (tabType) {
422:       const screenName = TAB_SCREEN_NAMES[tabType] || tabType;
423:       const screenContext = tabId 
424:         ? `${screenName}/${tabId.substring(0, 8)}` 
425:         : screenName;
426:       
427:       analytics.setScreen(screenContext);
428:     }
429:   }, [tabType, tabId]);
430: }
431: 
432: // Export screen names for external use
433: export { TAB_SCREEN_NAMES };
434: 
435: // Hook for tracking feature experiments
436: export function useFeatureExperiment(featureName: string, variant: string) {
437:   // const trackEvent = useTrackEvent();
438:   
439:   useEffect(() => {
440:     analytics.track('experiment_exposure', {
441:       experiment_name: featureName,
442:       variant,
443:       exposure_time: Date.now(),
444:     });
445:   }, [featureName, variant]);
446:   
447:   const trackConversion = useCallback((conversionType: string) => {
448:     analytics.track('experiment_conversion', {
449:       experiment_name: featureName,
450:       variant,
451:       conversion_type: conversionType,
452:     });
453:   }, [featureName, variant]);
454:   
455:   return { trackConversion };
456: }
457: 
458: // Hook for tracking user paths/navigation
459: export function usePathTracking(pathname: string) {
460:   const previousPath = useRef<string>('');
461:   
462:   useEffect(() => {
463:     if (previousPath.current && previousPath.current !== pathname) {
464:       analytics.track('path_transition', {
465:         from: previousPath.current,
466:         to: pathname,
467:         transition_type: 'navigation',
468:       });
469:     }
470:     previousPath.current = pathname;
471:   }, [pathname]);
472: }
473: 
474: // Hook for tracking feature adoption
475: export function useFeatureAdoptionTracking(featureName: string) {
476:   const startTime = useRef<number>(Date.now());
477:   const usageCount = useRef<number>(0);
478:   const trackEvent = useTrackEvent();
479:   
480:   const trackUsage = useCallback(() => {
481:     usageCount.current += 1;
482:     
483:     // Track discovery on first use
484:     if (usageCount.current === 1) {
485:       trackEvent.featureDiscovered({
486:         feature_name: featureName,
487:         discovery_method: 'organic',
488:         time_to_first_use_ms: Date.now() - startTime.current,
489:         initial_success: true,
490:       });
491:     }
492:     
493:     // Track adoption after 5 uses
494:     if (usageCount.current === 5) {
495:       const daysSinceFirst = (Date.now() - startTime.current) / (1000 * 60 * 60 * 24);
496:       trackEvent.featureAdopted({
497:         feature: featureName,
498:         adoption_stage: 'adopted',
499:         usage_count: usageCount.current,
500:         days_since_first_use: daysSinceFirst,
501:         usage_trend: 'increasing',
502:       });
503:     }
504:   }, [featureName, trackEvent]);
505:   
506:   return { trackUsage, usageCount: usageCount.current };
507: }
508: 
509: // Hook for tracking workflow completion
510: export function useWorkflowTracking(workflowType: string) {
511:   const startTime = useRef<number | null>(null);
512:   const stepsCompleted = useRef<number>(0);
513:   const toolsUsed = useRef<Set<string>>(new Set());
514:   const interruptions = useRef<number>(0);
515:   const trackEvent = useTrackEvent();
516:   
517:   const startWorkflow = useCallback((totalSteps: number) => {
518:     startTime.current = Date.now();
519:     stepsCompleted.current = 0;
520:     toolsUsed.current.clear();
521:     interruptions.current = 0;
522:     
523:     trackEvent.workflowStarted({
524:       workflow_type: workflowType,
525:       steps_completed: 0,
526:       total_steps: totalSteps,
527:       duration_ms: 0,
528:       interruptions: 0,
529:       completion_rate: 0,
530:       tools_used: [],
531:     });
532:   }, [workflowType, trackEvent]);
533:   
534:   const trackStep = useCallback((toolName?: string) => {
535:     stepsCompleted.current += 1;
536:     if (toolName) {
537:       toolsUsed.current.add(toolName);
538:     }
539:   }, []);
540:   
541:   const trackInterruption = useCallback(() => {
542:     interruptions.current += 1;
543:   }, []);
544:   
545:   const completeWorkflow = useCallback((totalSteps: number, success: boolean = true) => {
546:     if (!startTime.current) return;
547:     
548:     const duration = Date.now() - startTime.current;
549:     const completionRate = stepsCompleted.current / totalSteps;
550:     
551:     const eventData = {
552:       workflow_type: workflowType,
553:       steps_completed: stepsCompleted.current,
554:       total_steps: totalSteps,
555:       duration_ms: duration,
556:       interruptions: interruptions.current,
557:       completion_rate: completionRate,
558:       tools_used: Array.from(toolsUsed.current),
559:     };
560:     
561:     if (success) {
562:       trackEvent.workflowCompleted(eventData);
563:     } else {
564:       trackEvent.workflowAbandoned(eventData);
565:     }
566:     
567:     // Reset
568:     startTime.current = null;
569:   }, [workflowType, trackEvent]);
570:   
571:   return {
572:     startWorkflow,
573:     trackStep,
574:     trackInterruption,
575:     completeWorkflow,
576:   };
577: }
578: 
579: // Hook for tracking AI interaction quality
580: export function useAIInteractionTracking(model: string) {
581:   const interactionStart = useRef<number | null>(null);
582:   const contextSwitches = useRef<number>(0);
583:   const clarificationRequests = useRef<number>(0);
584:   const trackEvent = useTrackEvent();
585:   
586:   const startInteraction = useCallback(() => {
587:     interactionStart.current = Date.now();
588:     contextSwitches.current = 0;
589:     clarificationRequests.current = 0;
590:   }, []);
591:   
592:   const trackContextSwitch = useCallback(() => {
593:     contextSwitches.current += 1;
594:   }, []);
595:   
596:   const trackClarificationRequest = useCallback(() => {
597:     clarificationRequests.current += 1;
598:   }, []);
599:   
600:   const completeInteraction = useCallback((
601:     requestTokens: number,
602:     responseTokens: number,
603:     qualityScore?: number
604:   ) => {
605:     if (!interactionStart.current) return;
606:     
607:     trackEvent.aiInteraction({
608:       model,
609:       request_tokens: requestTokens,
610:       response_tokens: responseTokens,
611:       response_quality_score: qualityScore,
612:       context_switches: contextSwitches.current,
613:       clarification_requests: clarificationRequests.current,
614:     });
615:     
616:     // Reset
617:     interactionStart.current = null;
618:   }, [model, trackEvent]);
619:   
620:   return {
621:     startInteraction,
622:     trackContextSwitch,
623:     trackClarificationRequest,
624:     completeInteraction,
625:   };
626: }
627: 
628: // Hook for tracking network performance
629: export function useNetworkPerformanceTracking() {
630:   const trackEvent = useTrackEvent();
631:   
632:   const trackRequest = useCallback((
633:     _endpoint: string,
634:     endpointType: 'mcp' | 'api' | 'webhook',
635:     latency: number,
636:     payloadSize: number,
637:     success: boolean,
638:     retryCount: number = 0
639:   ) => {
640:     const connectionQuality: 'excellent' | 'good' | 'poor' = 
641:       latency < 100 ? 'excellent' :
642:       latency < 500 ? 'good' : 'poor';
643:     
644:     const eventData = {
645:       endpoint_type: endpointType,
646:       latency_ms: latency,
647:       payload_size_bytes: payloadSize,
648:       connection_quality: connectionQuality,
649:       retry_count: retryCount,
650:       circuit_breaker_triggered: false,
651:     };
652:     
653:     if (success) {
654:       trackEvent.networkPerformance(eventData);
655:     } else {
656:       trackEvent.networkFailure(eventData);
657:     }
658:   }, [trackEvent]);
659:   
660:   return { trackRequest };
661: }
````

## File: src/hooks/useApiCall.ts
````typescript
  1: import { useState, useCallback, useRef, useEffect } from 'react';
  2: 
  3: interface ApiCallOptions {
  4:   onSuccess?: (data: any) => void;
  5:   onError?: (error: Error) => void;
  6:   showErrorToast?: boolean;
  7:   showSuccessToast?: boolean;
  8:   successMessage?: string;
  9:   errorMessage?: string;
 10: }
 11: 
 12: interface ApiCallState<T> {
 13:   data: T | null;
 14:   isLoading: boolean;
 15:   error: Error | null;
 16:   call: (...args: any[]) => Promise<T | null>;
 17:   reset: () => void;
 18: }
 19: 
 20: /**
 21:  * Custom hook for making API calls with consistent error handling and loading states
 22:  * Includes automatic toast notifications and cleanup on unmount
 23:  */
 24: export function useApiCall<T>(
 25:   apiFunction: (...args: any[]) => Promise<T>,
 26:   options: ApiCallOptions = {}
 27: ): ApiCallState<T> {
 28:   const [data, setData] = useState<T | null>(null);
 29:   const [isLoading, setIsLoading] = useState(false);
 30:   const [error, setError] = useState<Error | null>(null);
 31:   const abortControllerRef = useRef<AbortController | null>(null);
 32:   const isMountedRef = useRef(true);
 33: 
 34:   const {
 35:     onSuccess,
 36:     onError,
 37:     showErrorToast = true,
 38:     showSuccessToast = false,
 39:     successMessage = 'Operation completed successfully',
 40:     errorMessage
 41:   } = options;
 42: 
 43:   const call = useCallback(
 44:     async (...args: any[]): Promise<T | null> => {
 45:       try {
 46:         // Cancel any pending request
 47:         if (abortControllerRef.current) {
 48:           abortControllerRef.current.abort();
 49:         }
 50: 
 51:         // Create new abort controller
 52:         abortControllerRef.current = new AbortController();
 53: 
 54:         setIsLoading(true);
 55:         setError(null);
 56: 
 57:         const result = await apiFunction(...args);
 58: 
 59:         // Only update state if component is still mounted
 60:         if (!isMountedRef.current) return null;
 61: 
 62:         setData(result);
 63:         
 64:         if (showSuccessToast) {
 65:           // TODO: Implement toast notification
 66:           console.log('Success:', successMessage);
 67:         }
 68: 
 69:         onSuccess?.(result);
 70:         return result;
 71:       } catch (err) {
 72:         // Ignore aborted requests
 73:         if (err instanceof Error && err.name === 'AbortError') {
 74:           return null;
 75:         }
 76: 
 77:         // Only update state if component is still mounted
 78:         if (!isMountedRef.current) return null;
 79: 
 80:         const error = err instanceof Error ? err : new Error('An error occurred');
 81:         setError(error);
 82: 
 83:         if (showErrorToast) {
 84:           // TODO: Implement toast notification
 85:           console.error('Error:', errorMessage || error.message);
 86:         }
 87: 
 88:         onError?.(error);
 89:         return null;
 90:       } finally {
 91:         if (isMountedRef.current) {
 92:           setIsLoading(false);
 93:         }
 94:       }
 95:     },
 96:     [apiFunction, onSuccess, onError, showErrorToast, showSuccessToast, successMessage, errorMessage]
 97:   );
 98: 
 99:   const reset = useCallback(() => {
100:     setData(null);
101:     setError(null);
102:     setIsLoading(false);
103:   }, []);
104: 
105:   // Cleanup on unmount
106:   useEffect(() => {
107:     return () => {
108:       isMountedRef.current = false;
109:       if (abortControllerRef.current) {
110:         abortControllerRef.current.abort();
111:       }
112:     };
113:   }, []);
114: 
115:   return { data, isLoading, error, call, reset };
116: }
````

## File: src/hooks/useDebounce.ts
````typescript
 1: import { useEffect, useState, useRef } from 'react';
 2: 
 3: /**
 4:  * Custom hook that debounces a value
 5:  * Useful for search inputs and reducing API calls
 6:  */
 7: export function useDebounce<T>(value: T, delay: number): T {
 8:   const [debouncedValue, setDebouncedValue] = useState<T>(value);
 9: 
10:   useEffect(() => {
11:     const handler = setTimeout(() => {
12:       setDebouncedValue(value);
13:     }, delay);
14: 
15:     return () => {
16:       clearTimeout(handler);
17:     };
18:   }, [value, delay]);
19: 
20:   return debouncedValue;
21: }
22: 
23: /**
24:  * Custom hook that returns a debounced callback
25:  * The callback will only be invoked after the delay has passed since the last call
26:  */
27: export function useDebouncedCallback<T extends (...args: any[]) => any>(
28:   callback: T,
29:   delay: number
30: ): T {
31:   const timeoutRef = useRef<NodeJS.Timeout | null>(null);
32:   const callbackRef = useRef(callback);
33: 
34:   // Update callback ref on each render to avoid stale closures
35:   callbackRef.current = callback;
36: 
37:   return useRef(
38:     ((...args: Parameters<T>) => {
39:       if (timeoutRef.current) {
40:         clearTimeout(timeoutRef.current);
41:       }
42: 
43:       timeoutRef.current = setTimeout(() => {
44:         callbackRef.current(...args);
45:       }, delay);
46:     }) as T
47:   ).current;
48: }
````

## File: src/hooks/useLoadingState.ts
````typescript
 1: import { useState, useCallback } from 'react';
 2: 
 3: interface LoadingState<T> {
 4:   data: T | null;
 5:   isLoading: boolean;
 6:   error: Error | null;
 7:   execute: (...args: any[]) => Promise<T>;
 8:   reset: () => void;
 9: }
10: 
11: /**
12:  * Custom hook for managing loading states with error handling
13:  * Reduces boilerplate code for async operations
14:  */
15: export function useLoadingState<T>(
16:   asyncFunction: (...args: any[]) => Promise<T>
17: ): LoadingState<T> {
18:   const [data, setData] = useState<T | null>(null);
19:   const [isLoading, setIsLoading] = useState(false);
20:   const [error, setError] = useState<Error | null>(null);
21: 
22:   const execute = useCallback(
23:     async (...args: any[]): Promise<T> => {
24:       try {
25:         setIsLoading(true);
26:         setError(null);
27:         const result = await asyncFunction(...args);
28:         setData(result);
29:         return result;
30:       } catch (err) {
31:         const error = err instanceof Error ? err : new Error('An error occurred');
32:         setError(error);
33:         throw error;
34:       } finally {
35:         setIsLoading(false);
36:       }
37:     },
38:     [asyncFunction]
39:   );
40: 
41:   const reset = useCallback(() => {
42:     setData(null);
43:     setError(null);
44:     setIsLoading(false);
45:   }, []);
46: 
47:   return { data, isLoading, error, execute, reset };
48: }
````

## File: src/hooks/usePagination.ts
````typescript
  1: import { useState, useMemo, useCallback } from 'react';
  2: 
  3: interface PaginationOptions {
  4:   initialPage?: number;
  5:   initialPageSize?: number;
  6:   pageSizeOptions?: number[];
  7: }
  8: 
  9: interface PaginationResult<T> {
 10:   currentPage: number;
 11:   pageSize: number;
 12:   totalPages: number;
 13:   totalItems: number;
 14:   paginatedData: T[];
 15:   goToPage: (page: number) => void;
 16:   nextPage: () => void;
 17:   previousPage: () => void;
 18:   setPageSize: (size: number) => void;
 19:   canGoNext: boolean;
 20:   canGoPrevious: boolean;
 21:   pageRange: number[];
 22: }
 23: 
 24: /**
 25:  * Custom hook for handling pagination logic
 26:  * Returns paginated data and pagination controls
 27:  */
 28: export function usePagination<T>(
 29:   data: T[],
 30:   options: PaginationOptions = {}
 31: ): PaginationResult<T> {
 32:   const {
 33:     initialPage = 1,
 34:     initialPageSize = 10,
 35:     pageSizeOptions: _pageSizeOptions = [10, 25, 50, 100]
 36:   } = options;
 37: 
 38:   const [currentPage, setCurrentPage] = useState(initialPage);
 39:   const [pageSize, setPageSize] = useState(initialPageSize);
 40: 
 41:   const totalItems = data.length;
 42:   const totalPages = Math.ceil(totalItems / pageSize);
 43: 
 44:   // Calculate paginated data
 45:   const paginatedData = useMemo(() => {
 46:     const startIndex = (currentPage - 1) * pageSize;
 47:     const endIndex = startIndex + pageSize;
 48:     return data.slice(startIndex, endIndex);
 49:   }, [data, currentPage, pageSize]);
 50: 
 51:   // Navigation functions
 52:   const goToPage = useCallback((page: number) => {
 53:     setCurrentPage(Math.max(1, Math.min(page, totalPages)));
 54:   }, [totalPages]);
 55: 
 56:   const nextPage = useCallback(() => {
 57:     goToPage(currentPage + 1);
 58:   }, [currentPage, goToPage]);
 59: 
 60:   const previousPage = useCallback(() => {
 61:     goToPage(currentPage - 1);
 62:   }, [currentPage, goToPage]);
 63: 
 64:   const handleSetPageSize = useCallback((size: number) => {
 65:     setPageSize(size);
 66:     // Reset to first page when page size changes
 67:     setCurrentPage(1);
 68:   }, []);
 69: 
 70:   // Generate page range for pagination UI
 71:   const pageRange = useMemo(() => {
 72:     const range: number[] = [];
 73:     const maxVisible = 7; // Maximum number of page buttons to show
 74:     
 75:     if (totalPages <= maxVisible) {
 76:       // Show all pages if total is less than max
 77:       for (let i = 1; i <= totalPages; i++) {
 78:         range.push(i);
 79:       }
 80:     } else {
 81:       // Always show first page
 82:       range.push(1);
 83:       
 84:       if (currentPage > 3) {
 85:         range.push(-1); // Ellipsis
 86:       }
 87:       
 88:       // Show pages around current page
 89:       const start = Math.max(2, currentPage - 1);
 90:       const end = Math.min(totalPages - 1, currentPage + 1);
 91:       
 92:       for (let i = start; i <= end; i++) {
 93:         range.push(i);
 94:       }
 95:       
 96:       if (currentPage < totalPages - 2) {
 97:         range.push(-1); // Ellipsis
 98:       }
 99:       
100:       // Always show last page
101:       if (totalPages > 1) {
102:         range.push(totalPages);
103:       }
104:     }
105:     
106:     return range;
107:   }, [currentPage, totalPages]);
108: 
109:   return {
110:     currentPage,
111:     pageSize,
112:     totalPages,
113:     totalItems,
114:     paginatedData,
115:     goToPage,
116:     nextPage,
117:     previousPage,
118:     setPageSize: handleSetPageSize,
119:     canGoNext: currentPage < totalPages,
120:     canGoPrevious: currentPage > 1,
121:     pageRange
122:   };
123: }
````

## File: src/hooks/usePerformanceMonitor.ts
````typescript
  1: import { useEffect, useRef } from 'react';
  2: import { eventBuilders, analytics } from '@/lib/analytics';
  3: 
  4: interface PerformanceThresholds {
  5:   renderTime?: number;  // ms
  6:   memoryUsage?: number; // MB
  7: }
  8: 
  9: const DEFAULT_THRESHOLDS: PerformanceThresholds = {
 10:   renderTime: 16, // 60fps threshold
 11:   memoryUsage: 50, // 50MB
 12: };
 13: 
 14: /**
 15:  * Hook to monitor component performance and track bottlenecks
 16:  */
 17: export function usePerformanceMonitor(
 18:   componentName: string,
 19:   thresholds: PerformanceThresholds = DEFAULT_THRESHOLDS
 20: ) {
 21:   const renderCount = useRef(0);
 22:   const lastRenderTime = useRef(performance.now());
 23:   const mountTime = useRef(performance.now());
 24:   
 25:   useEffect(() => {
 26:     renderCount.current += 1;
 27:     const currentTime = performance.now();
 28:     const renderTime = currentTime - lastRenderTime.current;
 29:     lastRenderTime.current = currentTime;
 30:     
 31:     // Skip first render (mount)
 32:     if (renderCount.current === 1) return;
 33:     
 34:     // Check render performance
 35:     if (thresholds.renderTime && renderTime > thresholds.renderTime) {
 36:       const event = eventBuilders.performanceBottleneck({
 37:         operation_type: `render.${componentName}`,
 38:         duration_ms: renderTime,
 39:         data_size: renderCount.current,
 40:         threshold_exceeded: true,
 41:       });
 42:       analytics.track(event.event, event.properties);
 43:     }
 44:     
 45:     // Check memory usage if available
 46:     if ('memory' in performance && (performance as any).memory && thresholds.memoryUsage) {
 47:       const memoryMB = (performance as any).memory.usedJSHeapSize / (1024 * 1024);
 48:       if (memoryMB > thresholds.memoryUsage) {
 49:         const event = eventBuilders.memoryWarning({
 50:           component: componentName,
 51:           memory_mb: memoryMB,
 52:           threshold_exceeded: true,
 53:           gc_count: undefined,
 54:         });
 55:         analytics.track(event.event, event.properties);
 56:       }
 57:     }
 58:   });
 59:   
 60:   // Track component unmount metrics
 61:   useEffect(() => {
 62:     return () => {
 63:       const lifetime = performance.now() - mountTime.current;
 64:       
 65:       // Only track if component lived for more than 5 seconds and had many renders
 66:       if (lifetime > 5000 && renderCount.current > 100) {
 67:         const avgRenderTime = lifetime / renderCount.current;
 68:         
 69:         // Track if average render time is high
 70:         if (avgRenderTime > 10) {
 71:           const event = eventBuilders.performanceBottleneck({
 72:             operation_type: `lifecycle.${componentName}`,
 73:             duration_ms: avgRenderTime,
 74:             data_size: renderCount.current,
 75:             threshold_exceeded: true,
 76:           });
 77:           analytics.track(event.event, event.properties);
 78:         }
 79:       }
 80:     };
 81:   }, [componentName]);
 82: }
 83: 
 84: /**
 85:  * Hook to track async operation performance
 86:  */
 87: export function useAsyncPerformanceTracker(operationName: string) {
 88:   const operationStart = useRef<number | null>(null);
 89:   
 90:   const startTracking = () => {
 91:     operationStart.current = performance.now();
 92:   };
 93:   
 94:   const endTracking = (success: boolean = true, dataSize?: number) => {
 95:     if (!operationStart.current) return;
 96:     
 97:     const duration = performance.now() - operationStart.current;
 98:     operationStart.current = null;
 99:     
100:     // Track if operation took too long
101:     if (duration > 3000) {
102:       const event = eventBuilders.performanceBottleneck({
103:         operation_type: `async.${operationName}`,
104:         duration_ms: duration,
105:         data_size: dataSize,
106:         threshold_exceeded: true,
107:       });
108:       analytics.track(event.event, event.properties);
109:     }
110:     
111:     // Track errors
112:     if (!success) {
113:       const event = eventBuilders.apiError({
114:         endpoint: operationName,
115:         error_code: 'async_operation_failed',
116:         retry_count: 0,
117:         response_time_ms: duration,
118:       });
119:       analytics.track(event.event, event.properties);
120:     }
121:   };
122:   
123:   return { startTracking, endTracking };
124: }
````

## File: src/hooks/useTabState.ts
````typescript
  1: import { useCallback, useMemo } from 'react';
  2: import { useTabContext } from '@/contexts/TabContext';
  3: import { Tab } from '@/contexts/TabContext';
  4: 
  5: interface UseTabStateReturn {
  6:   // State
  7:   tabs: Tab[];
  8:   activeTab: Tab | undefined;
  9:   activeTabId: string | null;
 10:   tabCount: number;
 11:   chatTabCount: number;
 12:   agentTabCount: number;
 13:   
 14:   // Operations
 15:   createChatTab: (projectId?: string, title?: string) => string;
 16:   createAgentTab: (agentRunId: string, agentName: string) => string;
 17:   createAgentExecutionTab: (agent: any, tabId: string) => string;
 18:   createProjectsTab: () => string | null;
 19:   createUsageTab: () => string | null;
 20:   createMCPTab: () => string | null;
 21:   createSettingsTab: () => string | null;
 22:   createClaudeMdTab: () => string | null;
 23:   createClaudeFileTab: (fileId: string, fileName: string) => string;
 24:   createCreateAgentTab: () => string;
 25:   createImportAgentTab: () => string;
 26:   closeTab: (id: string, force?: boolean) => Promise<boolean>;
 27:   closeCurrentTab: () => Promise<boolean>;
 28:   switchToTab: (id: string) => void;
 29:   switchToNextTab: () => void;
 30:   switchToPreviousTab: () => void;
 31:   switchToTabByIndex: (index: number) => void;
 32:   updateTab: (id: string, updates: Partial<Tab>) => void;
 33:   updateTabTitle: (id: string, title: string) => void;
 34:   updateTabStatus: (id: string, status: Tab['status']) => void;
 35:   markTabAsChanged: (id: string, hasChanges: boolean) => void;
 36:   findTabBySessionId: (sessionId: string) => Tab | undefined;
 37:   findTabByAgentRunId: (agentRunId: string) => Tab | undefined;
 38:   findTabByType: (type: Tab['type']) => Tab | undefined;
 39:   canAddTab: () => boolean;
 40: }
 41: 
 42: export const useTabState = (): UseTabStateReturn => {
 43:   const {
 44:     tabs,
 45:     activeTabId,
 46:     addTab,
 47:     removeTab,
 48:     updateTab,
 49:     setActiveTab,
 50:     getTabById,
 51:     getTabsByType
 52:   } = useTabContext();
 53: 
 54:   const activeTab = useMemo(() => 
 55:     activeTabId ? getTabById(activeTabId) : undefined,
 56:     [activeTabId, getTabById]
 57:   );
 58: 
 59:   const tabCount = tabs.length;
 60:   const chatTabCount = useMemo(() => getTabsByType('chat').length, [getTabsByType]);
 61:   const agentTabCount = useMemo(() => getTabsByType('agent').length, [getTabsByType]);
 62: 
 63:   const createChatTab = useCallback((projectId?: string, title?: string): string => {
 64:     const tabTitle = title || `Chat ${chatTabCount + 1}`;
 65:     return addTab({
 66:       type: 'chat',
 67:       title: tabTitle,
 68:       sessionId: projectId,
 69:       status: 'idle',
 70:       hasUnsavedChanges: false,
 71:       icon: 'message-square'
 72:     });
 73:   }, [addTab, chatTabCount]);
 74: 
 75:   const createAgentTab = useCallback((agentRunId: string, agentName: string): string => {
 76:     // Check if tab already exists
 77:     const existingTab = tabs.find(tab => tab.agentRunId === agentRunId);
 78:     if (existingTab) {
 79:       setActiveTab(existingTab.id);
 80:       return existingTab.id;
 81:     }
 82: 
 83:     return addTab({
 84:       type: 'agent',
 85:       title: agentName,
 86:       agentRunId,
 87:       status: 'running',
 88:       hasUnsavedChanges: false,
 89:       icon: 'bot'
 90:     });
 91:   }, [addTab, tabs, setActiveTab]);
 92: 
 93:   const createProjectsTab = useCallback((): string | null => {
 94:     // Check if projects tab already exists (singleton)
 95:     const existingTab = tabs.find(tab => tab.type === 'projects');
 96:     if (existingTab) {
 97:       setActiveTab(existingTab.id);
 98:       return existingTab.id;
 99:     }
100: 
101:     return addTab({
102:       type: 'projects',
103:       title: 'CC Projects',
104:       status: 'idle',
105:       hasUnsavedChanges: false,
106:       icon: 'folder'
107:     });
108:   }, [addTab, tabs, setActiveTab]);
109: 
110:   const createUsageTab = useCallback((): string | null => {
111:     // Check if usage tab already exists (singleton)
112:     const existingTab = tabs.find(tab => tab.type === 'usage');
113:     if (existingTab) {
114:       setActiveTab(existingTab.id);
115:       return existingTab.id;
116:     }
117: 
118:     return addTab({
119:       type: 'usage',
120:       title: 'Usage',
121:       status: 'idle',
122:       hasUnsavedChanges: false,
123:       icon: 'bar-chart'
124:     });
125:   }, [addTab, tabs, setActiveTab]);
126: 
127:   const createMCPTab = useCallback((): string | null => {
128:     // Check if MCP tab already exists (singleton)
129:     const existingTab = tabs.find(tab => tab.type === 'mcp');
130:     if (existingTab) {
131:       setActiveTab(existingTab.id);
132:       return existingTab.id;
133:     }
134: 
135:     return addTab({
136:       type: 'mcp',
137:       title: 'MCP Servers',
138:       status: 'idle',
139:       hasUnsavedChanges: false,
140:       icon: 'server'
141:     });
142:   }, [addTab, tabs, setActiveTab]);
143: 
144:   const createSettingsTab = useCallback((): string | null => {
145:     // Check if settings tab already exists (singleton)
146:     const existingTab = tabs.find(tab => tab.type === 'settings');
147:     if (existingTab) {
148:       setActiveTab(existingTab.id);
149:       return existingTab.id;
150:     }
151: 
152:     return addTab({
153:       type: 'settings',
154:       title: 'Settings',
155:       status: 'idle',
156:       hasUnsavedChanges: false,
157:       icon: 'settings'
158:     });
159:   }, [addTab, tabs, setActiveTab]);
160: 
161:   const createClaudeMdTab = useCallback((): string | null => {
162:     // Check if claude-md tab already exists (singleton)
163:     const existingTab = tabs.find(tab => tab.type === 'claude-md');
164:     if (existingTab) {
165:       setActiveTab(existingTab.id);
166:       return existingTab.id;
167:     }
168: 
169:     return addTab({
170:       type: 'claude-md',
171:       title: 'CLAUDE.md',
172:       status: 'idle',
173:       hasUnsavedChanges: false,
174:       icon: 'file-text'
175:     });
176:   }, [addTab, tabs, setActiveTab]);
177: 
178:   const createClaudeFileTab = useCallback((fileId: string, fileName: string): string => {
179:     // Check if tab already exists for this file
180:     const existingTab = tabs.find(tab => tab.type === 'claude-file' && tab.claudeFileId === fileId);
181:     if (existingTab) {
182:       setActiveTab(existingTab.id);
183:       return existingTab.id;
184:     }
185: 
186:     return addTab({
187:       type: 'claude-file',
188:       title: fileName,
189:       claudeFileId: fileId,
190:       status: 'idle',
191:       hasUnsavedChanges: false,
192:       icon: 'file-text'
193:     });
194:   }, [addTab, tabs, setActiveTab]);
195: 
196:   const createAgentExecutionTab = useCallback((agent: any, _tabId: string): string => {
197:     return addTab({
198:       type: 'agent-execution',
199:       title: `Run: ${agent.name}`,
200:       agentData: agent,
201:       status: 'idle',
202:       hasUnsavedChanges: false,
203:       icon: 'bot'
204:     });
205:   }, [addTab]);
206: 
207:   const createCreateAgentTab = useCallback((): string => {
208:     // Check if create agent tab already exists (singleton)
209:     const existingTab = tabs.find(tab => tab.type === 'create-agent');
210:     if (existingTab) {
211:       setActiveTab(existingTab.id);
212:       return existingTab.id;
213:     }
214: 
215:     return addTab({
216:       type: 'create-agent',
217:       title: 'Create Agent',
218:       status: 'idle',
219:       hasUnsavedChanges: false,
220:       icon: 'plus'
221:     });
222:   }, [addTab, tabs, setActiveTab]);
223: 
224:   const createImportAgentTab = useCallback((): string => {
225:     // Check if import agent tab already exists (singleton)
226:     const existingTab = tabs.find(tab => tab.type === 'import-agent');
227:     if (existingTab) {
228:       setActiveTab(existingTab.id);
229:       return existingTab.id;
230:     }
231: 
232:     return addTab({
233:       type: 'import-agent',
234:       title: 'Import Agent',
235:       status: 'idle',
236:       hasUnsavedChanges: false,
237:       icon: 'import'
238:     });
239:   }, [addTab, tabs, setActiveTab]);
240: 
241:   const closeTab = useCallback(async (id: string, force: boolean = false): Promise<boolean> => {
242:     const tab = getTabById(id);
243:     if (!tab) return true;
244: 
245:     // Check for unsaved changes
246:     if (!force && tab.hasUnsavedChanges) {
247:       // In a real implementation, you'd show a confirmation dialog here
248:       const confirmed = window.confirm(`Tab "${tab.title}" has unsaved changes. Close anyway?`);
249:       if (!confirmed) return false;
250:     }
251: 
252:     removeTab(id);
253:     return true;
254:   }, [getTabById, removeTab]);
255: 
256:   const closeCurrentTab = useCallback(async (): Promise<boolean> => {
257:     if (!activeTabId) return true;
258:     return closeTab(activeTabId);
259:   }, [activeTabId, closeTab]);
260: 
261:   const switchToNextTab = useCallback(() => {
262:     if (tabs.length === 0) return;
263:     
264:     const currentIndex = tabs.findIndex(tab => tab.id === activeTabId);
265:     const nextIndex = (currentIndex + 1) % tabs.length;
266:     setActiveTab(tabs[nextIndex].id);
267:   }, [tabs, activeTabId, setActiveTab]);
268: 
269:   const switchToPreviousTab = useCallback(() => {
270:     if (tabs.length === 0) return;
271:     
272:     const currentIndex = tabs.findIndex(tab => tab.id === activeTabId);
273:     const previousIndex = currentIndex === 0 ? tabs.length - 1 : currentIndex - 1;
274:     setActiveTab(tabs[previousIndex].id);
275:   }, [tabs, activeTabId, setActiveTab]);
276: 
277:   const switchToTabByIndex = useCallback((index: number) => {
278:     if (index >= 0 && index < tabs.length) {
279:       setActiveTab(tabs[index].id);
280:     }
281:   }, [tabs, setActiveTab]);
282: 
283:   const updateTabTitle = useCallback((id: string, title: string) => {
284:     updateTab(id, { title });
285:   }, [updateTab]);
286: 
287:   const updateTabStatus = useCallback((id: string, status: Tab['status']) => {
288:     updateTab(id, { status });
289:   }, [updateTab]);
290: 
291:   const markTabAsChanged = useCallback((id: string, hasChanges: boolean) => {
292:     updateTab(id, { hasUnsavedChanges: hasChanges });
293:   }, [updateTab]);
294: 
295:   const findTabBySessionId = useCallback((sessionId: string): Tab | undefined => {
296:     return tabs.find(tab => tab.type === 'chat' && tab.sessionId === sessionId);
297:   }, [tabs]);
298: 
299:   const findTabByAgentRunId = useCallback((agentRunId: string): Tab | undefined => {
300:     return tabs.find(tab => tab.type === 'agent' && tab.agentRunId === agentRunId);
301:   }, [tabs]);
302: 
303:   const findTabByType = useCallback((type: Tab['type']): Tab | undefined => {
304:     return tabs.find(tab => tab.type === type);
305:   }, [tabs]);
306: 
307:   const canAddTab = useCallback((): boolean => {
308:     return tabs.length < 20; // MAX_TABS from context
309:   }, [tabs.length]);
310: 
311:   return {
312:     // State
313:     tabs,
314:     activeTab,
315:     activeTabId,
316:     tabCount,
317:     chatTabCount,
318:     agentTabCount,
319:     
320:     // Operations
321:     createChatTab,
322:     createAgentTab,
323:     createAgentExecutionTab,
324:     createProjectsTab,
325:     createUsageTab,
326:     createMCPTab,
327:     createSettingsTab,
328:     createClaudeMdTab,
329:     createClaudeFileTab,
330:     createCreateAgentTab,
331:     createImportAgentTab,
332:     closeTab,
333:     closeCurrentTab,
334:     switchToTab: setActiveTab,
335:     switchToNextTab,
336:     switchToPreviousTab,
337:     switchToTabByIndex,
338:     updateTab,
339:     updateTabTitle,
340:     updateTabStatus,
341:     markTabAsChanged,
342:     findTabBySessionId,
343:     findTabByAgentRunId,
344:     findTabByType,
345:     canAddTab
346:   };
347: };
````

## File: src/hooks/useTheme.ts
````typescript
 1: import { useThemeContext } from '../contexts/ThemeContext';
 2: 
 3: /**
 4:  * Hook to access and control the theme system
 5:  * 
 6:  * @returns {Object} Theme utilities and state
 7:  * @returns {ThemeMode} theme - Current theme mode ('dark' | 'gray' | 'light' | 'custom')
 8:  * @returns {CustomThemeColors} customColors - Custom theme color configuration
 9:  * @returns {Function} setTheme - Function to change the theme mode
10:  * @returns {Function} setCustomColors - Function to update custom theme colors
11:  * @returns {boolean} isLoading - Whether theme operations are in progress
12:  * 
13:  * @example
14:  * const { theme, setTheme } = useTheme();
15:  * 
16:  * // Change theme
17:  * await setTheme('light');
18:  * 
19:  * // Update custom colors
20:  * await setCustomColors({ background: 'oklch(0.98 0.01 240)' });
21:  */
22: export const useTheme = () => {
23:   return useThemeContext();
24: };
````

## File: src/lib/analytics/consent.ts
````typescript
  1: import type { AnalyticsSettings } from './types';
  2: 
  3: const ANALYTICS_STORAGE_KEY = 'claudia-analytics-settings';
  4: 
  5: export class ConsentManager {
  6:   private static instance: ConsentManager;
  7:   private settings: AnalyticsSettings | null = null;
  8:   
  9:   private constructor() {}
 10:   
 11:   static getInstance(): ConsentManager {
 12:     if (!ConsentManager.instance) {
 13:       ConsentManager.instance = new ConsentManager();
 14:     }
 15:     return ConsentManager.instance;
 16:   }
 17:   
 18:   async initialize(): Promise<AnalyticsSettings> {
 19:     try {
 20:       // Try to load from localStorage first
 21:       const stored = localStorage.getItem(ANALYTICS_STORAGE_KEY);
 22:       if (stored) {
 23:         this.settings = JSON.parse(stored);
 24:       } else {
 25:         // Initialize with default settings
 26:         this.settings = {
 27:           enabled: false,
 28:           hasConsented: false,
 29:         };
 30:       }
 31:       
 32:       // Generate anonymous user ID if not exists
 33:       if (this.settings && !this.settings.userId) {
 34:         this.settings.userId = this.generateAnonymousId();
 35:         await this.saveSettings();
 36:       }
 37:       
 38:       // Generate session ID
 39:       if (this.settings) {
 40:         this.settings.sessionId = this.generateSessionId();
 41:       }
 42:       
 43:       return this.settings || {
 44:         enabled: false,
 45:         hasConsented: false,
 46:       };
 47:     } catch (error) {
 48:       console.error('Failed to initialize consent manager:', error);
 49:       // Return default settings on error
 50:       return {
 51:         enabled: false,
 52:         hasConsented: false,
 53:       };
 54:     }
 55:   }
 56:   
 57:   async grantConsent(): Promise<void> {
 58:     if (!this.settings) {
 59:       await this.initialize();
 60:     }
 61:     
 62:     this.settings!.enabled = true;
 63:     this.settings!.hasConsented = true;
 64:     this.settings!.consentDate = new Date().toISOString();
 65:     
 66:     await this.saveSettings();
 67:   }
 68:   
 69:   async revokeConsent(): Promise<void> {
 70:     if (!this.settings) {
 71:       await this.initialize();
 72:     }
 73:     
 74:     this.settings!.enabled = false;
 75:     
 76:     await this.saveSettings();
 77:   }
 78:   
 79:   async deleteAllData(): Promise<void> {
 80:     // Clear local storage
 81:     localStorage.removeItem(ANALYTICS_STORAGE_KEY);
 82:     
 83:     // Reset settings with new anonymous ID
 84:     this.settings = {
 85:       enabled: false,
 86:       hasConsented: false,
 87:       userId: this.generateAnonymousId(),
 88:       sessionId: this.generateSessionId(),
 89:     };
 90:     
 91:     await this.saveSettings();
 92:   }
 93:   
 94:   getSettings(): AnalyticsSettings | null {
 95:     return this.settings;
 96:   }
 97:   
 98:   hasConsented(): boolean {
 99:     return this.settings?.hasConsented || false;
100:   }
101:   
102:   isEnabled(): boolean {
103:     return this.settings?.enabled || false;
104:   }
105:   
106:   getUserId(): string {
107:     return this.settings?.userId || this.generateAnonymousId();
108:   }
109:   
110:   getSessionId(): string {
111:     return this.settings?.sessionId || this.generateSessionId();
112:   }
113:   
114:   private async saveSettings(): Promise<void> {
115:     if (!this.settings) return;
116:     
117:     try {
118:       localStorage.setItem(ANALYTICS_STORAGE_KEY, JSON.stringify(this.settings));
119:     } catch (error) {
120:       console.error('Failed to save analytics settings:', error);
121:     }
122:   }
123:   
124:   private generateAnonymousId(): string {
125:     // Generate a UUID v4
126:     return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
127:       const r = (Math.random() * 16) | 0;
128:       const v = c === 'x' ? r : (r & 0x3) | 0x8;
129:       return v.toString(16);
130:     });
131:   }
132:   
133:   private generateSessionId(): string {
134:     // Simple session ID based on timestamp and random value
135:     return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
136:   }
137: }
````

## File: src/lib/analytics/events.ts
````typescript
  1: import type { 
  2:   EventName,
  3:   FeatureUsageProperties,
  4:   ErrorProperties,
  5:   SessionProperties,
  6:   ModelProperties,
  7:   AgentProperties,
  8:   MCPProperties,
  9:   SlashCommandProperties,
 10:   PerformanceMetrics,
 11:   PromptSubmittedProperties,
 12:   SessionStoppedProperties,
 13:   EnhancedSessionStoppedProperties,
 14:   CheckpointCreatedProperties,
 15:   CheckpointRestoredProperties,
 16:   ToolExecutedProperties,
 17:   AgentStartedProperties,
 18:   AgentProgressProperties,
 19:   AgentErrorProperties,
 20:   MCPServerAddedProperties,
 21:   MCPServerRemovedProperties,
 22:   MCPToolInvokedProperties,
 23:   MCPConnectionErrorProperties,
 24:   SlashCommandSelectedProperties,
 25:   SlashCommandExecutedProperties,
 26:   SlashCommandCreatedProperties,
 27:   APIErrorProperties,
 28:   UIErrorProperties,
 29:   PerformanceBottleneckProperties,
 30:   MemoryWarningProperties,
 31:   UserJourneyProperties,
 32:   EnhancedPromptSubmittedProperties,
 33:   EnhancedToolExecutedProperties,
 34:   EnhancedErrorProperties,
 35:   SessionEngagementProperties,
 36:   FeatureDiscoveryProperties,
 37:   OutputQualityProperties,
 38:   ResourceUsageProperties,
 39:   FeatureAdoptionProperties,
 40:   FeatureCombinationProperties,
 41:   AIInteractionProperties,
 42:   PromptPatternProperties,
 43:   WorkflowProperties,
 44:   NetworkPerformanceProperties,
 45:   SuggestionProperties
 46: } from './types';
 47: 
 48: export const ANALYTICS_EVENTS = {
 49:   // Session events
 50:   SESSION_CREATED: 'session_created' as EventName,
 51:   SESSION_COMPLETED: 'session_completed' as EventName,
 52:   SESSION_RESUMED: 'session_resumed' as EventName,
 53:   PROMPT_SUBMITTED: 'prompt_submitted' as EventName,
 54:   SESSION_STOPPED: 'session_stopped' as EventName,
 55:   CHECKPOINT_CREATED: 'checkpoint_created' as EventName,
 56:   CHECKPOINT_RESTORED: 'checkpoint_restored' as EventName,
 57:   TOOL_EXECUTED: 'tool_executed' as EventName,
 58:   
 59:   // Feature usage events
 60:   FEATURE_USED: 'feature_used' as EventName,
 61:   MODEL_SELECTED: 'model_selected' as EventName,
 62:   TAB_CREATED: 'tab_created' as EventName,
 63:   TAB_CLOSED: 'tab_closed' as EventName,
 64:   FILE_OPENED: 'file_opened' as EventName,
 65:   FILE_EDITED: 'file_edited' as EventName,
 66:   FILE_SAVED: 'file_saved' as EventName,
 67:   
 68:   // Agent events
 69:   AGENT_EXECUTED: 'agent_executed' as EventName,
 70:   AGENT_STARTED: 'agent_started' as EventName,
 71:   AGENT_PROGRESS: 'agent_progress' as EventName,
 72:   AGENT_ERROR: 'agent_error' as EventName,
 73:   
 74:   // MCP events
 75:   MCP_SERVER_CONNECTED: 'mcp_server_connected' as EventName,
 76:   MCP_SERVER_DISCONNECTED: 'mcp_server_disconnected' as EventName,
 77:   MCP_SERVER_ADDED: 'mcp_server_added' as EventName,
 78:   MCP_SERVER_REMOVED: 'mcp_server_removed' as EventName,
 79:   MCP_TOOL_INVOKED: 'mcp_tool_invoked' as EventName,
 80:   MCP_CONNECTION_ERROR: 'mcp_connection_error' as EventName,
 81:   
 82:   // Slash command events
 83:   SLASH_COMMAND_USED: 'slash_command_used' as EventName,
 84:   SLASH_COMMAND_SELECTED: 'slash_command_selected' as EventName,
 85:   SLASH_COMMAND_EXECUTED: 'slash_command_executed' as EventName,
 86:   SLASH_COMMAND_CREATED: 'slash_command_created' as EventName,
 87:   
 88:   // Settings and system events
 89:   SETTINGS_CHANGED: 'settings_changed' as EventName,
 90:   APP_STARTED: 'app_started' as EventName,
 91:   APP_CLOSED: 'app_closed' as EventName,
 92:   
 93:   // Error and performance events
 94:   ERROR_OCCURRED: 'error_occurred' as EventName,
 95:   API_ERROR: 'api_error' as EventName,
 96:   UI_ERROR: 'ui_error' as EventName,
 97:   PERFORMANCE_BOTTLENECK: 'performance_bottleneck' as EventName,
 98:   MEMORY_WARNING: 'memory_warning' as EventName,
 99:   
100:   // User journey events
101:   JOURNEY_MILESTONE: 'journey_milestone' as EventName,
102:   USER_RETENTION: 'user_retention' as EventName,
103:   
104:   // AI interaction events
105:   AI_INTERACTION: 'ai_interaction' as EventName,
106:   PROMPT_PATTERN: 'prompt_pattern' as EventName,
107:   
108:   // Quality events
109:   OUTPUT_REGENERATED: 'output_regenerated' as EventName,
110:   CONVERSATION_ABANDONED: 'conversation_abandoned' as EventName,
111:   SUGGESTION_ACCEPTED: 'suggestion_accepted' as EventName,
112:   SUGGESTION_REJECTED: 'suggestion_rejected' as EventName,
113:   
114:   // Workflow events
115:   WORKFLOW_STARTED: 'workflow_started' as EventName,
116:   WORKFLOW_COMPLETED: 'workflow_completed' as EventName,
117:   WORKFLOW_ABANDONED: 'workflow_abandoned' as EventName,
118:   
119:   // Feature adoption events
120:   FEATURE_DISCOVERED: 'feature_discovered' as EventName,
121:   FEATURE_ADOPTED: 'feature_adopted' as EventName,
122:   FEATURE_COMBINATION: 'feature_combination' as EventName,
123:   
124:   // Resource usage events
125:   RESOURCE_USAGE_HIGH: 'resource_usage_high' as EventName,
126:   RESOURCE_USAGE_SAMPLED: 'resource_usage_sampled' as EventName,
127:   
128:   // Network performance events
129:   NETWORK_PERFORMANCE: 'network_performance' as EventName,
130:   NETWORK_FAILURE: 'network_failure' as EventName,
131:   
132:   // Engagement events
133:   SESSION_ENGAGEMENT: 'session_engagement' as EventName,
134: } as const;
135: 
136: // Event property builders - help ensure consistent event structure
137: export const eventBuilders = {
138:   session: (props: SessionProperties) => ({
139:     event: ANALYTICS_EVENTS.SESSION_CREATED,
140:     properties: {
141:       category: 'session',
142:       ...props,
143:     },
144:   }),
145:   
146:   feature: (feature: string, subfeature?: string, metadata?: Record<string, any>) => ({
147:     event: ANALYTICS_EVENTS.FEATURE_USED,
148:     properties: {
149:       category: 'feature',
150:       feature,
151:       subfeature,
152:       ...metadata,
153:     } as FeatureUsageProperties,
154:   }),
155:   
156:   error: (errorType: string, errorCode?: string, context?: string) => ({
157:     event: ANALYTICS_EVENTS.ERROR_OCCURRED,
158:     properties: {
159:       category: 'error',
160:       error_type: errorType,
161:       error_code: errorCode,
162:       context,
163:     } as ErrorProperties,
164:   }),
165:   
166:   model: (newModel: string, previousModel?: string, source?: string) => ({
167:     event: ANALYTICS_EVENTS.MODEL_SELECTED,
168:     properties: {
169:       category: 'model',
170:       new_model: newModel,
171:       previous_model: previousModel,
172:       source,
173:     } as ModelProperties,
174:   }),
175:   
176:   agent: (agentType: string, success: boolean, agentName?: string, durationMs?: number) => ({
177:     event: ANALYTICS_EVENTS.AGENT_EXECUTED,
178:     properties: {
179:       category: 'agent',
180:       agent_type: agentType,
181:       agent_name: agentName,
182:       success,
183:       duration_ms: durationMs,
184:     } as AgentProperties,
185:   }),
186:   
187:   mcp: (serverName: string, success: boolean, serverType?: string) => ({
188:     event: ANALYTICS_EVENTS.MCP_SERVER_CONNECTED,
189:     properties: {
190:       category: 'mcp',
191:       server_name: serverName,
192:       server_type: serverType,
193:       success,
194:     } as MCPProperties,
195:   }),
196:   
197:   slashCommand: (command: string, success: boolean) => ({
198:     event: ANALYTICS_EVENTS.SLASH_COMMAND_USED,
199:     properties: {
200:       category: 'slash_command',
201:       command,
202:       success,
203:     } as SlashCommandProperties,
204:   }),
205:   
206:   performance: (metrics: PerformanceMetrics) => ({
207:     event: ANALYTICS_EVENTS.FEATURE_USED,
208:     properties: {
209:       category: 'performance',
210:       feature: 'system_metrics',
211:       ...metrics,
212:     },
213:   }),
214:   
215:   // Claude Code Session event builders
216:   promptSubmitted: (props: PromptSubmittedProperties) => ({
217:     event: ANALYTICS_EVENTS.PROMPT_SUBMITTED,
218:     properties: {
219:       category: 'session',
220:       ...props,
221:     },
222:   }),
223:   
224:   sessionStopped: (props: SessionStoppedProperties) => ({
225:     event: ANALYTICS_EVENTS.SESSION_STOPPED,
226:     properties: {
227:       category: 'session',
228:       ...props,
229:     },
230:   }),
231:   
232:   // Enhanced session stopped with detailed metrics
233:   enhancedSessionStopped: (props: EnhancedSessionStoppedProperties) => ({
234:     event: ANALYTICS_EVENTS.SESSION_STOPPED,
235:     properties: {
236:       category: 'session',
237:       duration_ms: props.duration_ms,
238:       messages_count: props.messages_count,
239:       reason: props.reason,
240:       // Timing metrics
241:       time_to_first_message_ms: props.time_to_first_message_ms,
242:       average_response_time_ms: props.average_response_time_ms,
243:       idle_time_ms: props.idle_time_ms,
244:       // Interaction metrics
245:       prompts_sent: props.prompts_sent,
246:       tools_executed: props.tools_executed,
247:       tools_failed: props.tools_failed,
248:       files_created: props.files_created,
249:       files_modified: props.files_modified,
250:       files_deleted: props.files_deleted,
251:       // Content metrics
252:       total_tokens_used: props.total_tokens_used,
253:       code_blocks_generated: props.code_blocks_generated,
254:       errors_encountered: props.errors_encountered,
255:       // Session context
256:       model: props.model,
257:       has_checkpoints: props.has_checkpoints,
258:       checkpoint_count: props.checkpoint_count,
259:       was_resumed: props.was_resumed,
260:       // Agent context
261:       agent_type: props.agent_type,
262:       agent_name: props.agent_name ? sanitizers.sanitizeAgentName(props.agent_name) : undefined,
263:       agent_success: props.agent_success,
264:       // Stop context
265:       stop_source: props.stop_source,
266:       final_state: props.final_state,
267:       has_pending_prompts: props.has_pending_prompts,
268:       pending_prompts_count: props.pending_prompts_count,
269:     },
270:   }),
271:   
272:   checkpointCreated: (props: CheckpointCreatedProperties) => ({
273:     event: ANALYTICS_EVENTS.CHECKPOINT_CREATED,
274:     properties: {
275:       category: 'session',
276:       ...props,
277:     },
278:   }),
279:   
280:   checkpointRestored: (props: CheckpointRestoredProperties) => ({
281:     event: ANALYTICS_EVENTS.CHECKPOINT_RESTORED,
282:     properties: {
283:       category: 'session',
284:       ...props,
285:     },
286:   }),
287:   
288:   toolExecuted: (props: ToolExecutedProperties) => ({
289:     event: ANALYTICS_EVENTS.TOOL_EXECUTED,
290:     properties: {
291:       category: 'session',
292:       tool_name: sanitizers.sanitizeToolName(props.tool_name),
293:       execution_time_ms: props.execution_time_ms,
294:       success: props.success,
295:       error_message: props.error_message ? sanitizers.sanitizeErrorMessage(props.error_message) : undefined,
296:     },
297:   }),
298:   
299:   // Enhanced Agent event builders
300:   agentStarted: (props: AgentStartedProperties) => ({
301:     event: ANALYTICS_EVENTS.AGENT_STARTED,
302:     properties: {
303:       category: 'agent',
304:       agent_type: props.agent_type,
305:       agent_name: props.agent_name ? sanitizers.sanitizeAgentName(props.agent_name) : undefined,
306:       has_custom_prompt: props.has_custom_prompt,
307:     },
308:   }),
309:   
310:   agentProgress: (props: AgentProgressProperties) => ({
311:     event: ANALYTICS_EVENTS.AGENT_PROGRESS,
312:     properties: {
313:       category: 'agent',
314:       ...props,
315:     },
316:   }),
317:   
318:   agentError: (props: AgentErrorProperties) => ({
319:     event: ANALYTICS_EVENTS.AGENT_ERROR,
320:     properties: {
321:       category: 'agent',
322:       ...props,
323:     },
324:   }),
325:   
326:   // MCP event builders
327:   mcpServerAdded: (props: MCPServerAddedProperties) => ({
328:     event: ANALYTICS_EVENTS.MCP_SERVER_ADDED,
329:     properties: {
330:       category: 'mcp',
331:       ...props,
332:     },
333:   }),
334:   
335:   mcpServerRemoved: (props: MCPServerRemovedProperties) => ({
336:     event: ANALYTICS_EVENTS.MCP_SERVER_REMOVED,
337:     properties: {
338:       category: 'mcp',
339:       server_name: sanitizers.sanitizeServerName(props.server_name),
340:       was_connected: props.was_connected,
341:     },
342:   }),
343:   
344:   mcpToolInvoked: (props: MCPToolInvokedProperties) => ({
345:     event: ANALYTICS_EVENTS.MCP_TOOL_INVOKED,
346:     properties: {
347:       category: 'mcp',
348:       server_name: sanitizers.sanitizeServerName(props.server_name),
349:       tool_name: sanitizers.sanitizeToolName(props.tool_name),
350:       invocation_source: props.invocation_source,
351:     },
352:   }),
353:   
354:   mcpConnectionError: (props: MCPConnectionErrorProperties) => ({
355:     event: ANALYTICS_EVENTS.MCP_CONNECTION_ERROR,
356:     properties: {
357:       category: 'mcp',
358:       server_name: sanitizers.sanitizeServerName(props.server_name),
359:       error_type: props.error_type,
360:       retry_attempt: props.retry_attempt,
361:     },
362:   }),
363:   
364:   // Slash Command event builders
365:   slashCommandSelected: (props: SlashCommandSelectedProperties) => ({
366:     event: ANALYTICS_EVENTS.SLASH_COMMAND_SELECTED,
367:     properties: {
368:       category: 'slash_command',
369:       command_name: sanitizers.sanitizeCommandName(props.command_name),
370:       selection_method: props.selection_method,
371:     },
372:   }),
373:   
374:   slashCommandExecuted: (props: SlashCommandExecutedProperties) => ({
375:     event: ANALYTICS_EVENTS.SLASH_COMMAND_EXECUTED,
376:     properties: {
377:       category: 'slash_command',
378:       command_name: sanitizers.sanitizeCommandName(props.command_name),
379:       parameters_count: props.parameters_count,
380:       execution_time_ms: props.execution_time_ms,
381:     },
382:   }),
383:   
384:   slashCommandCreated: (props: SlashCommandCreatedProperties) => ({
385:     event: ANALYTICS_EVENTS.SLASH_COMMAND_CREATED,
386:     properties: {
387:       category: 'slash_command',
388:       ...props,
389:     },
390:   }),
391:   
392:   // Error and Performance event builders
393:   apiError: (props: APIErrorProperties) => ({
394:     event: ANALYTICS_EVENTS.API_ERROR,
395:     properties: {
396:       category: 'error',
397:       endpoint: sanitizers.sanitizeEndpoint(props.endpoint),
398:       error_code: props.error_code,
399:       retry_count: props.retry_count,
400:       response_time_ms: props.response_time_ms,
401:     },
402:   }),
403:   
404:   uiError: (props: UIErrorProperties) => ({
405:     event: ANALYTICS_EVENTS.UI_ERROR,
406:     properties: {
407:       category: 'error',
408:       ...props,
409:     },
410:   }),
411:   
412:   performanceBottleneck: (props: PerformanceBottleneckProperties) => ({
413:     event: ANALYTICS_EVENTS.PERFORMANCE_BOTTLENECK,
414:     properties: {
415:       category: 'performance',
416:       ...props,
417:     },
418:   }),
419:   
420:   memoryWarning: (props: MemoryWarningProperties) => ({
421:     event: ANALYTICS_EVENTS.MEMORY_WARNING,
422:     properties: {
423:       category: 'performance',
424:       ...props,
425:     },
426:   }),
427:   
428:   // User journey event builders
429:   journeyMilestone: (props: UserJourneyProperties) => ({
430:     event: ANALYTICS_EVENTS.JOURNEY_MILESTONE,
431:     properties: {
432:       category: 'user_journey',
433:       ...props,
434:     },
435:   }),
436:   
437:   // Enhanced prompt submission with more context
438:   enhancedPromptSubmitted: (props: EnhancedPromptSubmittedProperties) => ({
439:     event: ANALYTICS_EVENTS.PROMPT_SUBMITTED,
440:     properties: {
441:       category: 'session',
442:       prompt_length: props.prompt_length,
443:       model: props.model,
444:       has_attachments: props.has_attachments,
445:       source: props.source,
446:       word_count: props.word_count,
447:       conversation_depth: props.conversation_depth,
448:       prompt_complexity: props.prompt_complexity,
449:       contains_code: props.contains_code,
450:       language_detected: props.language_detected,
451:       session_age_ms: props.session_age_ms,
452:     },
453:   }),
454:   
455:   // Enhanced tool execution with more context
456:   enhancedToolExecuted: (props: EnhancedToolExecutedProperties) => ({
457:     event: ANALYTICS_EVENTS.TOOL_EXECUTED,
458:     properties: {
459:       category: 'session',
460:       tool_name: sanitizers.sanitizeToolName(props.tool_name),
461:       execution_time_ms: props.execution_time_ms,
462:       success: props.success,
463:       error_message: props.error_message ? sanitizers.sanitizeErrorMessage(props.error_message) : undefined,
464:       tool_category: props.tool_category,
465:       consecutive_failures: props.consecutive_failures,
466:       retry_attempted: props.retry_attempted,
467:       input_size_bytes: props.input_size_bytes,
468:       output_size_bytes: props.output_size_bytes,
469:     },
470:   }),
471:   
472:   // Enhanced error tracking
473:   enhancedError: (props: EnhancedErrorProperties) => ({
474:     event: ANALYTICS_EVENTS.ERROR_OCCURRED,
475:     properties: {
476:       category: 'error',
477:       error_type: props.error_type,
478:       error_code: props.error_code,
479:       error_message: props.error_message ? sanitizers.sanitizeErrorMessage(props.error_message) : undefined,
480:       context: props.context,
481:       user_action_before_error: props.user_action_before_error,
482:       recovery_attempted: props.recovery_attempted,
483:       recovery_successful: props.recovery_successful,
484:       error_frequency: props.error_frequency,
485:       stack_trace_hash: props.stack_trace_hash,
486:     },
487:   }),
488:   
489:   // Session engagement
490:   sessionEngagement: (props: SessionEngagementProperties) => ({
491:     event: ANALYTICS_EVENTS.SESSION_ENGAGEMENT,
492:     properties: {
493:       category: 'engagement',
494:       ...props,
495:     },
496:   }),
497:   
498:   // Feature discovery
499:   featureDiscovered: (props: FeatureDiscoveryProperties) => ({
500:     event: ANALYTICS_EVENTS.FEATURE_DISCOVERED,
501:     properties: {
502:       category: 'feature_adoption',
503:       ...props,
504:     },
505:   }),
506:   
507:   // Output quality
508:   outputRegenerated: (props: OutputQualityProperties) => ({
509:     event: ANALYTICS_EVENTS.OUTPUT_REGENERATED,
510:     properties: {
511:       category: 'quality',
512:       ...props,
513:     },
514:   }),
515:   
516:   // Conversation abandoned
517:   conversationAbandoned: (reason: string, messagesCount: number) => ({
518:     event: ANALYTICS_EVENTS.CONVERSATION_ABANDONED,
519:     properties: {
520:       category: 'quality',
521:       reason,
522:       messages_count: messagesCount,
523:     },
524:   }),
525:   
526:   // Suggestion tracking
527:   suggestionAccepted: (props: SuggestionProperties) => ({
528:     event: ANALYTICS_EVENTS.SUGGESTION_ACCEPTED,
529:     properties: {
530:       category: 'quality',
531:       ...props,
532:     },
533:   }),
534:   
535:   suggestionRejected: (props: SuggestionProperties) => ({
536:     event: ANALYTICS_EVENTS.SUGGESTION_REJECTED,
537:     properties: {
538:       category: 'quality',
539:       ...props,
540:     },
541:   }),
542:   
543:   // Resource usage
544:   resourceUsageHigh: (props: ResourceUsageProperties) => ({
545:     event: ANALYTICS_EVENTS.RESOURCE_USAGE_HIGH,
546:     properties: {
547:       category: 'performance',
548:       ...props,
549:     },
550:   }),
551:   
552:   resourceUsageSampled: (props: ResourceUsageProperties) => ({
553:     event: ANALYTICS_EVENTS.RESOURCE_USAGE_SAMPLED,
554:     properties: {
555:       category: 'performance',
556:       ...props,
557:     },
558:   }),
559:   
560:   // Feature adoption
561:   featureAdopted: (props: FeatureAdoptionProperties) => ({
562:     event: ANALYTICS_EVENTS.FEATURE_ADOPTED,
563:     properties: {
564:       category: 'feature_adoption',
565:       ...props,
566:     },
567:   }),
568:   
569:   featureCombination: (props: FeatureCombinationProperties) => ({
570:     event: ANALYTICS_EVENTS.FEATURE_COMBINATION,
571:     properties: {
572:       category: 'feature_adoption',
573:       ...props,
574:     },
575:   }),
576:   
577:   // AI interactions
578:   aiInteraction: (props: AIInteractionProperties) => ({
579:     event: ANALYTICS_EVENTS.AI_INTERACTION,
580:     properties: {
581:       category: 'ai',
582:       ...props,
583:     },
584:   }),
585:   
586:   promptPattern: (props: PromptPatternProperties) => ({
587:     event: ANALYTICS_EVENTS.PROMPT_PATTERN,
588:     properties: {
589:       category: 'ai',
590:       ...props,
591:     },
592:   }),
593:   
594:   // Workflow tracking
595:   workflowStarted: (props: WorkflowProperties) => ({
596:     event: ANALYTICS_EVENTS.WORKFLOW_STARTED,
597:     properties: {
598:       category: 'workflow',
599:       ...props,
600:     },
601:   }),
602:   
603:   workflowCompleted: (props: WorkflowProperties) => ({
604:     event: ANALYTICS_EVENTS.WORKFLOW_COMPLETED,
605:     properties: {
606:       category: 'workflow',
607:       ...props,
608:     },
609:   }),
610:   
611:   workflowAbandoned: (props: WorkflowProperties) => ({
612:     event: ANALYTICS_EVENTS.WORKFLOW_ABANDONED,
613:     properties: {
614:       category: 'workflow',
615:       ...props,
616:     },
617:   }),
618:   
619:   // Network performance
620:   networkPerformance: (props: NetworkPerformanceProperties) => ({
621:     event: ANALYTICS_EVENTS.NETWORK_PERFORMANCE,
622:     properties: {
623:       category: 'network',
624:       endpoint_type: props.endpoint_type,
625:       latency_ms: props.latency_ms,
626:       payload_size_bytes: props.payload_size_bytes,
627:       connection_quality: props.connection_quality,
628:       retry_count: props.retry_count,
629:       circuit_breaker_triggered: props.circuit_breaker_triggered,
630:     },
631:   }),
632:   
633:   networkFailure: (props: NetworkPerformanceProperties) => ({
634:     event: ANALYTICS_EVENTS.NETWORK_FAILURE,
635:     properties: {
636:       category: 'network',
637:       endpoint_type: props.endpoint_type,
638:       latency_ms: props.latency_ms,
639:       payload_size_bytes: props.payload_size_bytes,
640:       connection_quality: props.connection_quality,
641:       retry_count: props.retry_count,
642:       circuit_breaker_triggered: props.circuit_breaker_triggered,
643:     },
644:   }),
645: };
646: 
647: // Sanitization helpers to remove PII
648: export const sanitizers = {
649:   // Remove file paths, keeping only extension
650:   sanitizeFilePath: (path: string): string => {
651:     const ext = path.split('.').pop();
652:     return ext ? `*.${ext}` : 'unknown';
653:   },
654:   
655:   // Remove project names and paths
656:   sanitizeProjectPath: (_path: string): string => {
657:     return 'project';
658:   },
659:   
660:   // Sanitize error messages that might contain sensitive info
661:   sanitizeErrorMessage: (message: string): string => {
662:     // Remove file paths
663:     message = message.replace(/\/[\w\-\/\.]+/g, '/***');
664:     // Remove potential API keys or tokens
665:     message = message.replace(/[a-zA-Z0-9]{20,}/g, '***');
666:     // Remove email addresses
667:     message = message.replace(/[\w\.-]+@[\w\.-]+\.\w+/g, '***@***.***');
668:     return message;
669:   },
670:   
671:   // Sanitize agent names that might contain user info
672:   sanitizeAgentName: (name: string): string => {
673:     // Only keep the type, remove custom names
674:     return name.split('-')[0] || 'custom';
675:   },
676:   
677:   // Sanitize tool names to remove any user-specific info
678:   sanitizeToolName: (name: string): string => {
679:     // Remove any path-like structures
680:     return name.replace(/\/[\w\-\/\.]+/g, '').toLowerCase();
681:   },
682:   
683:   // Sanitize server names to remove any user-specific info
684:   sanitizeServerName: (name: string): string => {
685:     // Keep only the type or first part
686:     return name.split(/[\-_]/)[0] || 'custom';
687:   },
688:   
689:   // Sanitize command names
690:   sanitizeCommandName: (name: string): string => {
691:     // Remove any custom prefixes or user-specific parts
692:     return name.replace(/^custom-/, '').split('-')[0] || 'custom';
693:   },
694:   
695:   // Sanitize API endpoints
696:   sanitizeEndpoint: (endpoint: string): string => {
697:     // Remove any dynamic IDs or user-specific parts
698:     return endpoint.replace(/\/\d+/g, '/:id').replace(/\/[\w\-]{20,}/g, '/:id');
699:   },
700: };
````

## File: src/lib/analytics/index.ts
````typescript
  1: import posthog from 'posthog-js';
  2: import { ConsentManager } from './consent';
  3: import { sanitizers } from './events';
  4: import type { 
  5:   AnalyticsConfig, 
  6:   AnalyticsEvent, 
  7:   EventName,
  8:   AnalyticsSettings 
  9: } from './types';
 10: 
 11: export * from './types';
 12: export * from './events';
 13: export { ConsentManager } from './consent';
 14: export { ResourceMonitor, resourceMonitor } from './resourceMonitor';
 15: 
 16: class AnalyticsService {
 17:   private static instance: AnalyticsService;
 18:   private initialized = false;
 19:   private consentManager: ConsentManager;
 20:   private config: AnalyticsConfig;
 21:   private eventQueue: AnalyticsEvent[] = [];
 22:   private flushInterval: NodeJS.Timeout | null = null;
 23:   private currentScreen: string = 'app_start';
 24:   
 25:   private constructor() {
 26:     this.consentManager = ConsentManager.getInstance();
 27:     
 28:     // Default configuration - pulled from Vite environment variables
 29:     this.config = {
 30:       apiKey: import.meta.env.VITE_PUBLIC_POSTHOG_KEY || 'phc_YOUR_PROJECT_API_KEY',
 31:       apiHost: import.meta.env.VITE_PUBLIC_POSTHOG_HOST || 'https://app.posthog.com',
 32:       persistence: 'localStorage',
 33:       autocapture: false, // We'll manually track events
 34:       disable_session_recording: true, // Privacy first
 35:       opt_out_capturing_by_default: true, // Require explicit opt-in
 36:     };
 37:   }
 38:   
 39:   static getInstance(): AnalyticsService {
 40:     if (!AnalyticsService.instance) {
 41:       AnalyticsService.instance = new AnalyticsService();
 42:     }
 43:     return AnalyticsService.instance;
 44:   }
 45:   
 46:   async initialize(): Promise<void> {
 47:     if (this.initialized) return;
 48:     
 49:     try {
 50:       // Initialize consent manager
 51:       const settings = await this.consentManager.initialize();
 52:       
 53:       // Only initialize PostHog if user has consented
 54:       if (settings.hasConsented && settings.enabled) {
 55:         this.initializePostHog(settings);
 56:       }
 57:       
 58:       // Start event queue flush interval
 59:       this.startFlushInterval();
 60:       
 61:       this.initialized = true;
 62:     } catch (error) {
 63:       console.error('Failed to initialize analytics:', error);
 64:     }
 65:   }
 66:   
 67:   private initializePostHog(settings: AnalyticsSettings): void {
 68:     try {
 69:       posthog.init(this.config.apiKey, {
 70:         api_host: this.config.apiHost,
 71:         capture_pageview: false, // Disable automatic pageview capture
 72:         capture_pageleave: false, // Disable automatic pageleave
 73:         bootstrap: {
 74:           distinctID: settings.userId,
 75:         },
 76:         persistence: this.config.persistence,
 77:         autocapture: this.config.autocapture,
 78:         disable_session_recording: this.config.disable_session_recording,
 79:         opt_out_capturing_by_default: this.config.opt_out_capturing_by_default,
 80:         loaded: (ph) => {
 81:           // Set user properties
 82:           ph.identify(settings.userId, {
 83:             anonymous: true,
 84:             consent_date: settings.consentDate,
 85:             app_type: 'desktop',
 86:             app_name: 'claudia',
 87:           });
 88:           
 89:           // Set initial screen
 90:           ph.capture('$screen', {
 91:             $screen_name: 'app_start',
 92:           });
 93:           
 94:           // Opt in since user has consented
 95:           ph.opt_in_capturing();
 96:           
 97:           if (this.config.loaded) {
 98:             this.config.loaded(ph);
 99:           }
100:         },
101:       });
102:     } catch (error) {
103:       console.error('Failed to initialize PostHog:', error);
104:     }
105:   }
106:   
107:   async enable(): Promise<void> {
108:     await this.consentManager.grantConsent();
109:     const settings = this.consentManager.getSettings();
110:     if (settings) {
111:       this.initializePostHog(settings);
112:     }
113:   }
114:   
115:   async disable(): Promise<void> {
116:     await this.consentManager.revokeConsent();
117:     if (typeof posthog !== 'undefined' && posthog.opt_out_capturing) {
118:       posthog.opt_out_capturing();
119:     }
120:   }
121:   
122:   async deleteAllData(): Promise<void> {
123:     await this.consentManager.deleteAllData();
124:     if (typeof posthog !== 'undefined' && posthog.reset) {
125:       posthog.reset();
126:     }
127:   }
128:   
129:   setScreen(screenName: string): void {
130:     this.currentScreen = screenName;
131:     
132:     // Track screen view in PostHog
133:     if (typeof posthog !== 'undefined' && typeof posthog.capture === 'function') {
134:       posthog.capture('$screen', {
135:         $screen_name: screenName,
136:       });
137:     }
138:   }
139:   
140:   track(eventName: EventName | string, properties?: Record<string, any>): void {
141:     // Check if analytics is enabled
142:     if (!this.consentManager.isEnabled()) {
143:       return;
144:     }
145:     
146:     // Sanitize properties to remove PII
147:     const sanitizedProperties = this.sanitizeProperties(properties || {});
148:     
149:     // Add screen context to all events
150:     const enhancedProperties = {
151:       ...sanitizedProperties,
152:       screen_name: this.currentScreen,
153:       app_context: 'claudia_desktop',
154:     };
155:     
156:     // Create event
157:     const event: AnalyticsEvent = {
158:       event: eventName,
159:       properties: enhancedProperties,
160:       timestamp: Date.now(),
161:       sessionId: this.consentManager.getSessionId(),
162:       userId: this.consentManager.getUserId(),
163:     };
164:     
165:     // Add to queue
166:     this.eventQueue.push(event);
167:     
168:     // Send immediately if PostHog is initialized
169:     if (typeof posthog !== 'undefined' && typeof posthog.capture === 'function') {
170:       this.flushEvents();
171:     }
172:   }
173:   
174:   identify(traits?: Record<string, any>): void {
175:     if (!this.consentManager.isEnabled()) {
176:       return;
177:     }
178:     
179:     const userId = this.consentManager.getUserId();
180:     const sanitizedTraits = this.sanitizeProperties(traits || {});
181:     
182:     if (typeof posthog !== 'undefined' && posthog.identify) {
183:       posthog.identify(userId, {
184:         ...sanitizedTraits,
185:         anonymous: true,
186:       });
187:     }
188:   }
189:   
190:   private sanitizeProperties(properties: Record<string, any>): Record<string, any> {
191:     const sanitized: Record<string, any> = {};
192:     
193:     for (const [key, value] of Object.entries(properties)) {
194:       // Skip null/undefined values
195:       if (value == null) continue;
196:       
197:       // Apply specific sanitizers based on key
198:       if (key.includes('path') || key.includes('file')) {
199:         sanitized[key] = typeof value === 'string' ? sanitizers.sanitizeFilePath(value) : value;
200:       } else if (key.includes('project')) {
201:         sanitized[key] = typeof value === 'string' ? sanitizers.sanitizeProjectPath(value) : value;
202:       } else if (key.includes('error') || key.includes('message')) {
203:         sanitized[key] = typeof value === 'string' ? sanitizers.sanitizeErrorMessage(value) : value;
204:       } else if (key.includes('agent_name')) {
205:         sanitized[key] = typeof value === 'string' ? sanitizers.sanitizeAgentName(value) : value;
206:       } else {
207:         // For other properties, ensure no PII
208:         if (typeof value === 'string') {
209:           // Remove potential file paths
210:           let cleanValue = value.replace(/\/[\w\-\/\.]+/g, '/***');
211:           // Remove potential API keys
212:           cleanValue = cleanValue.replace(/[a-zA-Z0-9]{32,}/g, '***');
213:           // Remove emails
214:           cleanValue = cleanValue.replace(/[\w\.-]+@[\w\.-]+\.\w+/g, '***@***.***');
215:           sanitized[key] = cleanValue;
216:         } else {
217:           sanitized[key] = value;
218:         }
219:       }
220:     }
221:     
222:     return sanitized;
223:   }
224:   
225:   private flushEvents(): void {
226:     if (this.eventQueue.length === 0) return;
227:     
228:     const events = [...this.eventQueue];
229:     this.eventQueue = [];
230:     
231:     events.forEach(event => {
232:       if (typeof posthog !== 'undefined' && posthog.capture) {
233:         posthog.capture(event.event, {
234:           ...event.properties,
235:           $session_id: event.sessionId,
236:           timestamp: event.timestamp,
237:           $current_url: `claudia://${event.properties?.screen_name || 'unknown'}`,
238:         });
239:       }
240:     });
241:   }
242:   
243:   private startFlushInterval(): void {
244:     // Flush events every 5 seconds
245:     this.flushInterval = setInterval(() => {
246:       if (this.consentManager.isEnabled()) {
247:         this.flushEvents();
248:       }
249:     }, 5000);
250:   }
251:   
252:   shutdown(): void {
253:     if (this.flushInterval) {
254:       clearInterval(this.flushInterval);
255:       this.flushInterval = null;
256:     }
257:     
258:     // Flush any remaining events
259:     this.flushEvents();
260:   }
261:   
262:   // Convenience methods
263:   isEnabled(): boolean {
264:     return this.consentManager.isEnabled();
265:   }
266:   
267:   hasConsented(): boolean {
268:     return this.consentManager.hasConsented();
269:   }
270:   
271:   getSettings(): AnalyticsSettings | null {
272:     return this.consentManager.getSettings();
273:   }
274: }
275: 
276: // Export singleton instance
277: export const analytics = AnalyticsService.getInstance();
278: 
279: // Export for direct usage
280: export default analytics;
281: 
282: /**
283:  * Performance tracking utility for better insights
284:  */
285: export class PerformanceTracker {
286:   private static performanceData: Map<string, number[]> = new Map();
287:   
288:   /**
289:    * Record a performance metric
290:    * Automatically tracks percentiles when enough data is collected
291:    */
292:   static recordMetric(operation: string, duration: number): void {
293:     if (!this.performanceData.has(operation)) {
294:       this.performanceData.set(operation, []);
295:     }
296:     
297:     const data = this.performanceData.get(operation)!;
298:     data.push(duration);
299:     
300:     // Keep last 100 measurements for memory efficiency
301:     if (data.length > 100) {
302:       data.shift();
303:     }
304:     
305:     // Track percentiles every 10 measurements
306:     if (data.length >= 10 && data.length % 10 === 0) {
307:       const sorted = [...data].sort((a, b) => a - b);
308:       const p50 = sorted[Math.floor(sorted.length * 0.5)];
309:       const p95 = sorted[Math.floor(sorted.length * 0.95)];
310:       const p99 = sorted[Math.floor(sorted.length * 0.99)];
311:       
312:       analytics.track('performance_percentiles', {
313:         operation,
314:         p50,
315:         p95,
316:         p99,
317:         sample_size: data.length,
318:         min: sorted[0],
319:         max: sorted[sorted.length - 1],
320:         avg: data.reduce((a, b) => a + b, 0) / data.length,
321:       });
322:     }
323:   }
324:   
325:   /**
326:    * Get current statistics for an operation
327:    */
328:   static getStats(operation: string): { p50: number; p95: number; p99: number; count: number } | null {
329:     const data = this.performanceData.get(operation);
330:     if (!data || data.length === 0) return null;
331:     
332:     const sorted = [...data].sort((a, b) => a - b);
333:     return {
334:       p50: sorted[Math.floor(sorted.length * 0.5)],
335:       p95: sorted[Math.floor(sorted.length * 0.95)],
336:       p99: sorted[Math.floor(sorted.length * 0.99)],
337:       count: data.length,
338:     };
339:   }
340:   
341:   /**
342:    * Clear data for an operation or all operations
343:    */
344:   static clear(operation?: string): void {
345:     if (operation) {
346:       this.performanceData.delete(operation);
347:     } else {
348:       this.performanceData.clear();
349:     }
350:   }
351: }
````

## File: src/lib/analytics/resourceMonitor.ts
````typescript
  1: import { analytics, eventBuilders } from '@/lib/analytics';
  2: import type { ResourceUsageProperties } from './types';
  3: 
  4: /**
  5:  * Resource monitoring utility for tracking system resource usage and performance
  6:  * Helps identify performance bottlenecks and resource-intensive operations
  7:  */
  8: export class ResourceMonitor {
  9:   private static instance: ResourceMonitor;
 10:   private monitoringInterval: NodeJS.Timeout | null = null;
 11:   private isMonitoring = false;
 12:   private sampleCount = 0;
 13:   private highUsageThresholds = {
 14:     memory: 500, // MB
 15:     cpu: 80, // percent
 16:     networkRequests: 50, // per interval
 17:   };
 18:   
 19:   private constructor() {}
 20:   
 21:   static getInstance(): ResourceMonitor {
 22:     if (!ResourceMonitor.instance) {
 23:       ResourceMonitor.instance = new ResourceMonitor();
 24:     }
 25:     return ResourceMonitor.instance;
 26:   }
 27:   
 28:   /**
 29:    * Start monitoring resource usage with periodic sampling
 30:    * @param intervalMs - Sampling interval in milliseconds (default: 60000ms = 1 minute)
 31:    */
 32:   startMonitoring(intervalMs: number = 60000): void {
 33:     if (this.isMonitoring) {
 34:       console.warn('Resource monitoring is already active');
 35:       return;
 36:     }
 37:     
 38:     this.isMonitoring = true;
 39:     this.sampleCount = 0;
 40:     
 41:     // Initial sample
 42:     this.collectAndReportMetrics();
 43:     
 44:     // Set up periodic sampling
 45:     this.monitoringInterval = setInterval(() => {
 46:       this.collectAndReportMetrics();
 47:     }, intervalMs);
 48:     
 49:     console.log(`Resource monitoring started with ${intervalMs}ms interval`);
 50:   }
 51:   
 52:   /**
 53:    * Stop resource monitoring
 54:    */
 55:   stopMonitoring(): void {
 56:     if (this.monitoringInterval) {
 57:       clearInterval(this.monitoringInterval);
 58:       this.monitoringInterval = null;
 59:     }
 60:     this.isMonitoring = false;
 61:     console.log('Resource monitoring stopped');
 62:   }
 63:   
 64:   /**
 65:    * Collect current resource metrics
 66:    */
 67:   private collectResourceMetrics(): ResourceUsageProperties {
 68:     const metrics: ResourceUsageProperties = {
 69:       memory_usage_mb: this.getMemoryUsage(),
 70:       network_requests_count: this.getNetworkRequestsCount(),
 71:       active_connections: this.getActiveConnections(),
 72:     };
 73:     
 74:     // Add CPU usage if available
 75:     const cpuUsage = this.getCPUUsage();
 76:     if (cpuUsage !== null) {
 77:       metrics.cpu_usage_percent = cpuUsage;
 78:     }
 79:     
 80:     // Add cache hit rate if available
 81:     const cacheHitRate = this.getCacheHitRate();
 82:     if (cacheHitRate !== null) {
 83:       metrics.cache_hit_rate = cacheHitRate;
 84:     }
 85:     
 86:     return metrics;
 87:   }
 88:   
 89:   /**
 90:    * Collect metrics and report to analytics
 91:    */
 92:   private collectAndReportMetrics(): void {
 93:     try {
 94:       const metrics = this.collectResourceMetrics();
 95:       this.sampleCount++;
 96:       
 97:       // Always send sampled data every 10th sample for baseline tracking
 98:       if (this.sampleCount % 10 === 0) {
 99:         const event = eventBuilders.resourceUsageSampled(metrics);
100:         analytics.track(event.event, event.properties);
101:       }
102:       
103:       // Check for high usage conditions
104:       const isHighUsage = 
105:         metrics.memory_usage_mb > this.highUsageThresholds.memory ||
106:         (metrics.cpu_usage_percent && metrics.cpu_usage_percent > this.highUsageThresholds.cpu) ||
107:         metrics.network_requests_count > this.highUsageThresholds.networkRequests;
108:       
109:       if (isHighUsage) {
110:         const event = eventBuilders.resourceUsageHigh(metrics);
111:         analytics.track(event.event, event.properties);
112:       }
113:     } catch (error) {
114:       console.error('Failed to collect resource metrics:', error);
115:     }
116:   }
117:   
118:   /**
119:    * Get current memory usage in MB
120:    */
121:   private getMemoryUsage(): number {
122:     if ('memory' in performance && (performance as any).memory) {
123:       return (performance as any).memory.usedJSHeapSize / (1024 * 1024);
124:     }
125:     
126:     // Fallback: estimate based on performance timing
127:     return 0;
128:   }
129:   
130:   /**
131:    * Get CPU usage percentage (if available)
132:    */
133:   private getCPUUsage(): number | null {
134:     // This is a placeholder - actual CPU usage would require native APIs
135:     // In a Tauri app, you could call a Rust function to get real CPU usage
136:     return null;
137:   }
138:   
139:   /**
140:    * Get count of active network requests
141:    */
142:   private getNetworkRequestsCount(): number {
143:     // Count active fetch requests if performance observer is available
144:     if ('PerformanceObserver' in window) {
145:       const entries = performance.getEntriesByType('resource');
146:       const recentEntries = entries.filter(entry => 
147:         entry.startTime > performance.now() - 60000 // Last minute
148:       );
149:       return recentEntries.length;
150:     }
151:     return 0;
152:   }
153:   
154:   /**
155:    * Get number of active connections (WebSocket, SSE, etc.)
156:    */
157:   private getActiveConnections(): number {
158:     // This would need to be tracked by your connection management code
159:     // For now, return a placeholder
160:     return 0;
161:   }
162:   
163:   /**
164:    * Get cache hit rate if available
165:    */
166:   private getCacheHitRate(): number | null {
167:     // This would need to be calculated based on your caching implementation
168:     return null;
169:   }
170:   
171:   /**
172:    * Set custom thresholds for high usage detection
173:    */
174:   setThresholds(thresholds: Partial<typeof ResourceMonitor.prototype.highUsageThresholds>): void {
175:     this.highUsageThresholds = {
176:       ...this.highUsageThresholds,
177:       ...thresholds,
178:     };
179:   }
180:   
181:   /**
182:    * Get current thresholds
183:    */
184:   getThresholds(): typeof ResourceMonitor.prototype.highUsageThresholds {
185:     return { ...this.highUsageThresholds };
186:   }
187:   
188:   /**
189:    * Force a single metric collection and report
190:    */
191:   collectOnce(): ResourceUsageProperties {
192:     const metrics = this.collectResourceMetrics();
193:     
194:     // Check for high usage
195:     const isHighUsage = 
196:       metrics.memory_usage_mb > this.highUsageThresholds.memory ||
197:       (metrics.cpu_usage_percent && metrics.cpu_usage_percent > this.highUsageThresholds.cpu) ||
198:       metrics.network_requests_count > this.highUsageThresholds.networkRequests;
199:     
200:     if (isHighUsage) {
201:       const event = eventBuilders.resourceUsageHigh(metrics);
202:       analytics.track(event.event, event.properties);
203:     }
204:     
205:     return metrics;
206:   }
207: }
208: 
209: // Export singleton instance
210: export const resourceMonitor = ResourceMonitor.getInstance();
````

## File: src/lib/analytics/types.ts
````typescript
  1: export interface AnalyticsEvent {
  2:   event: string;
  3:   properties?: {
  4:     category?: string;
  5:     action?: string;
  6:     label?: string;
  7:     value?: number;
  8:     [key: string]: any;
  9:   };
 10:   timestamp: number;
 11:   sessionId: string;
 12:   userId: string; // anonymous UUID
 13: }
 14: 
 15: export interface AnalyticsSettings {
 16:   enabled: boolean;
 17:   hasConsented: boolean;
 18:   consentDate?: string;
 19:   userId?: string;
 20:   sessionId?: string;
 21: }
 22: 
 23: export interface AnalyticsConfig {
 24:   apiKey: string;
 25:   apiHost?: string;
 26:   persistence?: 'localStorage' | 'memory';
 27:   autocapture?: boolean;
 28:   disable_session_recording?: boolean;
 29:   opt_out_capturing_by_default?: boolean;
 30:   loaded?: (posthog: any) => void;
 31: }
 32: 
 33: export type EventName = 
 34:   | 'session_created'
 35:   | 'session_completed'
 36:   | 'session_resumed'
 37:   | 'feature_used'
 38:   | 'error_occurred'
 39:   | 'model_selected'
 40:   | 'tab_created'
 41:   | 'tab_closed'
 42:   | 'file_opened'
 43:   | 'file_edited'
 44:   | 'file_saved'
 45:   | 'agent_executed'
 46:   | 'mcp_server_connected'
 47:   | 'mcp_server_disconnected'
 48:   | 'slash_command_used'
 49:   | 'settings_changed'
 50:   | 'app_started'
 51:   | 'app_closed'
 52:   // New session events
 53:   | 'prompt_submitted'
 54:   | 'session_stopped'
 55:   | 'checkpoint_created'
 56:   | 'checkpoint_restored'
 57:   | 'tool_executed'
 58:   // New agent events
 59:   | 'agent_started'
 60:   | 'agent_progress'
 61:   | 'agent_error'
 62:   // New MCP events
 63:   | 'mcp_server_added'
 64:   | 'mcp_server_removed'
 65:   | 'mcp_tool_invoked'
 66:   | 'mcp_connection_error'
 67:   // New slash command events
 68:   | 'slash_command_selected'
 69:   | 'slash_command_executed'
 70:   | 'slash_command_created'
 71:   // New error and performance events
 72:   | 'api_error'
 73:   | 'ui_error'
 74:   | 'performance_bottleneck'
 75:   | 'memory_warning'
 76:   // User journey events
 77:   | 'journey_milestone'
 78:   | 'user_retention'
 79:   // AI interaction events
 80:   | 'ai_interaction'
 81:   | 'prompt_pattern'
 82:   // Quality events
 83:   | 'output_regenerated'
 84:   | 'conversation_abandoned'
 85:   | 'suggestion_accepted'
 86:   | 'suggestion_rejected'
 87:   // Workflow events
 88:   | 'workflow_started'
 89:   | 'workflow_completed'
 90:   | 'workflow_abandoned'
 91:   // Feature adoption events
 92:   | 'feature_discovered'
 93:   | 'feature_adopted'
 94:   | 'feature_combination'
 95:   // Resource usage events
 96:   | 'resource_usage_high'
 97:   | 'resource_usage_sampled'
 98:   // Network performance events
 99:   | 'network_performance'
100:   | 'network_failure'
101:   // Engagement events
102:   | 'session_engagement';
103: 
104: export interface FeatureUsageProperties {
105:   feature: string;
106:   subfeature?: string;
107:   metadata?: Record<string, any>;
108: }
109: 
110: export interface ErrorProperties {
111:   error_type: string;
112:   error_code?: string;
113:   error_message?: string;
114:   context?: string;
115: }
116: 
117: export interface SessionProperties {
118:   model?: string;
119:   source?: string;
120:   resumed?: boolean;
121:   checkpoint_id?: string;
122: }
123: 
124: export interface ModelProperties {
125:   previous_model?: string;
126:   new_model: string;
127:   source?: string;
128: }
129: 
130: export interface AgentProperties {
131:   agent_type: string;
132:   agent_name?: string;
133:   success: boolean;
134:   duration_ms?: number;
135: }
136: 
137: export interface MCPProperties {
138:   server_name: string;
139:   server_type?: string;
140:   success: boolean;
141: }
142: 
143: export interface SlashCommandProperties {
144:   command: string;
145:   success: boolean;
146: }
147: 
148: export interface PerformanceMetrics {
149:   startup_time_ms?: number;
150:   memory_usage_mb?: number;
151:   api_response_time_ms?: number;
152:   render_time_ms?: number;
153: }
154: 
155: // Claude Code Session event properties
156: export interface PromptSubmittedProperties {
157:   prompt_length: number;
158:   model: string;
159:   has_attachments: boolean;
160:   source: 'keyboard' | 'button';
161:   word_count: number;
162: }
163: 
164: export interface SessionStoppedProperties {
165:   duration_ms: number;
166:   messages_count: number;
167:   reason: 'user_stopped' | 'error' | 'completed';
168: }
169: 
170: // Enhanced session stopped properties for detailed analytics
171: export interface EnhancedSessionStoppedProperties extends SessionStoppedProperties {
172:   // Timing metrics
173:   time_to_first_message_ms?: number;
174:   average_response_time_ms?: number;
175:   idle_time_ms?: number;
176:   
177:   // Interaction metrics
178:   prompts_sent: number;
179:   tools_executed: number;
180:   tools_failed: number;
181:   files_created: number;
182:   files_modified: number;
183:   files_deleted: number;
184:   
185:   // Content metrics
186:   total_tokens_used?: number;
187:   code_blocks_generated?: number;
188:   errors_encountered: number;
189:   
190:   // Session context
191:   model: string;
192:   has_checkpoints: boolean;
193:   checkpoint_count?: number;
194:   was_resumed: boolean;
195:   
196:   // Agent context (if applicable)
197:   agent_type?: string;
198:   agent_name?: string;
199:   agent_success?: boolean;
200:   
201:   // Stop context
202:   stop_source: 'user_button' | 'keyboard_shortcut' | 'timeout' | 'error' | 'completed';
203:   final_state: 'success' | 'partial' | 'failed' | 'cancelled';
204:   has_pending_prompts: boolean;
205:   pending_prompts_count?: number;
206: }
207: 
208: export interface CheckpointCreatedProperties {
209:   checkpoint_number: number;
210:   session_duration_at_checkpoint: number;
211: }
212: 
213: export interface CheckpointRestoredProperties {
214:   checkpoint_id: string;
215:   time_since_checkpoint_ms: number;
216: }
217: 
218: export interface ToolExecutedProperties {
219:   tool_name: string;
220:   execution_time_ms: number;
221:   success: boolean;
222:   error_message?: string;
223: }
224: 
225: // Enhanced Agent properties
226: export interface AgentStartedProperties {
227:   agent_type: string;
228:   agent_name?: string;
229:   has_custom_prompt: boolean;
230: }
231: 
232: export interface AgentProgressProperties {
233:   step_number: number;
234:   step_type: string;
235:   duration_ms: number;
236:   agent_type: string;
237: }
238: 
239: export interface AgentErrorProperties {
240:   error_type: string;
241:   error_stage: string;
242:   retry_count: number;
243:   agent_type: string;
244: }
245: 
246: // MCP properties
247: export interface MCPServerAddedProperties {
248:   server_type: string;
249:   configuration_method: 'manual' | 'preset' | 'import';
250: }
251: 
252: export interface MCPServerRemovedProperties {
253:   server_name: string;
254:   was_connected: boolean;
255: }
256: 
257: export interface MCPToolInvokedProperties {
258:   server_name: string;
259:   tool_name: string;
260:   invocation_source: 'user' | 'agent' | 'suggestion';
261: }
262: 
263: export interface MCPConnectionErrorProperties {
264:   server_name: string;
265:   error_type: string;
266:   retry_attempt: number;
267: }
268: 
269: // Slash Command properties
270: export interface SlashCommandSelectedProperties {
271:   command_name: string;
272:   selection_method: 'click' | 'keyboard' | 'autocomplete';
273: }
274: 
275: export interface SlashCommandExecutedProperties {
276:   command_name: string;
277:   parameters_count: number;
278:   execution_time_ms: number;
279: }
280: 
281: export interface SlashCommandCreatedProperties {
282:   command_type: 'custom' | 'imported';
283:   has_parameters: boolean;
284: }
285: 
286: // Error and Performance properties
287: export interface APIErrorProperties {
288:   endpoint: string;
289:   error_code: string | number;
290:   retry_count: number;
291:   response_time_ms: number;
292: }
293: 
294: export interface UIErrorProperties {
295:   component_name: string;
296:   error_type: string;
297:   user_action?: string;
298: }
299: 
300: export interface PerformanceBottleneckProperties {
301:   operation_type: string;
302:   duration_ms: number;
303:   data_size?: number;
304:   threshold_exceeded: boolean;
305: }
306: 
307: export interface MemoryWarningProperties {
308:   component: string;
309:   memory_mb: number;
310:   threshold_exceeded: boolean;
311:   gc_count?: number;
312: }
313: 
314: // User Journey properties
315: export interface UserJourneyProperties {
316:   journey_stage: 'onboarding' | 'first_chat' | 'first_agent' | 'power_user';
317:   milestone_reached?: string;
318:   time_to_milestone_ms?: number;
319: }
320: 
321: // Enhanced prompt properties
322: export interface EnhancedPromptSubmittedProperties extends PromptSubmittedProperties {
323:   conversation_depth: number;
324:   prompt_complexity: 'simple' | 'moderate' | 'complex';
325:   contains_code: boolean;
326:   language_detected?: string;
327:   session_age_ms: number;
328: }
329: 
330: // Enhanced tool properties
331: export interface EnhancedToolExecutedProperties extends ToolExecutedProperties {
332:   tool_category: 'file' | 'search' | 'system' | 'custom';
333:   consecutive_failures?: number;
334:   retry_attempted: boolean;
335:   input_size_bytes?: number;
336:   output_size_bytes?: number;
337: }
338: 
339: // Enhanced error properties
340: export interface EnhancedErrorProperties extends ErrorProperties {
341:   user_action_before_error?: string;
342:   recovery_attempted: boolean;
343:   recovery_successful?: boolean;
344:   error_frequency: number;
345:   stack_trace_hash?: string;
346: }
347: 
348: // Session engagement properties
349: export interface SessionEngagementProperties {
350:   session_duration_ms: number;
351:   messages_sent: number;
352:   tools_used: string[];
353:   files_modified: number;
354:   engagement_score: number;
355: }
356: 
357: // Feature discovery properties
358: export interface FeatureDiscoveryProperties {
359:   feature_name: string;
360:   discovery_method: 'organic' | 'prompted' | 'documentation';
361:   time_to_first_use_ms: number;
362:   initial_success: boolean;
363: }
364: 
365: // Output quality properties
366: export interface OutputQualityProperties {
367:   regeneration_count: number;
368:   modification_requested: boolean;
369:   final_acceptance: boolean;
370:   time_to_acceptance_ms: number;
371: }
372: 
373: // Resource usage properties
374: export interface ResourceUsageProperties {
375:   cpu_usage_percent?: number;
376:   memory_usage_mb: number;
377:   disk_io_mb?: number;
378:   network_requests_count: number;
379:   cache_hit_rate?: number;
380:   active_connections: number;
381: }
382: 
383: // Feature adoption properties
384: export interface FeatureAdoptionProperties {
385:   feature: string;
386:   adoption_stage: 'discovered' | 'tried' | 'adopted' | 'abandoned';
387:   usage_count: number;
388:   days_since_first_use: number;
389:   usage_trend: 'increasing' | 'stable' | 'decreasing';
390: }
391: 
392: // Feature combination properties
393: export interface FeatureCombinationProperties {
394:   primary_feature: string;
395:   secondary_feature: string;
396:   combination_frequency: number;
397:   workflow_efficiency_gain?: number;
398: }
399: 
400: // AI interaction properties
401: export interface AIInteractionProperties {
402:   model: string;
403:   request_tokens: number;
404:   response_tokens: number;
405:   response_quality_score?: number;
406:   context_switches: number;
407:   clarification_requests: number;
408: }
409: 
410: // Prompt pattern properties
411: export interface PromptPatternProperties {
412:   prompt_category: string;
413:   prompt_effectiveness: 'high' | 'medium' | 'low';
414:   required_iterations: number;
415:   final_satisfaction: boolean;
416: }
417: 
418: // Workflow properties
419: export interface WorkflowProperties {
420:   workflow_type: string;
421:   steps_completed: number;
422:   total_steps: number;
423:   duration_ms: number;
424:   interruptions: number;
425:   completion_rate: number;
426:   tools_used: string[];
427: }
428: 
429: // Network performance properties
430: export interface NetworkPerformanceProperties {
431:   endpoint_type: 'mcp' | 'api' | 'webhook';
432:   latency_ms: number;
433:   payload_size_bytes: number;
434:   connection_quality: 'excellent' | 'good' | 'poor';
435:   retry_count: number;
436:   circuit_breaker_triggered: boolean;
437: }
438: 
439: // Suggestion properties
440: export interface SuggestionProperties {
441:   suggestion_type: string;
442:   suggestion_source: string;
443:   accepted: boolean;
444:   response_time_ms: number;
445: }
````

## File: src/lib/api-tracker.ts
````typescript
  1: import { api as originalApi } from './api';
  2: import { analytics, eventBuilders } from './analytics';
  3: 
  4: // Performance thresholds (in milliseconds)
  5: const PERFORMANCE_THRESHOLDS = {
  6:   fast: 100,
  7:   normal: 500,
  8:   slow: 2000,
  9:   bottleneck: 5000,
 10: };
 11: 
 12: // Memory threshold (in MB)
 13: const MEMORY_WARNING_THRESHOLD = 100;
 14: 
 15: /**
 16:  * Wraps an API method with error and performance tracking
 17:  */
 18: function wrapApiMethod<T extends (...args: any[]) => Promise<any>>(
 19:   methodName: string,
 20:   method: T
 21: ): T {
 22:   return (async (...args: any[]) => {
 23:     const startTime = performance.now();
 24:     const startMemory = ('memory' in performance ? (performance as any).memory?.usedJSHeapSize : 0) || 0;
 25:     let retryCount = 0;
 26:     
 27:     const trackPerformance = (success: boolean, error?: any) => {
 28:       const duration = performance.now() - startTime;
 29:       const memoryUsed = ((('memory' in performance ? (performance as any).memory?.usedJSHeapSize : 0) || 0) - startMemory) / (1024 * 1024); // Convert to MB
 30:       
 31:       // Track API errors
 32:       if (!success && error) {
 33:         const event = eventBuilders.apiError({
 34:           endpoint: methodName,
 35:           error_code: error.code || error.status || 'unknown',
 36:           retry_count: retryCount,
 37:           response_time_ms: duration,
 38:         });
 39:         analytics.track(event.event, event.properties);
 40:       }
 41:       
 42:       // Track performance bottlenecks
 43:       if (duration > PERFORMANCE_THRESHOLDS.bottleneck) {
 44:         const event = eventBuilders.performanceBottleneck({
 45:           operation_type: `api.${methodName}`,
 46:           duration_ms: duration,
 47:           data_size: undefined, // Could be enhanced to track payload size
 48:           threshold_exceeded: true,
 49:         });
 50:         analytics.track(event.event, event.properties);
 51:       }
 52:       
 53:       // Track network performance
 54:       const connectionQuality = 
 55:         duration < PERFORMANCE_THRESHOLDS.fast ? 'excellent' :
 56:         duration < PERFORMANCE_THRESHOLDS.normal ? 'good' : 'poor';
 57:       
 58:       if (success) {
 59:         const networkEvent = eventBuilders.networkPerformance({
 60:           endpoint_type: 'api',
 61:           latency_ms: duration,
 62:           payload_size_bytes: 0, // Could be enhanced with actual payload size
 63:           connection_quality: connectionQuality,
 64:           retry_count: retryCount,
 65:           circuit_breaker_triggered: false,
 66:         });
 67:         analytics.track(networkEvent.event, networkEvent.properties);
 68:       }
 69:       
 70:       // Track memory warnings
 71:       if (memoryUsed > MEMORY_WARNING_THRESHOLD) {
 72:         const event = eventBuilders.memoryWarning({
 73:           component: `api.${methodName}`,
 74:           memory_mb: memoryUsed,
 75:           threshold_exceeded: true,
 76:           gc_count: undefined, // Could be enhanced with GC tracking
 77:         });
 78:         analytics.track(event.event, event.properties);
 79:       }
 80:     };
 81:     
 82:     try {
 83:       const result = await method(...args);
 84:       trackPerformance(true);
 85:       return result;
 86:     } catch (error) {
 87:       trackPerformance(false, error);
 88:       throw error;
 89:     }
 90:   }) as T;
 91: }
 92: 
 93: /**
 94:  * Creates a tracked version of the API object
 95:  */
 96: function createTrackedApi() {
 97:   const trackedApi: any = {};
 98:   
 99:   // Wrap each method in the original API
100:   for (const [key, value] of Object.entries(originalApi)) {
101:     if (typeof value === 'function') {
102:       trackedApi[key] = wrapApiMethod(key, value);
103:     } else {
104:       trackedApi[key] = value;
105:     }
106:   }
107:   
108:   return trackedApi as typeof originalApi;
109: }
110: 
111: // Export the tracked API
112: export const api = createTrackedApi();
113: 
114: // Re-export types from the original API module
115: export * from './api';
````

## File: src/lib/api.ts
````typescript
   1: import { invoke } from "@tauri-apps/api/core";
   2: import type { HooksConfiguration } from '@/types/hooks';
   3: 
   4: /** Process type for tracking in ProcessRegistry */
   5: export type ProcessType = 
   6:   | { AgentRun: { agent_id: number; agent_name: string } }
   7:   | { ClaudeSession: { session_id: string } };
   8: 
   9: /** Information about a running process */
  10: export interface ProcessInfo {
  11:   run_id: number;
  12:   process_type: ProcessType;
  13:   pid: number;
  14:   started_at: string;
  15:   project_path: string;
  16:   task: string;
  17:   model: string;
  18: }
  19: 
  20: /**
  21:  * Represents a project in the ~/.claude/projects directory
  22:  */
  23: export interface Project {
  24:   /** The project ID (derived from the directory name) */
  25:   id: string;
  26:   /** The original project path (decoded from the directory name) */
  27:   path: string;
  28:   /** List of session IDs (JSONL file names without extension) */
  29:   sessions: string[];
  30:   /** Unix timestamp when the project directory was created */
  31:   created_at: number;
  32: }
  33: 
  34: /**
  35:  * Represents a session with its metadata
  36:  */
  37: export interface Session {
  38:   /** The session ID (UUID) */
  39:   id: string;
  40:   /** The project ID this session belongs to */
  41:   project_id: string;
  42:   /** The project path */
  43:   project_path: string;
  44:   /** Optional todo data associated with this session */
  45:   todo_data?: any;
  46:   /** Unix timestamp when the session file was created */
  47:   created_at: number;
  48:   /** First user message content (if available) */
  49:   first_message?: string;
  50:   /** Timestamp of the first user message (if available) */
  51:   message_timestamp?: string;
  52: }
  53: 
  54: /**
  55:  * Represents the settings from ~/.claude/settings.json
  56:  */
  57: export interface ClaudeSettings {
  58:   [key: string]: any;
  59: }
  60: 
  61: /**
  62:  * Represents the Claude Code version status
  63:  */
  64: export interface ClaudeVersionStatus {
  65:   /** Whether Claude Code is installed and working */
  66:   is_installed: boolean;
  67:   /** The version string if available */
  68:   version?: string;
  69:   /** The full output from the command */
  70:   output: string;
  71: }
  72: 
  73: /**
  74:  * Represents a CLAUDE.md file found in the project
  75:  */
  76: export interface ClaudeMdFile {
  77:   /** Relative path from the project root */
  78:   relative_path: string;
  79:   /** Absolute path to the file */
  80:   absolute_path: string;
  81:   /** File size in bytes */
  82:   size: number;
  83:   /** Last modified timestamp */
  84:   modified: number;
  85: }
  86: 
  87: /**
  88:  * Represents a file or directory entry
  89:  */
  90: export interface FileEntry {
  91:   name: string;
  92:   path: string;
  93:   is_directory: boolean;
  94:   size: number;
  95:   extension?: string;
  96: }
  97: 
  98: /**
  99:  * Represents a Claude installation found on the system
 100:  */
 101: export interface ClaudeInstallation {
 102:   /** Full path to the Claude binary */
 103:   path: string;
 104:   /** Version string if available */
 105:   version?: string;
 106:   /** Source of discovery (e.g., "nvm", "system", "homebrew", "which") */
 107:   source: string;
 108:   /** Type of installation */
 109:   installation_type: "System" | "Custom";
 110: }
 111: 
 112: // Agent API types
 113: export interface Agent {
 114:   id?: number;
 115:   name: string;
 116:   icon: string;
 117:   system_prompt: string;
 118:   default_task?: string;
 119:   model: string;
 120:   hooks?: string; // JSON string of HooksConfiguration
 121:   created_at: string;
 122:   updated_at: string;
 123: }
 124: 
 125: export interface AgentExport {
 126:   version: number;
 127:   exported_at: string;
 128:   agent: {
 129:     name: string;
 130:     icon: string;
 131:     system_prompt: string;
 132:     default_task?: string;
 133:     model: string;
 134:     hooks?: string;
 135:   };
 136: }
 137: 
 138: export interface GitHubAgentFile {
 139:   name: string;
 140:   path: string;
 141:   download_url: string;
 142:   size: number;
 143:   sha: string;
 144: }
 145: 
 146: export interface AgentRun {
 147:   id?: number;
 148:   agent_id: number;
 149:   agent_name: string;
 150:   agent_icon: string;
 151:   task: string;
 152:   model: string;
 153:   project_path: string;
 154:   session_id: string;
 155:   status: string; // 'pending', 'running', 'completed', 'failed', 'cancelled'
 156:   pid?: number;
 157:   process_started_at?: string;
 158:   created_at: string;
 159:   completed_at?: string;
 160: }
 161: 
 162: export interface AgentRunMetrics {
 163:   duration_ms?: number;
 164:   total_tokens?: number;
 165:   cost_usd?: number;
 166:   message_count?: number;
 167: }
 168: 
 169: export interface AgentRunWithMetrics {
 170:   id?: number;
 171:   agent_id: number;
 172:   agent_name: string;
 173:   agent_icon: string;
 174:   task: string;
 175:   model: string;
 176:   project_path: string;
 177:   session_id: string;
 178:   status: string; // 'pending', 'running', 'completed', 'failed', 'cancelled'
 179:   pid?: number;
 180:   process_started_at?: string;
 181:   created_at: string;
 182:   completed_at?: string;
 183:   metrics?: AgentRunMetrics;
 184:   output?: string; // Real-time JSONL content
 185: }
 186: 
 187: // Usage Dashboard types
 188: export interface UsageEntry {
 189:   project: string;
 190:   timestamp: string;
 191:   model: string;
 192:   input_tokens: number;
 193:   output_tokens: number;
 194:   cache_write_tokens: number;
 195:   cache_read_tokens: number;
 196:   cost: number;
 197: }
 198: 
 199: export interface ModelUsage {
 200:   model: string;
 201:   total_cost: number;
 202:   total_tokens: number;
 203:   input_tokens: number;
 204:   output_tokens: number;
 205:   cache_creation_tokens: number;
 206:   cache_read_tokens: number;
 207:   session_count: number;
 208: }
 209: 
 210: export interface DailyUsage {
 211:   date: string;
 212:   total_cost: number;
 213:   total_tokens: number;
 214:   models_used: string[];
 215: }
 216: 
 217: export interface ProjectUsage {
 218:   project_path: string;
 219:   project_name: string;
 220:   total_cost: number;
 221:   total_tokens: number;
 222:   session_count: number;
 223:   last_used: string;
 224: }
 225: 
 226: export interface UsageStats {
 227:   total_cost: number;
 228:   total_tokens: number;
 229:   total_input_tokens: number;
 230:   total_output_tokens: number;
 231:   total_cache_creation_tokens: number;
 232:   total_cache_read_tokens: number;
 233:   total_sessions: number;
 234:   by_model: ModelUsage[];
 235:   by_date: DailyUsage[];
 236:   by_project: ProjectUsage[];
 237: }
 238: 
 239: /**
 240:  * Represents a checkpoint in the session timeline
 241:  */
 242: export interface Checkpoint {
 243:   id: string;
 244:   sessionId: string;
 245:   projectId: string;
 246:   messageIndex: number;
 247:   timestamp: string;
 248:   description?: string;
 249:   parentCheckpointId?: string;
 250:   metadata: CheckpointMetadata;
 251: }
 252: 
 253: /**
 254:  * Metadata associated with a checkpoint
 255:  */
 256: export interface CheckpointMetadata {
 257:   totalTokens: number;
 258:   modelUsed: string;
 259:   userPrompt: string;
 260:   fileChanges: number;
 261:   snapshotSize: number;
 262: }
 263: 
 264: /**
 265:  * Represents a file snapshot at a checkpoint
 266:  */
 267: export interface FileSnapshot {
 268:   checkpointId: string;
 269:   filePath: string;
 270:   content: string;
 271:   hash: string;
 272:   isDeleted: boolean;
 273:   permissions?: number;
 274:   size: number;
 275: }
 276: 
 277: /**
 278:  * Represents a node in the timeline tree
 279:  */
 280: export interface TimelineNode {
 281:   checkpoint: Checkpoint;
 282:   children: TimelineNode[];
 283:   fileSnapshotIds: string[];
 284: }
 285: 
 286: /**
 287:  * The complete timeline for a session
 288:  */
 289: export interface SessionTimeline {
 290:   sessionId: string;
 291:   rootNode?: TimelineNode;
 292:   currentCheckpointId?: string;
 293:   autoCheckpointEnabled: boolean;
 294:   checkpointStrategy: CheckpointStrategy;
 295:   totalCheckpoints: number;
 296: }
 297: 
 298: /**
 299:  * Strategy for automatic checkpoint creation
 300:  */
 301: export type CheckpointStrategy = 'manual' | 'per_prompt' | 'per_tool_use' | 'smart';
 302: 
 303: /**
 304:  * Result of a checkpoint operation
 305:  */
 306: export interface CheckpointResult {
 307:   checkpoint: Checkpoint;
 308:   filesProcessed: number;
 309:   warnings: string[];
 310: }
 311: 
 312: /**
 313:  * Diff between two checkpoints
 314:  */
 315: export interface CheckpointDiff {
 316:   fromCheckpointId: string;
 317:   toCheckpointId: string;
 318:   modifiedFiles: FileDiff[];
 319:   addedFiles: string[];
 320:   deletedFiles: string[];
 321:   tokenDelta: number;
 322: }
 323: 
 324: /**
 325:  * Diff for a single file
 326:  */
 327: export interface FileDiff {
 328:   path: string;
 329:   additions: number;
 330:   deletions: number;
 331:   diffContent?: string;
 332: }
 333: 
 334: /**
 335:  * Represents an MCP server configuration
 336:  */
 337: export interface MCPServer {
 338:   /** Server name/identifier */
 339:   name: string;
 340:   /** Transport type: "stdio" or "sse" */
 341:   transport: string;
 342:   /** Command to execute (for stdio) */
 343:   command?: string;
 344:   /** Command arguments (for stdio) */
 345:   args: string[];
 346:   /** Environment variables */
 347:   env: Record<string, string>;
 348:   /** URL endpoint (for SSE) */
 349:   url?: string;
 350:   /** Configuration scope: "local", "project", or "user" */
 351:   scope: string;
 352:   /** Whether the server is currently active */
 353:   is_active: boolean;
 354:   /** Server status */
 355:   status: ServerStatus;
 356: }
 357: 
 358: /**
 359:  * Server status information
 360:  */
 361: export interface ServerStatus {
 362:   /** Whether the server is running */
 363:   running: boolean;
 364:   /** Last error message if any */
 365:   error?: string;
 366:   /** Last checked timestamp */
 367:   last_checked?: number;
 368: }
 369: 
 370: /**
 371:  * MCP configuration for project scope (.mcp.json)
 372:  */
 373: export interface MCPProjectConfig {
 374:   mcpServers: Record<string, MCPServerConfig>;
 375: }
 376: 
 377: /**
 378:  * Individual server configuration in .mcp.json
 379:  */
 380: export interface MCPServerConfig {
 381:   command: string;
 382:   args: string[];
 383:   env: Record<string, string>;
 384: }
 385: 
 386: /**
 387:  * Represents a custom slash command
 388:  */
 389: export interface SlashCommand {
 390:   /** Unique identifier for the command */
 391:   id: string;
 392:   /** Command name (without prefix) */
 393:   name: string;
 394:   /** Full command with prefix (e.g., "/project:optimize") */
 395:   full_command: string;
 396:   /** Command scope: "project" or "user" */
 397:   scope: string;
 398:   /** Optional namespace (e.g., "frontend" in "/project:frontend:component") */
 399:   namespace?: string;
 400:   /** Path to the markdown file */
 401:   file_path: string;
 402:   /** Command content (markdown body) */
 403:   content: string;
 404:   /** Optional description from frontmatter */
 405:   description?: string;
 406:   /** Allowed tools from frontmatter */
 407:   allowed_tools: string[];
 408:   /** Whether the command has bash commands (!) */
 409:   has_bash_commands: boolean;
 410:   /** Whether the command has file references (@) */
 411:   has_file_references: boolean;
 412:   /** Whether the command uses $ARGUMENTS placeholder */
 413:   accepts_arguments: boolean;
 414: }
 415: 
 416: /**
 417:  * Result of adding a server
 418:  */
 419: export interface AddServerResult {
 420:   success: boolean;
 421:   message: string;
 422:   server_name?: string;
 423: }
 424: 
 425: /**
 426:  * Import result for multiple servers
 427:  */
 428: export interface ImportResult {
 429:   imported_count: number;
 430:   failed_count: number;
 431:   servers: ImportServerResult[];
 432: }
 433: 
 434: /**
 435:  * Result for individual server import
 436:  */
 437: export interface ImportServerResult {
 438:   name: string;
 439:   success: boolean;
 440:   error?: string;
 441: }
 442: 
 443: /**
 444:  * API client for interacting with the Rust backend
 445:  */
 446: export const api = {
 447:   /**
 448:    * Lists all projects in the ~/.claude/projects directory
 449:    * @returns Promise resolving to an array of projects
 450:    */
 451:   async listProjects(): Promise<Project[]> {
 452:     try {
 453:       return await invoke<Project[]>("list_projects");
 454:     } catch (error) {
 455:       console.error("Failed to list projects:", error);
 456:       throw error;
 457:     }
 458:   },
 459: 
 460:   /**
 461:    * Retrieves sessions for a specific project
 462:    * @param projectId - The ID of the project to retrieve sessions for
 463:    * @returns Promise resolving to an array of sessions
 464:    */
 465:   async getProjectSessions(projectId: string): Promise<Session[]> {
 466:     try {
 467:       return await invoke<Session[]>('get_project_sessions', { projectId });
 468:     } catch (error) {
 469:       console.error("Failed to get project sessions:", error);
 470:       throw error;
 471:     }
 472:   },
 473: 
 474:   /**
 475:    * Fetch list of agents from GitHub repository
 476:    * @returns Promise resolving to list of available agents on GitHub
 477:    */
 478:   async fetchGitHubAgents(): Promise<GitHubAgentFile[]> {
 479:     try {
 480:       return await invoke<GitHubAgentFile[]>('fetch_github_agents');
 481:     } catch (error) {
 482:       console.error("Failed to fetch GitHub agents:", error);
 483:       throw error;
 484:     }
 485:   },
 486: 
 487:   /**
 488:    * Fetch and preview a specific agent from GitHub
 489:    * @param downloadUrl - The download URL for the agent file
 490:    * @returns Promise resolving to the agent export data
 491:    */
 492:   async fetchGitHubAgentContent(downloadUrl: string): Promise<AgentExport> {
 493:     try {
 494:       return await invoke<AgentExport>('fetch_github_agent_content', { downloadUrl });
 495:     } catch (error) {
 496:       console.error("Failed to fetch GitHub agent content:", error);
 497:       throw error;
 498:     }
 499:   },
 500: 
 501:   /**
 502:    * Import an agent directly from GitHub
 503:    * @param downloadUrl - The download URL for the agent file
 504:    * @returns Promise resolving to the imported agent
 505:    */
 506:   async importAgentFromGitHub(downloadUrl: string): Promise<Agent> {
 507:     try {
 508:       return await invoke<Agent>('import_agent_from_github', { downloadUrl });
 509:     } catch (error) {
 510:       console.error("Failed to import agent from GitHub:", error);
 511:       throw error;
 512:     }
 513:   },
 514: 
 515:   /**
 516:    * Reads the Claude settings file
 517:    * @returns Promise resolving to the settings object
 518:    */
 519:   async getClaudeSettings(): Promise<ClaudeSettings> {
 520:     try {
 521:       const result = await invoke<{ data: ClaudeSettings }>("get_claude_settings");
 522:       console.log("Raw result from get_claude_settings:", result);
 523:       
 524:       // The Rust backend returns ClaudeSettings { data: ... }
 525:       // We need to extract the data field
 526:       if (result && typeof result === 'object' && 'data' in result) {
 527:         return result.data;
 528:       }
 529:       
 530:       // If the result is already the settings object, return it
 531:       return result as ClaudeSettings;
 532:     } catch (error) {
 533:       console.error("Failed to get Claude settings:", error);
 534:       throw error;
 535:     }
 536:   },
 537: 
 538:   /**
 539:    * Opens a new Claude Code session
 540:    * @param path - Optional path to open the session in
 541:    * @returns Promise resolving when the session is opened
 542:    */
 543:   async openNewSession(path?: string): Promise<string> {
 544:     try {
 545:       return await invoke<string>("open_new_session", { path });
 546:     } catch (error) {
 547:       console.error("Failed to open new session:", error);
 548:       throw error;
 549:     }
 550:   },
 551: 
 552:   /**
 553:    * Reads the CLAUDE.md system prompt file
 554:    * @returns Promise resolving to the system prompt content
 555:    */
 556:   async getSystemPrompt(): Promise<string> {
 557:     try {
 558:       return await invoke<string>("get_system_prompt");
 559:     } catch (error) {
 560:       console.error("Failed to get system prompt:", error);
 561:       throw error;
 562:     }
 563:   },
 564: 
 565:   /**
 566:    * Checks if Claude Code is installed and gets its version
 567:    * @returns Promise resolving to the version status
 568:    */
 569:   async checkClaudeVersion(): Promise<ClaudeVersionStatus> {
 570:     try {
 571:       return await invoke<ClaudeVersionStatus>("check_claude_version");
 572:     } catch (error) {
 573:       console.error("Failed to check Claude version:", error);
 574:       throw error;
 575:     }
 576:   },
 577: 
 578:   /**
 579:    * Saves the CLAUDE.md system prompt file
 580:    * @param content - The new content for the system prompt
 581:    * @returns Promise resolving when the file is saved
 582:    */
 583:   async saveSystemPrompt(content: string): Promise<string> {
 584:     try {
 585:       return await invoke<string>("save_system_prompt", { content });
 586:     } catch (error) {
 587:       console.error("Failed to save system prompt:", error);
 588:       throw error;
 589:     }
 590:   },
 591: 
 592:   /**
 593:    * Saves the Claude settings file
 594:    * @param settings - The settings object to save
 595:    * @returns Promise resolving when the settings are saved
 596:    */
 597:   async saveClaudeSettings(settings: ClaudeSettings): Promise<string> {
 598:     try {
 599:       return await invoke<string>("save_claude_settings", { settings });
 600:     } catch (error) {
 601:       console.error("Failed to save Claude settings:", error);
 602:       throw error;
 603:     }
 604:   },
 605: 
 606:   /**
 607:    * Finds all CLAUDE.md files in a project directory
 608:    * @param projectPath - The absolute path to the project
 609:    * @returns Promise resolving to an array of CLAUDE.md files
 610:    */
 611:   async findClaudeMdFiles(projectPath: string): Promise<ClaudeMdFile[]> {
 612:     try {
 613:       return await invoke<ClaudeMdFile[]>("find_claude_md_files", { projectPath });
 614:     } catch (error) {
 615:       console.error("Failed to find CLAUDE.md files:", error);
 616:       throw error;
 617:     }
 618:   },
 619: 
 620:   /**
 621:    * Reads a specific CLAUDE.md file
 622:    * @param filePath - The absolute path to the file
 623:    * @returns Promise resolving to the file content
 624:    */
 625:   async readClaudeMdFile(filePath: string): Promise<string> {
 626:     try {
 627:       return await invoke<string>("read_claude_md_file", { filePath });
 628:     } catch (error) {
 629:       console.error("Failed to read CLAUDE.md file:", error);
 630:       throw error;
 631:     }
 632:   },
 633: 
 634:   /**
 635:    * Saves a specific CLAUDE.md file
 636:    * @param filePath - The absolute path to the file
 637:    * @param content - The new content for the file
 638:    * @returns Promise resolving when the file is saved
 639:    */
 640:   async saveClaudeMdFile(filePath: string, content: string): Promise<string> {
 641:     try {
 642:       return await invoke<string>("save_claude_md_file", { filePath, content });
 643:     } catch (error) {
 644:       console.error("Failed to save CLAUDE.md file:", error);
 645:       throw error;
 646:     }
 647:   },
 648: 
 649:   // Agent API methods
 650:   
 651:   /**
 652:    * Lists all CC agents
 653:    * @returns Promise resolving to an array of agents
 654:    */
 655:   async listAgents(): Promise<Agent[]> {
 656:     try {
 657:       return await invoke<Agent[]>('list_agents');
 658:     } catch (error) {
 659:       console.error("Failed to list agents:", error);
 660:       throw error;
 661:     }
 662:   },
 663: 
 664:   /**
 665:    * Creates a new agent
 666:    * @param name - The agent name
 667:    * @param icon - The icon identifier
 668:    * @param system_prompt - The system prompt for the agent
 669:    * @param default_task - Optional default task
 670:    * @param model - Optional model (defaults to 'sonnet')
 671:    * @param hooks - Optional hooks configuration as JSON string
 672:    * @returns Promise resolving to the created agent
 673:    */
 674:   async createAgent(
 675:     name: string, 
 676:     icon: string, 
 677:     system_prompt: string, 
 678:     default_task?: string, 
 679:     model?: string,
 680:     hooks?: string
 681:   ): Promise<Agent> {
 682:     try {
 683:       return await invoke<Agent>('create_agent', { 
 684:         name, 
 685:         icon, 
 686:         systemPrompt: system_prompt,
 687:         defaultTask: default_task,
 688:         model,
 689:         hooks
 690:       });
 691:     } catch (error) {
 692:       console.error("Failed to create agent:", error);
 693:       throw error;
 694:     }
 695:   },
 696: 
 697:   /**
 698:    * Updates an existing agent
 699:    * @param id - The agent ID
 700:    * @param name - The updated name
 701:    * @param icon - The updated icon
 702:    * @param system_prompt - The updated system prompt
 703:    * @param default_task - Optional default task
 704:    * @param model - Optional model
 705:    * @param hooks - Optional hooks configuration as JSON string
 706:    * @returns Promise resolving to the updated agent
 707:    */
 708:   async updateAgent(
 709:     id: number, 
 710:     name: string, 
 711:     icon: string, 
 712:     system_prompt: string, 
 713:     default_task?: string, 
 714:     model?: string,
 715:     hooks?: string
 716:   ): Promise<Agent> {
 717:     try {
 718:       return await invoke<Agent>('update_agent', { 
 719:         id, 
 720:         name, 
 721:         icon, 
 722:         systemPrompt: system_prompt,
 723:         defaultTask: default_task,
 724:         model,
 725:         hooks
 726:       });
 727:     } catch (error) {
 728:       console.error("Failed to update agent:", error);
 729:       throw error;
 730:     }
 731:   },
 732: 
 733:   /**
 734:    * Deletes an agent
 735:    * @param id - The agent ID to delete
 736:    * @returns Promise resolving when the agent is deleted
 737:    */
 738:   async deleteAgent(id: number): Promise<void> {
 739:     try {
 740:       return await invoke('delete_agent', { id });
 741:     } catch (error) {
 742:       console.error("Failed to delete agent:", error);
 743:       throw error;
 744:     }
 745:   },
 746: 
 747:   /**
 748:    * Gets a single agent by ID
 749:    * @param id - The agent ID
 750:    * @returns Promise resolving to the agent
 751:    */
 752:   async getAgent(id: number): Promise<Agent> {
 753:     try {
 754:       return await invoke<Agent>('get_agent', { id });
 755:     } catch (error) {
 756:       console.error("Failed to get agent:", error);
 757:       throw error;
 758:     }
 759:   },
 760: 
 761:   /**
 762:    * Exports a single agent to JSON format
 763:    * @param id - The agent ID to export
 764:    * @returns Promise resolving to the JSON string
 765:    */
 766:   async exportAgent(id: number): Promise<string> {
 767:     try {
 768:       return await invoke<string>('export_agent', { id });
 769:     } catch (error) {
 770:       console.error("Failed to export agent:", error);
 771:       throw error;
 772:     }
 773:   },
 774: 
 775:   /**
 776:    * Imports an agent from JSON data
 777:    * @param jsonData - The JSON string containing the agent export
 778:    * @returns Promise resolving to the imported agent
 779:    */
 780:   async importAgent(jsonData: string): Promise<Agent> {
 781:     try {
 782:       return await invoke<Agent>('import_agent', { jsonData });
 783:     } catch (error) {
 784:       console.error("Failed to import agent:", error);
 785:       throw error;
 786:     }
 787:   },
 788: 
 789:   /**
 790:    * Imports an agent from a file
 791:    * @param filePath - The path to the JSON file
 792:    * @returns Promise resolving to the imported agent
 793:    */
 794:   async importAgentFromFile(filePath: string): Promise<Agent> {
 795:     try {
 796:       return await invoke<Agent>('import_agent_from_file', { filePath });
 797:     } catch (error) {
 798:       console.error("Failed to import agent from file:", error);
 799:       throw error;
 800:     }
 801:   },
 802: 
 803:   /**
 804:    * Executes an agent
 805:    * @param agentId - The agent ID to execute
 806:    * @param projectPath - The project path to run the agent in
 807:    * @param task - The task description
 808:    * @param model - Optional model override
 809:    * @returns Promise resolving to the run ID when execution starts
 810:    */
 811:   async executeAgent(agentId: number, projectPath: string, task: string, model?: string): Promise<number> {
 812:     try {
 813:       return await invoke<number>('execute_agent', { agentId, projectPath, task, model });
 814:     } catch (error) {
 815:       console.error("Failed to execute agent:", error);
 816:       // Return a sentinel value to indicate error
 817:       throw new Error(`Failed to execute agent: ${error instanceof Error ? error.message : 'Unknown error'}`);
 818:     }
 819:   },
 820: 
 821:   /**
 822:    * Lists agent runs with metrics
 823:    * @param agentId - Optional agent ID to filter runs
 824:    * @returns Promise resolving to an array of agent runs with metrics
 825:    */
 826:   async listAgentRuns(agentId?: number): Promise<AgentRunWithMetrics[]> {
 827:     try {
 828:       return await invoke<AgentRunWithMetrics[]>('list_agent_runs', { agentId });
 829:     } catch (error) {
 830:       console.error("Failed to list agent runs:", error);
 831:       // Return empty array instead of throwing to prevent UI crashes
 832:       return [];
 833:     }
 834:   },
 835: 
 836:   /**
 837:    * Gets a single agent run by ID with metrics
 838:    * @param id - The run ID
 839:    * @returns Promise resolving to the agent run with metrics
 840:    */
 841:   async getAgentRun(id: number): Promise<AgentRunWithMetrics> {
 842:     try {
 843:       return await invoke<AgentRunWithMetrics>('get_agent_run', { id });
 844:     } catch (error) {
 845:       console.error("Failed to get agent run:", error);
 846:       throw new Error(`Failed to get agent run: ${error instanceof Error ? error.message : 'Unknown error'}`);
 847:     }
 848:   },
 849: 
 850:   /**
 851:    * Gets a single agent run by ID with real-time metrics from JSONL
 852:    * @param id - The run ID
 853:    * @returns Promise resolving to the agent run with metrics
 854:    */
 855:   async getAgentRunWithRealTimeMetrics(id: number): Promise<AgentRunWithMetrics> {
 856:     try {
 857:       return await invoke<AgentRunWithMetrics>('get_agent_run_with_real_time_metrics', { id });
 858:     } catch (error) {
 859:       console.error("Failed to get agent run with real-time metrics:", error);
 860:       throw new Error(`Failed to get agent run with real-time metrics: ${error instanceof Error ? error.message : 'Unknown error'}`);
 861:     }
 862:   },
 863: 
 864:   /**
 865:    * Lists all currently running agent sessions
 866:    * @returns Promise resolving to list of running agent sessions
 867:    */
 868:   async listRunningAgentSessions(): Promise<AgentRun[]> {
 869:     try {
 870:       return await invoke<AgentRun[]>('list_running_sessions');
 871:     } catch (error) {
 872:       console.error("Failed to list running agent sessions:", error);
 873:       throw new Error(`Failed to list running agent sessions: ${error instanceof Error ? error.message : 'Unknown error'}`);
 874:     }
 875:   },
 876: 
 877:   /**
 878:    * Kills a running agent session
 879:    * @param runId - The run ID to kill
 880:    * @returns Promise resolving to whether the session was successfully killed
 881:    */
 882:   async killAgentSession(runId: number): Promise<boolean> {
 883:     try {
 884:       return await invoke<boolean>('kill_agent_session', { runId });
 885:     } catch (error) {
 886:       console.error("Failed to kill agent session:", error);
 887:       throw new Error(`Failed to kill agent session: ${error instanceof Error ? error.message : 'Unknown error'}`);
 888:     }
 889:   },
 890: 
 891:   /**
 892:    * Gets the status of a specific agent session
 893:    * @param runId - The run ID to check
 894:    * @returns Promise resolving to the session status or null if not found
 895:    */
 896:   async getSessionStatus(runId: number): Promise<string | null> {
 897:     try {
 898:       return await invoke<string | null>('get_session_status', { runId });
 899:     } catch (error) {
 900:       console.error("Failed to get session status:", error);
 901:       throw new Error(`Failed to get session status: ${error instanceof Error ? error.message : 'Unknown error'}`);
 902:     }
 903:   },
 904: 
 905:   /**
 906:    * Cleanup finished processes and update their status
 907:    * @returns Promise resolving to list of run IDs that were cleaned up
 908:    */
 909:   async cleanupFinishedProcesses(): Promise<number[]> {
 910:     try {
 911:       return await invoke<number[]>('cleanup_finished_processes');
 912:     } catch (error) {
 913:       console.error("Failed to cleanup finished processes:", error);
 914:       throw new Error(`Failed to cleanup finished processes: ${error instanceof Error ? error.message : 'Unknown error'}`);
 915:     }
 916:   },
 917: 
 918:   /**
 919:    * Get real-time output for a running session (with live output fallback)
 920:    * @param runId - The run ID to get output for
 921:    * @returns Promise resolving to the current session output (JSONL format)
 922:    */
 923:   async getSessionOutput(runId: number): Promise<string> {
 924:     try {
 925:       return await invoke<string>('get_session_output', { runId });
 926:     } catch (error) {
 927:       console.error("Failed to get session output:", error);
 928:       throw new Error(`Failed to get session output: ${error instanceof Error ? error.message : 'Unknown error'}`);
 929:     }
 930:   },
 931: 
 932:   /**
 933:    * Get live output directly from process stdout buffer
 934:    * @param runId - The run ID to get live output for
 935:    * @returns Promise resolving to the current live output
 936:    */
 937:   async getLiveSessionOutput(runId: number): Promise<string> {
 938:     try {
 939:       return await invoke<string>('get_live_session_output', { runId });
 940:     } catch (error) {
 941:       console.error("Failed to get live session output:", error);
 942:       throw new Error(`Failed to get live session output: ${error instanceof Error ? error.message : 'Unknown error'}`);
 943:     }
 944:   },
 945: 
 946:   /**
 947:    * Start streaming real-time output for a running session
 948:    * @param runId - The run ID to stream output for
 949:    * @returns Promise that resolves when streaming starts
 950:    */
 951:   async streamSessionOutput(runId: number): Promise<void> {
 952:     try {
 953:       return await invoke<void>('stream_session_output', { runId });
 954:     } catch (error) {
 955:       console.error("Failed to start streaming session output:", error);
 956:       throw new Error(`Failed to start streaming session output: ${error instanceof Error ? error.message : 'Unknown error'}`);
 957:     }
 958:   },
 959: 
 960:   /**
 961:    * Loads the JSONL history for a specific session
 962:    */
 963:   async loadSessionHistory(sessionId: string, projectId: string): Promise<any[]> {
 964:     return invoke("load_session_history", { sessionId, projectId });
 965:   },
 966: 
 967:   /**
 968:    * Loads the JSONL history for a specific agent session
 969:    * Similar to loadSessionHistory but searches across all project directories
 970:    * @param sessionId - The session ID (UUID)
 971:    * @returns Promise resolving to array of session messages
 972:    */
 973:   async loadAgentSessionHistory(sessionId: string): Promise<any[]> {
 974:     try {
 975:       return await invoke<any[]>('load_agent_session_history', { sessionId });
 976:     } catch (error) {
 977:       console.error("Failed to load agent session history:", error);
 978:       throw error;
 979:     }
 980:   },
 981: 
 982:   /**
 983:    * Executes a new interactive Claude Code session with streaming output
 984:    */
 985:   async executeClaudeCode(projectPath: string, prompt: string, model: string): Promise<void> {
 986:     return invoke("execute_claude_code", { projectPath, prompt, model });
 987:   },
 988: 
 989:   /**
 990:    * Continues an existing Claude Code conversation with streaming output
 991:    */
 992:   async continueClaudeCode(projectPath: string, prompt: string, model: string): Promise<void> {
 993:     return invoke("continue_claude_code", { projectPath, prompt, model });
 994:   },
 995: 
 996:   /**
 997:    * Resumes an existing Claude Code session by ID with streaming output
 998:    */
 999:   async resumeClaudeCode(projectPath: string, sessionId: string, prompt: string, model: string): Promise<void> {
1000:     return invoke("resume_claude_code", { projectPath, sessionId, prompt, model });
1001:   },
1002: 
1003:   /**
1004:    * Cancels the currently running Claude Code execution
1005:    * @param sessionId - Optional session ID to cancel a specific session
1006:    */
1007:   async cancelClaudeExecution(sessionId?: string): Promise<void> {
1008:     return invoke("cancel_claude_execution", { sessionId });
1009:   },
1010: 
1011:   /**
1012:    * Lists all currently running Claude sessions
1013:    * @returns Promise resolving to list of running Claude sessions
1014:    */
1015:   async listRunningClaudeSessions(): Promise<any[]> {
1016:     return invoke("list_running_claude_sessions");
1017:   },
1018: 
1019:   /**
1020:    * Gets live output from a Claude session
1021:    * @param sessionId - The session ID to get output for
1022:    * @returns Promise resolving to the current live output
1023:    */
1024:   async getClaudeSessionOutput(sessionId: string): Promise<string> {
1025:     return invoke("get_claude_session_output", { sessionId });
1026:   },
1027: 
1028:   /**
1029:    * Lists files and directories in a given path
1030:    */
1031:   async listDirectoryContents(directoryPath: string): Promise<FileEntry[]> {
1032:     return invoke("list_directory_contents", { directoryPath });
1033:   },
1034: 
1035:   /**
1036:    * Searches for files and directories matching a pattern
1037:    */
1038:   async searchFiles(basePath: string, query: string): Promise<FileEntry[]> {
1039:     return invoke("search_files", { basePath, query });
1040:   },
1041: 
1042:   /**
1043:    * Gets overall usage statistics
1044:    * @returns Promise resolving to usage statistics
1045:    */
1046:   async getUsageStats(): Promise<UsageStats> {
1047:     try {
1048:       return await invoke<UsageStats>("get_usage_stats");
1049:     } catch (error) {
1050:       console.error("Failed to get usage stats:", error);
1051:       throw error;
1052:     }
1053:   },
1054: 
1055:   /**
1056:    * Gets usage statistics filtered by date range
1057:    * @param startDate - Start date (ISO format)
1058:    * @param endDate - End date (ISO format)
1059:    * @returns Promise resolving to usage statistics
1060:    */
1061:   async getUsageByDateRange(startDate: string, endDate: string): Promise<UsageStats> {
1062:     try {
1063:       return await invoke<UsageStats>("get_usage_by_date_range", { startDate, endDate });
1064:     } catch (error) {
1065:       console.error("Failed to get usage by date range:", error);
1066:       throw error;
1067:     }
1068:   },
1069: 
1070:   /**
1071:    * Gets usage statistics grouped by session
1072:    * @param since - Optional start date (YYYYMMDD)
1073:    * @param until - Optional end date (YYYYMMDD)
1074:    * @param order - Optional sort order ('asc' or 'desc')
1075:    * @returns Promise resolving to an array of session usage data
1076:    */
1077:   async getSessionStats(
1078:     since?: string,
1079:     until?: string,
1080:     order?: "asc" | "desc"
1081:   ): Promise<ProjectUsage[]> {
1082:     try {
1083:       return await invoke<ProjectUsage[]>("get_session_stats", {
1084:         since,
1085:         until,
1086:         order,
1087:       });
1088:     } catch (error) {
1089:       console.error("Failed to get session stats:", error);
1090:       throw error;
1091:     }
1092:   },
1093: 
1094:   /**
1095:    * Gets detailed usage entries with optional filtering
1096:    * @param limit - Optional limit for number of entries
1097:    * @returns Promise resolving to array of usage entries
1098:    */
1099:   async getUsageDetails(limit?: number): Promise<UsageEntry[]> {
1100:     try {
1101:       return await invoke<UsageEntry[]>("get_usage_details", { limit });
1102:     } catch (error) {
1103:       console.error("Failed to get usage details:", error);
1104:       throw error;
1105:     }
1106:   },
1107: 
1108:   /**
1109:    * Creates a checkpoint for the current session state
1110:    */
1111:   async createCheckpoint(
1112:     sessionId: string,
1113:     projectId: string,
1114:     projectPath: string,
1115:     messageIndex?: number,
1116:     description?: string
1117:   ): Promise<CheckpointResult> {
1118:     return invoke("create_checkpoint", {
1119:       sessionId,
1120:       projectId,
1121:       projectPath,
1122:       messageIndex,
1123:       description
1124:     });
1125:   },
1126: 
1127:   /**
1128:    * Restores a session to a specific checkpoint
1129:    */
1130:   async restoreCheckpoint(
1131:     checkpointId: string,
1132:     sessionId: string,
1133:     projectId: string,
1134:     projectPath: string
1135:   ): Promise<CheckpointResult> {
1136:     return invoke("restore_checkpoint", {
1137:       checkpointId,
1138:       sessionId,
1139:       projectId,
1140:       projectPath
1141:     });
1142:   },
1143: 
1144:   /**
1145:    * Lists all checkpoints for a session
1146:    */
1147:   async listCheckpoints(
1148:     sessionId: string,
1149:     projectId: string,
1150:     projectPath: string
1151:   ): Promise<Checkpoint[]> {
1152:     return invoke("list_checkpoints", {
1153:       sessionId,
1154:       projectId,
1155:       projectPath
1156:     });
1157:   },
1158: 
1159:   /**
1160:    * Forks a new timeline branch from a checkpoint
1161:    */
1162:   async forkFromCheckpoint(
1163:     checkpointId: string,
1164:     sessionId: string,
1165:     projectId: string,
1166:     projectPath: string,
1167:     newSessionId: string,
1168:     description?: string
1169:   ): Promise<CheckpointResult> {
1170:     return invoke("fork_from_checkpoint", {
1171:       checkpointId,
1172:       sessionId,
1173:       projectId,
1174:       projectPath,
1175:       newSessionId,
1176:       description
1177:     });
1178:   },
1179: 
1180:   /**
1181:    * Gets the timeline for a session
1182:    */
1183:   async getSessionTimeline(
1184:     sessionId: string,
1185:     projectId: string,
1186:     projectPath: string
1187:   ): Promise<SessionTimeline> {
1188:     return invoke("get_session_timeline", {
1189:       sessionId,
1190:       projectId,
1191:       projectPath
1192:     });
1193:   },
1194: 
1195:   /**
1196:    * Updates checkpoint settings for a session
1197:    */
1198:   async updateCheckpointSettings(
1199:     sessionId: string,
1200:     projectId: string,
1201:     projectPath: string,
1202:     autoCheckpointEnabled: boolean,
1203:     checkpointStrategy: CheckpointStrategy
1204:   ): Promise<void> {
1205:     return invoke("update_checkpoint_settings", {
1206:       sessionId,
1207:       projectId,
1208:       projectPath,
1209:       autoCheckpointEnabled,
1210:       checkpointStrategy
1211:     });
1212:   },
1213: 
1214:   /**
1215:    * Gets diff between two checkpoints
1216:    */
1217:   async getCheckpointDiff(
1218:     fromCheckpointId: string,
1219:     toCheckpointId: string,
1220:     sessionId: string,
1221:     projectId: string
1222:   ): Promise<CheckpointDiff> {
1223:     try {
1224:       return await invoke<CheckpointDiff>("get_checkpoint_diff", {
1225:         fromCheckpointId,
1226:         toCheckpointId,
1227:         sessionId,
1228:         projectId
1229:       });
1230:     } catch (error) {
1231:       console.error("Failed to get checkpoint diff:", error);
1232:       throw error;
1233:     }
1234:   },
1235: 
1236:   /**
1237:    * Tracks a message for checkpointing
1238:    */
1239:   async trackCheckpointMessage(
1240:     sessionId: string,
1241:     projectId: string,
1242:     projectPath: string,
1243:     message: string
1244:   ): Promise<void> {
1245:     try {
1246:       await invoke("track_checkpoint_message", {
1247:         sessionId,
1248:         projectId,
1249:         projectPath,
1250:         message
1251:       });
1252:     } catch (error) {
1253:       console.error("Failed to track checkpoint message:", error);
1254:       throw error;
1255:     }
1256:   },
1257: 
1258:   /**
1259:    * Checks if auto-checkpoint should be triggered
1260:    */
1261:   async checkAutoCheckpoint(
1262:     sessionId: string,
1263:     projectId: string,
1264:     projectPath: string,
1265:     message: string
1266:   ): Promise<boolean> {
1267:     try {
1268:       return await invoke<boolean>("check_auto_checkpoint", {
1269:         sessionId,
1270:         projectId,
1271:         projectPath,
1272:         message
1273:       });
1274:     } catch (error) {
1275:       console.error("Failed to check auto checkpoint:", error);
1276:       throw error;
1277:     }
1278:   },
1279: 
1280:   /**
1281:    * Triggers cleanup of old checkpoints
1282:    */
1283:   async cleanupOldCheckpoints(
1284:     sessionId: string,
1285:     projectId: string,
1286:     projectPath: string,
1287:     keepCount: number
1288:   ): Promise<number> {
1289:     try {
1290:       return await invoke<number>("cleanup_old_checkpoints", {
1291:         sessionId,
1292:         projectId,
1293:         projectPath,
1294:         keepCount
1295:       });
1296:     } catch (error) {
1297:       console.error("Failed to cleanup old checkpoints:", error);
1298:       throw error;
1299:     }
1300:   },
1301: 
1302:   /**
1303:    * Gets checkpoint settings for a session
1304:    */
1305:   async getCheckpointSettings(
1306:     sessionId: string,
1307:     projectId: string,
1308:     projectPath: string
1309:   ): Promise<{
1310:     auto_checkpoint_enabled: boolean;
1311:     checkpoint_strategy: CheckpointStrategy;
1312:     total_checkpoints: number;
1313:     current_checkpoint_id?: string;
1314:   }> {
1315:     try {
1316:       return await invoke("get_checkpoint_settings", {
1317:         sessionId,
1318:         projectId,
1319:         projectPath
1320:       });
1321:     } catch (error) {
1322:       console.error("Failed to get checkpoint settings:", error);
1323:       throw error;
1324:     }
1325:   },
1326: 
1327:   /**
1328:    * Clears checkpoint manager for a session (cleanup on session end)
1329:    */
1330:   async clearCheckpointManager(sessionId: string): Promise<void> {
1331:     try {
1332:       await invoke("clear_checkpoint_manager", { sessionId });
1333:     } catch (error) {
1334:       console.error("Failed to clear checkpoint manager:", error);
1335:       throw error;
1336:     }
1337:   },
1338: 
1339:   /**
1340:    * Tracks a batch of messages for a session for checkpointing
1341:    */
1342:   trackSessionMessages: (
1343:     sessionId: string, 
1344:     projectId: string, 
1345:     projectPath: string, 
1346:     messages: string[]
1347:   ): Promise<void> =>
1348:     invoke("track_session_messages", { sessionId, projectId, projectPath, messages }),
1349: 
1350:   /**
1351:    * Adds a new MCP server
1352:    */
1353:   async mcpAdd(
1354:     name: string,
1355:     transport: string,
1356:     command?: string,
1357:     args: string[] = [],
1358:     env: Record<string, string> = {},
1359:     url?: string,
1360:     scope: string = "local"
1361:   ): Promise<AddServerResult> {
1362:     try {
1363:       return await invoke<AddServerResult>("mcp_add", {
1364:         name,
1365:         transport,
1366:         command,
1367:         args,
1368:         env,
1369:         url,
1370:         scope
1371:       });
1372:     } catch (error) {
1373:       console.error("Failed to add MCP server:", error);
1374:       throw error;
1375:     }
1376:   },
1377: 
1378:   /**
1379:    * Lists all configured MCP servers
1380:    */
1381:   async mcpList(): Promise<MCPServer[]> {
1382:     try {
1383:       console.log("API: Calling mcp_list...");
1384:       const result = await invoke<MCPServer[]>("mcp_list");
1385:       console.log("API: mcp_list returned:", result);
1386:       return result;
1387:     } catch (error) {
1388:       console.error("API: Failed to list MCP servers:", error);
1389:       throw error;
1390:     }
1391:   },
1392: 
1393:   /**
1394:    * Gets details for a specific MCP server
1395:    */
1396:   async mcpGet(name: string): Promise<MCPServer> {
1397:     try {
1398:       return await invoke<MCPServer>("mcp_get", { name });
1399:     } catch (error) {
1400:       console.error("Failed to get MCP server:", error);
1401:       throw error;
1402:     }
1403:   },
1404: 
1405:   /**
1406:    * Removes an MCP server
1407:    */
1408:   async mcpRemove(name: string): Promise<string> {
1409:     try {
1410:       return await invoke<string>("mcp_remove", { name });
1411:     } catch (error) {
1412:       console.error("Failed to remove MCP server:", error);
1413:       throw error;
1414:     }
1415:   },
1416: 
1417:   /**
1418:    * Adds an MCP server from JSON configuration
1419:    */
1420:   async mcpAddJson(name: string, jsonConfig: string, scope: string = "local"): Promise<AddServerResult> {
1421:     try {
1422:       return await invoke<AddServerResult>("mcp_add_json", { name, jsonConfig, scope });
1423:     } catch (error) {
1424:       console.error("Failed to add MCP server from JSON:", error);
1425:       throw error;
1426:     }
1427:   },
1428: 
1429:   /**
1430:    * Imports MCP servers from Claude Desktop
1431:    */
1432:   async mcpAddFromClaudeDesktop(scope: string = "local"): Promise<ImportResult> {
1433:     try {
1434:       return await invoke<ImportResult>("mcp_add_from_claude_desktop", { scope });
1435:     } catch (error) {
1436:       console.error("Failed to import from Claude Desktop:", error);
1437:       throw error;
1438:     }
1439:   },
1440: 
1441:   /**
1442:    * Starts Claude Code as an MCP server
1443:    */
1444:   async mcpServe(): Promise<string> {
1445:     try {
1446:       return await invoke<string>("mcp_serve");
1447:     } catch (error) {
1448:       console.error("Failed to start MCP server:", error);
1449:       throw error;
1450:     }
1451:   },
1452: 
1453:   /**
1454:    * Tests connection to an MCP server
1455:    */
1456:   async mcpTestConnection(name: string): Promise<string> {
1457:     try {
1458:       return await invoke<string>("mcp_test_connection", { name });
1459:     } catch (error) {
1460:       console.error("Failed to test MCP connection:", error);
1461:       throw error;
1462:     }
1463:   },
1464: 
1465:   /**
1466:    * Resets project-scoped server approval choices
1467:    */
1468:   async mcpResetProjectChoices(): Promise<string> {
1469:     try {
1470:       return await invoke<string>("mcp_reset_project_choices");
1471:     } catch (error) {
1472:       console.error("Failed to reset project choices:", error);
1473:       throw error;
1474:     }
1475:   },
1476: 
1477:   /**
1478:    * Gets the status of MCP servers
1479:    */
1480:   async mcpGetServerStatus(): Promise<Record<string, ServerStatus>> {
1481:     try {
1482:       return await invoke<Record<string, ServerStatus>>("mcp_get_server_status");
1483:     } catch (error) {
1484:       console.error("Failed to get server status:", error);
1485:       throw error;
1486:     }
1487:   },
1488: 
1489:   /**
1490:    * Reads .mcp.json from the current project
1491:    */
1492:   async mcpReadProjectConfig(projectPath: string): Promise<MCPProjectConfig> {
1493:     try {
1494:       return await invoke<MCPProjectConfig>("mcp_read_project_config", { projectPath });
1495:     } catch (error) {
1496:       console.error("Failed to read project MCP config:", error);
1497:       throw error;
1498:     }
1499:   },
1500: 
1501:   /**
1502:    * Saves .mcp.json to the current project
1503:    */
1504:   async mcpSaveProjectConfig(projectPath: string, config: MCPProjectConfig): Promise<string> {
1505:     try {
1506:       return await invoke<string>("mcp_save_project_config", { projectPath, config });
1507:     } catch (error) {
1508:       console.error("Failed to save project MCP config:", error);
1509:       throw error;
1510:     }
1511:   },
1512: 
1513:   /**
1514:    * Get the stored Claude binary path from settings
1515:    * @returns Promise resolving to the path if set, null otherwise
1516:    */
1517:   async getClaudeBinaryPath(): Promise<string | null> {
1518:     try {
1519:       return await invoke<string | null>("get_claude_binary_path");
1520:     } catch (error) {
1521:       console.error("Failed to get Claude binary path:", error);
1522:       throw error;
1523:     }
1524:   },
1525: 
1526:   /**
1527:    * Set the Claude binary path in settings
1528:    * @param path - The absolute path to the Claude binary
1529:    * @returns Promise resolving when the path is saved
1530:    */
1531:   async setClaudeBinaryPath(path: string): Promise<void> {
1532:     try {
1533:       return await invoke<void>("set_claude_binary_path", { path });
1534:     } catch (error) {
1535:       console.error("Failed to set Claude binary path:", error);
1536:       throw error;
1537:     }
1538:   },
1539: 
1540:   /**
1541:    * List all available Claude installations on the system
1542:    * @returns Promise resolving to an array of Claude installations
1543:    */
1544:   async listClaudeInstallations(): Promise<ClaudeInstallation[]> {
1545:     try {
1546:       return await invoke<ClaudeInstallation[]>("list_claude_installations");
1547:     } catch (error) {
1548:       console.error("Failed to list Claude installations:", error);
1549:       throw error;
1550:     }
1551:   },
1552: 
1553:   // Storage API methods
1554: 
1555:   /**
1556:    * Lists all tables in the SQLite database
1557:    * @returns Promise resolving to an array of table information
1558:    */
1559:   async storageListTables(): Promise<any[]> {
1560:     try {
1561:       return await invoke<any[]>("storage_list_tables");
1562:     } catch (error) {
1563:       console.error("Failed to list tables:", error);
1564:       throw error;
1565:     }
1566:   },
1567: 
1568:   /**
1569:    * Reads table data with pagination
1570:    * @param tableName - Name of the table to read
1571:    * @param page - Page number (1-indexed)
1572:    * @param pageSize - Number of rows per page
1573:    * @param searchQuery - Optional search query
1574:    * @returns Promise resolving to table data with pagination info
1575:    */
1576:   async storageReadTable(
1577:     tableName: string,
1578:     page: number,
1579:     pageSize: number,
1580:     searchQuery?: string
1581:   ): Promise<any> {
1582:     try {
1583:       return await invoke<any>("storage_read_table", {
1584:         tableName,
1585:         page,
1586:         pageSize,
1587:         searchQuery,
1588:       });
1589:     } catch (error) {
1590:       console.error("Failed to read table:", error);
1591:       throw error;
1592:     }
1593:   },
1594: 
1595:   /**
1596:    * Updates a row in a table
1597:    * @param tableName - Name of the table
1598:    * @param primaryKeyValues - Map of primary key column names to values
1599:    * @param updates - Map of column names to new values
1600:    * @returns Promise resolving when the row is updated
1601:    */
1602:   async storageUpdateRow(
1603:     tableName: string,
1604:     primaryKeyValues: Record<string, any>,
1605:     updates: Record<string, any>
1606:   ): Promise<void> {
1607:     try {
1608:       return await invoke<void>("storage_update_row", {
1609:         tableName,
1610:         primaryKeyValues,
1611:         updates,
1612:       });
1613:     } catch (error) {
1614:       console.error("Failed to update row:", error);
1615:       throw error;
1616:     }
1617:   },
1618: 
1619:   /**
1620:    * Deletes a row from a table
1621:    * @param tableName - Name of the table
1622:    * @param primaryKeyValues - Map of primary key column names to values
1623:    * @returns Promise resolving when the row is deleted
1624:    */
1625:   async storageDeleteRow(
1626:     tableName: string,
1627:     primaryKeyValues: Record<string, any>
1628:   ): Promise<void> {
1629:     try {
1630:       return await invoke<void>("storage_delete_row", {
1631:         tableName,
1632:         primaryKeyValues,
1633:       });
1634:     } catch (error) {
1635:       console.error("Failed to delete row:", error);
1636:       throw error;
1637:     }
1638:   },
1639: 
1640:   /**
1641:    * Inserts a new row into a table
1642:    * @param tableName - Name of the table
1643:    * @param values - Map of column names to values
1644:    * @returns Promise resolving to the last insert row ID
1645:    */
1646:   async storageInsertRow(
1647:     tableName: string,
1648:     values: Record<string, any>
1649:   ): Promise<number> {
1650:     try {
1651:       return await invoke<number>("storage_insert_row", {
1652:         tableName,
1653:         values,
1654:       });
1655:     } catch (error) {
1656:       console.error("Failed to insert row:", error);
1657:       throw error;
1658:     }
1659:   },
1660: 
1661:   /**
1662:    * Executes a raw SQL query
1663:    * @param query - SQL query string
1664:    * @returns Promise resolving to query result
1665:    */
1666:   async storageExecuteSql(query: string): Promise<any> {
1667:     try {
1668:       return await invoke<any>("storage_execute_sql", { query });
1669:     } catch (error) {
1670:       console.error("Failed to execute SQL:", error);
1671:       throw error;
1672:     }
1673:   },
1674: 
1675:   /**
1676:    * Resets the entire database
1677:    * @returns Promise resolving when the database is reset
1678:    */
1679:   async storageResetDatabase(): Promise<void> {
1680:     try {
1681:       return await invoke<void>("storage_reset_database");
1682:     } catch (error) {
1683:       console.error("Failed to reset database:", error);
1684:       throw error;
1685:     }
1686:   },
1687: 
1688:   // Theme settings helpers
1689: 
1690:   /**
1691:    * Gets a setting from the app_settings table
1692:    * @param key - The setting key to retrieve
1693:    * @returns Promise resolving to the setting value or null if not found
1694:    */
1695:   async getSetting(key: string): Promise<string | null> {
1696:     try {
1697:       // Use storageReadTable to safely query the app_settings table
1698:       const result = await this.storageReadTable('app_settings', 1, 1000);
1699:       const setting = result?.data?.find((row: any) => row.key === key);
1700:       return setting?.value || null;
1701:     } catch (error) {
1702:       console.error(`Failed to get setting ${key}:`, error);
1703:       return null;
1704:     }
1705:   },
1706: 
1707:   /**
1708:    * Saves a setting to the app_settings table (insert or update)
1709:    * @param key - The setting key
1710:    * @param value - The setting value
1711:    * @returns Promise resolving when the setting is saved
1712:    */
1713:   async saveSetting(key: string, value: string): Promise<void> {
1714:     try {
1715:       // Try to update first
1716:       try {
1717:         await this.storageUpdateRow(
1718:           'app_settings',
1719:           { key },
1720:           { value }
1721:         );
1722:       } catch (updateError) {
1723:         // If update fails (row doesn't exist), insert new row
1724:         await this.storageInsertRow('app_settings', { key, value });
1725:       }
1726:     } catch (error) {
1727:       console.error(`Failed to save setting ${key}:`, error);
1728:       throw error;
1729:     }
1730:   },
1731: 
1732:   /**
1733:    * Get hooks configuration for a specific scope
1734:    * @param scope - The configuration scope: 'user', 'project', or 'local'
1735:    * @param projectPath - Project path (required for project and local scopes)
1736:    * @returns Promise resolving to the hooks configuration
1737:    */
1738:   async getHooksConfig(scope: 'user' | 'project' | 'local', projectPath?: string): Promise<HooksConfiguration> {
1739:     try {
1740:       return await invoke<HooksConfiguration>("get_hooks_config", { scope, projectPath });
1741:     } catch (error) {
1742:       console.error("Failed to get hooks config:", error);
1743:       throw error;
1744:     }
1745:   },
1746: 
1747:   /**
1748:    * Update hooks configuration for a specific scope
1749:    * @param scope - The configuration scope: 'user', 'project', or 'local'
1750:    * @param hooks - The hooks configuration to save
1751:    * @param projectPath - Project path (required for project and local scopes)
1752:    * @returns Promise resolving to success message
1753:    */
1754:   async updateHooksConfig(
1755:     scope: 'user' | 'project' | 'local',
1756:     hooks: HooksConfiguration,
1757:     projectPath?: string
1758:   ): Promise<string> {
1759:     try {
1760:       return await invoke<string>("update_hooks_config", { scope, projectPath, hooks });
1761:     } catch (error) {
1762:       console.error("Failed to update hooks config:", error);
1763:       throw error;
1764:     }
1765:   },
1766: 
1767:   /**
1768:    * Validate a hook command syntax
1769:    * @param command - The shell command to validate
1770:    * @returns Promise resolving to validation result
1771:    */
1772:   async validateHookCommand(command: string): Promise<{ valid: boolean; message: string }> {
1773:     try {
1774:       return await invoke<{ valid: boolean; message: string }>("validate_hook_command", { command });
1775:     } catch (error) {
1776:       console.error("Failed to validate hook command:", error);
1777:       throw error;
1778:     }
1779:   },
1780: 
1781:   /**
1782:    * Get merged hooks configuration (respecting priority)
1783:    * @param projectPath - The project path
1784:    * @returns Promise resolving to merged hooks configuration
1785:    */
1786:   async getMergedHooksConfig(projectPath: string): Promise<HooksConfiguration> {
1787:     try {
1788:       const [userHooks, projectHooks, localHooks] = await Promise.all([
1789:         this.getHooksConfig('user'),
1790:         this.getHooksConfig('project', projectPath),
1791:         this.getHooksConfig('local', projectPath)
1792:       ]);
1793: 
1794:       // Import HooksManager for merging
1795:       const { HooksManager } = await import('@/lib/hooksManager');
1796:       return HooksManager.mergeConfigs(userHooks, projectHooks, localHooks);
1797:     } catch (error) {
1798:       console.error("Failed to get merged hooks config:", error);
1799:       throw error;
1800:     }
1801:   },
1802: 
1803:   // Slash Commands API methods
1804: 
1805:   /**
1806:    * Lists all available slash commands
1807:    * @param projectPath - Optional project path to include project-specific commands
1808:    * @returns Promise resolving to array of slash commands
1809:    */
1810:   async slashCommandsList(projectPath?: string): Promise<SlashCommand[]> {
1811:     try {
1812:       return await invoke<SlashCommand[]>("slash_commands_list", { projectPath });
1813:     } catch (error) {
1814:       console.error("Failed to list slash commands:", error);
1815:       throw error;
1816:     }
1817:   },
1818: 
1819:   /**
1820:    * Gets a single slash command by ID
1821:    * @param commandId - Unique identifier of the command
1822:    * @returns Promise resolving to the slash command
1823:    */
1824:   async slashCommandGet(commandId: string): Promise<SlashCommand> {
1825:     try {
1826:       return await invoke<SlashCommand>("slash_command_get", { commandId });
1827:     } catch (error) {
1828:       console.error("Failed to get slash command:", error);
1829:       throw error;
1830:     }
1831:   },
1832: 
1833:   /**
1834:    * Creates or updates a slash command
1835:    * @param scope - Command scope: "project" or "user"
1836:    * @param name - Command name (without prefix)
1837:    * @param namespace - Optional namespace for organization
1838:    * @param content - Markdown content of the command
1839:    * @param description - Optional description
1840:    * @param allowedTools - List of allowed tools for this command
1841:    * @param projectPath - Required for project scope commands
1842:    * @returns Promise resolving to the saved command
1843:    */
1844:   async slashCommandSave(
1845:     scope: string,
1846:     name: string,
1847:     namespace: string | undefined,
1848:     content: string,
1849:     description: string | undefined,
1850:     allowedTools: string[],
1851:     projectPath?: string
1852:   ): Promise<SlashCommand> {
1853:     try {
1854:       return await invoke<SlashCommand>("slash_command_save", {
1855:         scope,
1856:         name,
1857:         namespace,
1858:         content,
1859:         description,
1860:         allowedTools,
1861:         projectPath
1862:       });
1863:     } catch (error) {
1864:       console.error("Failed to save slash command:", error);
1865:       throw error;
1866:     }
1867:   },
1868: 
1869:   /**
1870:    * Deletes a slash command
1871:    * @param commandId - Unique identifier of the command to delete
1872:    * @param projectPath - Optional project path for deleting project commands
1873:    * @returns Promise resolving to deletion message
1874:    */
1875:   async slashCommandDelete(commandId: string, projectPath?: string): Promise<string> {
1876:     try {
1877:       return await invoke<string>("slash_command_delete", { commandId, projectPath });
1878:     } catch (error) {
1879:       console.error("Failed to delete slash command:", error);
1880:       throw error;
1881:     }
1882:   }
1883: };
````

## File: src/lib/claudeSyntaxTheme.ts
````typescript
  1: import { ThemeMode } from '@/contexts/ThemeContext';
  2: 
  3: /**
  4:  * Claude-themed syntax highlighting theme factory
  5:  * Returns different syntax themes based on the current theme mode
  6:  * 
  7:  * @param theme - The current theme mode
  8:  * @returns Prism syntax highlighting theme object
  9:  */
 10: export const getClaudeSyntaxTheme = (theme: ThemeMode): any => {
 11:   const themes = {
 12:     dark: {
 13:       base: '#e3e8f0',
 14:       background: 'transparent',
 15:       comment: '#6b7280',
 16:       punctuation: '#9ca3af',
 17:       property: '#f59e0b', // Amber/Orange
 18:       tag: '#8b5cf6', // Violet
 19:       string: '#10b981', // Emerald Green
 20:       function: '#818cf8', // Indigo
 21:       keyword: '#c084fc', // Light Violet
 22:       variable: '#a78bfa', // Light Purple
 23:       operator: '#9ca3af',
 24:     },
 25:     gray: {
 26:       base: '#e3e8f0',
 27:       background: 'transparent',
 28:       comment: '#71717a',
 29:       punctuation: '#a1a1aa',
 30:       property: '#fbbf24', // Yellow
 31:       tag: '#a78bfa', // Light Purple
 32:       string: '#34d399', // Green
 33:       function: '#93bbfc', // Light Blue
 34:       keyword: '#d8b4fe', // Light Purple
 35:       variable: '#c084fc', // Purple
 36:       operator: '#a1a1aa',
 37:     },
 38:     light: {
 39:       base: '#1f2937',
 40:       background: 'transparent',
 41:       comment: '#9ca3af',
 42:       punctuation: '#6b7280',
 43:       property: '#dc2626', // Red
 44:       tag: '#7c3aed', // Purple
 45:       string: '#059669', // Green
 46:       function: '#2563eb', // Blue
 47:       keyword: '#9333ea', // Purple
 48:       variable: '#8b5cf6', // Violet
 49:       operator: '#6b7280',
 50:     },
 51:     white: {
 52:       base: '#000000',
 53:       background: 'transparent',
 54:       comment: '#6b7280',
 55:       punctuation: '#374151',
 56:       property: '#dc2626', // Red
 57:       tag: '#5b21b6', // Deep Purple
 58:       string: '#047857', // Dark Green
 59:       function: '#1e40af', // Dark Blue
 60:       keyword: '#6b21a8', // Dark Purple
 61:       variable: '#6d28d9', // Dark Violet
 62:       operator: '#374151',
 63:     },
 64:     custom: {
 65:       // Default to dark theme colors for custom
 66:       base: '#e3e8f0',
 67:       background: 'transparent',
 68:       comment: '#6b7280',
 69:       punctuation: '#9ca3af',
 70:       property: '#f59e0b',
 71:       tag: '#8b5cf6',
 72:       string: '#10b981',
 73:       function: '#818cf8',
 74:       keyword: '#c084fc',
 75:       variable: '#a78bfa',
 76:       operator: '#9ca3af',
 77:     }
 78:   };
 79: 
 80:   const colors = themes[theme] || themes.dark;
 81: 
 82:   return {
 83:     'code[class*="language-"]': {
 84:       color: colors.base,
 85:       background: colors.background,
 86:       textShadow: 'none',
 87:       fontFamily: 'var(--font-mono)',
 88:       fontSize: '0.875em',
 89:       textAlign: 'left',
 90:       whiteSpace: 'pre',
 91:       wordSpacing: 'normal',
 92:       wordBreak: 'normal',
 93:       wordWrap: 'normal',
 94:       lineHeight: '1.5',
 95:       MozTabSize: '4',
 96:       OTabSize: '4',
 97:       tabSize: '4',
 98:       WebkitHyphens: 'none',
 99:       MozHyphens: 'none',
100:       msHyphens: 'none',
101:       hyphens: 'none',
102:     },
103:     'pre[class*="language-"]': {
104:       color: colors.base,
105:       background: colors.background,
106:       textShadow: 'none',
107:       fontFamily: 'var(--font-mono)',
108:       fontSize: '0.875em',
109:       textAlign: 'left',
110:       whiteSpace: 'pre',
111:       wordSpacing: 'normal',
112:       wordBreak: 'normal',
113:       wordWrap: 'normal',
114:       lineHeight: '1.5',
115:       MozTabSize: '4',
116:       OTabSize: '4',
117:       tabSize: '4',
118:       WebkitHyphens: 'none',
119:       MozHyphens: 'none',
120:       msHyphens: 'none',
121:       hyphens: 'none',
122:       padding: '1em',
123:       margin: '0',
124:       overflow: 'auto',
125:     },
126:     ':not(pre) > code[class*="language-"]': {
127:       background: theme === 'light' 
128:         ? 'rgba(139, 92, 246, 0.1)' 
129:         : 'rgba(139, 92, 246, 0.1)',
130:       padding: '0.1em 0.3em',
131:       borderRadius: '0.3em',
132:       whiteSpace: 'normal',
133:     },
134:     'comment': {
135:       color: colors.comment,
136:       fontStyle: 'italic',
137:     },
138:     'prolog': {
139:       color: colors.comment,
140:     },
141:     'doctype': {
142:       color: colors.comment,
143:     },
144:     'cdata': {
145:       color: colors.comment,
146:     },
147:     'punctuation': {
148:       color: colors.punctuation,
149:     },
150:     'namespace': {
151:       opacity: '0.7',
152:     },
153:     'property': {
154:       color: colors.property,
155:     },
156:     'tag': {
157:       color: colors.tag,
158:     },
159:     'boolean': {
160:       color: colors.property,
161:     },
162:     'number': {
163:       color: colors.property,
164:     },
165:     'constant': {
166:       color: colors.property,
167:     },
168:     'symbol': {
169:       color: colors.property,
170:     },
171:     'deleted': {
172:       color: '#ef4444',
173:     },
174:     'selector': {
175:       color: colors.variable,
176:     },
177:     'attr-name': {
178:       color: colors.variable,
179:     },
180:     'string': {
181:       color: colors.string,
182:     },
183:     'char': {
184:       color: colors.string,
185:     },
186:     'builtin': {
187:       color: colors.tag,
188:     },
189:     'url': {
190:       color: colors.string,
191:     },
192:     'inserted': {
193:       color: colors.string,
194:     },
195:     'entity': {
196:       color: colors.variable,
197:       cursor: 'help',
198:     },
199:     'atrule': {
200:       color: colors.keyword,
201:     },
202:     'attr-value': {
203:       color: colors.string,
204:     },
205:     'keyword': {
206:       color: colors.keyword,
207:     },
208:     'function': {
209:       color: colors.function,
210:     },
211:     'class-name': {
212:       color: colors.property,
213:     },
214:     'regex': {
215:       color: '#06b6d4', // Cyan
216:     },
217:     'important': {
218:       color: colors.property,
219:       fontWeight: 'bold',
220:     },
221:     'variable': {
222:       color: colors.variable,
223:     },
224:     'bold': {
225:       fontWeight: 'bold',
226:     },
227:     'italic': {
228:       fontStyle: 'italic',
229:     },
230:     'operator': {
231:       color: colors.operator,
232:     },
233:     'script': {
234:       color: colors.base,
235:     },
236:     'parameter': {
237:       color: colors.property,
238:     },
239:     'method': {
240:       color: colors.function,
241:     },
242:     'field': {
243:       color: colors.property,
244:     },
245:     'annotation': {
246:       color: colors.comment,
247:     },
248:     'type': {
249:       color: colors.variable,
250:     },
251:     'module': {
252:       color: colors.tag,
253:     },
254:   };
255: };
256: 
257: // Export default dark theme for backward compatibility
258: export const claudeSyntaxTheme = getClaudeSyntaxTheme('dark');
````

## File: src/lib/date-utils.ts
````typescript
  1: /**
  2:  * Formats a Unix timestamp to a human-readable date string
  3:  * @param timestamp - Unix timestamp in seconds
  4:  * @returns Formatted date string
  5:  * 
  6:  * @example
  7:  * formatUnixTimestamp(1735555200) // "Dec 30, 2024"
  8:  */
  9: export function formatUnixTimestamp(timestamp: number): string {
 10:   const date = new Date(timestamp * 1000);
 11:   const now = new Date();
 12:   
 13:   // If it's today, show time
 14:   if (isToday(date)) {
 15:     return formatTime(date);
 16:   }
 17:   
 18:   // If it's yesterday
 19:   if (isYesterday(date)) {
 20:     return `Yesterday, ${formatTime(date)}`;
 21:   }
 22:   
 23:   // If it's within the last week, show day of week
 24:   if (isWithinWeek(date)) {
 25:     return `${getDayName(date)}, ${formatTime(date)}`;
 26:   }
 27:   
 28:   // If it's this year, don't show year
 29:   if (date.getFullYear() === now.getFullYear()) {
 30:     return date.toLocaleDateString('en-US', { 
 31:       month: 'short', 
 32:       day: 'numeric' 
 33:     });
 34:   }
 35:   
 36:   // Otherwise show full date
 37:   return date.toLocaleDateString('en-US', { 
 38:     month: 'short', 
 39:     day: 'numeric',
 40:     year: 'numeric'
 41:   });
 42: }
 43: 
 44: /**
 45:  * Formats an ISO timestamp string to a human-readable date
 46:  * @param isoString - ISO timestamp string
 47:  * @returns Formatted date string
 48:  * 
 49:  * @example
 50:  * formatISOTimestamp("2025-01-04T10:13:29.000Z") // "Jan 4, 2025"
 51:  */
 52: export function formatISOTimestamp(isoString: string): string {
 53:   const date = new Date(isoString);
 54:   return formatUnixTimestamp(Math.floor(date.getTime() / 1000));
 55: }
 56: 
 57: /**
 58:  * Truncates text to a specified length with ellipsis
 59:  * @param text - Text to truncate
 60:  * @param maxLength - Maximum length
 61:  * @returns Truncated text
 62:  */
 63: export function truncateText(text: string, maxLength: number): string {
 64:   if (text.length <= maxLength) return text;
 65:   return text.slice(0, maxLength - 3) + '...';
 66: }
 67: 
 68: /**
 69:  * Gets the first line of text
 70:  * @param text - Text to process
 71:  * @returns First line of text
 72:  */
 73: export function getFirstLine(text: string): string {
 74:   const lines = text.split('\n');
 75:   return lines[0] || '';
 76: }
 77: 
 78: // Helper functions
 79: function formatTime(date: Date): string {
 80:   return date.toLocaleTimeString('en-US', { 
 81:     hour: 'numeric', 
 82:     minute: '2-digit',
 83:     hour12: true 
 84:   });
 85: }
 86: 
 87: function isToday(date: Date): boolean {
 88:   const today = new Date();
 89:   return date.toDateString() === today.toDateString();
 90: }
 91: 
 92: function isYesterday(date: Date): boolean {
 93:   const yesterday = new Date();
 94:   yesterday.setDate(yesterday.getDate() - 1);
 95:   return date.toDateString() === yesterday.toDateString();
 96: }
 97: 
 98: function isWithinWeek(date: Date): boolean {
 99:   const weekAgo = new Date();
100:   weekAgo.setDate(weekAgo.getDate() - 7);
101:   return date > weekAgo;
102: }
103: 
104: function getDayName(date: Date): string {
105:   return date.toLocaleDateString('en-US', { weekday: 'long' });
106: }
107: 
108: /**
109:  * Formats a timestamp to a relative time string (e.g., "2 hours ago", "3 days ago")
110:  * @param timestamp - Unix timestamp in milliseconds
111:  * @returns Relative time string
112:  * 
113:  * @example
114:  * formatTimeAgo(Date.now() - 3600000) // "1 hour ago"
115:  * formatTimeAgo(Date.now() - 86400000) // "1 day ago"
116:  */
117: export function formatTimeAgo(timestamp: number): string {
118:   const now = Date.now();
119:   const diff = now - timestamp;
120:   
121:   const seconds = Math.floor(diff / 1000);
122:   const minutes = Math.floor(seconds / 60);
123:   const hours = Math.floor(minutes / 60);
124:   const days = Math.floor(hours / 24);
125:   const weeks = Math.floor(days / 7);
126:   const months = Math.floor(days / 30);
127:   const years = Math.floor(days / 365);
128:   
129:   if (years > 0) {
130:     return years === 1 ? '1 year ago' : `${years} years ago`;
131:   }
132:   if (months > 0) {
133:     return months === 1 ? '1 month ago' : `${months} months ago`;
134:   }
135:   if (weeks > 0) {
136:     return weeks === 1 ? '1 week ago' : `${weeks} weeks ago`;
137:   }
138:   if (days > 0) {
139:     return days === 1 ? '1 day ago' : `${days} days ago`;
140:   }
141:   if (hours > 0) {
142:     return hours === 1 ? '1 hour ago' : `${hours} hours ago`;
143:   }
144:   if (minutes > 0) {
145:     return minutes === 1 ? '1 minute ago' : `${minutes} minutes ago`;
146:   }
147:   if (seconds > 0) {
148:     return seconds === 1 ? '1 second ago' : `${seconds} seconds ago`;
149:   }
150:   
151:   return 'just now';
152: }
````

## File: src/lib/hooksManager.ts
````typescript
  1: /**
  2:  * Hooks configuration manager for Claude Code hooks
  3:  */
  4: 
  5: import {
  6:   HooksConfiguration,
  7:   HookMatcher,
  8:   HookValidationResult,
  9:   HookValidationError,
 10:   HookValidationWarning,
 11:   HookCommand,
 12: } from '@/types/hooks';
 13: 
 14: export class HooksManager {
 15:   /**
 16:    * Merge hooks configurations with proper priority
 17:    * Priority: local > project > user
 18:    */
 19:   static mergeConfigs(
 20:     user: HooksConfiguration,
 21:     project: HooksConfiguration,
 22:     local: HooksConfiguration
 23:   ): HooksConfiguration {
 24:     const merged: HooksConfiguration = {};
 25:     
 26:     // Events with matchers (tool-related)
 27:     const matcherEvents: (keyof HooksConfiguration)[] = ['PreToolUse', 'PostToolUse'];
 28:     
 29:     // Events without matchers (non-tool-related)
 30:     const directEvents: (keyof HooksConfiguration)[] = ['Notification', 'Stop', 'SubagentStop'];
 31: 
 32:     // Merge events with matchers
 33:     for (const event of matcherEvents) {
 34:       // Start with user hooks
 35:       let matchers = [...((user[event] as HookMatcher[] | undefined) || [])];
 36:       
 37:       // Add project hooks (may override by matcher pattern)
 38:       if (project[event]) {
 39:         matchers = this.mergeMatchers(matchers, project[event] as HookMatcher[]);
 40:       }
 41:       
 42:       // Add local hooks (highest priority)
 43:       if (local[event]) {
 44:         matchers = this.mergeMatchers(matchers, local[event] as HookMatcher[]);
 45:       }
 46:       
 47:       if (matchers.length > 0) {
 48:         (merged as any)[event] = matchers;
 49:       }
 50:     }
 51:     
 52:     // Merge events without matchers
 53:     for (const event of directEvents) {
 54:       // Combine all hooks from all levels (local takes precedence)
 55:       const hooks: HookCommand[] = [];
 56:       
 57:       // Add user hooks
 58:       if (user[event]) {
 59:         hooks.push(...(user[event] as HookCommand[]));
 60:       }
 61:       
 62:       // Add project hooks
 63:       if (project[event]) {
 64:         hooks.push(...(project[event] as HookCommand[]));
 65:       }
 66:       
 67:       // Add local hooks (highest priority)
 68:       if (local[event]) {
 69:         hooks.push(...(local[event] as HookCommand[]));
 70:       }
 71:       
 72:       if (hooks.length > 0) {
 73:         (merged as any)[event] = hooks;
 74:       }
 75:     }
 76:     
 77:     return merged;
 78:   }
 79: 
 80:   /**
 81:    * Merge matcher arrays, with later items taking precedence
 82:    */
 83:   private static mergeMatchers(
 84:     base: HookMatcher[],
 85:     override: HookMatcher[]
 86:   ): HookMatcher[] {
 87:     const result = [...base];
 88:     
 89:     for (const overrideMatcher of override) {
 90:       const existingIndex = result.findIndex(
 91:         m => m.matcher === overrideMatcher.matcher
 92:       );
 93:       
 94:       if (existingIndex >= 0) {
 95:         // Replace existing matcher
 96:         result[existingIndex] = overrideMatcher;
 97:       } else {
 98:         // Add new matcher
 99:         result.push(overrideMatcher);
100:       }
101:     }
102:     
103:     return result;
104:   }
105: 
106:   /**
107:    * Validate hooks configuration
108:    */
109:   static async validateConfig(hooks: HooksConfiguration): Promise<HookValidationResult> {
110:     const errors: HookValidationError[] = [];
111:     const warnings: HookValidationWarning[] = [];
112: 
113:     // Guard against undefined or null hooks
114:     if (!hooks) {
115:       return { valid: true, errors, warnings };
116:     }
117: 
118:     // Events with matchers
119:     const matcherEvents = ['PreToolUse', 'PostToolUse'] as const;
120:     
121:     // Events without matchers
122:     const directEvents = ['Notification', 'Stop', 'SubagentStop'] as const;
123: 
124:     // Validate events with matchers
125:     for (const event of matcherEvents) {
126:       const matchers = hooks[event];
127:       if (!matchers || !Array.isArray(matchers)) continue;
128: 
129:       for (const matcher of matchers) {
130:         // Validate regex pattern if provided
131:         if (matcher.matcher) {
132:           try {
133:             new RegExp(matcher.matcher);
134:           } catch (e) {
135:             errors.push({
136:               event,
137:               matcher: matcher.matcher,
138:               message: `Invalid regex pattern: ${e instanceof Error ? e.message : 'Unknown error'}`
139:             });
140:           }
141:         }
142: 
143:         // Validate commands
144:         if (matcher.hooks && Array.isArray(matcher.hooks)) {
145:           for (const hook of matcher.hooks) {
146:             if (!hook.command || !hook.command.trim()) {
147:               errors.push({
148:                 event,
149:                 matcher: matcher.matcher,
150:                 message: 'Empty command'
151:               });
152:             }
153: 
154:             // Check for dangerous patterns
155:             const dangers = this.checkDangerousPatterns(hook.command || '');
156:             warnings.push(...dangers.map(d => ({
157:               event,
158:               matcher: matcher.matcher,
159:               command: hook.command || '',
160:               message: d
161:             })));
162:           }
163:         }
164:       }
165:     }
166: 
167:     // Validate events without matchers
168:     for (const event of directEvents) {
169:       const directHooks = hooks[event];
170:       if (!directHooks || !Array.isArray(directHooks)) continue;
171: 
172:       for (const hook of directHooks) {
173:         if (!hook.command || !hook.command.trim()) {
174:           errors.push({
175:             event,
176:             message: 'Empty command'
177:           });
178:         }
179: 
180:         // Check for dangerous patterns
181:         const dangers = this.checkDangerousPatterns(hook.command || '');
182:         warnings.push(...dangers.map(d => ({
183:           event,
184:           command: hook.command || '',
185:           message: d
186:         })));
187:       }
188:     }
189: 
190:     return { valid: errors.length === 0, errors, warnings };
191:   }
192: 
193:   /**
194:    * Check for potentially dangerous command patterns
195:    */
196:   public static checkDangerousPatterns(command: string): string[] {
197:     const warnings: string[] = [];
198:     
199:     // Guard against undefined or null commands
200:     if (!command || typeof command !== 'string') {
201:       return warnings;
202:     }
203:     
204:     const patterns = [
205:       { pattern: /rm\s+-rf\s+\/(?:\s|$)/, message: 'Destructive command on root directory' },
206:       { pattern: /rm\s+-rf\s+~/, message: 'Destructive command on home directory' },
207:       { pattern: /:\s*\(\s*\)\s*\{.*\}\s*;/, message: 'Fork bomb pattern detected' },
208:       { pattern: /curl.*\|\s*(?:bash|sh)/, message: 'Downloading and executing remote code' },
209:       { pattern: /wget.*\|\s*(?:bash|sh)/, message: 'Downloading and executing remote code' },
210:       { pattern: />\/dev\/sda/, message: 'Direct disk write operation' },
211:       { pattern: /sudo\s+/, message: 'Elevated privileges required' },
212:       { pattern: /dd\s+.*of=\/dev\//, message: 'Dangerous disk operation' },
213:       { pattern: /mkfs\./, message: 'Filesystem formatting command' },
214:       { pattern: /:(){ :|:& };:/, message: 'Fork bomb detected' },
215:     ];
216: 
217:     for (const { pattern, message } of patterns) {
218:       if (pattern.test(command)) {
219:         warnings.push(message);
220:       }
221:     }
222: 
223:     // Check for unescaped variables that could lead to code injection
224:     if (command.includes('$') && !command.includes('"$')) {
225:       warnings.push('Unquoted shell variable detected - potential code injection risk');
226:     }
227: 
228:     return warnings;
229:   }
230: 
231:   /**
232:    * Escape a command for safe shell execution
233:    */
234:   static escapeCommand(command: string): string {
235:     // Basic shell escaping - in production, use a proper shell escaping library
236:     return command
237:       .replace(/\\/g, '\\\\')
238:       .replace(/"/g, '\\"')
239:       .replace(/\$/g, '\\$')
240:       .replace(/`/g, '\\`');
241:   }
242: 
243:   /**
244:    * Generate a unique ID for hooks/matchers/commands
245:    */
246:   static generateId(): string {
247:     return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
248:   }
249: }
````

## File: src/lib/linkDetector.tsx
````typescript
  1: /**
  2:  * URL Detection utility for terminal output
  3:  * Detects various URL formats including localhost addresses
  4:  */
  5: 
  6: import React from 'react';
  7: 
  8: // URL regex pattern that matches:
  9: // - http:// and https:// URLs
 10: // - localhost URLs with ports
 11: // - IP addresses with ports
 12: // - URLs with paths and query parameters
 13: const URL_REGEX = /(?:https?:\/\/)?(?:localhost|127\.0\.0\.1|0\.0\.0\.0|\[[0-9a-fA-F:]+\]|(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,})(?::[0-9]+)?(?:\/[^\s]*)?/gi;
 14: 
 15: // More specific localhost pattern for better accuracy
 16: const LOCALHOST_REGEX = /(?:https?:\/\/)?(?:localhost|127\.0\.0\.1|0\.0\.0\.0|\[::1\])(?::[0-9]+)?(?:\/[^\s]*)?/gi;
 17: 
 18: export interface DetectedLink {
 19:   url: string;
 20:   fullUrl: string; // URL with protocol
 21:   isLocalhost: boolean;
 22:   startIndex: number;
 23:   endIndex: number;
 24: }
 25: 
 26: /**
 27:  * Detects URLs in the given text
 28:  * @param text - The text to search for URLs
 29:  * @returns Array of detected links
 30:  */
 31: export function detectLinks(text: string): DetectedLink[] {
 32:   const links: DetectedLink[] = [];
 33:   const seenUrls = new Set<string>();
 34:   
 35:   // Reset regex lastIndex
 36:   URL_REGEX.lastIndex = 0;
 37:   
 38:   let match;
 39:   while ((match = URL_REGEX.exec(text)) !== null) {
 40:     const url = match[0];
 41:     
 42:     // Skip if we've already seen this URL
 43:     if (seenUrls.has(url)) continue;
 44:     seenUrls.add(url);
 45:     
 46:     // Ensure the URL has a protocol
 47:     let fullUrl = url;
 48:     if (!url.match(/^https?:\/\//)) {
 49:       // Default to http for localhost, https for others
 50:       const isLocalhost = LOCALHOST_REGEX.test(url);
 51:       fullUrl = `${isLocalhost ? 'http' : 'https'}://${url}`;
 52:     }
 53:     
 54:     // Validate the URL
 55:     try {
 56:       new URL(fullUrl);
 57:     } catch {
 58:       // Invalid URL, skip
 59:       continue;
 60:     }
 61:     
 62:     links.push({
 63:       url,
 64:       fullUrl,
 65:       isLocalhost: LOCALHOST_REGEX.test(url),
 66:       startIndex: match.index,
 67:       endIndex: match.index + url.length
 68:     });
 69:   }
 70:   
 71:   return links;
 72: }
 73: 
 74: /**
 75:  * Checks if a text contains any URLs
 76:  * @param text - The text to check
 77:  * @returns True if URLs are found
 78:  */
 79: export function hasLinks(text: string): boolean {
 80:   URL_REGEX.lastIndex = 0;
 81:   return URL_REGEX.test(text);
 82: }
 83: 
 84: /**
 85:  * Extracts the first URL from text
 86:  * @param text - The text to search
 87:  * @returns The first detected link or null
 88:  */
 89: export function getFirstLink(text: string): DetectedLink | null {
 90:   const links = detectLinks(text);
 91:   return links.length > 0 ? links[0] : null;
 92: }
 93: 
 94: /**
 95:  * Makes URLs in text clickable by wrapping them in a callback
 96:  * @param text - The text containing URLs
 97:  * @param onLinkClick - Callback when a link is clicked
 98:  * @returns React elements with clickable links
 99:  */
100: export function makeLinksClickable(
101:   text: string,
102:   onLinkClick: (url: string) => void
103: ): React.ReactNode[] {
104:   const links = detectLinks(text);
105:   
106:   if (links.length === 0) {
107:     return [text];
108:   }
109:   
110:   const elements: React.ReactNode[] = [];
111:   let lastIndex = 0;
112:   
113:   links.forEach((link, index) => {
114:     // Add text before the link
115:     if (link.startIndex > lastIndex) {
116:       elements.push(text.substring(lastIndex, link.startIndex));
117:     }
118:     
119:     // Add the clickable link
120:     elements.push(
121:       <a
122:         key={`link-${index}`}
123:         href={link.fullUrl}
124:         onClick={(e) => {
125:           e.preventDefault();
126:           onLinkClick(link.fullUrl);
127:         }}
128:         className="text-primary underline hover:text-primary/80 cursor-pointer"
129:         title={link.fullUrl}
130:       >
131:         {link.url}
132:       </a>
133:     );
134:     
135:     lastIndex = link.endIndex;
136:   });
137:   
138:   // Add remaining text
139:   if (lastIndex < text.length) {
140:     elements.push(text.substring(lastIndex));
141:   }
142:   
143:   return elements;
144: }
````

## File: src/lib/outputCache.tsx
````typescript
  1: import React, { createContext, useContext, useState, useCallback, useEffect } from 'react';
  2: import { api } from './api';
  3: 
  4: // Use the same message interface as AgentExecution for consistency
  5: export interface ClaudeStreamMessage {
  6:   type: "system" | "assistant" | "user" | "result";
  7:   subtype?: string;
  8:   message?: {
  9:     content?: any[];
 10:     usage?: {
 11:       input_tokens: number;
 12:       output_tokens: number;
 13:     };
 14:   };
 15:   usage?: {
 16:     input_tokens: number;
 17:     output_tokens: number;
 18:   };
 19:   [key: string]: any;
 20: }
 21: 
 22: interface CachedSessionOutput {
 23:   output: string;
 24:   messages: ClaudeStreamMessage[];
 25:   lastUpdated: number;
 26:   status: string;
 27: }
 28: 
 29: interface OutputCacheContextType {
 30:   getCachedOutput: (sessionId: number) => CachedSessionOutput | null;
 31:   setCachedOutput: (sessionId: number, data: CachedSessionOutput) => void;
 32:   updateSessionStatus: (sessionId: number, status: string) => void;
 33:   clearCache: (sessionId?: number) => void;
 34:   isPolling: boolean;
 35:   startBackgroundPolling: () => void;
 36:   stopBackgroundPolling: () => void;
 37: }
 38: 
 39: const OutputCacheContext = createContext<OutputCacheContextType | null>(null);
 40: 
 41: export function useOutputCache() {
 42:   const context = useContext(OutputCacheContext);
 43:   if (!context) {
 44:     throw new Error('useOutputCache must be used within an OutputCacheProvider');
 45:   }
 46:   return context;
 47: }
 48: 
 49: interface OutputCacheProviderProps {
 50:   children: React.ReactNode;
 51: }
 52: 
 53: export function OutputCacheProvider({ children }: OutputCacheProviderProps) {
 54:   const [cache, setCache] = useState<Map<number, CachedSessionOutput>>(new Map());
 55:   const [isPolling, setIsPolling] = useState(false);
 56:   const [pollingInterval, setPollingInterval] = useState<NodeJS.Timeout | null>(null);
 57: 
 58:   const getCachedOutput = useCallback((sessionId: number): CachedSessionOutput | null => {
 59:     return cache.get(sessionId) || null;
 60:   }, [cache]);
 61: 
 62:   const setCachedOutput = useCallback((sessionId: number, data: CachedSessionOutput) => {
 63:     setCache(prev => new Map(prev.set(sessionId, data)));
 64:   }, []);
 65: 
 66:   const updateSessionStatus = useCallback((sessionId: number, status: string) => {
 67:     setCache(prev => {
 68:       const existing = prev.get(sessionId);
 69:       if (existing) {
 70:         const updated = new Map(prev);
 71:         updated.set(sessionId, { ...existing, status });
 72:         return updated;
 73:       }
 74:       return prev;
 75:     });
 76:   }, []);
 77: 
 78:   const clearCache = useCallback((sessionId?: number) => {
 79:     if (sessionId) {
 80:       setCache(prev => {
 81:         const updated = new Map(prev);
 82:         updated.delete(sessionId);
 83:         return updated;
 84:       });
 85:     } else {
 86:       setCache(new Map());
 87:     }
 88:   }, []);
 89: 
 90:   const parseOutput = useCallback((rawOutput: string): ClaudeStreamMessage[] => {
 91:     if (!rawOutput) return [];
 92: 
 93:     const lines = rawOutput.split('\n').filter(line => line.trim());
 94:     const parsedMessages: ClaudeStreamMessage[] = [];
 95: 
 96:     for (const line of lines) {
 97:       try {
 98:         const message = JSON.parse(line) as ClaudeStreamMessage;
 99:         parsedMessages.push(message);
100:       } catch (err) {
101:         console.error("Failed to parse message:", err, line);
102:         // Add a fallback message for unparseable content
103:         parsedMessages.push({
104:           type: 'result',
105:           subtype: 'error',
106:           error: 'Failed to parse message',
107:           raw_content: line
108:         });
109:       }
110:     }
111: 
112:     return parsedMessages;
113:   }, []);
114: 
115:   const updateSessionCache = useCallback(async (sessionId: number, status: string) => {
116:     try {
117:       const rawOutput = await api.getSessionOutput(sessionId);
118:       const messages = parseOutput(rawOutput);
119:       
120:       setCachedOutput(sessionId, {
121:         output: rawOutput,
122:         messages,
123:         lastUpdated: Date.now(),
124:         status
125:       });
126:     } catch (error) {
127:       console.warn(`Failed to update cache for session ${sessionId}:`, error);
128:     }
129:   }, [parseOutput, setCachedOutput]);
130: 
131:   const pollRunningSessions = useCallback(async () => {
132:     try {
133:       const runningSessions = await api.listRunningAgentSessions();
134:       
135:       // Update cache for all running sessions
136:       for (const session of runningSessions) {
137:         if (session.id && session.status === 'running') {
138:           await updateSessionCache(session.id, session.status);
139:         }
140:       }
141: 
142:       // Clean up cache for sessions that are no longer running
143:       const runningIds = new Set(runningSessions.map(s => s.id).filter(Boolean));
144:       setCache(prev => {
145:         const updated = new Map();
146:         for (const [sessionId, data] of prev) {
147:           if (runningIds.has(sessionId) || data.status !== 'running') {
148:             updated.set(sessionId, data);
149:           }
150:         }
151:         return updated;
152:       });
153:     } catch (error) {
154:       console.warn('Failed to poll running sessions:', error);
155:     }
156:   }, [updateSessionCache]);
157: 
158:   const startBackgroundPolling = useCallback(() => {
159:     if (pollingInterval) return;
160: 
161:     setIsPolling(true);
162:     const interval = setInterval(pollRunningSessions, 3000); // Poll every 3 seconds
163:     setPollingInterval(interval);
164:   }, [pollingInterval, pollRunningSessions]);
165: 
166:   const stopBackgroundPolling = useCallback(() => {
167:     if (pollingInterval) {
168:       clearInterval(pollingInterval);
169:       setPollingInterval(null);
170:     }
171:     setIsPolling(false);
172:   }, [pollingInterval]);
173: 
174:   // Auto-start polling when provider mounts
175:   useEffect(() => {
176:     startBackgroundPolling();
177:     return () => stopBackgroundPolling();
178:   }, [startBackgroundPolling, stopBackgroundPolling]);
179: 
180:   const value: OutputCacheContextType = {
181:     getCachedOutput,
182:     setCachedOutput,
183:     updateSessionStatus,
184:     clearCache,
185:     isPolling,
186:     startBackgroundPolling,
187:     stopBackgroundPolling,
188:   };
189: 
190:   return (
191:     <OutputCacheContext.Provider value={value}>
192:       {children}
193:     </OutputCacheContext.Provider>
194:   );
195: }
````

## File: src/lib/utils.ts
````typescript
 1: import { type ClassValue, clsx } from "clsx";
 2: import { twMerge } from "tailwind-merge";
 3: 
 4: /**
 5:  * Combines multiple class values into a single string using clsx and tailwind-merge.
 6:  * This utility function helps manage dynamic class names and prevents Tailwind CSS conflicts.
 7:  * 
 8:  * @param inputs - Array of class values that can be strings, objects, arrays, etc.
 9:  * @returns A merged string of class names with Tailwind conflicts resolved
10:  * 
11:  * @example
12:  * cn("px-2 py-1", condition && "bg-blue-500", { "text-white": isActive })
13:  * // Returns: "px-2 py-1 bg-blue-500 text-white" (when condition and isActive are true)
14:  */
15: export function cn(...inputs: ClassValue[]) {
16:   return twMerge(clsx(inputs));
17: }
````

## File: src/stores/agentStore.ts
````typescript
  1: import { create } from 'zustand';
  2: import { subscribeWithSelector } from 'zustand/middleware';
  3: import type { StateCreator } from 'zustand';
  4: import { api } from '@/lib/api';
  5: import type { AgentRunWithMetrics } from '@/lib/api';
  6: 
  7: interface AgentState {
  8:   // Agent runs data
  9:   agentRuns: AgentRunWithMetrics[];
 10:   runningAgents: Set<string>;
 11:   sessionOutputs: Record<string, string>;
 12:   
 13:   // UI state
 14:   isLoadingRuns: boolean;
 15:   isLoadingOutput: boolean;
 16:   error: string | null;
 17:   lastFetchTime: number;
 18:   
 19:   // Actions
 20:   fetchAgentRuns: (forceRefresh?: boolean) => Promise<void>;
 21:   fetchSessionOutput: (runId: number) => Promise<void>;
 22:   createAgentRun: (data: { agentId: number; projectPath: string; task: string; model?: string }) => Promise<AgentRunWithMetrics>;
 23:   cancelAgentRun: (runId: number) => Promise<void>;
 24:   deleteAgentRun: (runId: number) => Promise<void>;
 25:   clearError: () => void;
 26:   
 27:   // Real-time updates
 28:   handleAgentRunUpdate: (run: AgentRunWithMetrics) => void;
 29:   
 30:   // Polling management
 31:   startPolling: (interval?: number) => void;
 32:   stopPolling: () => void;
 33:   pollingInterval: NodeJS.Timeout | null;
 34: }
 35: 
 36: const agentStore: StateCreator<
 37:   AgentState,
 38:   [],
 39:   [['zustand/subscribeWithSelector', never]],
 40:   AgentState
 41: > = (set, get) => ({
 42:     // Initial state
 43:     agentRuns: [],
 44:     runningAgents: new Set(),
 45:     sessionOutputs: {},
 46:     isLoadingRuns: false,
 47:     isLoadingOutput: false,
 48:     error: null,
 49:     lastFetchTime: 0,
 50:     pollingInterval: null,
 51:     
 52:     // Fetch agent runs with caching
 53:     fetchAgentRuns: async (forceRefresh = false) => {
 54:       const now = Date.now();
 55:       const { lastFetchTime } = get();
 56:       
 57:       // Cache for 5 seconds unless forced
 58:       if (!forceRefresh && now - lastFetchTime < 5000) {
 59:         return;
 60:       }
 61:       
 62:       set({ isLoadingRuns: true, error: null });
 63:       
 64:       try {
 65:         const runs = await api.listAgentRuns();
 66:         const runningIds = runs
 67:           .filter((r) => r.status === 'running' || r.status === 'pending')
 68:           .map((r) => r.id?.toString() || '')
 69:           .filter(Boolean);
 70:         
 71:         set({
 72:           agentRuns: runs,
 73:           runningAgents: new Set(runningIds),
 74:           isLoadingRuns: false,
 75:           lastFetchTime: now
 76:         });
 77:       } catch (error) {
 78:         set({
 79:           error: error instanceof Error ? error.message : 'Failed to fetch agent runs',
 80:           isLoadingRuns: false
 81:         });
 82:       }
 83:     },
 84:     
 85:     // Fetch session output for a specific run
 86:     fetchSessionOutput: async (runId: number) => {
 87:       set({ isLoadingOutput: true, error: null });
 88:       
 89:       try {
 90:         const output = await api.getAgentRunWithRealTimeMetrics(runId).then(run => run.output || '');
 91:         set((state) => ({
 92:           sessionOutputs: {
 93:             ...state.sessionOutputs,
 94:             [runId]: output
 95:           },
 96:           isLoadingOutput: false
 97:         }));
 98:       } catch (error) {
 99:         set({
100:           error: error instanceof Error ? error.message : 'Failed to fetch session output',
101:           isLoadingOutput: false
102:         });
103:       }
104:     },
105:     
106:     // Create a new agent run
107:     createAgentRun: async (data: { agentId: number; projectPath: string; task: string; model?: string }) => {
108:       try {
109:         const runId = await api.executeAgent(data.agentId, data.projectPath, data.task, data.model);
110:         
111:         // Fetch the created run details
112:         const run = await api.getAgentRun(runId);
113:         
114:         // Update local state immediately
115:         set((state) => ({
116:           agentRuns: [run, ...state.agentRuns],
117:           runningAgents: new Set([...state.runningAgents, runId.toString()])
118:         }));
119:         
120:         return run;
121:       } catch (error) {
122:         set({
123:           error: error instanceof Error ? error.message : 'Failed to create agent run'
124:         });
125:         throw error;
126:       }
127:     },
128:     
129:     // Cancel an agent run
130:     cancelAgentRun: async (runId: number) => {
131:       try {
132:         await api.killAgentSession(runId);
133:         
134:         // Update local state
135:         set((state) => ({
136:           agentRuns: state.agentRuns.map((r) =>
137:             r.id === runId ? { ...r, status: 'cancelled' } : r
138:           ),
139:           runningAgents: new Set(
140:             [...state.runningAgents].filter(id => id !== runId.toString())
141:           )
142:         }));
143:       } catch (error) {
144:         set({
145:           error: error instanceof Error ? error.message : 'Failed to cancel agent run'
146:         });
147:         throw error;
148:       }
149:     },
150:     
151:     // Delete an agent run
152:     deleteAgentRun: async (runId: number) => {
153:       try {
154:         // First ensure the run is cancelled if it's still running
155:         const run = get().agentRuns.find((r) => r.id === runId);
156:         if (run && (run.status === 'running' || run.status === 'pending')) {
157:           await api.killAgentSession(runId);
158:         }
159:         
160:         // Note: There's no deleteAgentRun API method, so we just remove from local state
161:         // The run will remain in the database but won't be shown in the UI
162:         
163:         // Update local state
164:         set((state) => ({
165:           agentRuns: state.agentRuns.filter((r) => r.id !== runId),
166:           runningAgents: new Set(
167:             [...state.runningAgents].filter(id => id !== runId.toString())
168:           ),
169:           sessionOutputs: Object.fromEntries(
170:             Object.entries(state.sessionOutputs).filter(([id]) => id !== runId.toString())
171:           )
172:         }));
173:       } catch (error) {
174:         set({
175:           error: error instanceof Error ? error.message : 'Failed to delete agent run'
176:         });
177:         throw error;
178:       }
179:     },
180:     
181:     // Clear error
182:     clearError: () => set({ error: null }),
183:     
184:     // Handle real-time agent run updates
185:     handleAgentRunUpdate: (run: AgentRunWithMetrics) => {
186:       set((state) => {
187:         const existingIndex = state.agentRuns.findIndex((r) => r.id === run.id);
188:         const updatedRuns = [...state.agentRuns];
189:         
190:         if (existingIndex >= 0) {
191:           updatedRuns[existingIndex] = run;
192:         } else {
193:           updatedRuns.unshift(run);
194:         }
195:         
196:         const runningIds = updatedRuns
197:           .filter((r) => r.status === 'running' || r.status === 'pending')
198:           .map((r) => r.id?.toString() || '')
199:           .filter(Boolean);
200:         
201:         return {
202:           agentRuns: updatedRuns,
203:           runningAgents: new Set(runningIds)
204:         };
205:       });
206:     },
207:     
208:     // Start polling for updates
209:     startPolling: (interval = 3000) => {
210:       const { pollingInterval, stopPolling } = get();
211:       
212:       // Clear existing interval
213:       if (pollingInterval) {
214:         stopPolling();
215:       }
216:       
217:       // Start new interval
218:       const newInterval = setInterval(() => {
219:         const { runningAgents } = get();
220:         if (runningAgents.size > 0) {
221:           get().fetchAgentRuns();
222:         }
223:       }, interval);
224:       
225:       set({ pollingInterval: newInterval });
226:     },
227:     
228:     // Stop polling
229:     stopPolling: () => {
230:       const { pollingInterval } = get();
231:       if (pollingInterval) {
232:         clearInterval(pollingInterval);
233:         set({ pollingInterval: null });
234:       }
235:     }
236:   });
237: 
238: export const useAgentStore = create<AgentState>()(
239:   subscribeWithSelector(agentStore)
240: );
````

## File: src/stores/README.md
````markdown
 1: # Store Implementation Notes
 2: 
 3: The store files (`sessionStore.ts` and `agentStore.ts`) provide examples of how to implement global state management with Zustand for the Claudia application.
 4: 
 5: ## Key Benefits:
 6: - Eliminates prop drilling across components
 7: - Centralizes state management
 8: - Provides optimized selectors for performance
 9: - Handles real-time updates efficiently
10: 
11: ## Implementation Status:
12: These stores are example implementations that would need to be adapted to match the actual API interface. The current API in `lib/api.ts` has different method names and signatures than what was assumed in the store implementations.
13: 
14: ## To Complete Implementation:
15: 1. Update the store methods to match actual API methods
16: 2. Add proper TypeScript types from the API
17: 3. Implement WebSocket/SSE for real-time updates
18: 4. Connect stores to components using the custom selectors
19: 
20: ## Example Usage:
21: ```typescript
22: import { useSessionStore } from '@/stores/sessionStore';
23: 
24: function MyComponent() {
25:   const { sessions, fetchSessions } = useSessionStore();
26:   
27:   useEffect(() => {
28:     fetchSessions();
29:   }, []);
30:   
31:   return <div>{sessions.length} sessions</div>;
32: }
33: ```
````

## File: src/stores/sessionStore.ts
````typescript
  1: import { create } from 'zustand';
  2: import { subscribeWithSelector } from 'zustand/middleware';
  3: import type { StateCreator } from 'zustand';
  4: import { api } from '@/lib/api';
  5: import type { Session, Project } from '@/lib/api';
  6: 
  7: interface SessionState {
  8:   // Projects and sessions data
  9:   projects: Project[];
 10:   sessions: Record<string, Session[]>; // Keyed by projectId
 11:   currentSessionId: string | null;
 12:   currentSession: Session | null;
 13:   sessionOutputs: Record<string, string>; // Keyed by sessionId
 14:   
 15:   // UI state
 16:   isLoadingProjects: boolean;
 17:   isLoadingSessions: boolean;
 18:   isLoadingOutputs: boolean;
 19:   error: string | null;
 20:   
 21:   // Actions
 22:   fetchProjects: () => Promise<void>;
 23:   fetchProjectSessions: (projectId: string) => Promise<void>;
 24:   setCurrentSession: (sessionId: string | null) => void;
 25:   fetchSessionOutput: (sessionId: string) => Promise<void>;
 26:   deleteSession: (sessionId: string, projectId: string) => Promise<void>;
 27:   clearError: () => void;
 28:   
 29:   // Real-time updates
 30:   handleSessionUpdate: (session: Session) => void;
 31:   handleOutputUpdate: (sessionId: string, output: string) => void;
 32: }
 33: 
 34: const sessionStore: StateCreator<
 35:   SessionState,
 36:   [],
 37:   [['zustand/subscribeWithSelector', never]],
 38:   SessionState
 39: > = (set, get) => ({
 40:     // Initial state
 41:     projects: [],
 42:     sessions: {},
 43:     currentSessionId: null,
 44:     currentSession: null,
 45:     sessionOutputs: {},
 46:     isLoadingProjects: false,
 47:     isLoadingSessions: false,
 48:     isLoadingOutputs: false,
 49:     error: null,
 50:     
 51:     // Fetch all projects
 52:     fetchProjects: async () => {
 53:       set({ isLoadingProjects: true, error: null });
 54:       try {
 55:         const projects = await api.listProjects();
 56:         set({ projects, isLoadingProjects: false });
 57:       } catch (error) {
 58:         set({ 
 59:           error: error instanceof Error ? error.message : 'Failed to fetch projects',
 60:           isLoadingProjects: false 
 61:         });
 62:       }
 63:     },
 64:     
 65:     // Fetch sessions for a specific project
 66:     fetchProjectSessions: async (projectId: string) => {
 67:       set({ isLoadingSessions: true, error: null });
 68:       try {
 69:         const projectSessions = await api.getProjectSessions(projectId);
 70:         set((state) => ({
 71:           sessions: {
 72:             ...state.sessions,
 73:             [projectId]: projectSessions
 74:           },
 75:           isLoadingSessions: false
 76:         }));
 77:       } catch (error) {
 78:         set({ 
 79:           error: error instanceof Error ? error.message : 'Failed to fetch sessions',
 80:           isLoadingSessions: false 
 81:         });
 82:       }
 83:     },
 84:     
 85:     // Set current session
 86:     setCurrentSession: (sessionId: string | null) => {
 87:       const { sessions } = get();
 88:       let currentSession: Session | null = null;
 89:       
 90:       if (sessionId) {
 91:         // Find session across all projects
 92:         for (const projectSessions of Object.values(sessions)) {
 93:           const found = projectSessions.find((s) => s.id === sessionId);
 94:           if (found) {
 95:             currentSession = found;
 96:             break;
 97:           }
 98:         }
 99:       }
100:       
101:       set({ currentSessionId: sessionId, currentSession });
102:     },
103:     
104:     // Fetch session output
105:     fetchSessionOutput: async (sessionId: string) => {
106:       set({ isLoadingOutputs: true, error: null });
107:       try {
108:         const output = await api.getClaudeSessionOutput(sessionId);
109:         set((state) => ({
110:           sessionOutputs: {
111:             ...state.sessionOutputs,
112:             [sessionId]: output
113:           },
114:           isLoadingOutputs: false
115:         }));
116:       } catch (error) {
117:         set({ 
118:           error: error instanceof Error ? error.message : 'Failed to fetch session output',
119:           isLoadingOutputs: false 
120:         });
121:       }
122:     },
123:     
124:     // Delete session
125:     deleteSession: async (sessionId: string, projectId: string) => {
126:       try {
127:         // Note: API doesn't have a deleteSession method, so this is a placeholder
128:         console.warn('deleteSession not implemented in API');
129:         
130:         // Update local state
131:         set((state) => ({
132:           sessions: {
133:             ...state.sessions,
134:             [projectId]: state.sessions[projectId]?.filter((s) => s.id !== sessionId) || []
135:           },
136:           currentSessionId: state.currentSessionId === sessionId ? null : state.currentSessionId,
137:           currentSession: state.currentSession?.id === sessionId ? null : state.currentSession,
138:           sessionOutputs: Object.fromEntries(
139:             Object.entries(state.sessionOutputs).filter(([id]) => id !== sessionId)
140:           )
141:         }));
142:       } catch (error) {
143:         set({ 
144:           error: error instanceof Error ? error.message : 'Failed to delete session'
145:         });
146:         throw error;
147:       }
148:     },
149:     
150:     // Clear error
151:     clearError: () => set({ error: null }),
152:     
153:     // Handle session update
154:     handleSessionUpdate: (session: Session) => {
155:       set(state => {
156:         const projectId = session.project_id;
157:         const projectSessions = state.sessions[projectId] || [];
158:         const existingIndex = projectSessions.findIndex((s) => s.id === session.id);
159:         
160:         let updatedSessions;
161:         if (existingIndex >= 0) {
162:           updatedSessions = [...projectSessions];
163:           updatedSessions[existingIndex] = session;
164:         } else {
165:           updatedSessions = [session, ...projectSessions];
166:         }
167:         
168:         return {
169:           sessions: {
170:             ...state.sessions,
171:             [projectId]: updatedSessions
172:           },
173:           currentSession: state.currentSessionId === session.id ? session : state.currentSession
174:         };
175:       });
176:     },
177:     
178:     // Handle output update
179:     handleOutputUpdate: (sessionId: string, output: string) => {
180:       set((state) => ({
181:         sessionOutputs: {
182:           ...state.sessionOutputs,
183:           [sessionId]: output
184:         }
185:       }));
186:     }
187:   });
188: 
189: export const useSessionStore = create<SessionState>()(
190:   subscribeWithSelector(sessionStore)
191: );
````

## File: src/types/hooks.ts
````typescript
  1: /**
  2:  * Types for Claude Code hooks configuration
  3:  */
  4: 
  5: export interface HookCommand {
  6:   type: 'command';
  7:   command: string;
  8:   timeout?: number; // Optional timeout in seconds (default: 60)
  9: }
 10: 
 11: export interface HookMatcher {
 12:   matcher?: string; // Pattern to match tool names (regex supported)
 13:   hooks: HookCommand[];
 14: }
 15: 
 16: export interface HooksConfiguration {
 17:   PreToolUse?: HookMatcher[];
 18:   PostToolUse?: HookMatcher[];
 19:   Notification?: HookCommand[];
 20:   Stop?: HookCommand[];
 21:   SubagentStop?: HookCommand[];
 22: }
 23: 
 24: export type HookEvent = keyof HooksConfiguration;
 25: 
 26: export interface ClaudeSettingsWithHooks {
 27:   hooks?: HooksConfiguration;
 28:   [key: string]: any;
 29: }
 30: 
 31: export interface HookValidationError {
 32:   event: string;
 33:   matcher?: string;
 34:   command?: string;
 35:   message: string;
 36: }
 37: 
 38: export interface HookValidationWarning {
 39:   event: string;
 40:   matcher?: string;
 41:   command: string;
 42:   message: string;
 43: }
 44: 
 45: export interface HookValidationResult {
 46:   valid: boolean;
 47:   errors: HookValidationError[];
 48:   warnings: HookValidationWarning[];
 49: }
 50: 
 51: export type HookScope = 'user' | 'project' | 'local';
 52: 
 53: // Common tool matchers for autocomplete
 54: export const COMMON_TOOL_MATCHERS = [
 55:   'Task',
 56:   'Bash',
 57:   'Glob',
 58:   'Grep',
 59:   'Read',
 60:   'Edit',
 61:   'MultiEdit',
 62:   'Write',
 63:   'WebFetch',
 64:   'WebSearch',
 65:   'Notebook.*',
 66:   'Edit|Write',
 67:   'mcp__.*',
 68:   'mcp__memory__.*',
 69:   'mcp__filesystem__.*',
 70:   'mcp__github__.*',
 71: ];
 72: 
 73: // Hook templates
 74: export interface HookTemplate {
 75:   id: string;
 76:   name: string;
 77:   description: string;
 78:   event: HookEvent;
 79:   matcher?: string;
 80:   commands: string[];
 81: }
 82: 
 83: export const HOOK_TEMPLATES: HookTemplate[] = [
 84:   {
 85:     id: 'log-bash-commands',
 86:     name: 'Log Shell Commands',
 87:     description: 'Log all bash commands to a file for auditing',
 88:     event: 'PreToolUse',
 89:     matcher: 'Bash',
 90:     commands: ['jq -r \'"\(.tool_input.command) - \(.tool_input.description // "No description")"\' >> ~/.claude/bash-command-log.txt']
 91:   },
 92:   {
 93:     id: 'format-on-save',
 94:     name: 'Auto-format Code',
 95:     description: 'Run code formatters after file modifications',
 96:     event: 'PostToolUse',
 97:     matcher: 'Write|Edit|MultiEdit',
 98:     commands: [
 99:       'if [[ "$( jq -r .tool_input.file_path )" =~ \\.(ts|tsx|js|jsx)$ ]]; then prettier --write "$( jq -r .tool_input.file_path )"; fi',
100:       'if [[ "$( jq -r .tool_input.file_path )" =~ \\.go$ ]]; then gofmt -w "$( jq -r .tool_input.file_path )"; fi'
101:     ]
102:   },
103:   {
104:     id: 'git-commit-guard',
105:     name: 'Protect Main Branch',
106:     description: 'Prevent direct commits to main/master branch',
107:     event: 'PreToolUse',
108:     matcher: 'Bash',
109:     commands: ['if [[ "$(jq -r .tool_input.command)" =~ "git commit" ]] && [[ "$(git branch --show-current 2>/dev/null)" =~ ^(main|master)$ ]]; then echo "Direct commits to main/master branch are not allowed"; exit 2; fi']
110:   },
111:   {
112:     id: 'custom-notification',
113:     name: 'Custom Notifications',
114:     description: 'Send custom notifications when Claude needs attention',
115:     event: 'Notification',
116:     commands: ['osascript -e "display notification \\"$(jq -r .message)\\" with title \\"$(jq -r .title)\\" sound name \\"Glass\\""']
117:   },
118:   {
119:     id: 'continue-on-tests',
120:     name: 'Auto-continue on Test Success',
121:     description: 'Automatically continue when tests pass',
122:     event: 'Stop',
123:     commands: ['if grep -q "All tests passed" "$( jq -r .transcript_path )"; then echo \'{"decision": "block", "reason": "All tests passed. Continue with next task."}\'; fi']
124:   }
125: ];
````

## File: src/App.tsx
````typescript
  1: import { useState, useEffect } from "react";
  2: import { motion, AnimatePresence } from "framer-motion";
  3: import { Plus, Loader2, Bot, FolderCode } from "lucide-react";
  4: import { api, type Project, type Session, type ClaudeMdFile } from "@/lib/api";
  5: import { OutputCacheProvider } from "@/lib/outputCache";
  6: import { TabProvider } from "@/contexts/TabContext";
  7: import { ThemeProvider } from "@/contexts/ThemeContext";
  8: import { Button } from "@/components/ui/button";
  9: import { Card } from "@/components/ui/card";
 10: import { ProjectList } from "@/components/ProjectList";
 11: import { SessionList } from "@/components/SessionList";
 12: import { RunningClaudeSessions } from "@/components/RunningClaudeSessions";
 13: import { Topbar } from "@/components/Topbar";
 14: import { MarkdownEditor } from "@/components/MarkdownEditor";
 15: import { ClaudeFileEditor } from "@/components/ClaudeFileEditor";
 16: import { Settings } from "@/components/Settings";
 17: import { CCAgents } from "@/components/CCAgents";
 18: import { UsageDashboard } from "@/components/UsageDashboard";
 19: import { MCPManager } from "@/components/MCPManager";
 20: import { NFOCredits } from "@/components/NFOCredits";
 21: import { ClaudeBinaryDialog } from "@/components/ClaudeBinaryDialog";
 22: import { Toast, ToastContainer } from "@/components/ui/toast";
 23: import { ProjectSettings } from '@/components/ProjectSettings';
 24: import { TabManager } from "@/components/TabManager";
 25: import { TabContent } from "@/components/TabContent";
 26: import { AgentsModal } from "@/components/AgentsModal";
 27: import { useTabState } from "@/hooks/useTabState";
 28: import { AnalyticsConsentBanner } from "@/components/AnalyticsConsent";
 29: import { useAppLifecycle, useTrackEvent } from "@/hooks";
 30: 
 31: type View = 
 32:   | "welcome" 
 33:   | "projects" 
 34:   | "editor" 
 35:   | "claude-file-editor" 
 36:   | "settings"
 37:   | "cc-agents"
 38:   | "create-agent"
 39:   | "github-agents"
 40:   | "agent-execution"
 41:   | "agent-run-view"
 42:   | "mcp"
 43:   | "usage-dashboard"
 44:   | "project-settings"
 45:   | "tabs"; // New view for tab-based interface
 46: 
 47: /**
 48:  * AppContent component - Contains the main app logic, wrapped by providers
 49:  */
 50: function AppContent() {
 51:   const [view, setView] = useState<View>("tabs");
 52:   const { createClaudeMdTab, createSettingsTab, createUsageTab, createMCPTab } = useTabState();
 53:   const [projects, setProjects] = useState<Project[]>([]);
 54:   const [selectedProject, setSelectedProject] = useState<Project | null>(null);
 55:   const [sessions, setSessions] = useState<Session[]>([]);
 56:   const [editingClaudeFile, setEditingClaudeFile] = useState<ClaudeMdFile | null>(null);
 57:   const [loading, setLoading] = useState(true);
 58:   const [error, setError] = useState<string | null>(null);
 59:   const [showNFO, setShowNFO] = useState(false);
 60:   const [showClaudeBinaryDialog, setShowClaudeBinaryDialog] = useState(false);
 61:   const [toast, setToast] = useState<{ message: string; type: "success" | "error" | "info" } | null>(null);
 62:   const [projectForSettings, setProjectForSettings] = useState<Project | null>(null);
 63:   const [previousView] = useState<View>("welcome");
 64:   const [showAgentsModal, setShowAgentsModal] = useState(false);
 65:   
 66:   // Initialize analytics lifecycle tracking
 67:   useAppLifecycle();
 68:   const trackEvent = useTrackEvent();
 69:   
 70:   // Track user journey milestones
 71:   const [hasTrackedFirstChat] = useState(false);
 72:   // const [hasTrackedFirstAgent] = useState(false);
 73:   
 74:   // Track when user reaches different journey stages
 75:   useEffect(() => {
 76:     if (view === "projects" && projects.length > 0 && !hasTrackedFirstChat) {
 77:       // User has projects - they're past onboarding
 78:       trackEvent.journeyMilestone({
 79:         journey_stage: 'onboarding',
 80:         milestone_reached: 'projects_created',
 81:         time_to_milestone_ms: Date.now() - performance.timing.navigationStart
 82:       });
 83:     }
 84:   }, [view, projects.length, hasTrackedFirstChat, trackEvent]);
 85: 
 86:   // Load projects on mount when in projects view
 87:   useEffect(() => {
 88:     if (view === "projects") {
 89:       loadProjects();
 90:     } else if (view === "welcome") {
 91:       // Reset loading state for welcome view
 92:       setLoading(false);
 93:     }
 94:   }, [view]);
 95: 
 96:   // Keyboard shortcuts for tab navigation
 97:   useEffect(() => {
 98:     if (view !== "tabs") return;
 99:     
100:     const handleKeyDown = (e: KeyboardEvent) => {
101:       const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
102:       const modKey = isMac ? e.metaKey : e.ctrlKey;
103:       
104:       if (modKey) {
105:         switch (e.key) {
106:           case 't':
107:             e.preventDefault();
108:             window.dispatchEvent(new CustomEvent('create-chat-tab'));
109:             break;
110:           case 'w':
111:             e.preventDefault();
112:             window.dispatchEvent(new CustomEvent('close-current-tab'));
113:             break;
114:           case 'Tab':
115:             e.preventDefault();
116:             if (e.shiftKey) {
117:               window.dispatchEvent(new CustomEvent('switch-to-previous-tab'));
118:             } else {
119:               window.dispatchEvent(new CustomEvent('switch-to-next-tab'));
120:             }
121:             break;
122:           default:
123:             // Handle number keys 1-9
124:             if (e.key >= '1' && e.key <= '9') {
125:               e.preventDefault();
126:               const index = parseInt(e.key) - 1;
127:               window.dispatchEvent(new CustomEvent('switch-to-tab-by-index', { detail: { index } }));
128:             }
129:             break;
130:         }
131:       }
132:     };
133: 
134:     window.addEventListener('keydown', handleKeyDown);
135:     return () => window.removeEventListener('keydown', handleKeyDown);
136:   }, [view]);
137: 
138:   // Listen for Claude not found events
139:   useEffect(() => {
140:     const handleClaudeNotFound = () => {
141:       setShowClaudeBinaryDialog(true);
142:     };
143: 
144:     window.addEventListener('claude-not-found', handleClaudeNotFound as EventListener);
145:     return () => {
146:       window.removeEventListener('claude-not-found', handleClaudeNotFound as EventListener);
147:     };
148:   }, []);
149: 
150:   /**
151:    * Loads all projects from the ~/.claude/projects directory
152:    */
153:   const loadProjects = async () => {
154:     try {
155:       setLoading(true);
156:       setError(null);
157:       const projectList = await api.listProjects();
158:       setProjects(projectList);
159:     } catch (err) {
160:       console.error("Failed to load projects:", err);
161:       setError("Failed to load projects. Please ensure ~/.claude directory exists.");
162:     } finally {
163:       setLoading(false);
164:     }
165:   };
166: 
167:   /**
168:    * Handles project selection and loads its sessions
169:    */
170:   const handleProjectClick = async (project: Project) => {
171:     try {
172:       setLoading(true);
173:       setError(null);
174:       const sessionList = await api.getProjectSessions(project.id);
175:       setSessions(sessionList);
176:       setSelectedProject(project);
177:     } catch (err) {
178:       console.error("Failed to load sessions:", err);
179:       setError("Failed to load sessions for this project.");
180:     } finally {
181:       setLoading(false);
182:     }
183:   };
184: 
185:   /**
186:    * Opens a new Claude Code session in the interactive UI
187:    */
188:   const handleNewSession = async () => {
189:     handleViewChange("tabs");
190:     // The tab system will handle creating a new chat tab
191:   };
192: 
193:   /**
194:    * Returns to project list view
195:    */
196:   const handleBack = () => {
197:     setSelectedProject(null);
198:     setSessions([]);
199:   };
200: 
201:   /**
202:    * Handles editing a CLAUDE.md file from a project
203:    */
204:   const handleEditClaudeFile = (file: ClaudeMdFile) => {
205:     setEditingClaudeFile(file);
206:     handleViewChange("claude-file-editor");
207:   };
208: 
209:   /**
210:    * Returns from CLAUDE.md file editor to projects view
211:    */
212:   const handleBackFromClaudeFileEditor = () => {
213:     setEditingClaudeFile(null);
214:     handleViewChange("projects");
215:   };
216: 
217:   /**
218:    * Handles view changes with navigation protection
219:    */
220:   const handleViewChange = (newView: View) => {
221:     // No need for navigation protection with tabs since sessions stay open
222:     setView(newView);
223:   };
224: 
225:   /**
226:    * Handles navigating to hooks configuration
227:    */
228:   const handleProjectSettings = (project: Project) => {
229:     setProjectForSettings(project);
230:     handleViewChange("project-settings");
231:   };
232: 
233: 
234:   const renderContent = () => {
235:     switch (view) {
236:       case "welcome":
237:         return (
238:           <div className="flex items-center justify-center p-4" style={{ height: "100%" }}>
239:             <div className="w-full max-w-4xl">
240:               {/* Welcome Header */}
241:               <motion.div
242:                 initial={{ opacity: 0, y: -20 }}
243:                 animate={{ opacity: 1, y: 0 }}
244:                 transition={{ duration: 0.5 }}
245:                 className="mb-12 text-center"
246:               >
247:                 <h1 className="text-4xl font-bold tracking-tight">
248:                   <span className="rotating-symbol"></span>
249:                   Welcome to Claudia
250:                 </h1>
251:               </motion.div>
252: 
253:               {/* Navigation Cards */}
254:               <div className="grid grid-cols-1 md:grid-cols-2 gap-6 max-w-2xl mx-auto">
255:                 {/* CC Agents Card */}
256:                 <motion.div
257:                   initial={{ opacity: 0, scale: 0.9 }}
258:                   animate={{ opacity: 1, scale: 1 }}
259:                   transition={{ duration: 0.5, delay: 0.1 }}
260:                 >
261:                   <Card 
262:                     className="h-64 cursor-pointer transition-all duration-200 hover:scale-105 hover:shadow-lg border border-border/50 shimmer-hover trailing-border"
263:                     onClick={() => handleViewChange("cc-agents")}
264:                   >
265:                     <div className="h-full flex flex-col items-center justify-center p-8">
266:                       <Bot className="h-16 w-16 mb-4 text-primary" />
267:                       <h2 className="text-xl font-semibold">CC Agents</h2>
268:                     </div>
269:                   </Card>
270:                 </motion.div>
271: 
272:                 {/* CC Projects Card */}
273:                 <motion.div
274:                   initial={{ opacity: 0, scale: 0.9 }}
275:                   animate={{ opacity: 1, scale: 1 }}
276:                   transition={{ duration: 0.5, delay: 0.2 }}
277:                 >
278:                   <Card 
279:                     className="h-64 cursor-pointer transition-all duration-200 hover:scale-105 hover:shadow-lg border border-border/50 shimmer-hover trailing-border"
280:                     onClick={() => handleViewChange("projects")}
281:                   >
282:                     <div className="h-full flex flex-col items-center justify-center p-8">
283:                       <FolderCode className="h-16 w-16 mb-4 text-primary" />
284:                       <h2 className="text-xl font-semibold">CC Projects</h2>
285:                     </div>
286:                   </Card>
287:                 </motion.div>
288: 
289:               </div>
290:             </div>
291:           </div>
292:         );
293: 
294:       case "cc-agents":
295:         return (
296:           <CCAgents 
297:             onBack={() => handleViewChange("welcome")} 
298:           />
299:         );
300: 
301:       case "editor":
302:         return (
303:           <div className="flex-1 overflow-hidden">
304:             <MarkdownEditor onBack={() => handleViewChange("welcome")} />
305:           </div>
306:         );
307:       
308:       case "settings":
309:         return (
310:           <div className="flex-1 flex flex-col" style={{ minHeight: 0 }}>
311:             <Settings onBack={() => handleViewChange("welcome")} />
312:           </div>
313:         );
314:       
315:       case "projects":
316:         return (
317:           <div className="flex-1 overflow-y-auto">
318:             <div className="container mx-auto p-6">
319:               {/* Header with back button */}
320:               <motion.div
321:                 initial={{ opacity: 0, y: -20 }}
322:                 animate={{ opacity: 1, y: 0 }}
323:                 transition={{ duration: 0.5 }}
324:                 className="mb-6"
325:               >
326:                 <Button
327:                   variant="ghost"
328:                   size="sm"
329:                   onClick={() => handleViewChange("welcome")}
330:                   className="mb-4"
331:                 >
332:                   ← Back to Home
333:                 </Button>
334:                 <div className="mb-4">
335:                   <h1 className="text-3xl font-bold tracking-tight">CC Projects</h1>
336:                   <p className="mt-1 text-sm text-muted-foreground">
337:                     Browse your Claude Code sessions
338:                   </p>
339:                 </div>
340:               </motion.div>
341: 
342:               {/* Error display */}
343:               {error && (
344:                 <motion.div
345:                   initial={{ opacity: 0 }}
346:                   animate={{ opacity: 1 }}
347:                   className="mb-4 rounded-lg border border-destructive/50 bg-destructive/10 p-3 text-xs text-destructive max-w-2xl"
348:                 >
349:                   {error}
350:                 </motion.div>
351:               )}
352: 
353:               {/* Loading state */}
354:               {loading && (
355:                 <div className="flex items-center justify-center py-8">
356:                   <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
357:                 </div>
358:               )}
359: 
360:               {/* Content */}
361:               {!loading && (
362:                 <AnimatePresence mode="wait">
363:                   {selectedProject ? (
364:                     <motion.div
365:                       key="sessions"
366:                       initial={{ opacity: 0, x: 20 }}
367:                       animate={{ opacity: 1, x: 0 }}
368:                       exit={{ opacity: 0, x: -20 }}
369:                       transition={{ duration: 0.3 }}
370:                     >
371:                       <SessionList
372:                         sessions={sessions}
373:                         projectPath={selectedProject.path}
374:                         onBack={handleBack}
375:                         onEditClaudeFile={handleEditClaudeFile}
376:                       />
377:                     </motion.div>
378:                   ) : (
379:                     <motion.div
380:                       key="projects"
381:                       initial={{ opacity: 0, x: -20 }}
382:                       animate={{ opacity: 1, x: 0 }}
383:                       exit={{ opacity: 0, x: 20 }}
384:                       transition={{ duration: 0.3 }}
385:                     >
386:                       {/* New session button at the top */}
387:                       <motion.div
388:                         initial={{ opacity: 0, y: 20 }}
389:                         animate={{ opacity: 1, y: 0 }}
390:                         transition={{ duration: 0.5 }}
391:                         className="mb-4"
392:                       >
393:                         <Button
394:                           onClick={handleNewSession}
395:                           size="default"
396:                           className="w-full max-w-md"
397:                         >
398:                           <Plus className="mr-2 h-4 w-4" />
399:                           New Claude Code session
400:                         </Button>
401:                       </motion.div>
402: 
403:                       {/* Running Claude Sessions */}
404:                       <RunningClaudeSessions />
405: 
406:                       {/* Project list */}
407:                       {projects.length > 0 ? (
408:                         <ProjectList
409:                           projects={projects}
410:                           onProjectClick={handleProjectClick}
411:                           onProjectSettings={handleProjectSettings}
412:                           loading={loading}
413:                           className="animate-fade-in"
414:                         />
415:                       ) : (
416:                         <div className="py-8 text-center">
417:                           <p className="text-sm text-muted-foreground">
418:                             No projects found in ~/.claude/projects
419:                           </p>
420:                         </div>
421:                       )}
422:                     </motion.div>
423:                   )}
424:                 </AnimatePresence>
425:               )}
426:             </div>
427:           </div>
428:         );
429:       
430:       case "claude-file-editor":
431:         return editingClaudeFile ? (
432:           <ClaudeFileEditor
433:             file={editingClaudeFile}
434:             onBack={handleBackFromClaudeFileEditor}
435:           />
436:         ) : null;
437:       
438:       case "tabs":
439:         return (
440:           <div className="h-full flex flex-col">
441:             <TabManager className="flex-shrink-0" />
442:             <div className="flex-1 overflow-hidden">
443:               <TabContent />
444:             </div>
445:           </div>
446:         );
447:       
448:       case "usage-dashboard":
449:         return (
450:           <UsageDashboard onBack={() => handleViewChange("welcome")} />
451:         );
452:       
453:       case "mcp":
454:         return (
455:           <MCPManager onBack={() => handleViewChange("welcome")} />
456:         );
457:       
458:       case "project-settings":
459:         if (projectForSettings) {
460:           return (
461:             <ProjectSettings
462:               project={projectForSettings}
463:               onBack={() => {
464:                 setProjectForSettings(null);
465:                 handleViewChange(previousView || "projects");
466:               }}
467:             />
468:           );
469:         }
470:         break;
471:       
472:       default:
473:         return null;
474:     }
475:   };
476: 
477:   return (
478:     <div className="h-screen bg-background flex flex-col">
479:       {/* Topbar */}
480:       <Topbar
481:         onClaudeClick={() => createClaudeMdTab()}
482:         onSettingsClick={() => createSettingsTab()}
483:         onUsageClick={() => createUsageTab()}
484:         onMCPClick={() => createMCPTab()}
485:         onInfoClick={() => setShowNFO(true)}
486:         onAgentsClick={() => setShowAgentsModal(true)}
487:       />
488:       
489:       {/* Analytics Consent Banner */}
490:       <AnalyticsConsentBanner />
491:       
492:       {/* Main Content */}
493:       <div className="flex-1 overflow-hidden">
494:         {renderContent()}
495:       </div>
496:       
497:       {/* NFO Credits Modal */}
498:       {showNFO && <NFOCredits onClose={() => setShowNFO(false)} />}
499:       
500:       {/* Agents Modal */}
501:       <AgentsModal 
502:         open={showAgentsModal} 
503:         onOpenChange={setShowAgentsModal} 
504:       />
505:       
506:       {/* Claude Binary Dialog */}
507:       <ClaudeBinaryDialog
508:         open={showClaudeBinaryDialog}
509:         onOpenChange={setShowClaudeBinaryDialog}
510:         onSuccess={() => {
511:           setToast({ message: "Claude binary path saved successfully", type: "success" });
512:           // Trigger a refresh of the Claude version check
513:           window.location.reload();
514:         }}
515:         onError={(message) => setToast({ message, type: "error" })}
516:       />
517:       
518:       {/* Toast Container */}
519:       <ToastContainer>
520:         {toast && (
521:           <Toast
522:             message={toast.message}
523:             type={toast.type}
524:             onDismiss={() => setToast(null)}
525:           />
526:         )}
527:       </ToastContainer>
528:     </div>
529:   );
530: }
531: 
532: /**
533:  * Main App component - Wraps the app with providers
534:  */
535: function App() {
536:   return (
537:     <ThemeProvider>
538:       <OutputCacheProvider>
539:         <TabProvider>
540:           <AppContent />
541:         </TabProvider>
542:       </OutputCacheProvider>
543:     </ThemeProvider>
544:   );
545: }
546: 
547: export default App;
````

## File: src/main.tsx
````typescript
 1: import React from "react";
 2: import ReactDOM from "react-dom/client";
 3: import App from "./App";
 4: import { ErrorBoundary } from "./components/ErrorBoundary";
 5: import { AnalyticsErrorBoundary } from "./components/AnalyticsErrorBoundary";
 6: import { analytics, resourceMonitor } from "./lib/analytics";
 7: import { PostHogProvider } from "posthog-js/react";
 8: import "./assets/shimmer.css";
 9: import "./styles.css";
10: 
11: // Initialize analytics before rendering
12: analytics.initialize();
13: 
14: // Start resource monitoring (check every 2 minutes)
15: resourceMonitor.startMonitoring(120000);
16: 
17: ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
18:   <React.StrictMode>
19:     <PostHogProvider
20:       apiKey={import.meta.env.VITE_PUBLIC_POSTHOG_KEY}
21:       options={{
22:         api_host: import.meta.env.VITE_PUBLIC_POSTHOG_HOST,
23:         defaults: '2025-05-24',
24:         capture_exceptions: true,
25:         debug: import.meta.env.MODE === "development",
26:       }}
27:     >
28:       <ErrorBoundary>
29:         <AnalyticsErrorBoundary>
30:           <App />
31:         </AnalyticsErrorBoundary>
32:       </ErrorBoundary>
33:     </PostHogProvider>
34:   </React.StrictMode>,
35: );
````

## File: src/styles.css
````css
  1: @import "tailwindcss";
  2: 
  3: /* Custom scrollbar hiding */
  4: .scrollbar-hide {
  5:   scrollbar-width: none;
  6:   -ms-overflow-style: none;
  7: }
  8: 
  9: .scrollbar-hide::-webkit-scrollbar {
 10:   display: none;
 11: }
 12: 
 13: /* Dark theme configuration */
 14: @theme {
 15:   /* Colors */
 16:   --color-background: oklch(0.12 0.01 240);
 17:   --color-foreground: oklch(0.98 0.01 240);
 18:   --color-card: oklch(0.14 0.01 240);
 19:   --color-card-foreground: oklch(0.98 0.01 240);
 20:   --color-popover: oklch(0.12 0.01 240);
 21:   --color-popover-foreground: oklch(0.98 0.01 240);
 22:   --color-primary: oklch(0.98 0.01 240);
 23:   --color-primary-foreground: oklch(0.17 0.01 240);
 24:   --color-secondary: oklch(0.16 0.01 240);
 25:   --color-secondary-foreground: oklch(0.98 0.01 240);
 26:   --color-muted: oklch(0.16 0.01 240);
 27:   --color-muted-foreground: oklch(0.68 0.01 240);
 28:   --color-accent: oklch(0.16 0.01 240);
 29:   --color-accent-foreground: oklch(0.98 0.01 240);
 30:   --color-destructive: oklch(0.6 0.2 25);
 31:   --color-destructive-foreground: oklch(0.98 0.01 240);
 32:   --color-border: oklch(0.16 0.01 240);
 33:   --color-input: oklch(0.16 0.01 240);
 34:   --color-ring: oklch(0.52 0.015 240);
 35:   
 36:   /* Additional colors for status messages */
 37:   --color-green-500: oklch(0.72 0.20 142);
 38:   --color-green-600: oklch(0.64 0.22 142);
 39: 
 40:   /* Border radius */
 41:   --radius-sm: 0.25rem;
 42:   --radius-base: 0.375rem;
 43:   --radius-md: 0.5rem;
 44:   --radius-lg: 0.75rem;
 45:   --radius-xl: 1rem;
 46: 
 47:   /* Fonts */
 48:   --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
 49:   --font-mono: ui-monospace, SFMono-Regular, "SF Mono", Consolas, "Liberation Mono", Menlo, monospace;
 50: 
 51:   /* Transitions */
 52:   --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
 53:   --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
 54: }
 55: 
 56: /* Theme Variations */
 57: /* Default is dark theme - already defined above */
 58: 
 59: /* Light Theme */
 60: .theme-light {
 61:   --color-background: oklch(0.98 0.01 240);
 62:   --color-foreground: oklch(0.12 0.01 240);
 63:   --color-card: oklch(0.96 0.01 240);
 64:   --color-card-foreground: oklch(0.12 0.01 240);
 65:   --color-popover: oklch(0.98 0.01 240);
 66:   --color-popover-foreground: oklch(0.12 0.01 240);
 67:   --color-primary: oklch(0.12 0.01 240);
 68:   --color-primary-foreground: oklch(0.98 0.01 240);
 69:   --color-secondary: oklch(0.94 0.01 240);
 70:   --color-secondary-foreground: oklch(0.12 0.01 240);
 71:   --color-muted: oklch(0.94 0.01 240);
 72:   --color-muted-foreground: oklch(0.45 0.01 240);
 73:   --color-accent: oklch(0.94 0.01 240);
 74:   --color-accent-foreground: oklch(0.12 0.01 240);
 75:   --color-destructive: oklch(0.6 0.2 25);
 76:   --color-destructive-foreground: oklch(0.98 0.01 240);
 77:   --color-border: oklch(0.90 0.01 240);
 78:   --color-input: oklch(0.90 0.01 240);
 79:   --color-ring: oklch(0.52 0.015 240);
 80:   
 81:   /* Additional colors for status messages */
 82:   --color-green-500: oklch(0.62 0.20 142);
 83:   --color-green-600: oklch(0.54 0.22 142);
 84: }
 85: 
 86: /* Gray Theme */
 87: .theme-gray {
 88:   --color-background: oklch(0.22 0.01 240);
 89:   --color-foreground: oklch(0.98 0.01 240);
 90:   --color-card: oklch(0.26 0.01 240);
 91:   --color-card-foreground: oklch(0.98 0.01 240);
 92:   --color-popover: oklch(0.22 0.01 240);
 93:   --color-popover-foreground: oklch(0.98 0.01 240);
 94:   --color-primary: oklch(0.98 0.01 240);
 95:   --color-primary-foreground: oklch(0.22 0.01 240);
 96:   --color-secondary: oklch(0.30 0.01 240);
 97:   --color-secondary-foreground: oklch(0.98 0.01 240);
 98:   --color-muted: oklch(0.30 0.01 240);
 99:   --color-muted-foreground: oklch(0.70 0.01 240);
100:   --color-accent: oklch(0.30 0.01 240);
101:   --color-accent-foreground: oklch(0.98 0.01 240);
102:   --color-destructive: oklch(0.6 0.2 25);
103:   --color-destructive-foreground: oklch(0.98 0.01 240);
104:   --color-border: oklch(0.30 0.01 240);
105:   --color-input: oklch(0.30 0.01 240);
106:   --color-ring: oklch(0.60 0.015 240);
107:   
108:   /* Additional colors for status messages */
109:   --color-green-500: oklch(0.72 0.20 142);
110:   --color-green-600: oklch(0.64 0.22 142);
111: }
112: 
113: /* White Theme (High Contrast Light) */
114: .theme-white {
115:   --color-background: oklch(1.0 0 240);
116:   --color-foreground: oklch(0.0 0 240);
117:   --color-card: oklch(0.98 0.01 240);
118:   --color-card-foreground: oklch(0.0 0 240);
119:   --color-popover: oklch(1.0 0 240);
120:   --color-popover-foreground: oklch(0.0 0 240);
121:   --color-primary: oklch(0.0 0 240);
122:   --color-primary-foreground: oklch(1.0 0 240);
123:   --color-secondary: oklch(0.96 0.01 240);
124:   --color-secondary-foreground: oklch(0.0 0 240);
125:   --color-muted: oklch(0.96 0.01 240);
126:   --color-muted-foreground: oklch(0.35 0.01 240);
127:   --color-accent: oklch(0.96 0.01 240);
128:   --color-accent-foreground: oklch(0.0 0 240);
129:   --color-destructive: oklch(0.55 0.25 25);
130:   --color-destructive-foreground: oklch(1.0 0 240);
131:   --color-border: oklch(0.85 0.01 240);
132:   --color-input: oklch(0.85 0.01 240);
133:   --color-ring: oklch(0.40 0.015 240);
134:   
135:   /* Additional colors for status messages */
136:   --color-green-500: oklch(0.55 0.25 142);
137:   --color-green-600: oklch(0.47 0.27 142);
138: }
139: 
140: /* Custom Theme - CSS variables will be set dynamically by ThemeContext */
141: .theme-custom {
142:   /* Custom theme variables are applied dynamically via JavaScript */
143: }
144: 
145: /* Reset and base styles */
146: * {
147:   border-color: var(--color-border);
148: }
149: 
150: html {
151:   color-scheme: dark;
152: }
153: 
154: body {
155:   background-color: var(--color-background);
156:   color: var(--color-foreground);
157:   font-family: var(--font-sans);
158: }
159: 
160: /* Placeholder text styling */
161: input::placeholder,
162: textarea::placeholder {
163:   color: var(--color-muted-foreground);
164:   opacity: 0.6;
165: }
166: 
167: /* Cursor pointer for all interactive elements */
168: button,
169: a,
170: [role="button"],
171: [role="link"],
172: [role="menuitem"],
173: [role="tab"],
174: [tabindex]:not([tabindex="-1"]),
175: .cursor-pointer {
176:   cursor: pointer;
177: }
178: 
179: /* Ensure disabled elements don't have pointer cursor */
180: button:disabled,
181: [disabled],
182: .disabled {
183:   cursor: not-allowed !important;
184: }
185: 
186: /* Remove all focus styles globally */
187: * {
188:   outline: none !important;
189:   outline-offset: 0 !important;
190: }
191: 
192: *:focus,
193: *:focus-visible,
194: *:focus-within {
195:   outline: none !important;
196:   box-shadow: none !important;
197: }
198: 
199: /* Specifically remove focus styles from form elements */
200: input:focus,
201: input:focus-visible,
202: textarea:focus,
203: textarea:focus-visible,
204: select:focus,
205: select:focus-visible,
206: button:focus,
207: button:focus-visible,
208: [role="button"]:focus,
209: [role="button"]:focus-visible,
210: [role="combobox"]:focus,
211: [role="combobox"]:focus-visible {
212:   outline: none !important;
213:   box-shadow: none !important;
214:   border-color: var(--color-input) !important;
215: }
216: 
217: /* Remove ring styles */
218: .ring-0,
219: .ring-1,
220: .ring-2,
221: .ring,
222: .ring-offset-0,
223: .ring-offset-1,
224: .ring-offset-2,
225: .ring-offset {
226:   box-shadow: none !important;
227: }
228: 
229: /* Custom utilities */
230: @utility animate-in {
231:   animation-name: enter;
232:   animation-duration: 150ms;
233:   animation-fill-mode: both;
234: }
235: 
236: @utility animate-out {
237:   animation-name: exit;
238:   animation-duration: 150ms;
239:   animation-fill-mode: both;
240: }
241: 
242: @utility line-clamp-2 {
243:   overflow: hidden;
244:   display: -webkit-box;
245:   -webkit-box-orient: vertical;
246:   -webkit-line-clamp: 2;
247: }
248: 
249: @keyframes enter {
250:   from {
251:     opacity: var(--tw-enter-opacity, 1);
252:     transform: translate3d(var(--tw-enter-translate-x, 0), var(--tw-enter-translate-y, 0), 0) scale3d(var(--tw-enter-scale, 1), var(--tw-enter-scale, 1), var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0));
253:   }
254: }
255: 
256: @keyframes exit {
257:   to {
258:     opacity: var(--tw-exit-opacity, 1);
259:     transform: translate3d(var(--tw-exit-translate-x, 0), var(--tw-exit-translate-y, 0), 0) scale3d(var(--tw-exit-scale, 1), var(--tw-exit-scale, 1), var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0));
260:   }
261: }
262: 
263: /* Markdown Editor Theme-aware Styles */
264: [data-color-mode="dark"],
265: .theme-dark [data-color-mode="dark"],
266: .theme-gray [data-color-mode="dark"] {
267:   --color-border-default: rgb(48, 54, 61);
268:   --color-canvas-default: rgb(13, 17, 23);
269:   --color-canvas-subtle: rgb(22, 27, 34);
270:   --color-fg-default: rgb(201, 209, 217);
271:   --color-fg-muted: rgb(139, 148, 158);
272:   --color-fg-subtle: rgb(110, 118, 129);
273:   --color-accent-fg: rgb(88, 166, 255);
274:   --color-danger-fg: rgb(248, 81, 73);
275: }
276: 
277: [data-color-mode="light"],
278: .theme-light [data-color-mode="light"],
279: .theme-white [data-color-mode="light"] {
280:   --color-border-default: rgb(216, 222, 228);
281:   --color-canvas-default: rgb(255, 255, 255);
282:   --color-canvas-subtle: rgb(246, 248, 250);
283:   --color-fg-default: rgb(31, 35, 40);
284:   --color-fg-muted: rgb(101, 109, 118);
285:   --color-fg-subtle: rgb(149, 157, 165);
286:   --color-accent-fg: rgb(9, 105, 218);
287:   --color-danger-fg: rgb(207, 34, 46);
288: }
289: 
290: .w-md-editor {
291:   background-color: transparent !important;
292:   color: var(--color-foreground) !important;
293: }
294: 
295: .w-md-editor.w-md-editor-focus {
296:   box-shadow: none !important;
297:   border-color: var(--color-border) !important;
298:   outline: none !important;
299: }
300: 
301: .w-md-editor-toolbar {
302:   background-color: var(--color-card) !important;
303:   border-bottom: 1px solid var(--color-border) !important;
304: }
305: 
306: .w-md-editor-toolbar-divider {
307:   background-color: var(--color-border) !important;
308: }
309: 
310: .w-md-editor-toolbar button {
311:   color: var(--color-foreground) !important;
312: }
313: 
314: .w-md-editor-toolbar button:hover {
315:   background-color: var(--color-accent) !important;
316:   color: var(--color-accent-foreground) !important;
317: }
318: 
319: .w-md-editor-content {
320:   background-color: var(--color-background) !important;
321: }
322: 
323: .w-md-editor-text-pre,
324: .w-md-editor-text-input,
325: .w-md-editor-text {
326:   color: var(--color-foreground) !important;
327:   background-color: transparent !important;
328: }
329: 
330: .w-md-editor-preview {
331:   background-color: var(--color-background) !important;
332: }
333: 
334: .wmde-markdown {
335:   background-color: transparent !important;
336:   color: var(--color-foreground) !important;
337: }
338: 
339: /* Prose styles for markdown rendering */
340: .prose {
341:   color: var(--color-foreground);
342:   max-width: 65ch;
343:   font-size: 1rem;
344:   line-height: 1.75;
345: }
346: 
347: .prose-sm {
348:   font-size: 0.875rem;
349:   line-height: 1.714;
350: }
351: 
352: .prose p {
353:   margin-top: 1.25em;
354:   margin-bottom: 1.25em;
355: }
356: 
357: .prose-sm p {
358:   margin-top: 1.143em;
359:   margin-bottom: 1.143em;
360: }
361: 
362: .prose [class~="lead"] {
363:   font-size: 1.25em;
364:   line-height: 1.6;
365:   margin-top: 1.2em;
366:   margin-bottom: 1.2em;
367: }
368: 
369: .prose h1, .prose h2, .prose h3, .prose h4, .prose h5, .prose h6 {
370:   margin-top: 0;
371:   margin-bottom: 0.8888889em;
372:   font-weight: 600;
373:   line-height: 1.1111111;
374: }
375: 
376: .prose h1 {
377:   font-size: 2.25em;
378: }
379: 
380: .prose h2 {
381:   font-size: 1.5em;
382: }
383: 
384: .prose h3 {
385:   font-size: 1.25em;
386: }
387: 
388: .prose h4 {
389:   font-size: 1em;
390: }
391: 
392: .prose a {
393:   color: var(--color-primary);
394:   text-decoration: underline;
395:   font-weight: 500;
396: }
397: 
398: .prose strong {
399:   font-weight: 600;
400: }
401: 
402: .prose ol, .prose ul {
403:   margin-top: 1.25em;
404:   margin-bottom: 1.25em;
405:   padding-left: 1.625em;
406: }
407: 
408: .prose li {
409:   margin-top: 0.5em;
410:   margin-bottom: 0.5em;
411: }
412: 
413: .prose > ul > li p {
414:   margin-top: 0.75em;
415:   margin-bottom: 0.75em;
416: }
417: 
418: .prose > ol > li > *:first-child {
419:   margin-top: 1.25em;
420: }
421: 
422: .prose code {
423:   font-weight: 600;
424:   font-size: 0.875em;
425:   background-color: var(--color-muted);
426:   padding: 0.125em 0.375em;
427:   border-radius: 0.25rem;
428: }
429: 
430: .prose pre {
431:   overflow-x: auto;
432:   font-size: 0.875em;
433:   line-height: 1.714;
434:   margin-top: 1.714em;
435:   margin-bottom: 1.714em;
436:   border-radius: 0.375rem;
437:   padding: 0.857em 1.143em;
438:   background-color: var(--color-card);
439: }
440: 
441: .prose pre code {
442:   background-color: transparent;
443:   border-width: 0;
444:   border-radius: 0;
445:   padding: 0;
446:   font-weight: 400;
447:   color: inherit;
448:   font-size: inherit;
449:   font-family: inherit;
450:   line-height: inherit;
451: }
452: 
453: .prose blockquote {
454:   font-weight: 500;
455:   font-style: italic;
456:   margin-top: 1.6em;
457:   margin-bottom: 1.6em;
458:   padding-left: 1em;
459:   border-left: 0.25rem solid var(--color-border);
460: }
461: 
462: .prose hr {
463:   margin-top: 3em;
464:   margin-bottom: 3em;
465:   border-color: var(--color-border);
466: }
467: 
468: .prose table {
469:   width: 100%;
470:   table-layout: auto;
471:   text-align: left;
472:   margin-top: 2em;
473:   margin-bottom: 2em;
474:   font-size: 0.875em;
475:   line-height: 1.714;
476: }
477: 
478: .prose thead {
479:   border-bottom-width: 1px;
480:   border-bottom-color: var(--color-border);
481: }
482: 
483: .prose thead th {
484:   vertical-align: bottom;
485:   padding-right: 0.571em;
486:   padding-bottom: 0.571em;
487:   padding-left: 0.571em;
488:   font-weight: 600;
489: }
490: 
491: .prose tbody tr {
492:   border-bottom-width: 1px;
493:   border-bottom-color: var(--color-border);
494: }
495: 
496: .prose tbody tr:last-child {
497:   border-bottom-width: 0;
498: }
499: 
500: .prose tbody td {
501:   vertical-align: baseline;
502:   padding: 0.571em;
503: }
504: 
505: /* Dark mode adjustments */
506: .prose.dark\:prose-invert {
507:   color: var(--color-foreground);
508: }
509: 
510: .prose.dark\:prose-invert a {
511:   color: var(--color-primary);
512: }
513: 
514: .prose.dark\:prose-invert strong {
515:   color: inherit;
516: }
517: 
518: .prose.dark\:prose-invert code {
519:   color: var(--color-foreground);
520:   background-color: var(--color-muted);
521: }
522: 
523: .prose.dark\:prose-invert pre {
524:   background-color: rgb(13, 17, 23);
525:   border: 1px solid var(--color-border);
526: }
527: 
528: .prose.dark\:prose-invert thead {
529:   border-bottom-color: var(--color-border);
530: }
531: 
532: .prose.dark\:prose-invert tbody tr {
533:   border-bottom-color: var(--color-border);
534: }
535: 
536: /* Remove maximum width constraint */
537: .prose.max-w-none {
538:   max-width: none;
539: }
540: 
541: /* Rotating symbol animation */
542: @keyframes rotate-symbol {
543:   0%   { content: "◐"; transform: scale(1); }
544:   25%  { content: "◓"; transform: scale(1); }
545:   50%  { content: "◑"; transform: scale(1); }
546:   75%  { content: "◒"; transform: scale(1); }
547:   100% { content: "◐"; transform: scale(1); }
548: }
549: 
550: @keyframes fade-in {
551:   from {
552:     opacity: 0;
553:     transform: scale(0.8);
554:   }
555:   to {
556:     opacity: 1;
557:     transform: scale(1);
558:   }
559: }
560: 
561: .rotating-symbol {
562:   display: inline-block;
563:   vertical-align: middle;
564:   line-height: 1;
565:   animation: fade-in 0.2s ease-out;
566:   font-weight: normal;
567:   font-size: 1.5rem; /* Make it bigger! */
568:   position: relative;
569:   top: -2px;
570: }
571: 
572: .rotating-symbol::before {
573:   content: "◐";
574:   animation: rotate-symbol 1.6s steps(4, end) infinite;
575:   display: inline-block;
576:   font-size: inherit;
577:   line-height: 1;
578:   vertical-align: baseline;
579:   transform-origin: center;
580: }
581: 
582: /* Removed special font-weight for larger sizes to maintain consistency */
583: 
584: /* Shimmer hover effect */
585: @keyframes shimmer {
586:   0% {
587:     background-position: -200% 0;
588:   }
589:   100% {
590:     background-position: 200% 0;
591:   }
592: }
593: 
594: .shimmer-hover {
595:   position: relative;
596:   overflow: hidden;
597: }
598: 
599: .shimmer-hover::before {
600:   content: "";
601:   position: absolute;
602:   top: 0;
603:   left: -100%;
604:   width: 100%;
605:   height: 100%;
606:   background: linear-gradient(
607:     90deg,
608:     transparent,
609:     rgba(255, 255, 255, 0.05),
610:     transparent
611:   );
612:   transition: left 0.5s;
613: }
614: 
615: .shimmer-hover:hover::before {
616:   left: 100%;
617:   animation: shimmer 0.5s;
618: }
619: 
620: /* Trailing border effect */
621: @property --angle {
622:   syntax: "<angle>";
623:   initial-value: 0deg;
624:   inherits: false;
625: }
626: 
627: @keyframes trail-rotate {
628:   to {
629:     --angle: 360deg;
630:   }
631: }
632: 
633: .trailing-border {
634:   position: relative;
635:   background: var(--color-card);
636:   z-index: 0;
637:   overflow: visible;
638: }
639: 
640: /* The correctly traveling border line */
641: .trailing-border::after {
642:   content: "";
643:   position: absolute;
644:   inset: -2px;
645:   padding: 2px;
646:   border-radius: inherit;
647:   background: conic-gradient(
648:     from var(--angle),
649:     transparent 0%,
650:     transparent 85%,
651:     #d97757 90%,
652:     #ff9a7a 92.5%,
653:     #d97757 95%,
654:     transparent 100%
655:   );
656:   -webkit-mask: 
657:     linear-gradient(#fff 0 0) content-box, 
658:     linear-gradient(#fff 0 0);
659:   -webkit-mask-composite: xor;
660:   mask-composite: exclude;
661:   opacity: 0;
662:   transition: opacity 0.3s ease;
663:   z-index: -1;
664: }
665: 
666: .trailing-border:hover::after {
667:   opacity: 1;
668:   animation: trail-rotate 2s linear infinite;
669: }
670: 
671: /* Ensure the card content stays above the border effect */
672: .trailing-border > * {
673:   position: relative;
674:   z-index: 1;
675: }
676: 
677: /* --- ELEGANT SCROLLBARS --- */
678: 
679: /* Firefox - thin and minimal */
680: * {
681:   scrollbar-width: thin;
682:   scrollbar-color: rgba(156, 163, 175, 0.3) transparent;
683: }
684: 
685: /* Global webkit scrollbar - ultra thin and elegant */
686: ::-webkit-scrollbar {
687:   width: 3px;
688:   height: 3px;
689: }
690: 
691: ::-webkit-scrollbar-track {
692:   background: transparent;
693: }
694: 
695: ::-webkit-scrollbar-thumb {
696:   background-color: rgba(156, 163, 175, 0.5);
697:   border-radius: 2px;
698:   transition: background-color 0.2s ease;
699: }
700: 
701: ::-webkit-scrollbar-thumb:hover {
702:   background-color: rgba(156, 163, 175, 0.6);
703: }
704: 
705: ::-webkit-scrollbar-corner {
706:   background: transparent;
707: }
708: 
709: /* Code blocks - slightly larger for better usability */
710: pre::-webkit-scrollbar,
711: .w-md-editor-content::-webkit-scrollbar,
712: code::-webkit-scrollbar {
713:   width: 8px;
714:   height: 8px;
715: }
716: 
717: pre::-webkit-scrollbar-thumb,
718: .w-md-editor-content::-webkit-scrollbar-thumb,
719: code::-webkit-scrollbar-thumb {
720:   background-color: rgba(156, 163, 175, 0.4);
721:   border-radius: 4px;
722: }
723: 
724: pre::-webkit-scrollbar-thumb:hover,
725: .w-md-editor-content::-webkit-scrollbar-thumb:hover,
726: code::-webkit-scrollbar-thumb:hover {
727:   background-color: rgba(156, 163, 175, 0.6);
728: }
729: 
730: /* NFO Credits Scanlines Animation */
731: @keyframes scanlines {
732:   0% {
733:     transform: translateY(-100%);
734:   }
735:   100% {
736:     transform: translateY(100%);
737:   }
738: }
739: 
740: .animate-scanlines {
741:   animation: scanlines 8s linear infinite;
742: }
743: 
744: /* Screenshot Shutter Animation */
745: @keyframes shutterFlash {
746:   0% {
747:     opacity: 0;
748:   }
749:   50% {
750:     opacity: 1;
751:   }
752:   100% {
753:     opacity: 0;
754:   }
755: }
756: 
757: .shutter-flash {
758:   animation: shutterFlash 0.5s ease-in-out;
759: }
760: 
761: /* Image Move to Input Animation */
762: @keyframes moveToInput {
763:   0% {
764:     transform: scale(1) translateY(0);
765:     opacity: 1;
766:   }
767:   50% {
768:     transform: scale(0.3) translateY(50%);
769:     opacity: 0.8;
770:   }
771:   100% {
772:     transform: scale(0.1) translateY(100vh);
773:     opacity: 0;
774:   }
775: }
776: 
777: .image-move-to-input {
778:   animation: moveToInput 0.8s ease-in-out forwards;
779: }
````

## File: src/vite-env.d.ts
````typescript
1: /// <reference types="vite/client" />
````

## File: src-tauri/capabilities/default.json
````json
 1: {
 2:   "$schema": "../gen/schemas/desktop-schema.json",
 3:   "identifier": "default",
 4:   "description": "Capability for the main window",
 5:   "windows": ["main"],
 6:   "permissions": [
 7:     "core:default",
 8:     "dialog:default",
 9:     "dialog:allow-open",
10:     "dialog:allow-save",
11:     "shell:allow-execute",
12:     "shell:allow-spawn",
13:     "shell:allow-open",
14:     {
15:       "identifier": "shell:allow-execute",
16:       "allow": [
17:         {
18:           "name": "claude",
19:           "sidecar": false,
20:           "args": true
21:         }
22:       ]
23:     },
24:     {
25:       "identifier": "shell:allow-spawn",
26:       "allow": [
27:         {
28:           "name": "claude",
29:           "sidecar": false,
30:           "args": true
31:         }
32:       ]
33:     },
34:     "fs:default",
35:     "fs:allow-mkdir",
36:     "fs:allow-read",
37:     "fs:allow-write",
38:     "fs:allow-remove",
39:     "fs:allow-rename",
40:     "fs:allow-exists",
41:     "fs:allow-copy-file",
42:     "fs:read-all",
43:     "fs:write-all",
44:     "fs:scope-app-recursive",
45:     "fs:scope-home-recursive",
46:     "http:default",
47:     "http:allow-fetch",
48:     "process:default",
49:     "notification:default",
50:     "clipboard-manager:default",
51:     "global-shortcut:default",
52:     "updater:default"
53:   ]
54: }
````

## File: src-tauri/src/checkpoint/manager.rs
````rust
  1: use anyhow::{Context, Result};
  2: use chrono::{DateTime, TimeZone, Utc};
  3: use log;
  4: use std::collections::HashMap;
  5: use std::fs;
  6: use std::path::PathBuf;
  7: use std::sync::Arc;
  8: use tokio::sync::RwLock;
  9: 
 10: use super::{
 11:     storage::{self, CheckpointStorage},
 12:     Checkpoint, CheckpointMetadata, CheckpointPaths, CheckpointResult, CheckpointStrategy,
 13:     FileSnapshot, FileState, FileTracker, SessionTimeline,
 14: };
 15: 
 16: /// Manages checkpoint operations for a session
 17: pub struct CheckpointManager {
 18:     project_id: String,
 19:     session_id: String,
 20:     project_path: PathBuf,
 21:     file_tracker: Arc<RwLock<FileTracker>>,
 22:     pub storage: Arc<CheckpointStorage>,
 23:     timeline: Arc<RwLock<SessionTimeline>>,
 24:     current_messages: Arc<RwLock<Vec<String>>>, // JSONL messages
 25: }
 26: 
 27: impl CheckpointManager {
 28:     /// Create a new checkpoint manager
 29:     pub async fn new(
 30:         project_id: String,
 31:         session_id: String,
 32:         project_path: PathBuf,
 33:         claude_dir: PathBuf,
 34:     ) -> Result<Self> {
 35:         let storage = Arc::new(CheckpointStorage::new(claude_dir.clone()));
 36: 
 37:         // Initialize storage
 38:         storage.init_storage(&project_id, &session_id)?;
 39: 
 40:         // Load or create timeline
 41:         let paths = CheckpointPaths::new(&claude_dir, &project_id, &session_id);
 42:         let timeline = if paths.timeline_file.exists() {
 43:             storage.load_timeline(&paths.timeline_file)?
 44:         } else {
 45:             SessionTimeline::new(session_id.clone())
 46:         };
 47: 
 48:         let file_tracker = FileTracker {
 49:             tracked_files: HashMap::new(),
 50:         };
 51: 
 52:         Ok(Self {
 53:             project_id,
 54:             session_id,
 55:             project_path,
 56:             file_tracker: Arc::new(RwLock::new(file_tracker)),
 57:             storage,
 58:             timeline: Arc::new(RwLock::new(timeline)),
 59:             current_messages: Arc::new(RwLock::new(Vec::new())),
 60:         })
 61:     }
 62: 
 63:     /// Track a new message in the session
 64:     pub async fn track_message(&self, jsonl_message: String) -> Result<()> {
 65:         let mut messages = self.current_messages.write().await;
 66:         messages.push(jsonl_message.clone());
 67: 
 68:         // Parse message to check for tool usage
 69:         if let Ok(msg) = serde_json::from_str::<serde_json::Value>(&jsonl_message) {
 70:             if let Some(content) = msg.get("message").and_then(|m| m.get("content")) {
 71:                 if let Some(content_array) = content.as_array() {
 72:                     for item in content_array {
 73:                         if item.get("type").and_then(|t| t.as_str()) == Some("tool_use") {
 74:                             if let Some(tool_name) = item.get("name").and_then(|n| n.as_str()) {
 75:                                 if let Some(input) = item.get("input") {
 76:                                     self.track_tool_operation(tool_name, input).await?;
 77:                                 }
 78:                             }
 79:                         }
 80:                     }
 81:                 }
 82:             }
 83:         }
 84: 
 85:         Ok(())
 86:     }
 87: 
 88:     /// Track file operations from tool usage
 89:     async fn track_tool_operation(&self, tool: &str, input: &serde_json::Value) -> Result<()> {
 90:         match tool.to_lowercase().as_str() {
 91:             "edit" | "write" | "multiedit" => {
 92:                 if let Some(file_path) = input.get("file_path").and_then(|p| p.as_str()) {
 93:                     self.track_file_modification(file_path).await?;
 94:                 }
 95:             }
 96:             "bash" => {
 97:                 // Try to detect file modifications from bash commands
 98:                 if let Some(command) = input.get("command").and_then(|c| c.as_str()) {
 99:                     self.track_bash_side_effects(command).await?;
100:                 }
101:             }
102:             _ => {}
103:         }
104:         Ok(())
105:     }
106: 
107:     /// Track a file modification
108:     pub async fn track_file_modification(&self, file_path: &str) -> Result<()> {
109:         let mut tracker = self.file_tracker.write().await;
110:         let full_path = self.project_path.join(file_path);
111: 
112:         // Read current file state
113:         let (hash, exists, _size, modified) = if full_path.exists() {
114:             let content = fs::read_to_string(&full_path).unwrap_or_default();
115:             let metadata = fs::metadata(&full_path)?;
116:             let modified = metadata
117:                 .modified()
118:                 .ok()
119:                 .and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok())
120:                 .map(|d| {
121:                     Utc.timestamp_opt(d.as_secs() as i64, d.subsec_nanos())
122:                         .unwrap()
123:                 })
124:                 .unwrap_or_else(Utc::now);
125: 
126:             (
127:                 storage::CheckpointStorage::calculate_file_hash(&content),
128:                 true,
129:                 metadata.len(),
130:                 modified,
131:             )
132:         } else {
133:             (String::new(), false, 0, Utc::now())
134:         };
135: 
136:         // Check if file has actually changed
137:         let is_modified =
138:             if let Some(existing_state) = tracker.tracked_files.get(&PathBuf::from(file_path)) {
139:                 // File is modified if:
140:                 // 1. Hash has changed
141:                 // 2. Existence state has changed
142:                 // 3. It was already marked as modified
143:                 existing_state.last_hash != hash
144:                     || existing_state.exists != exists
145:                     || existing_state.is_modified
146:             } else {
147:                 // New file is always considered modified
148:                 true
149:             };
150: 
151:         tracker.tracked_files.insert(
152:             PathBuf::from(file_path),
153:             FileState {
154:                 last_hash: hash,
155:                 is_modified,
156:                 last_modified: modified,
157:                 exists,
158:             },
159:         );
160: 
161:         Ok(())
162:     }
163: 
164:     /// Track potential file changes from bash commands
165:     async fn track_bash_side_effects(&self, command: &str) -> Result<()> {
166:         // Common file-modifying commands
167:         let file_commands = [
168:             "echo", "cat", "cp", "mv", "rm", "touch", "sed", "awk", "npm", "yarn", "pnpm", "bun",
169:             "cargo", "make", "gcc", "g++",
170:         ];
171: 
172:         // Simple heuristic: if command contains file-modifying operations
173:         for cmd in &file_commands {
174:             if command.contains(cmd) {
175:                 // Mark all tracked files as potentially modified
176:                 let mut tracker = self.file_tracker.write().await;
177:                 for (_, state) in tracker.tracked_files.iter_mut() {
178:                     state.is_modified = true;
179:                 }
180:                 break;
181:             }
182:         }
183: 
184:         Ok(())
185:     }
186: 
187:     /// Create a checkpoint
188:     pub async fn create_checkpoint(
189:         &self,
190:         description: Option<String>,
191:         parent_checkpoint_id: Option<String>,
192:     ) -> Result<CheckpointResult> {
193:         let messages = self.current_messages.read().await;
194:         let message_index = messages.len().saturating_sub(1);
195: 
196:         // Extract metadata from the last user message
197:         let (user_prompt, model_used, total_tokens) =
198:             self.extract_checkpoint_metadata(&messages).await?;
199: 
200:         // Ensure every file in the project is tracked so new checkpoints include all files
201:         // Recursively walk the project directory and track each file
202:         fn collect_files(
203:             dir: &std::path::Path,
204:             base: &std::path::Path,
205:             files: &mut Vec<std::path::PathBuf>,
206:         ) -> Result<(), std::io::Error> {
207:             for entry in std::fs::read_dir(dir)? {
208:                 let entry = entry?;
209:                 let path = entry.path();
210:                 if path.is_dir() {
211:                     // Skip hidden directories like .git
212:                     if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
213:                         if name.starts_with('.') {
214:                             continue;
215:                         }
216:                     }
217:                     collect_files(&path, base, files)?;
218:                 } else if path.is_file() {
219:                     // Compute relative path from project root
220:                     if let Ok(rel) = path.strip_prefix(base) {
221:                         files.push(rel.to_path_buf());
222:                     }
223:                 }
224:             }
225:             Ok(())
226:         }
227:         let mut all_files = Vec::new();
228:         let project_dir = &self.project_path;
229:         let _ = collect_files(project_dir.as_path(), project_dir.as_path(), &mut all_files);
230:         for rel in all_files {
231:             if let Some(p) = rel.to_str() {
232:                 // Track each file for snapshot
233:                 let _ = self.track_file_modification(p).await;
234:             }
235:         }
236: 
237:         // Generate checkpoint ID early so snapshots reference it
238:         let checkpoint_id = storage::CheckpointStorage::generate_checkpoint_id();
239: 
240:         // Create file snapshots
241:         let file_snapshots = self.create_file_snapshots(&checkpoint_id).await?;
242: 
243:         // Generate checkpoint struct
244:         let checkpoint = Checkpoint {
245:             id: checkpoint_id.clone(),
246:             session_id: self.session_id.clone(),
247:             project_id: self.project_id.clone(),
248:             message_index,
249:             timestamp: Utc::now(),
250:             description,
251:             parent_checkpoint_id: {
252:                 if let Some(parent_id) = parent_checkpoint_id {
253:                     Some(parent_id)
254:                 } else {
255:                     // Perform an asynchronous read to avoid blocking within the runtime
256:                     let timeline = self.timeline.read().await;
257:                     timeline.current_checkpoint_id.clone()
258:                 }
259:             },
260:             metadata: CheckpointMetadata {
261:                 total_tokens,
262:                 model_used,
263:                 user_prompt,
264:                 file_changes: file_snapshots.len(),
265:                 snapshot_size: storage::CheckpointStorage::estimate_checkpoint_size(
266:                     &messages.join("\n"),
267:                     &file_snapshots,
268:                 ),
269:             },
270:         };
271: 
272:         // Save checkpoint
273:         let messages_content = messages.join("\n");
274:         let result = self.storage.save_checkpoint(
275:             &self.project_id,
276:             &self.session_id,
277:             &checkpoint,
278:             file_snapshots,
279:             &messages_content,
280:         )?;
281: 
282:         // Reload timeline from disk so in-memory timeline has updated nodes and total_checkpoints
283:         let claude_dir = self.storage.claude_dir.clone();
284:         let paths = CheckpointPaths::new(&claude_dir, &self.project_id, &self.session_id);
285:         let updated_timeline = self.storage.load_timeline(&paths.timeline_file)?;
286:         {
287:             let mut timeline_lock = self.timeline.write().await;
288:             *timeline_lock = updated_timeline;
289:         }
290: 
291:         // Update timeline (current checkpoint only)
292:         let mut timeline = self.timeline.write().await;
293:         timeline.current_checkpoint_id = Some(checkpoint_id);
294: 
295:         // Reset file tracker
296:         let mut tracker = self.file_tracker.write().await;
297:         for (_, state) in tracker.tracked_files.iter_mut() {
298:             state.is_modified = false;
299:         }
300: 
301:         Ok(result)
302:     }
303: 
304:     /// Extract metadata from messages for checkpoint
305:     async fn extract_checkpoint_metadata(
306:         &self,
307:         messages: &[String],
308:     ) -> Result<(String, String, u64)> {
309:         let mut user_prompt = String::new();
310:         let mut model_used = String::from("unknown");
311:         let mut total_tokens = 0u64;
312: 
313:         // Iterate through messages in reverse to find the last user prompt
314:         for msg_str in messages.iter().rev() {
315:             if let Ok(msg) = serde_json::from_str::<serde_json::Value>(msg_str) {
316:                 // Check for user message
317:                 if msg.get("type").and_then(|t| t.as_str()) == Some("user") {
318:                     if let Some(content) = msg
319:                         .get("message")
320:                         .and_then(|m| m.get("content"))
321:                         .and_then(|c| c.as_array())
322:                     {
323:                         for item in content {
324:                             if item.get("type").and_then(|t| t.as_str()) == Some("text") {
325:                                 if let Some(text) = item.get("text").and_then(|t| t.as_str()) {
326:                                     user_prompt = text.to_string();
327:                                     break;
328:                                 }
329:                             }
330:                         }
331:                     }
332:                 }
333: 
334:                 // Extract model info
335:                 if let Some(model) = msg.get("model").and_then(|m| m.as_str()) {
336:                     model_used = model.to_string();
337:                 }
338: 
339:                 // Also check for model in message.model (assistant messages)
340:                 if let Some(message) = msg.get("message") {
341:                     if let Some(model) = message.get("model").and_then(|m| m.as_str()) {
342:                         model_used = model.to_string();
343:                     }
344:                 }
345: 
346:                 // Count tokens - check both top-level and nested usage
347:                 // First check for usage in message.usage (assistant messages)
348:                 if let Some(message) = msg.get("message") {
349:                     if let Some(usage) = message.get("usage") {
350:                         if let Some(input) = usage.get("input_tokens").and_then(|t| t.as_u64()) {
351:                             total_tokens += input;
352:                         }
353:                         if let Some(output) = usage.get("output_tokens").and_then(|t| t.as_u64()) {
354:                             total_tokens += output;
355:                         }
356:                         // Also count cache tokens
357:                         if let Some(cache_creation) = usage
358:                             .get("cache_creation_input_tokens")
359:                             .and_then(|t| t.as_u64())
360:                         {
361:                             total_tokens += cache_creation;
362:                         }
363:                         if let Some(cache_read) = usage
364:                             .get("cache_read_input_tokens")
365:                             .and_then(|t| t.as_u64())
366:                         {
367:                             total_tokens += cache_read;
368:                         }
369:                     }
370:                 }
371: 
372:                 // Then check for top-level usage (result messages)
373:                 if let Some(usage) = msg.get("usage") {
374:                     if let Some(input) = usage.get("input_tokens").and_then(|t| t.as_u64()) {
375:                         total_tokens += input;
376:                     }
377:                     if let Some(output) = usage.get("output_tokens").and_then(|t| t.as_u64()) {
378:                         total_tokens += output;
379:                     }
380:                     // Also count cache tokens
381:                     if let Some(cache_creation) = usage
382:                         .get("cache_creation_input_tokens")
383:                         .and_then(|t| t.as_u64())
384:                     {
385:                         total_tokens += cache_creation;
386:                     }
387:                     if let Some(cache_read) = usage
388:                         .get("cache_read_input_tokens")
389:                         .and_then(|t| t.as_u64())
390:                     {
391:                         total_tokens += cache_read;
392:                     }
393:                 }
394:             }
395:         }
396: 
397:         Ok((user_prompt, model_used, total_tokens))
398:     }
399: 
400:     /// Create file snapshots for all tracked modified files
401:     async fn create_file_snapshots(&self, checkpoint_id: &str) -> Result<Vec<FileSnapshot>> {
402:         let tracker = self.file_tracker.read().await;
403:         let mut snapshots = Vec::new();
404: 
405:         for (rel_path, state) in &tracker.tracked_files {
406:             // Skip files that haven't been modified
407:             if !state.is_modified {
408:                 continue;
409:             }
410: 
411:             let full_path = self.project_path.join(rel_path);
412: 
413:             let (content, exists, permissions, size, current_hash) = if full_path.exists() {
414:                 let content = fs::read_to_string(&full_path).unwrap_or_default();
415:                 let current_hash = storage::CheckpointStorage::calculate_file_hash(&content);
416: 
417:                 // Don't skip based on hash - if is_modified is true, we should snapshot it
418:                 // The hash check in track_file_modification already determined if it changed
419: 
420:                 let metadata = fs::metadata(&full_path)?;
421:                 let permissions = {
422:                     #[cfg(unix)]
423:                     {
424:                         use std::os::unix::fs::PermissionsExt;
425:                         Some(metadata.permissions().mode())
426:                     }
427:                     #[cfg(not(unix))]
428:                     {
429:                         None
430:                     }
431:                 };
432:                 (content, true, permissions, metadata.len(), current_hash)
433:             } else {
434:                 (String::new(), false, None, 0, String::new())
435:             };
436: 
437:             snapshots.push(FileSnapshot {
438:                 checkpoint_id: checkpoint_id.to_string(),
439:                 file_path: rel_path.clone(),
440:                 content,
441:                 hash: current_hash,
442:                 is_deleted: !exists,
443:                 permissions,
444:                 size,
445:             });
446:         }
447: 
448:         Ok(snapshots)
449:     }
450: 
451:     /// Restore a checkpoint
452:     pub async fn restore_checkpoint(&self, checkpoint_id: &str) -> Result<CheckpointResult> {
453:         // Load checkpoint data
454:         let (checkpoint, file_snapshots, messages) =
455:             self.storage
456:                 .load_checkpoint(&self.project_id, &self.session_id, checkpoint_id)?;
457: 
458:         // First, collect all files currently in the project to handle deletions
459:         fn collect_all_project_files(
460:             dir: &std::path::Path,
461:             base: &std::path::Path,
462:             files: &mut Vec<std::path::PathBuf>,
463:         ) -> Result<(), std::io::Error> {
464:             for entry in std::fs::read_dir(dir)? {
465:                 let entry = entry?;
466:                 let path = entry.path();
467:                 if path.is_dir() {
468:                     // Skip hidden directories like .git
469:                     if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
470:                         if name.starts_with('.') {
471:                             continue;
472:                         }
473:                     }
474:                     collect_all_project_files(&path, base, files)?;
475:                 } else if path.is_file() {
476:                     // Compute relative path from project root
477:                     if let Ok(rel) = path.strip_prefix(base) {
478:                         files.push(rel.to_path_buf());
479:                     }
480:                 }
481:             }
482:             Ok(())
483:         }
484: 
485:         let mut current_files = Vec::new();
486:         let _ =
487:             collect_all_project_files(&self.project_path, &self.project_path, &mut current_files);
488: 
489:         // Create a set of files that should exist after restore
490:         let mut checkpoint_files = std::collections::HashSet::new();
491:         for snapshot in &file_snapshots {
492:             if !snapshot.is_deleted {
493:                 checkpoint_files.insert(snapshot.file_path.clone());
494:             }
495:         }
496: 
497:         // Delete files that exist now but shouldn't exist in the checkpoint
498:         let mut warnings = Vec::new();
499:         let mut files_processed = 0;
500: 
501:         for current_file in current_files {
502:             if !checkpoint_files.contains(&current_file) {
503:                 // This file exists now but not in the checkpoint, so delete it
504:                 let full_path = self.project_path.join(&current_file);
505:                 match fs::remove_file(&full_path) {
506:                     Ok(_) => {
507:                         files_processed += 1;
508:                         log::info!("Deleted file not in checkpoint: {:?}", current_file);
509:                     }
510:                     Err(e) => {
511:                         warnings.push(format!(
512:                             "Failed to delete {}: {}",
513:                             current_file.display(),
514:                             e
515:                         ));
516:                     }
517:                 }
518:             }
519:         }
520: 
521:         // Clean up empty directories
522:         fn remove_empty_dirs(
523:             dir: &std::path::Path,
524:             base: &std::path::Path,
525:         ) -> Result<bool, std::io::Error> {
526:             if dir == base {
527:                 return Ok(false); // Don't remove the base directory
528:             }
529: 
530:             let mut is_empty = true;
531:             for entry in fs::read_dir(dir)? {
532:                 let entry = entry?;
533:                 let path = entry.path();
534:                 if path.is_dir() {
535:                     if !remove_empty_dirs(&path, base)? {
536:                         is_empty = false;
537:                     }
538:                 } else {
539:                     is_empty = false;
540:                 }
541:             }
542: 
543:             if is_empty {
544:                 fs::remove_dir(dir)?;
545:                 Ok(true)
546:             } else {
547:                 Ok(false)
548:             }
549:         }
550: 
551:         // Clean up any empty directories left after file deletion
552:         let _ = remove_empty_dirs(&self.project_path, &self.project_path);
553: 
554:         // Restore files from checkpoint
555:         for snapshot in &file_snapshots {
556:             match self.restore_file_snapshot(snapshot).await {
557:                 Ok(_) => files_processed += 1,
558:                 Err(e) => warnings.push(format!(
559:                     "Failed to restore {}: {}",
560:                     snapshot.file_path.display(),
561:                     e
562:                 )),
563:             }
564:         }
565: 
566:         // Update current messages
567:         let mut current_messages = self.current_messages.write().await;
568:         current_messages.clear();
569:         for line in messages.lines() {
570:             current_messages.push(line.to_string());
571:         }
572: 
573:         // Update timeline
574:         let mut timeline = self.timeline.write().await;
575:         timeline.current_checkpoint_id = Some(checkpoint_id.to_string());
576: 
577:         // Update file tracker
578:         let mut tracker = self.file_tracker.write().await;
579:         tracker.tracked_files.clear();
580:         for snapshot in &file_snapshots {
581:             if !snapshot.is_deleted {
582:                 tracker.tracked_files.insert(
583:                     snapshot.file_path.clone(),
584:                     FileState {
585:                         last_hash: snapshot.hash.clone(),
586:                         is_modified: false,
587:                         last_modified: Utc::now(),
588:                         exists: true,
589:                     },
590:                 );
591:             }
592:         }
593: 
594:         Ok(CheckpointResult {
595:             checkpoint: checkpoint.clone(),
596:             files_processed,
597:             warnings,
598:         })
599:     }
600: 
601:     /// Restore a single file from snapshot
602:     async fn restore_file_snapshot(&self, snapshot: &FileSnapshot) -> Result<()> {
603:         let full_path = self.project_path.join(&snapshot.file_path);
604: 
605:         if snapshot.is_deleted {
606:             // Delete the file if it exists
607:             if full_path.exists() {
608:                 fs::remove_file(&full_path).context("Failed to delete file")?;
609:             }
610:         } else {
611:             // Create parent directories if needed
612:             if let Some(parent) = full_path.parent() {
613:                 fs::create_dir_all(parent).context("Failed to create parent directories")?;
614:             }
615: 
616:             // Write file content
617:             fs::write(&full_path, &snapshot.content).context("Failed to write file")?;
618: 
619:             // Restore permissions if available
620:             #[cfg(unix)]
621:             if let Some(mode) = snapshot.permissions {
622:                 use std::os::unix::fs::PermissionsExt;
623:                 let permissions = std::fs::Permissions::from_mode(mode);
624:                 fs::set_permissions(&full_path, permissions)
625:                     .context("Failed to set file permissions")?;
626:             }
627:         }
628: 
629:         Ok(())
630:     }
631: 
632:     /// Get the current timeline
633:     pub async fn get_timeline(&self) -> SessionTimeline {
634:         self.timeline.read().await.clone()
635:     }
636: 
637:     /// List all checkpoints
638:     pub async fn list_checkpoints(&self) -> Vec<Checkpoint> {
639:         let timeline = self.timeline.read().await;
640:         let mut checkpoints = Vec::new();
641: 
642:         if let Some(root) = &timeline.root_node {
643:             Self::collect_checkpoints_from_node(root, &mut checkpoints);
644:         }
645: 
646:         checkpoints
647:     }
648: 
649:     /// Recursively collect checkpoints from timeline tree
650:     fn collect_checkpoints_from_node(
651:         node: &super::TimelineNode,
652:         checkpoints: &mut Vec<Checkpoint>,
653:     ) {
654:         checkpoints.push(node.checkpoint.clone());
655:         for child in &node.children {
656:             Self::collect_checkpoints_from_node(child, checkpoints);
657:         }
658:     }
659: 
660:     /// Fork from a checkpoint
661:     pub async fn fork_from_checkpoint(
662:         &self,
663:         checkpoint_id: &str,
664:         description: Option<String>,
665:     ) -> Result<CheckpointResult> {
666:         // Load the checkpoint to fork from
667:         let (_base_checkpoint, _, _) =
668:             self.storage
669:                 .load_checkpoint(&self.project_id, &self.session_id, checkpoint_id)?;
670: 
671:         // Restore to that checkpoint first
672:         self.restore_checkpoint(checkpoint_id).await?;
673: 
674:         // Create a new checkpoint with the fork
675:         let fork_description =
676:             description.unwrap_or_else(|| format!("Fork from checkpoint {}", &checkpoint_id[..8]));
677: 
678:         self.create_checkpoint(Some(fork_description), Some(checkpoint_id.to_string()))
679:             .await
680:     }
681: 
682:     /// Check if auto-checkpoint should be triggered
683:     pub async fn should_auto_checkpoint(&self, message: &str) -> bool {
684:         let timeline = self.timeline.read().await;
685: 
686:         if !timeline.auto_checkpoint_enabled {
687:             return false;
688:         }
689: 
690:         match timeline.checkpoint_strategy {
691:             CheckpointStrategy::Manual => false,
692:             CheckpointStrategy::PerPrompt => {
693:                 // Check if message is a user prompt
694:                 if let Ok(msg) = serde_json::from_str::<serde_json::Value>(message) {
695:                     msg.get("type").and_then(|t| t.as_str()) == Some("user")
696:                 } else {
697:                     false
698:                 }
699:             }
700:             CheckpointStrategy::PerToolUse => {
701:                 // Check if message contains tool use
702:                 if let Ok(msg) = serde_json::from_str::<serde_json::Value>(message) {
703:                     if let Some(content) = msg
704:                         .get("message")
705:                         .and_then(|m| m.get("content"))
706:                         .and_then(|c| c.as_array())
707:                     {
708:                         content.iter().any(|item| {
709:                             item.get("type").and_then(|t| t.as_str()) == Some("tool_use")
710:                         })
711:                     } else {
712:                         false
713:                     }
714:                 } else {
715:                     false
716:                 }
717:             }
718:             CheckpointStrategy::Smart => {
719:                 // Smart strategy: checkpoint after destructive operations
720:                 if let Ok(msg) = serde_json::from_str::<serde_json::Value>(message) {
721:                     if let Some(content) = msg
722:                         .get("message")
723:                         .and_then(|m| m.get("content"))
724:                         .and_then(|c| c.as_array())
725:                     {
726:                         content.iter().any(|item| {
727:                             if item.get("type").and_then(|t| t.as_str()) == Some("tool_use") {
728:                                 let tool_name =
729:                                     item.get("name").and_then(|n| n.as_str()).unwrap_or("");
730:                                 matches!(
731:                                     tool_name.to_lowercase().as_str(),
732:                                     "write" | "edit" | "multiedit" | "bash" | "rm" | "delete"
733:                                 )
734:                             } else {
735:                                 false
736:                             }
737:                         })
738:                     } else {
739:                         false
740:                     }
741:                 } else {
742:                     false
743:                 }
744:             }
745:         }
746:     }
747: 
748:     /// Update checkpoint settings
749:     pub async fn update_settings(
750:         &self,
751:         auto_checkpoint_enabled: bool,
752:         checkpoint_strategy: CheckpointStrategy,
753:     ) -> Result<()> {
754:         let mut timeline = self.timeline.write().await;
755:         timeline.auto_checkpoint_enabled = auto_checkpoint_enabled;
756:         timeline.checkpoint_strategy = checkpoint_strategy;
757: 
758:         // Save updated timeline
759:         let claude_dir = self.storage.claude_dir.clone();
760:         let paths = CheckpointPaths::new(&claude_dir, &self.project_id, &self.session_id);
761:         self.storage
762:             .save_timeline(&paths.timeline_file, &timeline)?;
763: 
764:         Ok(())
765:     }
766: 
767:     /// Get files modified since a given timestamp
768:     pub async fn get_files_modified_since(&self, since: DateTime<Utc>) -> Vec<PathBuf> {
769:         let tracker = self.file_tracker.read().await;
770:         tracker
771:             .tracked_files
772:             .iter()
773:             .filter(|(_, state)| state.last_modified > since && state.is_modified)
774:             .map(|(path, _)| path.clone())
775:             .collect()
776:     }
777: 
778:     /// Get the last modification time of any tracked file
779:     pub async fn get_last_modification_time(&self) -> Option<DateTime<Utc>> {
780:         let tracker = self.file_tracker.read().await;
781:         tracker
782:             .tracked_files
783:             .values()
784:             .map(|state| state.last_modified)
785:             .max()
786:     }
787: }
````

## File: src-tauri/src/checkpoint/mod.rs
````rust
  1: use chrono::{DateTime, Utc};
  2: use serde::{Deserialize, Serialize};
  3: use std::collections::HashMap;
  4: use std::path::PathBuf;
  5: 
  6: pub mod manager;
  7: pub mod state;
  8: pub mod storage;
  9: 
 10: /// Represents a checkpoint in the session timeline
 11: #[derive(Debug, Clone, Serialize, Deserialize)]
 12: #[serde(rename_all = "camelCase")]
 13: pub struct Checkpoint {
 14:     /// Unique identifier for the checkpoint
 15:     pub id: String,
 16:     /// Session ID this checkpoint belongs to
 17:     pub session_id: String,
 18:     /// Project ID for the session
 19:     pub project_id: String,
 20:     /// Index of the last message in this checkpoint
 21:     pub message_index: usize,
 22:     /// Timestamp when checkpoint was created
 23:     pub timestamp: DateTime<Utc>,
 24:     /// User-provided description
 25:     pub description: Option<String>,
 26:     /// Parent checkpoint ID for fork tracking
 27:     pub parent_checkpoint_id: Option<String>,
 28:     /// Metadata about the checkpoint
 29:     pub metadata: CheckpointMetadata,
 30: }
 31: 
 32: /// Metadata associated with a checkpoint
 33: #[derive(Debug, Clone, Serialize, Deserialize)]
 34: #[serde(rename_all = "camelCase")]
 35: pub struct CheckpointMetadata {
 36:     /// Total tokens used up to this point
 37:     pub total_tokens: u64,
 38:     /// Model used for the last operation
 39:     pub model_used: String,
 40:     /// The user prompt that led to this state
 41:     pub user_prompt: String,
 42:     /// Number of file changes in this checkpoint
 43:     pub file_changes: usize,
 44:     /// Size of all file snapshots in bytes
 45:     pub snapshot_size: u64,
 46: }
 47: 
 48: /// Represents a snapshot of a file at a checkpoint
 49: #[derive(Debug, Clone, Serialize, Deserialize)]
 50: #[serde(rename_all = "camelCase")]
 51: pub struct FileSnapshot {
 52:     /// Checkpoint this snapshot belongs to
 53:     pub checkpoint_id: String,
 54:     /// Relative path from project root
 55:     pub file_path: PathBuf,
 56:     /// Full content of the file (will be compressed)
 57:     pub content: String,
 58:     /// SHA-256 hash for integrity verification
 59:     pub hash: String,
 60:     /// Whether this file was deleted at this checkpoint
 61:     pub is_deleted: bool,
 62:     /// File permissions (Unix mode)
 63:     pub permissions: Option<u32>,
 64:     /// File size in bytes
 65:     pub size: u64,
 66: }
 67: 
 68: /// Represents a node in the timeline tree
 69: #[derive(Debug, Clone, Serialize, Deserialize)]
 70: #[serde(rename_all = "camelCase")]
 71: pub struct TimelineNode {
 72:     /// The checkpoint at this node
 73:     pub checkpoint: Checkpoint,
 74:     /// Child nodes (for branches/forks)
 75:     pub children: Vec<TimelineNode>,
 76:     /// IDs of file snapshots associated with this checkpoint
 77:     pub file_snapshot_ids: Vec<String>,
 78: }
 79: 
 80: /// The complete timeline for a session
 81: #[derive(Debug, Clone, Serialize, Deserialize)]
 82: #[serde(rename_all = "camelCase")]
 83: pub struct SessionTimeline {
 84:     /// Session ID this timeline belongs to
 85:     pub session_id: String,
 86:     /// Root node of the timeline tree
 87:     pub root_node: Option<TimelineNode>,
 88:     /// ID of the current active checkpoint
 89:     pub current_checkpoint_id: Option<String>,
 90:     /// Whether auto-checkpointing is enabled
 91:     pub auto_checkpoint_enabled: bool,
 92:     /// Strategy for automatic checkpoints
 93:     pub checkpoint_strategy: CheckpointStrategy,
 94:     /// Total number of checkpoints in timeline
 95:     pub total_checkpoints: usize,
 96: }
 97: 
 98: /// Strategy for automatic checkpoint creation
 99: #[derive(Debug, Clone, Serialize, Deserialize)]
100: #[serde(rename_all = "snake_case")]
101: pub enum CheckpointStrategy {
102:     /// Only create checkpoints manually
103:     Manual,
104:     /// Create checkpoint after each user prompt
105:     PerPrompt,
106:     /// Create checkpoint after each tool use
107:     PerToolUse,
108:     /// Create checkpoint after destructive operations
109:     Smart,
110: }
111: 
112: /// Tracks the state of files for checkpointing
113: #[derive(Debug, Clone)]
114: pub struct FileTracker {
115:     /// Map of file paths to their current state
116:     pub tracked_files: HashMap<PathBuf, FileState>,
117: }
118: 
119: /// State of a tracked file
120: #[derive(Debug, Clone)]
121: pub struct FileState {
122:     /// Last known hash of the file
123:     pub last_hash: String,
124:     /// Whether the file has been modified since last checkpoint
125:     pub is_modified: bool,
126:     /// Last modification timestamp
127:     pub last_modified: DateTime<Utc>,
128:     /// Whether the file currently exists
129:     pub exists: bool,
130: }
131: 
132: /// Result of a checkpoint operation
133: #[derive(Debug, Serialize, Deserialize)]
134: pub struct CheckpointResult {
135:     /// The created/restored checkpoint
136:     pub checkpoint: Checkpoint,
137:     /// Number of files snapshot/restored
138:     pub files_processed: usize,
139:     /// Any warnings during the operation
140:     pub warnings: Vec<String>,
141: }
142: 
143: /// Diff between two checkpoints
144: #[derive(Debug, Serialize, Deserialize)]
145: pub struct CheckpointDiff {
146:     /// Source checkpoint ID
147:     pub from_checkpoint_id: String,
148:     /// Target checkpoint ID  
149:     pub to_checkpoint_id: String,
150:     /// Files that were modified
151:     pub modified_files: Vec<FileDiff>,
152:     /// Files that were added
153:     pub added_files: Vec<PathBuf>,
154:     /// Files that were deleted
155:     pub deleted_files: Vec<PathBuf>,
156:     /// Token usage difference
157:     pub token_delta: i64,
158: }
159: 
160: /// Diff for a single file
161: #[derive(Debug, Serialize, Deserialize)]
162: pub struct FileDiff {
163:     /// File path
164:     pub path: PathBuf,
165:     /// Number of additions
166:     pub additions: usize,
167:     /// Number of deletions
168:     pub deletions: usize,
169:     /// Unified diff content (optional)
170:     pub diff_content: Option<String>,
171: }
172: 
173: impl Default for CheckpointStrategy {
174:     fn default() -> Self {
175:         CheckpointStrategy::Smart
176:     }
177: }
178: 
179: impl SessionTimeline {
180:     /// Create a new empty timeline
181:     pub fn new(session_id: String) -> Self {
182:         Self {
183:             session_id,
184:             root_node: None,
185:             current_checkpoint_id: None,
186:             auto_checkpoint_enabled: false,
187:             checkpoint_strategy: CheckpointStrategy::default(),
188:             total_checkpoints: 0,
189:         }
190:     }
191: 
192:     /// Find a checkpoint by ID in the timeline tree
193:     pub fn find_checkpoint(&self, checkpoint_id: &str) -> Option<&TimelineNode> {
194:         self.root_node
195:             .as_ref()
196:             .and_then(|root| Self::find_in_tree(root, checkpoint_id))
197:     }
198: 
199:     fn find_in_tree<'a>(node: &'a TimelineNode, checkpoint_id: &str) -> Option<&'a TimelineNode> {
200:         if node.checkpoint.id == checkpoint_id {
201:             return Some(node);
202:         }
203: 
204:         for child in &node.children {
205:             if let Some(found) = Self::find_in_tree(child, checkpoint_id) {
206:                 return Some(found);
207:             }
208:         }
209: 
210:         None
211:     }
212: }
213: 
214: /// Checkpoint storage paths
215: pub struct CheckpointPaths {
216:     pub timeline_file: PathBuf,
217:     pub checkpoints_dir: PathBuf,
218:     pub files_dir: PathBuf,
219: }
220: 
221: impl CheckpointPaths {
222:     pub fn new(claude_dir: &PathBuf, project_id: &str, session_id: &str) -> Self {
223:         let base_dir = claude_dir
224:             .join("projects")
225:             .join(project_id)
226:             .join(".timelines")
227:             .join(session_id);
228: 
229:         Self {
230:             timeline_file: base_dir.join("timeline.json"),
231:             checkpoints_dir: base_dir.join("checkpoints"),
232:             files_dir: base_dir.join("files"),
233:         }
234:     }
235: 
236:     pub fn checkpoint_dir(&self, checkpoint_id: &str) -> PathBuf {
237:         self.checkpoints_dir.join(checkpoint_id)
238:     }
239: 
240:     pub fn checkpoint_metadata_file(&self, checkpoint_id: &str) -> PathBuf {
241:         self.checkpoint_dir(checkpoint_id).join("metadata.json")
242:     }
243: 
244:     pub fn checkpoint_messages_file(&self, checkpoint_id: &str) -> PathBuf {
245:         self.checkpoint_dir(checkpoint_id).join("messages.jsonl")
246:     }
247: 
248:     #[allow(dead_code)]
249:     pub fn file_snapshot_path(&self, _checkpoint_id: &str, file_hash: &str) -> PathBuf {
250:         // In content-addressable storage, files are stored by hash in the content pool
251:         self.files_dir.join("content_pool").join(file_hash)
252:     }
253: 
254:     #[allow(dead_code)]
255:     pub fn file_reference_path(&self, checkpoint_id: &str, safe_filename: &str) -> PathBuf {
256:         // References are stored per checkpoint
257:         self.files_dir
258:             .join("refs")
259:             .join(checkpoint_id)
260:             .join(format!("{}.json", safe_filename))
261:     }
262: }
````

## File: src-tauri/src/checkpoint/state.rs
````rust
  1: use anyhow::Result;
  2: use std::collections::HashMap;
  3: use std::path::PathBuf;
  4: use std::sync::Arc;
  5: use tokio::sync::RwLock;
  6: 
  7: use super::manager::CheckpointManager;
  8: 
  9: /// Manages checkpoint managers for active sessions
 10: ///
 11: /// This struct maintains a stateful collection of CheckpointManager instances,
 12: /// one per active session, to avoid recreating them on every command invocation.
 13: /// It provides thread-safe access to managers and handles their lifecycle.
 14: #[derive(Default, Clone)]
 15: pub struct CheckpointState {
 16:     /// Map of session_id to CheckpointManager
 17:     /// Uses Arc<CheckpointManager> to allow sharing across async boundaries
 18:     managers: Arc<RwLock<HashMap<String, Arc<CheckpointManager>>>>,
 19:     /// The Claude directory path for consistent access
 20:     claude_dir: Arc<RwLock<Option<PathBuf>>>,
 21: }
 22: 
 23: impl CheckpointState {
 24:     /// Creates a new CheckpointState instance
 25:     pub fn new() -> Self {
 26:         Self {
 27:             managers: Arc::new(RwLock::new(HashMap::new())),
 28:             claude_dir: Arc::new(RwLock::new(None)),
 29:         }
 30:     }
 31: 
 32:     /// Sets the Claude directory path
 33:     ///
 34:     /// This should be called once during application initialization
 35:     pub async fn set_claude_dir(&self, claude_dir: PathBuf) {
 36:         let mut dir = self.claude_dir.write().await;
 37:         *dir = Some(claude_dir);
 38:     }
 39: 
 40:     /// Gets or creates a CheckpointManager for a session
 41:     ///
 42:     /// If a manager already exists for the session, it returns the existing one.
 43:     /// Otherwise, it creates a new manager and stores it for future use.
 44:     ///
 45:     /// # Arguments
 46:     /// * `session_id` - The session identifier
 47:     /// * `project_id` - The project identifier
 48:     /// * `project_path` - The path to the project directory
 49:     ///
 50:     /// # Returns
 51:     /// An Arc reference to the CheckpointManager for thread-safe sharing
 52:     pub async fn get_or_create_manager(
 53:         &self,
 54:         session_id: String,
 55:         project_id: String,
 56:         project_path: PathBuf,
 57:     ) -> Result<Arc<CheckpointManager>> {
 58:         let mut managers = self.managers.write().await;
 59: 
 60:         // Check if manager already exists
 61:         if let Some(manager) = managers.get(&session_id) {
 62:             return Ok(Arc::clone(manager));
 63:         }
 64: 
 65:         // Get Claude directory
 66:         let claude_dir = {
 67:             let dir = self.claude_dir.read().await;
 68:             dir.as_ref()
 69:                 .ok_or_else(|| anyhow::anyhow!("Claude directory not set"))?
 70:                 .clone()
 71:         };
 72: 
 73:         // Create new manager
 74:         let manager =
 75:             CheckpointManager::new(project_id, session_id.clone(), project_path, claude_dir)
 76:                 .await?;
 77: 
 78:         let manager_arc = Arc::new(manager);
 79:         managers.insert(session_id, Arc::clone(&manager_arc));
 80: 
 81:         Ok(manager_arc)
 82:     }
 83: 
 84:     /// Gets an existing CheckpointManager for a session
 85:     ///
 86:     /// Returns None if no manager exists for the session
 87:     #[allow(dead_code)]
 88:     pub async fn get_manager(&self, session_id: &str) -> Option<Arc<CheckpointManager>> {
 89:         let managers = self.managers.read().await;
 90:         managers.get(session_id).map(Arc::clone)
 91:     }
 92: 
 93:     /// Removes a CheckpointManager for a session
 94:     ///
 95:     /// This should be called when a session ends to free resources
 96:     pub async fn remove_manager(&self, session_id: &str) -> Option<Arc<CheckpointManager>> {
 97:         let mut managers = self.managers.write().await;
 98:         managers.remove(session_id)
 99:     }
100: 
101:     /// Clears all managers
102:     ///
103:     /// This is useful for cleanup during application shutdown
104:     #[allow(dead_code)]
105:     pub async fn clear_all(&self) {
106:         let mut managers = self.managers.write().await;
107:         managers.clear();
108:     }
109: 
110:     /// Gets the number of active managers
111:     pub async fn active_count(&self) -> usize {
112:         let managers = self.managers.read().await;
113:         managers.len()
114:     }
115: 
116:     /// Lists all active session IDs
117:     pub async fn list_active_sessions(&self) -> Vec<String> {
118:         let managers = self.managers.read().await;
119:         managers.keys().cloned().collect()
120:     }
121: 
122:     /// Checks if a session has an active manager
123:     #[allow(dead_code)]
124:     pub async fn has_active_manager(&self, session_id: &str) -> bool {
125:         self.get_manager(session_id).await.is_some()
126:     }
127: 
128:     /// Clears all managers and returns the count that were cleared
129:     #[allow(dead_code)]
130:     pub async fn clear_all_and_count(&self) -> usize {
131:         let count = self.active_count().await;
132:         self.clear_all().await;
133:         count
134:     }
135: }
136: 
137: #[cfg(test)]
138: mod tests {
139:     use super::*;
140:     use tempfile::TempDir;
141: 
142:     #[tokio::test]
143:     async fn test_checkpoint_state_lifecycle() {
144:         let state = CheckpointState::new();
145:         let temp_dir = TempDir::new().unwrap();
146:         let claude_dir = temp_dir.path().to_path_buf();
147: 
148:         // Set Claude directory
149:         state.set_claude_dir(claude_dir.clone()).await;
150: 
151:         // Create a manager
152:         let session_id = "test-session-123".to_string();
153:         let project_id = "test-project".to_string();
154:         let project_path = temp_dir.path().join("project");
155:         std::fs::create_dir_all(&project_path).unwrap();
156: 
157:         let manager1 = state
158:             .get_or_create_manager(session_id.clone(), project_id.clone(), project_path.clone())
159:             .await
160:             .unwrap();
161: 
162:         // Getting the same session should return the same manager
163:         let manager2 = state
164:             .get_or_create_manager(session_id.clone(), project_id.clone(), project_path.clone())
165:             .await
166:             .unwrap();
167: 
168:         assert!(Arc::ptr_eq(&manager1, &manager2));
169:         assert_eq!(state.active_count().await, 1);
170: 
171:         // Remove the manager
172:         let removed = state.remove_manager(&session_id).await;
173:         assert!(removed.is_some());
174:         assert_eq!(state.active_count().await, 0);
175: 
176:         // Getting after removal should create a new one
177:         let manager3 = state
178:             .get_or_create_manager(session_id.clone(), project_id, project_path)
179:             .await
180:             .unwrap();
181: 
182:         assert!(!Arc::ptr_eq(&manager1, &manager3));
183:     }
184: }
````

## File: src-tauri/src/checkpoint/storage.rs
````rust
  1: use anyhow::{Context, Result};
  2: use sha2::{Digest, Sha256};
  3: use std::fs;
  4: use std::path::{Path, PathBuf};
  5: use uuid::Uuid;
  6: use zstd::stream::{decode_all, encode_all};
  7: 
  8: use super::{
  9:     Checkpoint, CheckpointPaths, CheckpointResult, FileSnapshot, SessionTimeline, TimelineNode,
 10: };
 11: 
 12: /// Manages checkpoint storage operations
 13: pub struct CheckpointStorage {
 14:     pub claude_dir: PathBuf,
 15:     compression_level: i32,
 16: }
 17: 
 18: impl CheckpointStorage {
 19:     /// Create a new checkpoint storage instance
 20:     pub fn new(claude_dir: PathBuf) -> Self {
 21:         Self {
 22:             claude_dir,
 23:             compression_level: 3, // Default zstd compression level
 24:         }
 25:     }
 26: 
 27:     /// Initialize checkpoint storage for a session
 28:     pub fn init_storage(&self, project_id: &str, session_id: &str) -> Result<()> {
 29:         let paths = CheckpointPaths::new(&self.claude_dir, project_id, session_id);
 30: 
 31:         // Create directory structure
 32:         fs::create_dir_all(&paths.checkpoints_dir)
 33:             .context("Failed to create checkpoints directory")?;
 34:         fs::create_dir_all(&paths.files_dir).context("Failed to create files directory")?;
 35: 
 36:         // Initialize empty timeline if it doesn't exist
 37:         if !paths.timeline_file.exists() {
 38:             let timeline = SessionTimeline::new(session_id.to_string());
 39:             self.save_timeline(&paths.timeline_file, &timeline)?;
 40:         }
 41: 
 42:         Ok(())
 43:     }
 44: 
 45:     /// Save a checkpoint to disk
 46:     pub fn save_checkpoint(
 47:         &self,
 48:         project_id: &str,
 49:         session_id: &str,
 50:         checkpoint: &Checkpoint,
 51:         file_snapshots: Vec<FileSnapshot>,
 52:         messages: &str, // JSONL content up to checkpoint
 53:     ) -> Result<CheckpointResult> {
 54:         let paths = CheckpointPaths::new(&self.claude_dir, project_id, session_id);
 55:         let checkpoint_dir = paths.checkpoint_dir(&checkpoint.id);
 56: 
 57:         // Create checkpoint directory
 58:         fs::create_dir_all(&checkpoint_dir).context("Failed to create checkpoint directory")?;
 59: 
 60:         // Save checkpoint metadata
 61:         let metadata_path = paths.checkpoint_metadata_file(&checkpoint.id);
 62:         let metadata_json = serde_json::to_string_pretty(checkpoint)
 63:             .context("Failed to serialize checkpoint metadata")?;
 64:         fs::write(&metadata_path, metadata_json).context("Failed to write checkpoint metadata")?;
 65: 
 66:         // Save messages (compressed)
 67:         let messages_path = paths.checkpoint_messages_file(&checkpoint.id);
 68:         let compressed_messages = encode_all(messages.as_bytes(), self.compression_level)
 69:             .context("Failed to compress messages")?;
 70:         fs::write(&messages_path, compressed_messages)
 71:             .context("Failed to write compressed messages")?;
 72: 
 73:         // Save file snapshots
 74:         let mut warnings = Vec::new();
 75:         let mut files_processed = 0;
 76: 
 77:         for snapshot in &file_snapshots {
 78:             match self.save_file_snapshot(&paths, snapshot) {
 79:                 Ok(_) => files_processed += 1,
 80:                 Err(e) => warnings.push(format!(
 81:                     "Failed to save {}: {}",
 82:                     snapshot.file_path.display(),
 83:                     e
 84:                 )),
 85:             }
 86:         }
 87: 
 88:         // Update timeline
 89:         self.update_timeline_with_checkpoint(&paths.timeline_file, checkpoint, &file_snapshots)?;
 90: 
 91:         Ok(CheckpointResult {
 92:             checkpoint: checkpoint.clone(),
 93:             files_processed,
 94:             warnings,
 95:         })
 96:     }
 97: 
 98:     /// Save a single file snapshot
 99:     fn save_file_snapshot(&self, paths: &CheckpointPaths, snapshot: &FileSnapshot) -> Result<()> {
100:         // Use content-addressable storage: store files by their hash
101:         // This prevents duplication of identical file content across checkpoints
102:         let content_pool_dir = paths.files_dir.join("content_pool");
103:         fs::create_dir_all(&content_pool_dir).context("Failed to create content pool directory")?;
104: 
105:         // Store the actual content in the content pool
106:         let content_file = content_pool_dir.join(&snapshot.hash);
107: 
108:         // Only write the content if it doesn't already exist
109:         if !content_file.exists() {
110:             // Compress and save file content
111:             let compressed_content =
112:                 encode_all(snapshot.content.as_bytes(), self.compression_level)
113:                     .context("Failed to compress file content")?;
114:             fs::write(&content_file, compressed_content)
115:                 .context("Failed to write file content to pool")?;
116:         }
117: 
118:         // Create a reference in the checkpoint-specific directory
119:         let checkpoint_refs_dir = paths.files_dir.join("refs").join(&snapshot.checkpoint_id);
120:         fs::create_dir_all(&checkpoint_refs_dir)
121:             .context("Failed to create checkpoint refs directory")?;
122: 
123:         // Save file metadata with reference to content
124:         let ref_metadata = serde_json::json!({
125:             "path": snapshot.file_path,
126:             "hash": snapshot.hash,
127:             "is_deleted": snapshot.is_deleted,
128:             "permissions": snapshot.permissions,
129:             "size": snapshot.size,
130:         });
131: 
132:         // Use a sanitized filename for the reference
133:         let safe_filename = snapshot
134:             .file_path
135:             .to_string_lossy()
136:             .replace('/', "_")
137:             .replace('\\', "_");
138:         let ref_path = checkpoint_refs_dir.join(format!("{}.json", safe_filename));
139: 
140:         fs::write(&ref_path, serde_json::to_string_pretty(&ref_metadata)?)
141:             .context("Failed to write file reference")?;
142: 
143:         Ok(())
144:     }
145: 
146:     /// Load a checkpoint from disk
147:     pub fn load_checkpoint(
148:         &self,
149:         project_id: &str,
150:         session_id: &str,
151:         checkpoint_id: &str,
152:     ) -> Result<(Checkpoint, Vec<FileSnapshot>, String)> {
153:         let paths = CheckpointPaths::new(&self.claude_dir, project_id, session_id);
154: 
155:         // Load checkpoint metadata
156:         let metadata_path = paths.checkpoint_metadata_file(checkpoint_id);
157:         let metadata_json =
158:             fs::read_to_string(&metadata_path).context("Failed to read checkpoint metadata")?;
159:         let checkpoint: Checkpoint =
160:             serde_json::from_str(&metadata_json).context("Failed to parse checkpoint metadata")?;
161: 
162:         // Load messages
163:         let messages_path = paths.checkpoint_messages_file(checkpoint_id);
164:         let compressed_messages =
165:             fs::read(&messages_path).context("Failed to read compressed messages")?;
166:         let messages = String::from_utf8(
167:             decode_all(&compressed_messages[..]).context("Failed to decompress messages")?,
168:         )
169:         .context("Invalid UTF-8 in messages")?;
170: 
171:         // Load file snapshots
172:         let file_snapshots = self.load_file_snapshots(&paths, checkpoint_id)?;
173: 
174:         Ok((checkpoint, file_snapshots, messages))
175:     }
176: 
177:     /// Load all file snapshots for a checkpoint
178:     fn load_file_snapshots(
179:         &self,
180:         paths: &CheckpointPaths,
181:         checkpoint_id: &str,
182:     ) -> Result<Vec<FileSnapshot>> {
183:         let refs_dir = paths.files_dir.join("refs").join(checkpoint_id);
184:         if !refs_dir.exists() {
185:             return Ok(Vec::new());
186:         }
187: 
188:         let content_pool_dir = paths.files_dir.join("content_pool");
189:         let mut snapshots = Vec::new();
190: 
191:         // Read all reference files
192:         for entry in fs::read_dir(&refs_dir)? {
193:             let entry = entry?;
194:             let path = entry.path();
195: 
196:             // Skip non-JSON files
197:             if path.extension().and_then(|e| e.to_str()) != Some("json") {
198:                 continue;
199:             }
200: 
201:             // Load reference metadata
202:             let ref_json = fs::read_to_string(&path).context("Failed to read file reference")?;
203:             let ref_metadata: serde_json::Value =
204:                 serde_json::from_str(&ref_json).context("Failed to parse file reference")?;
205: 
206:             let hash = ref_metadata["hash"]
207:                 .as_str()
208:                 .ok_or_else(|| anyhow::anyhow!("Missing hash in reference"))?;
209: 
210:             // Load content from pool
211:             let content_file = content_pool_dir.join(hash);
212:             let content = if content_file.exists() {
213:                 let compressed_content =
214:                     fs::read(&content_file).context("Failed to read file content from pool")?;
215:                 String::from_utf8(
216:                     decode_all(&compressed_content[..])
217:                         .context("Failed to decompress file content")?,
218:                 )
219:                 .context("Invalid UTF-8 in file content")?
220:             } else {
221:                 // Handle missing content gracefully
222:                 log::warn!("Content file missing for hash: {}", hash);
223:                 String::new()
224:             };
225: 
226:             snapshots.push(FileSnapshot {
227:                 checkpoint_id: checkpoint_id.to_string(),
228:                 file_path: PathBuf::from(ref_metadata["path"].as_str().unwrap_or("")),
229:                 content,
230:                 hash: hash.to_string(),
231:                 is_deleted: ref_metadata["is_deleted"].as_bool().unwrap_or(false),
232:                 permissions: ref_metadata["permissions"].as_u64().map(|p| p as u32),
233:                 size: ref_metadata["size"].as_u64().unwrap_or(0),
234:             });
235:         }
236: 
237:         Ok(snapshots)
238:     }
239: 
240:     /// Save timeline to disk
241:     pub fn save_timeline(&self, timeline_path: &Path, timeline: &SessionTimeline) -> Result<()> {
242:         let timeline_json =
243:             serde_json::to_string_pretty(timeline).context("Failed to serialize timeline")?;
244:         fs::write(timeline_path, timeline_json).context("Failed to write timeline")?;
245:         Ok(())
246:     }
247: 
248:     /// Load timeline from disk
249:     pub fn load_timeline(&self, timeline_path: &Path) -> Result<SessionTimeline> {
250:         let timeline_json = fs::read_to_string(timeline_path).context("Failed to read timeline")?;
251:         let timeline: SessionTimeline =
252:             serde_json::from_str(&timeline_json).context("Failed to parse timeline")?;
253:         Ok(timeline)
254:     }
255: 
256:     /// Update timeline with a new checkpoint
257:     fn update_timeline_with_checkpoint(
258:         &self,
259:         timeline_path: &Path,
260:         checkpoint: &Checkpoint,
261:         file_snapshots: &[FileSnapshot],
262:     ) -> Result<()> {
263:         let mut timeline = self.load_timeline(timeline_path)?;
264: 
265:         let new_node = TimelineNode {
266:             checkpoint: checkpoint.clone(),
267:             children: Vec::new(),
268:             file_snapshot_ids: file_snapshots.iter().map(|s| s.hash.clone()).collect(),
269:         };
270: 
271:         // If this is the first checkpoint
272:         if timeline.root_node.is_none() {
273:             timeline.root_node = Some(new_node);
274:             timeline.current_checkpoint_id = Some(checkpoint.id.clone());
275:         } else if let Some(parent_id) = &checkpoint.parent_checkpoint_id {
276:             // Check if parent exists before modifying
277:             let parent_exists = timeline.find_checkpoint(parent_id).is_some();
278: 
279:             if parent_exists {
280:                 if let Some(root) = &mut timeline.root_node {
281:                     Self::add_child_to_node(root, parent_id, new_node)?;
282:                     timeline.current_checkpoint_id = Some(checkpoint.id.clone());
283:                 }
284:             } else {
285:                 anyhow::bail!("Parent checkpoint not found: {}", parent_id);
286:             }
287:         }
288: 
289:         timeline.total_checkpoints += 1;
290:         self.save_timeline(timeline_path, &timeline)?;
291: 
292:         Ok(())
293:     }
294: 
295:     /// Recursively add a child node to the timeline tree
296:     fn add_child_to_node(
297:         node: &mut TimelineNode,
298:         parent_id: &str,
299:         child: TimelineNode,
300:     ) -> Result<()> {
301:         if node.checkpoint.id == parent_id {
302:             node.children.push(child);
303:             return Ok(());
304:         }
305: 
306:         for child_node in &mut node.children {
307:             if Self::add_child_to_node(child_node, parent_id, child.clone()).is_ok() {
308:                 return Ok(());
309:             }
310:         }
311: 
312:         anyhow::bail!("Parent checkpoint not found: {}", parent_id)
313:     }
314: 
315:     /// Calculate hash of file content
316:     pub fn calculate_file_hash(content: &str) -> String {
317:         let mut hasher = Sha256::new();
318:         hasher.update(content.as_bytes());
319:         format!("{:x}", hasher.finalize())
320:     }
321: 
322:     /// Generate a new checkpoint ID
323:     pub fn generate_checkpoint_id() -> String {
324:         Uuid::new_v4().to_string()
325:     }
326: 
327:     /// Estimate storage size for a checkpoint
328:     pub fn estimate_checkpoint_size(messages: &str, file_snapshots: &[FileSnapshot]) -> u64 {
329:         let messages_size = messages.len() as u64;
330:         let files_size: u64 = file_snapshots.iter().map(|s| s.content.len() as u64).sum();
331: 
332:         // Estimate compressed size (typically 20-30% of original for text)
333:         (messages_size + files_size) / 4
334:     }
335: 
336:     /// Clean up old checkpoints based on retention policy
337:     pub fn cleanup_old_checkpoints(
338:         &self,
339:         project_id: &str,
340:         session_id: &str,
341:         keep_count: usize,
342:     ) -> Result<usize> {
343:         let paths = CheckpointPaths::new(&self.claude_dir, project_id, session_id);
344:         let timeline = self.load_timeline(&paths.timeline_file)?;
345: 
346:         // Collect all checkpoint IDs in chronological order
347:         let mut all_checkpoints = Vec::new();
348:         if let Some(root) = &timeline.root_node {
349:             Self::collect_checkpoints(root, &mut all_checkpoints);
350:         }
351: 
352:         // Sort by timestamp (oldest first)
353:         all_checkpoints.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));
354: 
355:         // Keep only the most recent checkpoints
356:         let to_remove = all_checkpoints.len().saturating_sub(keep_count);
357:         let mut removed_count = 0;
358: 
359:         for checkpoint in all_checkpoints.into_iter().take(to_remove) {
360:             if self.remove_checkpoint(&paths, &checkpoint.id).is_ok() {
361:                 removed_count += 1;
362:             }
363:         }
364: 
365:         // Run garbage collection to clean up orphaned content
366:         if removed_count > 0 {
367:             match self.garbage_collect_content(project_id, session_id) {
368:                 Ok(gc_count) => {
369:                     log::info!("Garbage collected {} orphaned content files", gc_count);
370:                 }
371:                 Err(e) => {
372:                     log::warn!("Failed to garbage collect content: {}", e);
373:                 }
374:             }
375:         }
376: 
377:         Ok(removed_count)
378:     }
379: 
380:     /// Collect all checkpoints from the tree in order
381:     fn collect_checkpoints(node: &TimelineNode, checkpoints: &mut Vec<Checkpoint>) {
382:         checkpoints.push(node.checkpoint.clone());
383:         for child in &node.children {
384:             Self::collect_checkpoints(child, checkpoints);
385:         }
386:     }
387: 
388:     /// Remove a checkpoint and its associated files
389:     fn remove_checkpoint(&self, paths: &CheckpointPaths, checkpoint_id: &str) -> Result<()> {
390:         // Remove checkpoint metadata directory
391:         let checkpoint_dir = paths.checkpoint_dir(checkpoint_id);
392:         if checkpoint_dir.exists() {
393:             fs::remove_dir_all(&checkpoint_dir).context("Failed to remove checkpoint directory")?;
394:         }
395: 
396:         // Remove file references for this checkpoint
397:         let refs_dir = paths.files_dir.join("refs").join(checkpoint_id);
398:         if refs_dir.exists() {
399:             fs::remove_dir_all(&refs_dir).context("Failed to remove file references")?;
400:         }
401: 
402:         // Note: We don't remove content from the pool here as it might be
403:         // referenced by other checkpoints. Use garbage_collect_content() for that.
404: 
405:         Ok(())
406:     }
407: 
408:     /// Garbage collect unreferenced content from the content pool
409:     pub fn garbage_collect_content(&self, project_id: &str, session_id: &str) -> Result<usize> {
410:         let paths = CheckpointPaths::new(&self.claude_dir, project_id, session_id);
411:         let content_pool_dir = paths.files_dir.join("content_pool");
412:         let refs_dir = paths.files_dir.join("refs");
413: 
414:         if !content_pool_dir.exists() {
415:             return Ok(0);
416:         }
417: 
418:         // Collect all referenced hashes
419:         let mut referenced_hashes = std::collections::HashSet::new();
420: 
421:         if refs_dir.exists() {
422:             for checkpoint_entry in fs::read_dir(&refs_dir)? {
423:                 let checkpoint_dir = checkpoint_entry?.path();
424:                 if checkpoint_dir.is_dir() {
425:                     for ref_entry in fs::read_dir(&checkpoint_dir)? {
426:                         let ref_path = ref_entry?.path();
427:                         if ref_path.extension().and_then(|e| e.to_str()) == Some("json") {
428:                             if let Ok(ref_json) = fs::read_to_string(&ref_path) {
429:                                 if let Ok(ref_metadata) =
430:                                     serde_json::from_str::<serde_json::Value>(&ref_json)
431:                                 {
432:                                     if let Some(hash) = ref_metadata["hash"].as_str() {
433:                                         referenced_hashes.insert(hash.to_string());
434:                                     }
435:                                 }
436:                             }
437:                         }
438:                     }
439:                 }
440:             }
441:         }
442: 
443:         // Remove unreferenced content
444:         let mut removed_count = 0;
445:         for entry in fs::read_dir(&content_pool_dir)? {
446:             let content_file = entry?.path();
447:             if content_file.is_file() {
448:                 if let Some(hash) = content_file.file_name().and_then(|n| n.to_str()) {
449:                     if !referenced_hashes.contains(hash) {
450:                         if fs::remove_file(&content_file).is_ok() {
451:                             removed_count += 1;
452:                         }
453:                     }
454:                 }
455:             }
456:         }
457: 
458:         Ok(removed_count)
459:     }
460: }
````

## File: src-tauri/src/commands/agents.rs
````rust
   1: use anyhow::Result;
   2: use chrono;
   3: use dirs;
   4: use log::{debug, error, info, warn};
   5: use reqwest;
   6: use rusqlite::{params, Connection, Result as SqliteResult};
   7: use serde::{Deserialize, Serialize};
   8: use serde_json::Value as JsonValue;
   9: use std::io::{BufRead, BufReader};
  10: use std::process::Stdio;
  11: use std::sync::Mutex;
  12: use tauri::{AppHandle, Emitter, Manager, State};
  13: use tauri_plugin_shell::ShellExt;
  14: use tauri_plugin_shell::process::CommandEvent;
  15: use tokio::io::{AsyncBufReadExt, BufReader as TokioBufReader};
  16: use tokio::process::Command;
  17: 
  18: /// Finds the full path to the claude binary
  19: /// This is necessary because macOS apps have a limited PATH environment
  20: fn find_claude_binary(app_handle: &AppHandle) -> Result<String, String> {
  21:     crate::claude_binary::find_claude_binary(app_handle)
  22: }
  23: 
  24: /// Represents a CC Agent stored in the database
  25: #[derive(Debug, Serialize, Deserialize, Clone)]
  26: pub struct Agent {
  27:     pub id: Option<i64>,
  28:     pub name: String,
  29:     pub icon: String,
  30:     pub system_prompt: String,
  31:     pub default_task: Option<String>,
  32:     pub model: String,
  33:     pub enable_file_read: bool,
  34:     pub enable_file_write: bool,
  35:     pub enable_network: bool,
  36:     pub hooks: Option<String>, // JSON string of hooks configuration
  37:     pub created_at: String,
  38:     pub updated_at: String,
  39: }
  40: 
  41: /// Represents an agent execution run
  42: #[derive(Debug, Serialize, Deserialize, Clone)]
  43: pub struct AgentRun {
  44:     pub id: Option<i64>,
  45:     pub agent_id: i64,
  46:     pub agent_name: String,
  47:     pub agent_icon: String,
  48:     pub task: String,
  49:     pub model: String,
  50:     pub project_path: String,
  51:     pub session_id: String, // UUID session ID from Claude Code
  52:     pub status: String,     // 'pending', 'running', 'completed', 'failed', 'cancelled'
  53:     pub pid: Option<u32>,
  54:     pub process_started_at: Option<String>,
  55:     pub created_at: String,
  56:     pub completed_at: Option<String>,
  57: }
  58: 
  59: /// Represents runtime metrics calculated from JSONL
  60: #[derive(Debug, Serialize, Deserialize, Clone)]
  61: pub struct AgentRunMetrics {
  62:     pub duration_ms: Option<i64>,
  63:     pub total_tokens: Option<i64>,
  64:     pub cost_usd: Option<f64>,
  65:     pub message_count: Option<i64>,
  66: }
  67: 
  68: /// Combined agent run with real-time metrics
  69: #[derive(Debug, Serialize, Deserialize, Clone)]
  70: pub struct AgentRunWithMetrics {
  71:     #[serde(flatten)]
  72:     pub run: AgentRun,
  73:     pub metrics: Option<AgentRunMetrics>,
  74:     pub output: Option<String>, // Real-time JSONL content
  75: }
  76: 
  77: /// Agent export format
  78: #[derive(Debug, Serialize, Deserialize)]
  79: pub struct AgentExport {
  80:     pub version: u32,
  81:     pub exported_at: String,
  82:     pub agent: AgentData,
  83: }
  84: 
  85: /// Agent data within export
  86: #[derive(Debug, Serialize, Deserialize)]
  87: pub struct AgentData {
  88:     pub name: String,
  89:     pub icon: String,
  90:     pub system_prompt: String,
  91:     pub default_task: Option<String>,
  92:     pub model: String,
  93:     pub hooks: Option<String>,
  94: }
  95: 
  96: /// Database connection state
  97: pub struct AgentDb(pub Mutex<Connection>);
  98: 
  99: /// Real-time JSONL reading and processing functions
 100: impl AgentRunMetrics {
 101:     /// Calculate metrics from JSONL content
 102:     pub fn from_jsonl(jsonl_content: &str) -> Self {
 103:         let mut total_tokens = 0i64;
 104:         let mut cost_usd = 0.0f64;
 105:         let mut message_count = 0i64;
 106:         let mut start_time: Option<chrono::DateTime<chrono::Utc>> = None;
 107:         let mut end_time: Option<chrono::DateTime<chrono::Utc>> = None;
 108: 
 109:         for line in jsonl_content.lines() {
 110:             if let Ok(json) = serde_json::from_str::<JsonValue>(line) {
 111:                 message_count += 1;
 112: 
 113:                 // Track timestamps
 114:                 if let Some(timestamp_str) = json.get("timestamp").and_then(|t| t.as_str()) {
 115:                     if let Ok(timestamp) = chrono::DateTime::parse_from_rfc3339(timestamp_str) {
 116:                         let utc_time = timestamp.with_timezone(&chrono::Utc);
 117:                         if start_time.is_none() || utc_time < start_time.unwrap() {
 118:                             start_time = Some(utc_time);
 119:                         }
 120:                         if end_time.is_none() || utc_time > end_time.unwrap() {
 121:                             end_time = Some(utc_time);
 122:                         }
 123:                     }
 124:                 }
 125: 
 126:                 // Extract token usage - check both top-level and nested message.usage
 127:                 let usage = json
 128:                     .get("usage")
 129:                     .or_else(|| json.get("message").and_then(|m| m.get("usage")));
 130: 
 131:                 if let Some(usage) = usage {
 132:                     if let Some(input_tokens) = usage.get("input_tokens").and_then(|t| t.as_i64()) {
 133:                         total_tokens += input_tokens;
 134:                     }
 135:                     if let Some(output_tokens) = usage.get("output_tokens").and_then(|t| t.as_i64())
 136:                     {
 137:                         total_tokens += output_tokens;
 138:                     }
 139:                 }
 140: 
 141:                 // Extract cost information
 142:                 if let Some(cost) = json.get("cost").and_then(|c| c.as_f64()) {
 143:                     cost_usd += cost;
 144:                 }
 145:             }
 146:         }
 147: 
 148:         let duration_ms = match (start_time, end_time) {
 149:             (Some(start), Some(end)) => Some((end - start).num_milliseconds()),
 150:             _ => None,
 151:         };
 152: 
 153:         Self {
 154:             duration_ms,
 155:             total_tokens: if total_tokens > 0 {
 156:                 Some(total_tokens)
 157:             } else {
 158:                 None
 159:             },
 160:             cost_usd: if cost_usd > 0.0 { Some(cost_usd) } else { None },
 161:             message_count: if message_count > 0 {
 162:                 Some(message_count)
 163:             } else {
 164:                 None
 165:             },
 166:         }
 167:     }
 168: }
 169: 
 170: /// Read JSONL content from a session file
 171: pub async fn read_session_jsonl(session_id: &str, project_path: &str) -> Result<String, String> {
 172:     let claude_dir = dirs::home_dir()
 173:         .ok_or("Failed to get home directory")?
 174:         .join(".claude")
 175:         .join("projects");
 176: 
 177:     // Encode project path to match Claude Code's directory naming
 178:     let encoded_project = project_path.replace('/', "-");
 179:     let project_dir = claude_dir.join(&encoded_project);
 180:     let session_file = project_dir.join(format!("{}.jsonl", session_id));
 181: 
 182:     if !session_file.exists() {
 183:         return Err(format!(
 184:             "Session file not found: {}",
 185:             session_file.display()
 186:         ));
 187:     }
 188: 
 189:     match tokio::fs::read_to_string(&session_file).await {
 190:         Ok(content) => Ok(content),
 191:         Err(e) => Err(format!("Failed to read session file: {}", e)),
 192:     }
 193: }
 194: 
 195: /// Get agent run with real-time metrics
 196: pub async fn get_agent_run_with_metrics(run: AgentRun) -> AgentRunWithMetrics {
 197:     match read_session_jsonl(&run.session_id, &run.project_path).await {
 198:         Ok(jsonl_content) => {
 199:             let metrics = AgentRunMetrics::from_jsonl(&jsonl_content);
 200:             AgentRunWithMetrics {
 201:                 run,
 202:                 metrics: Some(metrics),
 203:                 output: Some(jsonl_content),
 204:             }
 205:         }
 206:         Err(e) => {
 207:             log::warn!("Failed to read JSONL for session {}: {}", run.session_id, e);
 208:             AgentRunWithMetrics {
 209:                 run,
 210:                 metrics: None,
 211:                 output: None,
 212:             }
 213:         }
 214:     }
 215: }
 216: 
 217: /// Initialize the agents database
 218: pub fn init_database(app: &AppHandle) -> SqliteResult<Connection> {
 219:     let app_dir = app
 220:         .path()
 221:         .app_data_dir()
 222:         .expect("Failed to get app data dir");
 223:     std::fs::create_dir_all(&app_dir).expect("Failed to create app data dir");
 224: 
 225:     let db_path = app_dir.join("agents.db");
 226:     let conn = Connection::open(db_path)?;
 227: 
 228:     // Create agents table
 229:     conn.execute(
 230:         "CREATE TABLE IF NOT EXISTS agents (
 231:             id INTEGER PRIMARY KEY AUTOINCREMENT,
 232:             name TEXT NOT NULL,
 233:             icon TEXT NOT NULL,
 234:             system_prompt TEXT NOT NULL,
 235:             default_task TEXT,
 236:             model TEXT NOT NULL DEFAULT 'sonnet',
 237:             enable_file_read BOOLEAN NOT NULL DEFAULT 1,
 238:             enable_file_write BOOLEAN NOT NULL DEFAULT 1,
 239:             enable_network BOOLEAN NOT NULL DEFAULT 0,
 240:             hooks TEXT,
 241:             created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
 242:             updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
 243:         )",
 244:         [],
 245:     )?;
 246: 
 247:     // Add columns to existing table if they don't exist
 248:     let _ = conn.execute("ALTER TABLE agents ADD COLUMN default_task TEXT", []);
 249:     let _ = conn.execute(
 250:         "ALTER TABLE agents ADD COLUMN model TEXT DEFAULT 'sonnet'",
 251:         [],
 252:     );
 253:     let _ = conn.execute("ALTER TABLE agents ADD COLUMN hooks TEXT", []);
 254:     let _ = conn.execute(
 255:         "ALTER TABLE agents ADD COLUMN enable_file_read BOOLEAN DEFAULT 1",
 256:         [],
 257:     );
 258:     let _ = conn.execute(
 259:         "ALTER TABLE agents ADD COLUMN enable_file_write BOOLEAN DEFAULT 1",
 260:         [],
 261:     );
 262:     let _ = conn.execute(
 263:         "ALTER TABLE agents ADD COLUMN enable_network BOOLEAN DEFAULT 0",
 264:         [],
 265:     );
 266: 
 267:     // Create agent_runs table
 268:     conn.execute(
 269:         "CREATE TABLE IF NOT EXISTS agent_runs (
 270:             id INTEGER PRIMARY KEY AUTOINCREMENT,
 271:             agent_id INTEGER NOT NULL,
 272:             agent_name TEXT NOT NULL,
 273:             agent_icon TEXT NOT NULL,
 274:             task TEXT NOT NULL,
 275:             model TEXT NOT NULL,
 276:             project_path TEXT NOT NULL,
 277:             session_id TEXT NOT NULL,
 278:             status TEXT NOT NULL DEFAULT 'pending',
 279:             pid INTEGER,
 280:             process_started_at TEXT,
 281:             created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
 282:             completed_at TEXT,
 283:             FOREIGN KEY (agent_id) REFERENCES agents(id) ON DELETE CASCADE
 284:         )",
 285:         [],
 286:     )?;
 287: 
 288:     // Migrate existing agent_runs table if needed
 289:     let _ = conn.execute("ALTER TABLE agent_runs ADD COLUMN session_id TEXT", []);
 290:     let _ = conn.execute(
 291:         "ALTER TABLE agent_runs ADD COLUMN status TEXT DEFAULT 'pending'",
 292:         [],
 293:     );
 294:     let _ = conn.execute("ALTER TABLE agent_runs ADD COLUMN pid INTEGER", []);
 295:     let _ = conn.execute(
 296:         "ALTER TABLE agent_runs ADD COLUMN process_started_at TEXT",
 297:         [],
 298:     );
 299: 
 300:     // Drop old columns that are no longer needed (data is now read from JSONL files)
 301:     // Note: SQLite doesn't support DROP COLUMN, so we'll ignore errors for existing columns
 302:     let _ = conn.execute(
 303:         "UPDATE agent_runs SET session_id = '' WHERE session_id IS NULL",
 304:         [],
 305:     );
 306:     let _ = conn.execute("UPDATE agent_runs SET status = 'completed' WHERE status IS NULL AND completed_at IS NOT NULL", []);
 307:     let _ = conn.execute("UPDATE agent_runs SET status = 'failed' WHERE status IS NULL AND completed_at IS NOT NULL AND session_id = ''", []);
 308:     let _ = conn.execute(
 309:         "UPDATE agent_runs SET status = 'pending' WHERE status IS NULL",
 310:         [],
 311:     );
 312: 
 313:     // Create trigger to update the updated_at timestamp
 314:     conn.execute(
 315:         "CREATE TRIGGER IF NOT EXISTS update_agent_timestamp 
 316:          AFTER UPDATE ON agents 
 317:          FOR EACH ROW
 318:          BEGIN
 319:              UPDATE agents SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
 320:          END",
 321:         [],
 322:     )?;
 323: 
 324: 
 325:     // Create settings table for app-wide settings
 326:     conn.execute(
 327:         "CREATE TABLE IF NOT EXISTS app_settings (
 328:             key TEXT PRIMARY KEY,
 329:             value TEXT NOT NULL,
 330:             created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
 331:             updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
 332:         )",
 333:         [],
 334:     )?;
 335: 
 336:     // Create trigger to update the updated_at timestamp
 337:     conn.execute(
 338:         "CREATE TRIGGER IF NOT EXISTS update_app_settings_timestamp 
 339:          AFTER UPDATE ON app_settings 
 340:          FOR EACH ROW
 341:          BEGIN
 342:              UPDATE app_settings SET updated_at = CURRENT_TIMESTAMP WHERE key = NEW.key;
 343:          END",
 344:         [],
 345:     )?;
 346: 
 347:     Ok(conn)
 348: }
 349: 
 350: /// List all agents
 351: #[tauri::command]
 352: pub async fn list_agents(db: State<'_, AgentDb>) -> Result<Vec<Agent>, String> {
 353:     let conn = db.0.lock().map_err(|e| e.to_string())?;
 354: 
 355:     let mut stmt = conn
 356:         .prepare("SELECT id, name, icon, system_prompt, default_task, model, enable_file_read, enable_file_write, enable_network, hooks, created_at, updated_at FROM agents ORDER BY created_at DESC")
 357:         .map_err(|e| e.to_string())?;
 358: 
 359:     let agents = stmt
 360:         .query_map([], |row| {
 361:             Ok(Agent {
 362:                 id: Some(row.get(0)?),
 363:                 name: row.get(1)?,
 364:                 icon: row.get(2)?,
 365:                 system_prompt: row.get(3)?,
 366:                 default_task: row.get(4)?,
 367:                 model: row
 368:                     .get::<_, String>(5)
 369:                     .unwrap_or_else(|_| "sonnet".to_string()),
 370:                 enable_file_read: row.get::<_, bool>(6).unwrap_or(true),
 371:                 enable_file_write: row.get::<_, bool>(7).unwrap_or(true),
 372:                 enable_network: row.get::<_, bool>(8).unwrap_or(false),
 373:                 hooks: row.get(9)?,
 374:                 created_at: row.get(10)?,
 375:                 updated_at: row.get(11)?,
 376:             })
 377:         })
 378:         .map_err(|e| e.to_string())?
 379:         .collect::<Result<Vec<_>, _>>()
 380:         .map_err(|e| e.to_string())?;
 381: 
 382:     Ok(agents)
 383: }
 384: 
 385: /// Create a new agent
 386: #[tauri::command]
 387: pub async fn create_agent(
 388:     db: State<'_, AgentDb>,
 389:     name: String,
 390:     icon: String,
 391:     system_prompt: String,
 392:     default_task: Option<String>,
 393:     model: Option<String>,
 394:     enable_file_read: Option<bool>,
 395:     enable_file_write: Option<bool>,
 396:     enable_network: Option<bool>,
 397:     hooks: Option<String>,
 398: ) -> Result<Agent, String> {
 399:     let conn = db.0.lock().map_err(|e| e.to_string())?;
 400:     let model = model.unwrap_or_else(|| "sonnet".to_string());
 401:     let enable_file_read = enable_file_read.unwrap_or(true);
 402:     let enable_file_write = enable_file_write.unwrap_or(true);
 403:     let enable_network = enable_network.unwrap_or(false);
 404: 
 405:     conn.execute(
 406:         "INSERT INTO agents (name, icon, system_prompt, default_task, model, enable_file_read, enable_file_write, enable_network, hooks) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)",
 407:         params![name, icon, system_prompt, default_task, model, enable_file_read, enable_file_write, enable_network, hooks],
 408:     )
 409:     .map_err(|e| e.to_string())?;
 410: 
 411:     let id = conn.last_insert_rowid();
 412: 
 413:     // Fetch the created agent
 414:     let agent = conn
 415:         .query_row(
 416:             "SELECT id, name, icon, system_prompt, default_task, model, enable_file_read, enable_file_write, enable_network, hooks, created_at, updated_at FROM agents WHERE id = ?1",
 417:             params![id],
 418:             |row| {
 419:                 Ok(Agent {
 420:                     id: Some(row.get(0)?),
 421:                     name: row.get(1)?,
 422:                     icon: row.get(2)?,
 423:                     system_prompt: row.get(3)?,
 424:                     default_task: row.get(4)?,
 425:                     model: row.get(5)?,
 426:                     enable_file_read: row.get(6)?,
 427:                     enable_file_write: row.get(7)?,
 428:                     enable_network: row.get(8)?,
 429:                     hooks: row.get(9)?,
 430:                     created_at: row.get(10)?,
 431:                     updated_at: row.get(11)?,
 432:                 })
 433:             },
 434:         )
 435:         .map_err(|e| e.to_string())?;
 436: 
 437:     Ok(agent)
 438: }
 439: 
 440: /// Update an existing agent
 441: #[tauri::command]
 442: pub async fn update_agent(
 443:     db: State<'_, AgentDb>,
 444:     id: i64,
 445:     name: String,
 446:     icon: String,
 447:     system_prompt: String,
 448:     default_task: Option<String>,
 449:     model: Option<String>,
 450:     enable_file_read: Option<bool>,
 451:     enable_file_write: Option<bool>,
 452:     enable_network: Option<bool>,
 453:     hooks: Option<String>,
 454: ) -> Result<Agent, String> {
 455:     let conn = db.0.lock().map_err(|e| e.to_string())?;
 456:     let model = model.unwrap_or_else(|| "sonnet".to_string());
 457: 
 458:     // Build dynamic query based on provided parameters
 459:     let mut query =
 460:         "UPDATE agents SET name = ?1, icon = ?2, system_prompt = ?3, default_task = ?4, model = ?5, hooks = ?6"
 461:             .to_string();
 462:     let mut params_vec: Vec<Box<dyn rusqlite::ToSql>> = vec![
 463:         Box::new(name),
 464:         Box::new(icon),
 465:         Box::new(system_prompt),
 466:         Box::new(default_task),
 467:         Box::new(model),
 468:         Box::new(hooks),
 469:     ];
 470:     let mut param_count = 6;
 471: 
 472:     if let Some(efr) = enable_file_read {
 473:         param_count += 1;
 474:         query.push_str(&format!(", enable_file_read = ?{}", param_count));
 475:         params_vec.push(Box::new(efr));
 476:     }
 477:     if let Some(efw) = enable_file_write {
 478:         param_count += 1;
 479:         query.push_str(&format!(", enable_file_write = ?{}", param_count));
 480:         params_vec.push(Box::new(efw));
 481:     }
 482:     if let Some(en) = enable_network {
 483:         param_count += 1;
 484:         query.push_str(&format!(", enable_network = ?{}", param_count));
 485:         params_vec.push(Box::new(en));
 486:     }
 487: 
 488:     param_count += 1;
 489:     query.push_str(&format!(" WHERE id = ?{}", param_count));
 490:     params_vec.push(Box::new(id));
 491: 
 492:     conn.execute(
 493:         &query,
 494:         rusqlite::params_from_iter(params_vec.iter().map(|p| p.as_ref())),
 495:     )
 496:     .map_err(|e| e.to_string())?;
 497: 
 498:     // Fetch the updated agent
 499:     let agent = conn
 500:         .query_row(
 501:             "SELECT id, name, icon, system_prompt, default_task, model, enable_file_read, enable_file_write, enable_network, hooks, created_at, updated_at FROM agents WHERE id = ?1",
 502:             params![id],
 503:             |row| {
 504:                 Ok(Agent {
 505:                     id: Some(row.get(0)?),
 506:                     name: row.get(1)?,
 507:                     icon: row.get(2)?,
 508:                     system_prompt: row.get(3)?,
 509:                     default_task: row.get(4)?,
 510:                     model: row.get(5)?,
 511:                     enable_file_read: row.get(6)?,
 512:                     enable_file_write: row.get(7)?,
 513:                     enable_network: row.get(8)?,
 514:                     hooks: row.get(9)?,
 515:                     created_at: row.get(10)?,
 516:                     updated_at: row.get(11)?,
 517:                 })
 518:             },
 519:         )
 520:         .map_err(|e| e.to_string())?;
 521: 
 522:     Ok(agent)
 523: }
 524: 
 525: /// Delete an agent
 526: #[tauri::command]
 527: pub async fn delete_agent(db: State<'_, AgentDb>, id: i64) -> Result<(), String> {
 528:     let conn = db.0.lock().map_err(|e| e.to_string())?;
 529: 
 530:     conn.execute("DELETE FROM agents WHERE id = ?1", params![id])
 531:         .map_err(|e| e.to_string())?;
 532: 
 533:     Ok(())
 534: }
 535: 
 536: /// Get a single agent by ID
 537: #[tauri::command]
 538: pub async fn get_agent(db: State<'_, AgentDb>, id: i64) -> Result<Agent, String> {
 539:     let conn = db.0.lock().map_err(|e| e.to_string())?;
 540: 
 541:     let agent = conn
 542:         .query_row(
 543:             "SELECT id, name, icon, system_prompt, default_task, model, enable_file_read, enable_file_write, enable_network, hooks, created_at, updated_at FROM agents WHERE id = ?1",
 544:             params![id],
 545:             |row| {
 546:                 Ok(Agent {
 547:                     id: Some(row.get(0)?),
 548:                     name: row.get(1)?,
 549:                     icon: row.get(2)?,
 550:                     system_prompt: row.get(3)?,
 551:                     default_task: row.get(4)?,
 552:                     model: row.get::<_, String>(5).unwrap_or_else(|_| "sonnet".to_string()),
 553:                     enable_file_read: row.get::<_, bool>(6).unwrap_or(true),
 554:                     enable_file_write: row.get::<_, bool>(7).unwrap_or(true),
 555:                     enable_network: row.get::<_, bool>(8).unwrap_or(false),
 556:                     hooks: row.get(9)?,
 557:                     created_at: row.get(10)?,
 558:                     updated_at: row.get(11)?,
 559:                 })
 560:             },
 561:         )
 562:         .map_err(|e| e.to_string())?;
 563: 
 564:     Ok(agent)
 565: }
 566: 
 567: /// List agent runs (optionally filtered by agent_id)
 568: #[tauri::command]
 569: pub async fn list_agent_runs(
 570:     db: State<'_, AgentDb>,
 571:     agent_id: Option<i64>,
 572: ) -> Result<Vec<AgentRun>, String> {
 573:     let conn = db.0.lock().map_err(|e| e.to_string())?;
 574: 
 575:     let query = if agent_id.is_some() {
 576:         "SELECT id, agent_id, agent_name, agent_icon, task, model, project_path, session_id, status, pid, process_started_at, created_at, completed_at 
 577:          FROM agent_runs WHERE agent_id = ?1 ORDER BY created_at DESC"
 578:     } else {
 579:         "SELECT id, agent_id, agent_name, agent_icon, task, model, project_path, session_id, status, pid, process_started_at, created_at, completed_at 
 580:          FROM agent_runs ORDER BY created_at DESC"
 581:     };
 582: 
 583:     let mut stmt = conn.prepare(query).map_err(|e| e.to_string())?;
 584: 
 585:     let run_mapper = |row: &rusqlite::Row| -> rusqlite::Result<AgentRun> {
 586:         Ok(AgentRun {
 587:             id: Some(row.get(0)?),
 588:             agent_id: row.get(1)?,
 589:             agent_name: row.get(2)?,
 590:             agent_icon: row.get(3)?,
 591:             task: row.get(4)?,
 592:             model: row.get(5)?,
 593:             project_path: row.get(6)?,
 594:             session_id: row.get(7)?,
 595:             status: row
 596:                 .get::<_, String>(8)
 597:                 .unwrap_or_else(|_| "pending".to_string()),
 598:             pid: row
 599:                 .get::<_, Option<i64>>(9)
 600:                 .ok()
 601:                 .flatten()
 602:                 .map(|p| p as u32),
 603:             process_started_at: row.get(10)?,
 604:             created_at: row.get(11)?,
 605:             completed_at: row.get(12)?,
 606:         })
 607:     };
 608: 
 609:     let runs = if let Some(aid) = agent_id {
 610:         stmt.query_map(params![aid], run_mapper)
 611:     } else {
 612:         stmt.query_map(params![], run_mapper)
 613:     }
 614:     .map_err(|e| e.to_string())?
 615:     .collect::<Result<Vec<_>, _>>()
 616:     .map_err(|e| e.to_string())?;
 617: 
 618:     Ok(runs)
 619: }
 620: 
 621: /// Get a single agent run by ID
 622: #[tauri::command]
 623: pub async fn get_agent_run(db: State<'_, AgentDb>, id: i64) -> Result<AgentRun, String> {
 624:     let conn = db.0.lock().map_err(|e| e.to_string())?;
 625: 
 626:     let run = conn
 627:         .query_row(
 628:             "SELECT id, agent_id, agent_name, agent_icon, task, model, project_path, session_id, status, pid, process_started_at, created_at, completed_at 
 629:              FROM agent_runs WHERE id = ?1",
 630:             params![id],
 631:             |row| {
 632:                 Ok(AgentRun {
 633:                     id: Some(row.get(0)?),
 634:                     agent_id: row.get(1)?,
 635:                     agent_name: row.get(2)?,
 636:                     agent_icon: row.get(3)?,
 637:                     task: row.get(4)?,
 638:                     model: row.get(5)?,
 639:                     project_path: row.get(6)?,
 640:                     session_id: row.get(7)?,
 641:                     status: row.get::<_, String>(8).unwrap_or_else(|_| "pending".to_string()),
 642:                     pid: row.get::<_, Option<i64>>(9).ok().flatten().map(|p| p as u32),
 643:                     process_started_at: row.get(10)?,
 644:                     created_at: row.get(11)?,
 645:                     completed_at: row.get(12)?,
 646:                 })
 647:             },
 648:         )
 649:         .map_err(|e| e.to_string())?;
 650: 
 651:     Ok(run)
 652: }
 653: 
 654: /// Get agent run with real-time metrics from JSONL
 655: #[tauri::command]
 656: pub async fn get_agent_run_with_real_time_metrics(
 657:     db: State<'_, AgentDb>,
 658:     id: i64,
 659: ) -> Result<AgentRunWithMetrics, String> {
 660:     let run = get_agent_run(db, id).await?;
 661:     Ok(get_agent_run_with_metrics(run).await)
 662: }
 663: 
 664: /// List agent runs with real-time metrics from JSONL
 665: #[tauri::command]
 666: pub async fn list_agent_runs_with_metrics(
 667:     db: State<'_, AgentDb>,
 668:     agent_id: Option<i64>,
 669: ) -> Result<Vec<AgentRunWithMetrics>, String> {
 670:     let runs = list_agent_runs(db, agent_id).await?;
 671:     let mut runs_with_metrics = Vec::new();
 672: 
 673:     for run in runs {
 674:         let run_with_metrics = get_agent_run_with_metrics(run).await;
 675:         runs_with_metrics.push(run_with_metrics);
 676:     }
 677: 
 678:     Ok(runs_with_metrics)
 679: }
 680: 
 681: /// Execute a CC agent with streaming output
 682: #[tauri::command]
 683: pub async fn execute_agent(
 684:     app: AppHandle,
 685:     agent_id: i64,
 686:     project_path: String,
 687:     task: String,
 688:     model: Option<String>,
 689:     db: State<'_, AgentDb>,
 690:     registry: State<'_, crate::process::ProcessRegistryState>,
 691: ) -> Result<i64, String> {
 692:     info!("Executing agent {} with task: {}", agent_id, task);
 693: 
 694:     // Get the agent from database
 695:     let agent = get_agent(db.clone(), agent_id).await?;
 696:     let execution_model = model.unwrap_or(agent.model.clone());
 697:     
 698:     // Create .claude/settings.json with agent hooks if it doesn't exist
 699:     if let Some(hooks_json) = &agent.hooks {
 700:         let claude_dir = std::path::Path::new(&project_path).join(".claude");
 701:         let settings_path = claude_dir.join("settings.json");
 702:         
 703:         // Create .claude directory if it doesn't exist
 704:         if !claude_dir.exists() {
 705:             std::fs::create_dir_all(&claude_dir)
 706:                 .map_err(|e| format!("Failed to create .claude directory: {}", e))?;
 707:             info!("Created .claude directory at: {:?}", claude_dir);
 708:         }
 709:         
 710:         // Check if settings.json already exists
 711:         if !settings_path.exists() {
 712:             // Parse the hooks JSON
 713:             let hooks: serde_json::Value = serde_json::from_str(hooks_json)
 714:                 .map_err(|e| format!("Failed to parse agent hooks: {}", e))?;
 715:             
 716:             // Create a settings object with just the hooks
 717:             let settings = serde_json::json!({
 718:                 "hooks": hooks
 719:             });
 720:             
 721:             // Write the settings file
 722:             let settings_content = serde_json::to_string_pretty(&settings)
 723:                 .map_err(|e| format!("Failed to serialize settings: {}", e))?;
 724:             
 725:             std::fs::write(&settings_path, settings_content)
 726:                 .map_err(|e| format!("Failed to write settings.json: {}", e))?;
 727:             
 728:             info!("Created settings.json with agent hooks at: {:?}", settings_path);
 729:         } else {
 730:             info!("settings.json already exists at: {:?}", settings_path);
 731:         }
 732:     }
 733: 
 734:     // Create a new run record
 735:     let run_id = {
 736:         let conn = db.0.lock().map_err(|e| e.to_string())?;
 737:         conn.execute(
 738:             "INSERT INTO agent_runs (agent_id, agent_name, agent_icon, task, model, project_path, session_id) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)",
 739:             params![agent_id, agent.name, agent.icon, task, execution_model, project_path, ""],
 740:         )
 741:         .map_err(|e| e.to_string())?;
 742:         conn.last_insert_rowid()
 743:     };
 744: 
 745:     // Find Claude binary
 746:     info!("Running agent '{}'", agent.name);
 747:     let claude_path = match find_claude_binary(&app) {
 748:         Ok(path) => path,
 749:         Err(e) => {
 750:             error!("Failed to find claude binary: {}", e);
 751:             return Err(e);
 752:         }
 753:     };
 754: 
 755:     // Build arguments
 756:     let args = vec![
 757:         "-p".to_string(),
 758:         task.clone(),
 759:         "--system-prompt".to_string(),
 760:         agent.system_prompt.clone(),
 761:         "--model".to_string(),
 762:         execution_model.clone(),
 763:         "--output-format".to_string(),
 764:         "stream-json".to_string(),
 765:         "--verbose".to_string(),
 766:         "--dangerously-skip-permissions".to_string(),
 767:     ];
 768: 
 769:     // Execute based on whether we should use sidecar or system binary
 770:     if should_use_sidecar(&claude_path) {
 771:         spawn_agent_sidecar(app, run_id, agent_id, agent.name.clone(), args, project_path, task, execution_model, db, registry).await
 772:     } else {
 773:         spawn_agent_system(app, run_id, agent_id, agent.name.clone(), claude_path, args, project_path, task, execution_model, db, registry).await
 774:     }
 775: }
 776: 
 777: /// Determines whether to use sidecar or system binary execution for agents
 778: fn should_use_sidecar(claude_path: &str) -> bool {
 779:     claude_path == "claude-code"
 780: }
 781: 
 782: /// Creates a sidecar command for agent execution
 783: fn create_agent_sidecar_command(
 784:     app: &AppHandle,
 785:     args: Vec<String>,
 786:     project_path: &str,
 787: ) -> Result<tauri_plugin_shell::process::Command, String> {
 788:     let mut sidecar_cmd = app
 789:         .shell()
 790:         .sidecar("claude-code")
 791:         .map_err(|e| format!("Failed to create sidecar command: {}", e))?;
 792:     
 793:     // Add all arguments
 794:     sidecar_cmd = sidecar_cmd.args(args);
 795:     
 796:     // Set working directory
 797:     sidecar_cmd = sidecar_cmd.current_dir(project_path);
 798:     
 799:     // Pass through proxy environment variables if they exist (only uppercase)
 800:     for (key, value) in std::env::vars() {
 801:         if key == "HTTP_PROXY"
 802:             || key == "HTTPS_PROXY"
 803:             || key == "NO_PROXY"
 804:             || key == "ALL_PROXY"
 805:         {
 806:             debug!("Setting proxy env var for agent sidecar: {}={}", key, value);
 807:             sidecar_cmd = sidecar_cmd.env(&key, &value);
 808:         }
 809:     }
 810:     
 811:     Ok(sidecar_cmd)
 812: }
 813: 
 814: /// Creates a system binary command for agent execution
 815: fn create_agent_system_command(
 816:     claude_path: &str,
 817:     args: Vec<String>,
 818:     project_path: &str,
 819: ) -> Command {
 820:     let mut cmd = create_command_with_env(claude_path);
 821:     
 822:     // Add all arguments
 823:     for arg in args {
 824:         cmd.arg(arg);
 825:     }
 826:     
 827:     cmd.current_dir(project_path)
 828:         .stdin(Stdio::null())
 829:         .stdout(Stdio::piped())
 830:         .stderr(Stdio::piped());
 831:     
 832:     cmd
 833: }
 834: 
 835: /// Spawn agent using sidecar command
 836: async fn spawn_agent_sidecar(
 837:     app: AppHandle,
 838:     run_id: i64,
 839:     agent_id: i64,
 840:     agent_name: String,
 841:     args: Vec<String>,
 842:     project_path: String,
 843:     task: String,
 844:     execution_model: String,
 845:     db: State<'_, AgentDb>,
 846:     registry: State<'_, crate::process::ProcessRegistryState>,
 847: ) -> Result<i64, String> {
 848:     // Build the sidecar command
 849:     let sidecar_cmd = create_agent_sidecar_command(&app, args, &project_path)?;
 850: 
 851:     // Spawn the process
 852:     info!("🚀 Spawning Claude sidecar process...");
 853:     let (mut receiver, child) = sidecar_cmd.spawn().map_err(|e| {
 854:         error!("❌ Failed to spawn Claude sidecar process: {}", e);
 855:         format!("Failed to spawn Claude sidecar: {}", e)
 856:     })?;
 857: 
 858:     // Get the PID from child
 859:     let pid = child.pid();
 860:     let now = chrono::Utc::now().to_rfc3339();
 861:     info!("✅ Claude sidecar process spawned successfully with PID: {}", pid);
 862: 
 863:     // Update the database with PID and status
 864:     {
 865:         let conn = db.0.lock().map_err(|e| e.to_string())?;
 866:         conn.execute(
 867:             "UPDATE agent_runs SET status = 'running', pid = ?1, process_started_at = ?2 WHERE id = ?3",
 868:             params![pid as i64, now, run_id],
 869:         ).map_err(|e| e.to_string())?;
 870:         info!("📝 Updated database with running status and PID");
 871:     }
 872: 
 873:     // Get app directory for database path
 874:     let app_dir = app
 875:         .path()
 876:         .app_data_dir()
 877:         .expect("Failed to get app data dir");
 878:     let db_path = app_dir.join("agents.db");
 879: 
 880:     // Shared state for collecting session ID and live output
 881:     let session_id = std::sync::Arc::new(Mutex::new(String::new()));
 882:     let live_output = std::sync::Arc::new(Mutex::new(String::new()));
 883:     let _start_time = std::time::Instant::now();
 884: 
 885:     // Register the process in the registry
 886:     registry
 887:         .0
 888:         .register_sidecar_process(
 889:             run_id,
 890:             agent_id,
 891:             agent_name,
 892:             pid as u32,
 893:             project_path.clone(),
 894:             task.clone(),
 895:             execution_model.clone(),
 896:         )
 897:         .map_err(|e| format!("Failed to register sidecar process: {}", e))?;
 898:     info!("📋 Registered sidecar process in registry");
 899: 
 900:     // Handle sidecar events
 901:     let app_handle = app.clone();
 902:     let session_id_clone = session_id.clone();
 903:     let live_output_clone = live_output.clone();
 904:     let registry_clone = registry.0.clone();
 905:     let first_output = std::sync::Arc::new(std::sync::atomic::AtomicBool::new(false));
 906:     let first_output_clone = first_output.clone();
 907:     let db_path_for_sidecar = db_path.clone();
 908: 
 909:     tokio::spawn(async move {
 910:         info!("📖 Starting to read Claude sidecar events...");
 911:         let mut line_count = 0;
 912: 
 913:         while let Some(event) = receiver.recv().await {
 914:             match event {
 915:                 CommandEvent::Stdout(line_bytes) => {
 916:                     let line = String::from_utf8_lossy(&line_bytes);
 917:                     line_count += 1;
 918: 
 919:                     // Log first output
 920:                     if !first_output_clone.load(std::sync::atomic::Ordering::Relaxed) {
 921:                         info!(
 922:                             "🎉 First output received from Claude sidecar process! Line: {}",
 923:                             line
 924:                         );
 925:                         first_output_clone.store(true, std::sync::atomic::Ordering::Relaxed);
 926:                     }
 927: 
 928:                     if line_count <= 5 {
 929:                         info!("sidecar stdout[{}]: {}", line_count, line);
 930:                     } else {
 931:                         debug!("sidecar stdout[{}]: {}", line_count, line);
 932:                     }
 933: 
 934:                     // Store live output
 935:                     if let Ok(mut output) = live_output_clone.lock() {
 936:                         output.push_str(&line);
 937:                         output.push('\n');
 938:                     }
 939: 
 940:                     // Also store in process registry
 941:                     let _ = registry_clone.append_live_output(run_id, &line);
 942: 
 943:                     // Extract session ID from JSONL output
 944:                     if let Ok(json) = serde_json::from_str::<JsonValue>(&line) {
 945:                         if json.get("type").and_then(|t| t.as_str()) == Some("system") &&
 946:                            json.get("subtype").and_then(|s| s.as_str()) == Some("init") {
 947:                             if let Some(sid) = json.get("session_id").and_then(|s| s.as_str()) {
 948:                                 if let Ok(mut current_session_id) = session_id_clone.lock() {
 949:                                     if current_session_id.is_empty() {
 950:                                         *current_session_id = sid.to_string();
 951:                                         info!("🔑 Extracted session ID: {}", sid);
 952:                                         
 953:                                         // Update database immediately with session ID
 954:                                         if let Ok(conn) = Connection::open(&db_path_for_sidecar) {
 955:                                             match conn.execute(
 956:                                                 "UPDATE agent_runs SET session_id = ?1 WHERE id = ?2",
 957:                                                 params![sid, run_id],
 958:                                             ) {
 959:                                                 Ok(rows) => {
 960:                                                     if rows > 0 {
 961:                                                         info!("✅ Updated agent run {} with session ID immediately", run_id);
 962:                                                     }
 963:                                                 }
 964:                                                 Err(e) => {
 965:                                                     error!("❌ Failed to update session ID immediately: {}", e);
 966:                                                 }
 967:                                             }
 968:                                         }
 969:                                     }
 970:                                 }
 971:                             }
 972:                         }
 973:                     }
 974: 
 975:                     // Emit the line to the frontend
 976:                     let _ = app_handle.emit(&format!("agent-output:{}", run_id), &line);
 977:                     let _ = app_handle.emit("agent-output", &line);
 978:                 }
 979:                 CommandEvent::Stderr(line_bytes) => {
 980:                     let line = String::from_utf8_lossy(&line_bytes);
 981:                     error!("sidecar stderr: {}", line);
 982:                     let _ = app_handle.emit(&format!("agent-error:{}", run_id), &line);
 983:                     let _ = app_handle.emit("agent-error", &line);
 984:                 }
 985:                 CommandEvent::Terminated(payload) => {
 986:                     info!("Claude sidecar process terminated with code: {:?}", payload.code);
 987:                     
 988:                     // Get the session ID
 989:                     let extracted_session_id = if let Ok(sid) = session_id.lock() {
 990:                         sid.clone()
 991:                     } else {
 992:                         String::new()
 993:                     };
 994: 
 995:                     // Update database with completion
 996:                     if let Ok(conn) = Connection::open(&db_path) {
 997:                         let _ = conn.execute(
 998:                             "UPDATE agent_runs SET session_id = ?1, status = 'completed', completed_at = CURRENT_TIMESTAMP WHERE id = ?2",
 999:                             params![extracted_session_id, run_id],
1000:                         );
1001:                     }
1002: 
1003:                     let success = payload.code.unwrap_or(1) == 0;
1004:                     let _ = app.emit("agent-complete", success);
1005:                     let _ = app.emit(&format!("agent-complete:{}", run_id), success);
1006:                     break;
1007:                 }
1008:                 _ => {}
1009:             }
1010:         }
1011: 
1012:         info!("📖 Finished reading Claude sidecar events. Total lines: {}", line_count);
1013:     });
1014: 
1015:     Ok(run_id)
1016: }
1017: 
1018: /// Spawn agent using system binary command
1019: async fn spawn_agent_system(
1020:     app: AppHandle,
1021:     run_id: i64,
1022:     agent_id: i64,
1023:     agent_name: String,
1024:     claude_path: String,
1025:     args: Vec<String>,
1026:     project_path: String,
1027:     task: String,
1028:     execution_model: String,
1029:     db: State<'_, AgentDb>,
1030:     registry: State<'_, crate::process::ProcessRegistryState>,
1031: ) -> Result<i64, String> {
1032:     // Build the command
1033:     let mut cmd = create_agent_system_command(&claude_path, args, &project_path);
1034: 
1035:     // Spawn the process
1036:     info!("🚀 Spawning Claude system process...");
1037:     let mut child = cmd.spawn().map_err(|e| {
1038:         error!("❌ Failed to spawn Claude process: {}", e);
1039:         format!("Failed to spawn Claude: {}", e)
1040:     })?;
1041: 
1042:     info!("🔌 Using Stdio::null() for stdin - no input expected");
1043: 
1044:     // Get the PID and register the process
1045:     let pid = child.id().unwrap_or(0);
1046:     let now = chrono::Utc::now().to_rfc3339();
1047:     info!("✅ Claude process spawned successfully with PID: {}", pid);
1048: 
1049:     // Update the database with PID and status
1050:     {
1051:         let conn = db.0.lock().map_err(|e| e.to_string())?;
1052:         conn.execute(
1053:             "UPDATE agent_runs SET status = 'running', pid = ?1, process_started_at = ?2 WHERE id = ?3",
1054:             params![pid as i64, now, run_id],
1055:         ).map_err(|e| e.to_string())?;
1056:         info!("📝 Updated database with running status and PID");
1057:     }
1058: 
1059:     // Get stdout and stderr
1060:     let stdout = child.stdout.take().ok_or("Failed to get stdout")?;
1061:     let stderr = child.stderr.take().ok_or("Failed to get stderr")?;
1062:     info!("📡 Set up stdout/stderr readers");
1063: 
1064:     // Create readers
1065:     let stdout_reader = TokioBufReader::new(stdout);
1066:     let stderr_reader = TokioBufReader::new(stderr);
1067: 
1068:     // Create variables we need for the spawned tasks
1069:     let app_dir = app
1070:         .path()
1071:         .app_data_dir()
1072:         .expect("Failed to get app data dir");
1073:     let db_path = app_dir.join("agents.db");
1074: 
1075:     // Shared state for collecting session ID and live output
1076:     let session_id = std::sync::Arc::new(Mutex::new(String::new()));
1077:     let live_output = std::sync::Arc::new(Mutex::new(String::new()));
1078:     let start_time = std::time::Instant::now();
1079: 
1080:     // Spawn tasks to read stdout and stderr
1081:     let app_handle = app.clone();
1082:     let session_id_clone = session_id.clone();
1083:     let live_output_clone = live_output.clone();
1084:     let registry_clone = registry.0.clone();
1085:     let first_output = std::sync::Arc::new(std::sync::atomic::AtomicBool::new(false));
1086:     let first_output_clone = first_output.clone();
1087:     let db_path_for_stdout = db_path.clone(); // Clone the db_path for the stdout task
1088: 
1089:     let stdout_task = tokio::spawn(async move {
1090:         info!("📖 Starting to read Claude stdout...");
1091:         let mut lines = stdout_reader.lines();
1092:         let mut line_count = 0;
1093: 
1094:         while let Ok(Some(line)) = lines.next_line().await {
1095:             line_count += 1;
1096: 
1097:             // Log first output
1098:             if !first_output_clone.load(std::sync::atomic::Ordering::Relaxed) {
1099:                 info!(
1100:                     "🎉 First output received from Claude process! Line: {}",
1101:                     line
1102:                 );
1103:                 first_output_clone.store(true, std::sync::atomic::Ordering::Relaxed);
1104:             }
1105: 
1106:             if line_count <= 5 {
1107:                 info!("stdout[{}]: {}", line_count, line);
1108:             } else {
1109:                 debug!("stdout[{}]: {}", line_count, line);
1110:             }
1111: 
1112:             // Store live output in both local buffer and registry
1113:             if let Ok(mut output) = live_output_clone.lock() {
1114:                 output.push_str(&line);
1115:                 output.push('\n');
1116:             }
1117: 
1118:             // Also store in process registry for cross-session access
1119:             let _ = registry_clone.append_live_output(run_id, &line);
1120: 
1121:             // Extract session ID from JSONL output
1122:             if let Ok(json) = serde_json::from_str::<JsonValue>(&line) {
1123:                 // Claude Code uses "session_id" (underscore), not "sessionId"
1124:                 if json.get("type").and_then(|t| t.as_str()) == Some("system") &&
1125:                    json.get("subtype").and_then(|s| s.as_str()) == Some("init") {
1126:                     if let Some(sid) = json.get("session_id").and_then(|s| s.as_str()) {
1127:                         if let Ok(mut current_session_id) = session_id_clone.lock() {
1128:                             if current_session_id.is_empty() {
1129:                                 *current_session_id = sid.to_string();
1130:                                 info!("🔑 Extracted session ID: {}", sid);
1131:                                 
1132:                                 // Update database immediately with session ID
1133:                                 if let Ok(conn) = Connection::open(&db_path_for_stdout) {
1134:                                     match conn.execute(
1135:                                         "UPDATE agent_runs SET session_id = ?1 WHERE id = ?2",
1136:                                         params![sid, run_id],
1137:                                     ) {
1138:                                         Ok(rows) => {
1139:                                             if rows > 0 {
1140:                                                 info!("✅ Updated agent run {} with session ID immediately", run_id);
1141:                                             }
1142:                                         }
1143:                                         Err(e) => {
1144:                                             error!("❌ Failed to update session ID immediately: {}", e);
1145:                                         }
1146:                                     }
1147:                                 }
1148:                             }
1149:                         }
1150:                     }
1151:                 }
1152:             }
1153: 
1154:             // Emit the line to the frontend with run_id for isolation
1155:             let _ = app_handle.emit(&format!("agent-output:{}", run_id), &line);
1156:             // Also emit to the generic event for backward compatibility
1157:             let _ = app_handle.emit("agent-output", &line);
1158:         }
1159: 
1160:         info!(
1161:             "📖 Finished reading Claude stdout. Total lines: {}",
1162:             line_count
1163:         );
1164:     });
1165: 
1166:     let app_handle_stderr = app.clone();
1167:     let first_error = std::sync::Arc::new(std::sync::atomic::AtomicBool::new(false));
1168:     let first_error_clone = first_error.clone();
1169: 
1170:     let stderr_task = tokio::spawn(async move {
1171:         info!("📖 Starting to read Claude stderr...");
1172:         let mut lines = stderr_reader.lines();
1173:         let mut error_count = 0;
1174: 
1175:         while let Ok(Some(line)) = lines.next_line().await {
1176:             error_count += 1;
1177: 
1178:             // Log first error
1179:             if !first_error_clone.load(std::sync::atomic::Ordering::Relaxed) {
1180:                 warn!("⚠️ First error output from Claude process! Line: {}", line);
1181:                 first_error_clone.store(true, std::sync::atomic::Ordering::Relaxed);
1182:             }
1183: 
1184:             error!("stderr[{}]: {}", error_count, line);
1185:             // Emit error lines to the frontend with run_id for isolation
1186:             let _ = app_handle_stderr.emit(&format!("agent-error:{}", run_id), &line);
1187:             // Also emit to the generic event for backward compatibility
1188:             let _ = app_handle_stderr.emit("agent-error", &line);
1189:         }
1190: 
1191:         if error_count > 0 {
1192:             warn!(
1193:                 "📖 Finished reading Claude stderr. Total error lines: {}",
1194:                 error_count
1195:             );
1196:         } else {
1197:             info!("📖 Finished reading Claude stderr. No errors.");
1198:         }
1199:     });
1200: 
1201:     // Register the process in the registry for live output tracking (after stdout/stderr setup)
1202:     registry
1203:         .0
1204:         .register_process(
1205:             run_id,
1206:             agent_id,
1207:             agent_name,
1208:             pid,
1209:             project_path.clone(),
1210:             task.clone(),
1211:             execution_model.clone(),
1212:             child,
1213:         )
1214:         .map_err(|e| format!("Failed to register process: {}", e))?;
1215:     info!("📋 Registered process in registry");
1216: 
1217:     let db_path_for_monitor = db_path.clone(); // Clone for the monitor task
1218: 
1219:     // Monitor process status and wait for completion
1220:     tokio::spawn(async move {
1221:         info!("🕐 Starting process monitoring...");
1222: 
1223:         // Wait for first output with timeout
1224:         for i in 0..300 {
1225:             // 30 seconds (300 * 100ms)
1226:             if first_output.load(std::sync::atomic::Ordering::Relaxed) {
1227:                 info!(
1228:                     "✅ Output detected after {}ms, continuing normal execution",
1229:                     i * 100
1230:                 );
1231:                 break;
1232:             }
1233: 
1234:             if i == 299 {
1235:                 warn!("⏰ TIMEOUT: No output from Claude process after 30 seconds");
1236:                 warn!("💡 This usually means:");
1237:                 warn!("   1. Claude process is waiting for user input");
1238:                 warn!("   3. Claude failed to initialize but didn't report an error");
1239:                 warn!("   4. Network connectivity issues");
1240:                 warn!("   5. Authentication issues (API key not found/invalid)");
1241: 
1242:                 // Process timed out - kill it via PID
1243:                 warn!(
1244:                     "🔍 Process likely stuck waiting for input, attempting to kill PID: {}",
1245:                     pid
1246:                 );
1247:                 let kill_result = std::process::Command::new("kill")
1248:                     .arg("-TERM")
1249:                     .arg(pid.to_string())
1250:                     .output();
1251: 
1252:                 match kill_result {
1253:                     Ok(output) if output.status.success() => {
1254:                         warn!("🔍 Successfully sent TERM signal to process");
1255:                     }
1256:                     Ok(_) => {
1257:                         warn!("🔍 Failed to kill process with TERM, trying KILL");
1258:                         let _ = std::process::Command::new("kill")
1259:                             .arg("-KILL")
1260:                             .arg(pid.to_string())
1261:                             .output();
1262:                     }
1263:                     Err(e) => {
1264:                         warn!("🔍 Error killing process: {}", e);
1265:                     }
1266:                 }
1267: 
1268:                 // Update database
1269:                 if let Ok(conn) = Connection::open(&db_path_for_monitor) {
1270:                     let _ = conn.execute(
1271:                         "UPDATE agent_runs SET status = 'failed', completed_at = CURRENT_TIMESTAMP WHERE id = ?1",
1272:                         params![run_id],
1273:                     );
1274:                 }
1275: 
1276:                 let _ = app.emit("agent-complete", false);
1277:                 let _ = app.emit(&format!("agent-complete:{}", run_id), false);
1278:                 return;
1279:             }
1280: 
1281:             tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
1282:         }
1283: 
1284:         // Wait for reading tasks to complete
1285:         info!("⏳ Waiting for stdout/stderr reading to complete...");
1286:         let _ = stdout_task.await;
1287:         let _ = stderr_task.await;
1288: 
1289:         let duration_ms = start_time.elapsed().as_millis() as i64;
1290:         info!("⏱️ Process execution took {} ms", duration_ms);
1291: 
1292:         // Get the session ID that was extracted
1293:         let extracted_session_id = if let Ok(sid) = session_id.lock() {
1294:             sid.clone()
1295:         } else {
1296:             String::new()
1297:         };
1298: 
1299:         // Wait for process completion and update status
1300:         info!("✅ Claude process execution monitoring complete");
1301: 
1302:         // Update the run record with session ID and mark as completed - open a new connection
1303:         if let Ok(conn) = Connection::open(&db_path_for_monitor) {
1304:             info!("🔄 Updating database with extracted session ID: {}", extracted_session_id);
1305:             match conn.execute(
1306:                 "UPDATE agent_runs SET session_id = ?1, status = 'completed', completed_at = CURRENT_TIMESTAMP WHERE id = ?2",
1307:                 params![extracted_session_id, run_id],
1308:             ) {
1309:                 Ok(rows_affected) => {
1310:                     if rows_affected > 0 {
1311:                         info!("✅ Successfully updated agent run {} with session ID: {}", run_id, extracted_session_id);
1312:                     } else {
1313:                         warn!("⚠️ No rows affected when updating agent run {} with session ID", run_id);
1314:                     }
1315:                 }
1316:                 Err(e) => {
1317:                     error!("❌ Failed to update agent run {} with session ID: {}", run_id, e);
1318:                 }
1319:             }
1320:         } else {
1321:             error!("❌ Failed to open database to update session ID for run {}", run_id);
1322:         }
1323: 
1324:         // Cleanup will be handled by the cleanup_finished_processes function
1325: 
1326:         let _ = app.emit("agent-complete", true);
1327:         let _ = app.emit(&format!("agent-complete:{}", run_id), true);
1328:     });
1329: 
1330:     Ok(run_id)
1331: }
1332: 
1333: /// List all currently running agent sessions
1334: #[tauri::command]
1335: pub async fn list_running_sessions(
1336:     db: State<'_, AgentDb>,
1337:     registry: State<'_, crate::process::ProcessRegistryState>,
1338: ) -> Result<Vec<AgentRun>, String> {
1339:     let conn = db.0.lock().map_err(|e| e.to_string())?;
1340: 
1341:     // First get all running sessions from the database
1342:     let mut stmt = conn.prepare(
1343:         "SELECT id, agent_id, agent_name, agent_icon, task, model, project_path, session_id, status, pid, process_started_at, created_at, completed_at 
1344:          FROM agent_runs WHERE status = 'running' ORDER BY process_started_at DESC"
1345:     ).map_err(|e| e.to_string())?;
1346: 
1347:     let mut runs = stmt
1348:         .query_map([], |row| {
1349:             Ok(AgentRun {
1350:                 id: Some(row.get(0)?),
1351:                 agent_id: row.get(1)?,
1352:                 agent_name: row.get(2)?,
1353:                 agent_icon: row.get(3)?,
1354:                 task: row.get(4)?,
1355:                 model: row.get(5)?,
1356:                 project_path: row.get(6)?,
1357:                 session_id: row.get(7)?,
1358:                 status: row
1359:                     .get::<_, String>(8)
1360:                     .unwrap_or_else(|_| "pending".to_string()),
1361:                 pid: row
1362:                     .get::<_, Option<i64>>(9)
1363:                     .ok()
1364:                     .flatten()
1365:                     .map(|p| p as u32),
1366:                 process_started_at: row.get(10)?,
1367:                 created_at: row.get(11)?,
1368:                 completed_at: row.get(12)?,
1369:             })
1370:         })
1371:         .map_err(|e| e.to_string())?
1372:         .collect::<Result<Vec<_>, _>>()
1373:         .map_err(|e| e.to_string())?;
1374: 
1375:     drop(stmt);
1376:     drop(conn);
1377: 
1378:     // Cross-check with the process registry to ensure accuracy
1379:     // Get actually running processes from the registry
1380:     let registry_processes = registry.0.get_running_agent_processes()?;
1381:     let registry_run_ids: std::collections::HashSet<i64> = registry_processes
1382:         .iter()
1383:         .map(|p| p.run_id)
1384:         .collect();
1385: 
1386:     // Filter out any database entries that aren't actually running in the registry
1387:     // This handles cases where processes crashed without updating the database
1388:     runs.retain(|run| {
1389:         if let Some(run_id) = run.id {
1390:             registry_run_ids.contains(&run_id)
1391:         } else {
1392:             false
1393:         }
1394:     });
1395: 
1396:     Ok(runs)
1397: }
1398: 
1399: /// Kill a running agent session
1400: #[tauri::command]
1401: pub async fn kill_agent_session(
1402:     app: AppHandle,
1403:     db: State<'_, AgentDb>,
1404:     registry: State<'_, crate::process::ProcessRegistryState>,
1405:     run_id: i64,
1406: ) -> Result<bool, String> {
1407:     info!("Attempting to kill agent session {}", run_id);
1408: 
1409:     // First try to kill using the process registry
1410:     let killed_via_registry = match registry.0.kill_process(run_id).await {
1411:         Ok(success) => {
1412:             if success {
1413:                 info!("Successfully killed process {} via registry", run_id);
1414:                 true
1415:             } else {
1416:                 warn!("Process {} not found in registry", run_id);
1417:                 false
1418:             }
1419:         }
1420:         Err(e) => {
1421:             warn!("Failed to kill process {} via registry: {}", run_id, e);
1422:             false
1423:         }
1424:     };
1425: 
1426:     // If registry kill didn't work, try fallback with PID from database
1427:     if !killed_via_registry {
1428:         let pid_result = {
1429:             let conn = db.0.lock().map_err(|e| e.to_string())?;
1430:             conn.query_row(
1431:                 "SELECT pid FROM agent_runs WHERE id = ?1 AND status = 'running'",
1432:                 params![run_id],
1433:                 |row| row.get::<_, Option<i64>>(0),
1434:             )
1435:             .map_err(|e| e.to_string())?
1436:         };
1437: 
1438:         if let Some(pid) = pid_result {
1439:             info!("Attempting fallback kill for PID {} from database", pid);
1440:             let _ = registry.0.kill_process_by_pid(run_id, pid as u32)?;
1441:         }
1442:     }
1443: 
1444:     // Update the database to mark as cancelled
1445:     let conn = db.0.lock().map_err(|e| e.to_string())?;
1446:     let updated = conn.execute(
1447:         "UPDATE agent_runs SET status = 'cancelled', completed_at = CURRENT_TIMESTAMP WHERE id = ?1 AND status = 'running'",
1448:         params![run_id],
1449:     ).map_err(|e| e.to_string())?;
1450: 
1451:     // Emit cancellation event with run_id for proper isolation
1452:     let _ = app.emit(&format!("agent-cancelled:{}", run_id), true);
1453: 
1454:     Ok(updated > 0 || killed_via_registry)
1455: }
1456: 
1457: /// Get the status of a specific agent session
1458: #[tauri::command]
1459: pub async fn get_session_status(
1460:     db: State<'_, AgentDb>,
1461:     run_id: i64,
1462: ) -> Result<Option<String>, String> {
1463:     let conn = db.0.lock().map_err(|e| e.to_string())?;
1464: 
1465:     match conn.query_row(
1466:         "SELECT status FROM agent_runs WHERE id = ?1",
1467:         params![run_id],
1468:         |row| row.get::<_, String>(0),
1469:     ) {
1470:         Ok(status) => Ok(Some(status)),
1471:         Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
1472:         Err(e) => Err(e.to_string()),
1473:     }
1474: }
1475: 
1476: /// Cleanup finished processes and update their status
1477: #[tauri::command]
1478: pub async fn cleanup_finished_processes(db: State<'_, AgentDb>) -> Result<Vec<i64>, String> {
1479:     let conn = db.0.lock().map_err(|e| e.to_string())?;
1480: 
1481:     // Get all running processes
1482:     let mut stmt = conn
1483:         .prepare("SELECT id, pid FROM agent_runs WHERE status = 'running' AND pid IS NOT NULL")
1484:         .map_err(|e| e.to_string())?;
1485: 
1486:     let running_processes = stmt
1487:         .query_map([], |row| Ok((row.get::<_, i64>(0)?, row.get::<_, i64>(1)?)))
1488:         .map_err(|e| e.to_string())?
1489:         .collect::<Result<Vec<_>, _>>()
1490:         .map_err(|e| e.to_string())?;
1491: 
1492:     drop(stmt);
1493: 
1494:     let mut cleaned_up = Vec::new();
1495: 
1496:     for (run_id, pid) in running_processes {
1497:         // Check if the process is still running
1498:         let is_running = if cfg!(target_os = "windows") {
1499:             // On Windows, use tasklist to check if process exists
1500:             match std::process::Command::new("tasklist")
1501:                 .args(["/FI", &format!("PID eq {}", pid)])
1502:                 .args(["/FO", "CSV"])
1503:                 .output()
1504:             {
1505:                 Ok(output) => {
1506:                     let output_str = String::from_utf8_lossy(&output.stdout);
1507:                     output_str.lines().count() > 1 // Header + process line if exists
1508:                 }
1509:                 Err(_) => false,
1510:             }
1511:         } else {
1512:             // On Unix-like systems, use kill -0 to check if process exists
1513:             match std::process::Command::new("kill")
1514:                 .args(["-0", &pid.to_string()])
1515:                 .output()
1516:             {
1517:                 Ok(output) => output.status.success(),
1518:                 Err(_) => false,
1519:             }
1520:         };
1521: 
1522:         if !is_running {
1523:             // Process has finished, update status
1524:             let updated = conn.execute(
1525:                 "UPDATE agent_runs SET status = 'completed', completed_at = CURRENT_TIMESTAMP WHERE id = ?1",
1526:                 params![run_id],
1527:             ).map_err(|e| e.to_string())?;
1528: 
1529:             if updated > 0 {
1530:                 cleaned_up.push(run_id);
1531:                 info!(
1532:                     "Marked agent run {} as completed (PID {} no longer running)",
1533:                     run_id, pid
1534:                 );
1535:             }
1536:         }
1537:     }
1538: 
1539:     Ok(cleaned_up)
1540: }
1541: 
1542: /// Get live output from a running process
1543: #[tauri::command]
1544: pub async fn get_live_session_output(
1545:     registry: State<'_, crate::process::ProcessRegistryState>,
1546:     run_id: i64,
1547: ) -> Result<String, String> {
1548:     registry.0.get_live_output(run_id)
1549: }
1550: 
1551: /// Get real-time output for a running session by reading its JSONL file with live output fallback
1552: #[tauri::command]
1553: pub async fn get_session_output(
1554:     db: State<'_, AgentDb>,
1555:     registry: State<'_, crate::process::ProcessRegistryState>,
1556:     run_id: i64,
1557: ) -> Result<String, String> {
1558:     // Get the session information
1559:     let run = get_agent_run(db, run_id).await?;
1560: 
1561:     // If no session ID yet, try to get live output from registry
1562:     if run.session_id.is_empty() {
1563:         let live_output = registry.0.get_live_output(run_id)?;
1564:         if !live_output.is_empty() {
1565:             return Ok(live_output);
1566:         }
1567:         return Ok(String::new());
1568:     }
1569: 
1570:     // Get the Claude directory
1571:     let claude_dir = dirs::home_dir()
1572:         .ok_or("Failed to get home directory")?
1573:         .join(".claude");
1574: 
1575:     // Find the correct project directory by searching for the session file
1576:     let projects_dir = claude_dir.join("projects");
1577:     
1578:     // Check if projects directory exists
1579:     if !projects_dir.exists() {
1580:         log::error!("Projects directory not found at: {:?}", projects_dir);
1581:         return Err("Projects directory not found".to_string());
1582:     }
1583: 
1584:     // Search for the session file in all project directories
1585:     let mut session_file_path = None;
1586:     log::info!("Searching for session file {} in all project directories", run.session_id);
1587:     
1588:     if let Ok(entries) = std::fs::read_dir(&projects_dir) {
1589:         for entry in entries.filter_map(Result::ok) {
1590:             let path = entry.path();
1591:             if path.is_dir() {
1592:                 let dir_name = path.file_name().unwrap_or_default().to_string_lossy();
1593:                 log::debug!("Checking project directory: {}", dir_name);
1594:                 
1595:                 let potential_session_file = path.join(format!("{}.jsonl", run.session_id));
1596:                 if potential_session_file.exists() {
1597:                     log::info!("Found session file at: {:?}", potential_session_file);
1598:                     session_file_path = Some(potential_session_file);
1599:                     break;
1600:                 } else {
1601:                     log::debug!("Session file not found in: {}", dir_name);
1602:                 }
1603:             }
1604:         }
1605:     } else {
1606:         log::error!("Failed to read projects directory");
1607:     }
1608: 
1609:     // If we found the session file, read it
1610:     if let Some(session_path) = session_file_path {
1611:         match tokio::fs::read_to_string(&session_path).await {
1612:             Ok(content) => Ok(content),
1613:             Err(e) => {
1614:                 log::error!("Failed to read session file {}: {}", session_path.display(), e);
1615:                 // Fallback to live output if file read fails
1616:                 let live_output = registry.0.get_live_output(run_id)?;
1617:                 Ok(live_output)
1618:             }
1619:         }
1620:     } else {
1621:         // If session file not found, try the old method as fallback
1622:         log::warn!("Session file not found for {}, trying legacy method", run.session_id);
1623:         match read_session_jsonl(&run.session_id, &run.project_path).await {
1624:             Ok(content) => Ok(content),
1625:             Err(_) => {
1626:                 // Final fallback to live output
1627:                 let live_output = registry.0.get_live_output(run_id)?;
1628:                 Ok(live_output)
1629:             }
1630:         }
1631:     }
1632: }
1633: 
1634: /// Stream real-time session output by watching the JSONL file
1635: #[tauri::command]
1636: pub async fn stream_session_output(
1637:     app: AppHandle,
1638:     db: State<'_, AgentDb>,
1639:     run_id: i64,
1640: ) -> Result<(), String> {
1641:     // Get the session information
1642:     let run = get_agent_run(db, run_id).await?;
1643: 
1644:     // If no session ID yet, can't stream
1645:     if run.session_id.is_empty() {
1646:         return Err("Session not started yet".to_string());
1647:     }
1648: 
1649:     let session_id = run.session_id.clone();
1650:     let project_path = run.project_path.clone();
1651: 
1652:     // Spawn a task to monitor the file
1653:     tokio::spawn(async move {
1654:         let claude_dir = match dirs::home_dir() {
1655:             Some(home) => home.join(".claude").join("projects"),
1656:             None => return,
1657:         };
1658: 
1659:         let encoded_project = project_path.replace('/', "-");
1660:         let project_dir = claude_dir.join(&encoded_project);
1661:         let session_file = project_dir.join(format!("{}.jsonl", session_id));
1662: 
1663:         let mut last_size = 0u64;
1664: 
1665:         // Monitor file changes continuously while session is running
1666:         loop {
1667:             if session_file.exists() {
1668:                 if let Ok(metadata) = tokio::fs::metadata(&session_file).await {
1669:                     let current_size = metadata.len();
1670: 
1671:                     if current_size > last_size {
1672:                         // File has grown, read new content
1673:                         if let Ok(content) = tokio::fs::read_to_string(&session_file).await {
1674:                             let _ = app
1675:                                 .emit("session-output-update", &format!("{}:{}", run_id, content));
1676:                         }
1677:                         last_size = current_size;
1678:                     }
1679:                 }
1680:             } else {
1681:                 // If session file doesn't exist yet, keep waiting
1682:                 tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
1683:                 continue;
1684:             }
1685: 
1686:             // Check if the session is still running by querying the database
1687:             // If the session is no longer running, stop streaming
1688:             if let Ok(conn) = rusqlite::Connection::open(
1689:                 app.path()
1690:                     .app_data_dir()
1691:                     .expect("Failed to get app data dir")
1692:                     .join("agents.db"),
1693:             ) {
1694:                 if let Ok(status) = conn.query_row(
1695:                     "SELECT status FROM agent_runs WHERE id = ?1",
1696:                     rusqlite::params![run_id],
1697:                     |row| row.get::<_, String>(0),
1698:                 ) {
1699:                     if status != "running" {
1700:                         debug!("Session {} is no longer running, stopping stream", run_id);
1701:                         break;
1702:                     }
1703:                 } else {
1704:                     // If we can't query the status, assume it's still running
1705:                     debug!(
1706:                         "Could not query session status for {}, continuing stream",
1707:                         run_id
1708:                     );
1709:                 }
1710:             }
1711: 
1712:             tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
1713:         }
1714: 
1715:         debug!("Stopped streaming for session {}", run_id);
1716:     });
1717: 
1718:     Ok(())
1719: }
1720: 
1721: /// Export a single agent to JSON format
1722: #[tauri::command]
1723: pub async fn export_agent(db: State<'_, AgentDb>, id: i64) -> Result<String, String> {
1724:     let conn = db.0.lock().map_err(|e| e.to_string())?;
1725: 
1726:     // Fetch the agent
1727:     let agent = conn
1728:         .query_row(
1729:             "SELECT name, icon, system_prompt, default_task, model, hooks FROM agents WHERE id = ?1",
1730:             params![id],
1731:             |row| {
1732:                 Ok(serde_json::json!({
1733:                     "name": row.get::<_, String>(0)?,
1734:                     "icon": row.get::<_, String>(1)?,
1735:                     "system_prompt": row.get::<_, String>(2)?,
1736:                     "default_task": row.get::<_, Option<String>>(3)?,
1737:                     "model": row.get::<_, String>(4)?,
1738:                     "hooks": row.get::<_, Option<String>>(5)?
1739:                 }))
1740:             },
1741:         )
1742:         .map_err(|e| format!("Failed to fetch agent: {}", e))?;
1743: 
1744:     // Create the export wrapper
1745:     let export_data = serde_json::json!({
1746:         "version": 1,
1747:         "exported_at": chrono::Utc::now().to_rfc3339(),
1748:         "agent": agent
1749:     });
1750: 
1751:     // Convert to pretty JSON string
1752:     serde_json::to_string_pretty(&export_data)
1753:         .map_err(|e| format!("Failed to serialize agent: {}", e))
1754: }
1755: 
1756: /// Export agent to file with native dialog
1757: #[tauri::command]
1758: pub async fn export_agent_to_file(
1759:     db: State<'_, AgentDb>,
1760:     id: i64,
1761:     file_path: String,
1762: ) -> Result<(), String> {
1763:     // Get the JSON data
1764:     let json_data = export_agent(db, id).await?;
1765: 
1766:     // Write to file
1767:     std::fs::write(&file_path, json_data).map_err(|e| format!("Failed to write file: {}", e))?;
1768: 
1769:     Ok(())
1770: }
1771: 
1772: /// Get the stored Claude binary path from settings
1773: #[tauri::command]
1774: pub async fn get_claude_binary_path(db: State<'_, AgentDb>) -> Result<Option<String>, String> {
1775:     let conn = db.0.lock().map_err(|e| e.to_string())?;
1776: 
1777:     match conn.query_row(
1778:         "SELECT value FROM app_settings WHERE key = 'claude_binary_path'",
1779:         [],
1780:         |row| row.get::<_, String>(0),
1781:     ) {
1782:         Ok(path) => Ok(Some(path)),
1783:         Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
1784:         Err(e) => Err(format!("Failed to get Claude binary path: {}", e)),
1785:     }
1786: }
1787: 
1788: /// Set the Claude binary path in settings
1789: #[tauri::command]
1790: pub async fn set_claude_binary_path(db: State<'_, AgentDb>, path: String) -> Result<(), String> {
1791:     let conn = db.0.lock().map_err(|e| e.to_string())?;
1792: 
1793:     // Validate that the path exists and is executable
1794:     let path_buf = std::path::PathBuf::from(&path);
1795:     if !path_buf.exists() {
1796:         return Err(format!("File does not exist: {}", path));
1797:     }
1798: 
1799:     // Check if it's executable (on Unix systems)
1800:     #[cfg(unix)]
1801:     {
1802:         use std::os::unix::fs::PermissionsExt;
1803:         let metadata = std::fs::metadata(&path_buf)
1804:             .map_err(|e| format!("Failed to read file metadata: {}", e))?;
1805:         let permissions = metadata.permissions();
1806:         if permissions.mode() & 0o111 == 0 {
1807:             return Err(format!("File is not executable: {}", path));
1808:         }
1809:     }
1810: 
1811:     // Insert or update the setting
1812:     conn.execute(
1813:         "INSERT INTO app_settings (key, value) VALUES ('claude_binary_path', ?1)
1814:          ON CONFLICT(key) DO UPDATE SET value = ?1",
1815:         params![path],
1816:     )
1817:     .map_err(|e| format!("Failed to save Claude binary path: {}", e))?;
1818: 
1819:     Ok(())
1820: }
1821: 
1822: /// List all available Claude installations on the system
1823: #[tauri::command]
1824: pub async fn list_claude_installations(
1825:     _app: AppHandle,
1826: ) -> Result<Vec<crate::claude_binary::ClaudeInstallation>, String> {
1827:     let installations = crate::claude_binary::discover_claude_installations();
1828: 
1829:     if installations.is_empty() {
1830:         return Err("No Claude Code installations found on the system".to_string());
1831:     }
1832: 
1833:     Ok(installations)
1834: }
1835: 
1836: /// Helper function to create a tokio Command with proper environment variables
1837: /// This ensures commands like Claude can find Node.js and other dependencies
1838: fn create_command_with_env(program: &str) -> Command {
1839:     // Convert std::process::Command to tokio::process::Command
1840:     let _std_cmd = crate::claude_binary::create_command_with_env(program);
1841: 
1842:     // Create a new tokio Command from the program path
1843:     let mut tokio_cmd = Command::new(program);
1844: 
1845:     // Copy over all environment variables from the std::process::Command
1846:     // This is a workaround since we can't directly convert between the two types
1847:     for (key, value) in std::env::vars() {
1848:         if key == "PATH"
1849:             || key == "HOME"
1850:             || key == "USER"
1851:             || key == "SHELL"
1852:             || key == "LANG"
1853:             || key == "LC_ALL"
1854:             || key.starts_with("LC_")
1855:             || key == "NODE_PATH"
1856:             || key == "NVM_DIR"
1857:             || key == "NVM_BIN"
1858:             || key == "HOMEBREW_PREFIX"
1859:             || key == "HOMEBREW_CELLAR"
1860:         {
1861:             tokio_cmd.env(&key, &value);
1862:         }
1863:     }
1864: 
1865:     // Add NVM support if the program is in an NVM directory
1866:     if program.contains("/.nvm/versions/node/") {
1867:         if let Some(node_bin_dir) = std::path::Path::new(program).parent() {
1868:             let current_path = std::env::var("PATH").unwrap_or_default();
1869:             let node_bin_str = node_bin_dir.to_string_lossy();
1870:             if !current_path.contains(&node_bin_str.as_ref()) {
1871:                 let new_path = format!("{}:{}", node_bin_str, current_path);
1872:                 tokio_cmd.env("PATH", new_path);
1873:             }
1874:         }
1875:     }
1876: 
1877:     // Ensure PATH contains common Homebrew locations
1878:     if let Ok(existing_path) = std::env::var("PATH") {
1879:         let mut paths: Vec<&str> = existing_path.split(':').collect();
1880:         for p in ["/opt/homebrew/bin", "/usr/local/bin", "/usr/bin", "/bin"].iter() {
1881:             if !paths.contains(p) {
1882:                 paths.push(p);
1883:             }
1884:         }
1885:         let joined = paths.join(":");
1886:         tokio_cmd.env("PATH", joined);
1887:     } else {
1888:         tokio_cmd.env("PATH", "/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin");
1889:     }
1890: 
1891:     tokio_cmd
1892: }
1893: 
1894: /// Import an agent from JSON data
1895: #[tauri::command]
1896: pub async fn import_agent(db: State<'_, AgentDb>, json_data: String) -> Result<Agent, String> {
1897:     // Parse the JSON data
1898:     let export_data: AgentExport =
1899:         serde_json::from_str(&json_data).map_err(|e| format!("Invalid JSON format: {}", e))?;
1900: 
1901:     // Validate version
1902:     if export_data.version != 1 {
1903:         return Err(format!(
1904:             "Unsupported export version: {}. This version of the app only supports version 1.",
1905:             export_data.version
1906:         ));
1907:     }
1908: 
1909:     let agent_data = export_data.agent;
1910:     let conn = db.0.lock().map_err(|e| e.to_string())?;
1911: 
1912:     // Check if an agent with the same name already exists
1913:     let existing_count: i64 = conn
1914:         .query_row(
1915:             "SELECT COUNT(*) FROM agents WHERE name = ?1",
1916:             params![agent_data.name],
1917:             |row| row.get(0),
1918:         )
1919:         .map_err(|e| e.to_string())?;
1920: 
1921:     // If agent with same name exists, append a suffix
1922:     let final_name = if existing_count > 0 {
1923:         format!("{} (Imported)", agent_data.name)
1924:     } else {
1925:         agent_data.name
1926:     };
1927: 
1928:     // Create the agent
1929:     conn.execute(
1930:         "INSERT INTO agents (name, icon, system_prompt, default_task, model, enable_file_read, enable_file_write, enable_network, hooks) VALUES (?1, ?2, ?3, ?4, ?5, 1, 1, 0, ?6)",
1931:         params![
1932:             final_name,
1933:             agent_data.icon,
1934:             agent_data.system_prompt,
1935:             agent_data.default_task,
1936:             agent_data.model,
1937:             agent_data.hooks
1938:         ],
1939:     )
1940:     .map_err(|e| format!("Failed to create agent: {}", e))?;
1941: 
1942:     let id = conn.last_insert_rowid();
1943: 
1944:     // Fetch the created agent
1945:     let agent = conn
1946:         .query_row(
1947:             "SELECT id, name, icon, system_prompt, default_task, model, enable_file_read, enable_file_write, enable_network, hooks, created_at, updated_at FROM agents WHERE id = ?1",
1948:             params![id],
1949:             |row| {
1950:                 Ok(Agent {
1951:                     id: Some(row.get(0)?),
1952:                     name: row.get(1)?,
1953:                     icon: row.get(2)?,
1954:                     system_prompt: row.get(3)?,
1955:                     default_task: row.get(4)?,
1956:                     model: row.get(5)?,
1957:                     enable_file_read: row.get(6)?,
1958:                     enable_file_write: row.get(7)?,
1959:                     enable_network: row.get(8)?,
1960:                     hooks: row.get(9)?,
1961:                     created_at: row.get(10)?,
1962:                     updated_at: row.get(11)?,
1963:                 })
1964:             },
1965:         )
1966:         .map_err(|e| format!("Failed to fetch created agent: {}", e))?;
1967: 
1968:     Ok(agent)
1969: }
1970: 
1971: /// Import agent from file
1972: #[tauri::command]
1973: pub async fn import_agent_from_file(
1974:     db: State<'_, AgentDb>,
1975:     file_path: String,
1976: ) -> Result<Agent, String> {
1977:     // Read the file
1978:     let json_data =
1979:         std::fs::read_to_string(&file_path).map_err(|e| format!("Failed to read file: {}", e))?;
1980: 
1981:     // Import the agent
1982:     import_agent(db, json_data).await
1983: }
1984: 
1985: // GitHub Agent Import functionality
1986: 
1987: /// Represents a GitHub agent file from the API
1988: #[derive(Debug, Serialize, Deserialize, Clone)]
1989: pub struct GitHubAgentFile {
1990:     pub name: String,
1991:     pub path: String,
1992:     pub download_url: String,
1993:     pub size: i64,
1994:     pub sha: String,
1995: }
1996: 
1997: /// Represents the GitHub API response for directory contents
1998: #[derive(Debug, Deserialize)]
1999: struct GitHubApiResponse {
2000:     name: String,
2001:     path: String,
2002:     sha: String,
2003:     size: i64,
2004:     download_url: Option<String>,
2005:     #[serde(rename = "type")]
2006:     file_type: String,
2007: }
2008: 
2009: /// Fetch list of agents from GitHub repository
2010: #[tauri::command]
2011: pub async fn fetch_github_agents() -> Result<Vec<GitHubAgentFile>, String> {
2012:     info!("Fetching agents from GitHub repository...");
2013: 
2014:     let client = reqwest::Client::new();
2015:     let url = "https://api.github.com/repos/getAsterisk/claudia/contents/cc_agents";
2016: 
2017:     let response = client
2018:         .get(url)
2019:         .header("Accept", "application/vnd.github+json")
2020:         .header("User-Agent", "Claudia-App")
2021:         .send()
2022:         .await
2023:         .map_err(|e| format!("Failed to fetch from GitHub: {}", e))?;
2024: 
2025:     if !response.status().is_success() {
2026:         let status = response.status();
2027:         let error_text = response.text().await.unwrap_or_default();
2028:         return Err(format!("GitHub API error ({}): {}", status, error_text));
2029:     }
2030: 
2031:     let api_files: Vec<GitHubApiResponse> = response
2032:         .json()
2033:         .await
2034:         .map_err(|e| format!("Failed to parse GitHub response: {}", e))?;
2035: 
2036:     // Filter only .claudia.json files
2037:     let agent_files: Vec<GitHubAgentFile> = api_files
2038:         .into_iter()
2039:         .filter(|f| f.name.ends_with(".claudia.json") && f.file_type == "file")
2040:         .filter_map(|f| {
2041:             f.download_url.map(|download_url| GitHubAgentFile {
2042:                 name: f.name,
2043:                 path: f.path,
2044:                 download_url,
2045:                 size: f.size,
2046:                 sha: f.sha,
2047:             })
2048:         })
2049:         .collect();
2050: 
2051:     info!("Found {} agents on GitHub", agent_files.len());
2052:     Ok(agent_files)
2053: }
2054: 
2055: /// Fetch and preview a specific agent from GitHub
2056: #[tauri::command]
2057: pub async fn fetch_github_agent_content(download_url: String) -> Result<AgentExport, String> {
2058:     info!("Fetching agent content from: {}", download_url);
2059: 
2060:     let client = reqwest::Client::new();
2061:     let response = client
2062:         .get(&download_url)
2063:         .header("Accept", "application/json")
2064:         .header("User-Agent", "Claudia-App")
2065:         .send()
2066:         .await
2067:         .map_err(|e| format!("Failed to download agent: {}", e))?;
2068: 
2069:     if !response.status().is_success() {
2070:         return Err(format!(
2071:             "Failed to download agent: HTTP {}",
2072:             response.status()
2073:         ));
2074:     }
2075: 
2076:     let json_text = response
2077:         .text()
2078:         .await
2079:         .map_err(|e| format!("Failed to read response: {}", e))?;
2080: 
2081:     // Parse and validate the agent data
2082:     let export_data: AgentExport = serde_json::from_str(&json_text)
2083:         .map_err(|e| format!("Invalid agent JSON format: {}", e))?;
2084: 
2085:     // Validate version
2086:     if export_data.version != 1 {
2087:         return Err(format!(
2088:             "Unsupported agent version: {}",
2089:             export_data.version
2090:         ));
2091:     }
2092: 
2093:     Ok(export_data)
2094: }
2095: 
2096: /// Import an agent directly from GitHub
2097: #[tauri::command]
2098: pub async fn import_agent_from_github(
2099:     db: State<'_, AgentDb>,
2100:     download_url: String,
2101: ) -> Result<Agent, String> {
2102:     info!("Importing agent from GitHub: {}", download_url);
2103: 
2104:     // First, fetch the agent content
2105:     let export_data = fetch_github_agent_content(download_url).await?;
2106: 
2107:     // Convert to JSON string and use existing import logic
2108:     let json_data = serde_json::to_string(&export_data)
2109:         .map_err(|e| format!("Failed to serialize agent data: {}", e))?;
2110: 
2111:     // Import using existing function
2112:     import_agent(db, json_data).await
2113: }
2114: 
2115: /// Load agent session history from JSONL file
2116: /// Similar to Claude Code's load_session_history, but searches across all project directories
2117: #[tauri::command]
2118: pub async fn load_agent_session_history(
2119:     session_id: String,
2120: ) -> Result<Vec<serde_json::Value>, String> {
2121:     log::info!("Loading agent session history for session: {}", session_id);
2122: 
2123:     let claude_dir = dirs::home_dir()
2124:         .ok_or("Failed to get home directory")?
2125:         .join(".claude");
2126: 
2127:     let projects_dir = claude_dir.join("projects");
2128:     
2129:     if !projects_dir.exists() {
2130:         log::error!("Projects directory not found at: {:?}", projects_dir);
2131:         return Err("Projects directory not found".to_string());
2132:     }
2133: 
2134:     // Search for the session file in all project directories
2135:     let mut session_file_path = None;
2136:     log::info!("Searching for session file {} in all project directories", session_id);
2137:     
2138:     if let Ok(entries) = std::fs::read_dir(&projects_dir) {
2139:         for entry in entries.filter_map(Result::ok) {
2140:             let path = entry.path();
2141:             if path.is_dir() {
2142:                 let dir_name = path.file_name().unwrap_or_default().to_string_lossy();
2143:                 log::debug!("Checking project directory: {}", dir_name);
2144:                 
2145:                 let potential_session_file = path.join(format!("{}.jsonl", session_id));
2146:                 if potential_session_file.exists() {
2147:                     log::info!("Found session file at: {:?}", potential_session_file);
2148:                     session_file_path = Some(potential_session_file);
2149:                     break;
2150:                 } else {
2151:                     log::debug!("Session file not found in: {}", dir_name);
2152:                 }
2153:             }
2154:         }
2155:     } else {
2156:         log::error!("Failed to read projects directory");
2157:     }
2158: 
2159:     if let Some(session_path) = session_file_path {
2160:         let file = std::fs::File::open(&session_path)
2161:             .map_err(|e| format!("Failed to open session file: {}", e))?;
2162: 
2163:         let reader = BufReader::new(file);
2164:         let mut messages = Vec::new();
2165: 
2166:         for line in reader.lines() {
2167:             if let Ok(line) = line {
2168:                 if let Ok(json) = serde_json::from_str::<serde_json::Value>(&line) {
2169:                     messages.push(json);
2170:                 }
2171:             }
2172:         }
2173: 
2174:         Ok(messages)
2175:     } else {
2176:         Err(format!("Session file not found: {}", session_id))
2177:     }
2178: }
````

## File: src-tauri/src/commands/claude.rs
````rust
   1: use anyhow::{Context, Result};
   2: use serde::{Deserialize, Serialize};
   3: use std::fs;
   4: use std::io::{BufRead, BufReader};
   5: use std::path::PathBuf;
   6: use std::process::Stdio;
   7: use std::sync::Arc;
   8: use std::time::SystemTime;
   9: use tauri::{AppHandle, Emitter, Manager};
  10: use tokio::process::{Child, Command};
  11: use tokio::sync::Mutex;
  12: 
  13: 
  14: /// Global state to track current Claude process
  15: pub struct ClaudeProcessState {
  16:     pub current_process: Arc<Mutex<Option<Child>>>,
  17: }
  18: 
  19: impl Default for ClaudeProcessState {
  20:     fn default() -> Self {
  21:         Self {
  22:             current_process: Arc::new(Mutex::new(None)),
  23:         }
  24:     }
  25: }
  26: 
  27: /// Represents a project in the ~/.claude/projects directory
  28: #[derive(Debug, Clone, Serialize, Deserialize)]
  29: pub struct Project {
  30:     /// The project ID (derived from the directory name)
  31:     pub id: String,
  32:     /// The original project path (decoded from the directory name)
  33:     pub path: String,
  34:     /// List of session IDs (JSONL file names without extension)
  35:     pub sessions: Vec<String>,
  36:     /// Unix timestamp when the project directory was created
  37:     pub created_at: u64,
  38: }
  39: 
  40: /// Represents a session with its metadata
  41: #[derive(Debug, Clone, Serialize, Deserialize)]
  42: pub struct Session {
  43:     /// The session ID (UUID)
  44:     pub id: String,
  45:     /// The project ID this session belongs to
  46:     pub project_id: String,
  47:     /// The project path
  48:     pub project_path: String,
  49:     /// Optional todo data associated with this session
  50:     pub todo_data: Option<serde_json::Value>,
  51:     /// Unix timestamp when the session file was created
  52:     pub created_at: u64,
  53:     /// First user message content (if available)
  54:     pub first_message: Option<String>,
  55:     /// Timestamp of the first user message (if available)
  56:     pub message_timestamp: Option<String>,
  57: }
  58: 
  59: /// Represents a message entry in the JSONL file
  60: #[derive(Debug, Deserialize)]
  61: struct JsonlEntry {
  62:     #[serde(rename = "type")]
  63:     #[allow(dead_code)]
  64:     entry_type: Option<String>,
  65:     message: Option<MessageContent>,
  66:     timestamp: Option<String>,
  67: }
  68: 
  69: /// Represents the message content
  70: #[derive(Debug, Deserialize)]
  71: struct MessageContent {
  72:     role: Option<String>,
  73:     content: Option<String>,
  74: }
  75: 
  76: /// Represents the settings from ~/.claude/settings.json
  77: #[derive(Debug, Clone, Serialize, Deserialize)]
  78: pub struct ClaudeSettings {
  79:     #[serde(flatten)]
  80:     pub data: serde_json::Value,
  81: }
  82: 
  83: impl Default for ClaudeSettings {
  84:     fn default() -> Self {
  85:         Self {
  86:             data: serde_json::json!({}),
  87:         }
  88:     }
  89: }
  90: 
  91: /// Represents the Claude Code version status
  92: #[derive(Debug, Clone, Serialize, Deserialize)]
  93: pub struct ClaudeVersionStatus {
  94:     /// Whether Claude Code is installed and working
  95:     pub is_installed: bool,
  96:     /// The version string if available
  97:     pub version: Option<String>,
  98:     /// The full output from the command
  99:     pub output: String,
 100: }
 101: 
 102: /// Represents a CLAUDE.md file found in the project
 103: #[derive(Debug, Clone, Serialize, Deserialize)]
 104: pub struct ClaudeMdFile {
 105:     /// Relative path from the project root
 106:     pub relative_path: String,
 107:     /// Absolute path to the file
 108:     pub absolute_path: String,
 109:     /// File size in bytes
 110:     pub size: u64,
 111:     /// Last modified timestamp
 112:     pub modified: u64,
 113: }
 114: 
 115: /// Represents a file or directory entry
 116: #[derive(Debug, Clone, Serialize, Deserialize)]
 117: pub struct FileEntry {
 118:     /// The name of the file or directory
 119:     pub name: String,
 120:     /// The full path
 121:     pub path: String,
 122:     /// Whether this is a directory
 123:     pub is_directory: bool,
 124:     /// File size in bytes (0 for directories)
 125:     pub size: u64,
 126:     /// File extension (if applicable)
 127:     pub extension: Option<String>,
 128: }
 129: 
 130: /// Finds the full path to the claude binary
 131: /// This is necessary because macOS apps have a limited PATH environment
 132: fn find_claude_binary(app_handle: &AppHandle) -> Result<String, String> {
 133:     crate::claude_binary::find_claude_binary(app_handle)
 134: }
 135: 
 136: /// Gets the path to the ~/.claude directory
 137: fn get_claude_dir() -> Result<PathBuf> {
 138:     dirs::home_dir()
 139:         .context("Could not find home directory")?
 140:         .join(".claude")
 141:         .canonicalize()
 142:         .context("Could not find ~/.claude directory")
 143: }
 144: 
 145: /// Gets the actual project path by reading the cwd from the first JSONL entry
 146: fn get_project_path_from_sessions(project_dir: &PathBuf) -> Result<String, String> {
 147:     // Try to read any JSONL file in the directory
 148:     let entries = fs::read_dir(project_dir)
 149:         .map_err(|e| format!("Failed to read project directory: {}", e))?;
 150: 
 151:     for entry in entries {
 152:         if let Ok(entry) = entry {
 153:             let path = entry.path();
 154:             if path.is_file() && path.extension().and_then(|s| s.to_str()) == Some("jsonl") {
 155:                 // Read the first line of the JSONL file
 156:                 if let Ok(file) = fs::File::open(&path) {
 157:                     let reader = BufReader::new(file);
 158:                     if let Some(Ok(first_line)) = reader.lines().next() {
 159:                         // Parse the JSON and extract cwd
 160:                         if let Ok(json) = serde_json::from_str::<serde_json::Value>(&first_line) {
 161:                             if let Some(cwd) = json.get("cwd").and_then(|v| v.as_str()) {
 162:                                 return Ok(cwd.to_string());
 163:                             }
 164:                         }
 165:                     }
 166:                 }
 167:             }
 168:         }
 169:     }
 170: 
 171:     Err("Could not determine project path from session files".to_string())
 172: }
 173: 
 174: /// Decodes a project directory name back to its original path
 175: /// The directory names in ~/.claude/projects are encoded paths
 176: /// DEPRECATED: Use get_project_path_from_sessions instead when possible
 177: fn decode_project_path(encoded: &str) -> String {
 178:     // This is a fallback - the encoding isn't reversible when paths contain hyphens
 179:     // For example: -Users-mufeedvh-dev-jsonl-viewer could be /Users/mufeedvh/dev/jsonl-viewer
 180:     // or /Users/mufeedvh/dev/jsonl/viewer
 181:     encoded.replace('-', "/")
 182: }
 183: 
 184: /// Extracts the first valid user message from a JSONL file
 185: fn extract_first_user_message(jsonl_path: &PathBuf) -> (Option<String>, Option<String>) {
 186:     let file = match fs::File::open(jsonl_path) {
 187:         Ok(file) => file,
 188:         Err(_) => return (None, None),
 189:     };
 190: 
 191:     let reader = BufReader::new(file);
 192: 
 193:     for line in reader.lines() {
 194:         if let Ok(line) = line {
 195:             if let Ok(entry) = serde_json::from_str::<JsonlEntry>(&line) {
 196:                 if let Some(message) = entry.message {
 197:                     if message.role.as_deref() == Some("user") {
 198:                         if let Some(content) = message.content {
 199:                             // Skip if it contains the caveat message
 200:                             if content.contains("Caveat: The messages below were generated by the user while running local commands") {
 201:                                 continue;
 202:                             }
 203: 
 204:                             // Skip if it starts with command tags
 205:                             if content.starts_with("<command-name>")
 206:                                 || content.starts_with("<local-command-stdout>")
 207:                             {
 208:                                 continue;
 209:                             }
 210: 
 211:                             // Found a valid user message
 212:                             return (Some(content), entry.timestamp);
 213:                         }
 214:                     }
 215:                 }
 216:             }
 217:         }
 218:     }
 219: 
 220:     (None, None)
 221: }
 222: 
 223: /// Helper function to create a tokio Command with proper environment variables
 224: /// This ensures commands like Claude can find Node.js and other dependencies
 225: fn create_command_with_env(program: &str) -> Command {
 226:     // Convert std::process::Command to tokio::process::Command
 227:     let _std_cmd = crate::claude_binary::create_command_with_env(program);
 228: 
 229:     // Create a new tokio Command from the program path
 230:     let mut tokio_cmd = Command::new(program);
 231: 
 232:     // Copy over all environment variables
 233:     for (key, value) in std::env::vars() {
 234:         if key == "PATH"
 235:             || key == "HOME"
 236:             || key == "USER"
 237:             || key == "SHELL"
 238:             || key == "LANG"
 239:             || key == "LC_ALL"
 240:             || key.starts_with("LC_")
 241:             || key == "NODE_PATH"
 242:             || key == "NVM_DIR"
 243:             || key == "NVM_BIN"
 244:             || key == "HOMEBREW_PREFIX"
 245:             || key == "HOMEBREW_CELLAR"
 246:         {
 247:             log::debug!("Inheriting env var: {}={}", key, value);
 248:             tokio_cmd.env(&key, &value);
 249:         }
 250:     }
 251: 
 252:     // Add NVM support if the program is in an NVM directory
 253:     if program.contains("/.nvm/versions/node/") {
 254:         if let Some(node_bin_dir) = std::path::Path::new(program).parent() {
 255:             let current_path = std::env::var("PATH").unwrap_or_default();
 256:             let node_bin_str = node_bin_dir.to_string_lossy();
 257:             if !current_path.contains(&node_bin_str.as_ref()) {
 258:                 let new_path = format!("{}:{}", node_bin_str, current_path);
 259:                 tokio_cmd.env("PATH", new_path);
 260:             }
 261:         }
 262:     }
 263: 
 264:     tokio_cmd
 265: }
 266: 
 267: /// Creates a system binary command with the given arguments
 268: fn create_system_command(
 269:     claude_path: &str,
 270:     args: Vec<String>,
 271:     project_path: &str,
 272: ) -> Command {
 273:     let mut cmd = create_command_with_env(claude_path);
 274:     
 275:     // Add all arguments
 276:     for arg in args {
 277:         cmd.arg(arg);
 278:     }
 279:     
 280:     cmd.current_dir(project_path)
 281:         .stdout(Stdio::piped())
 282:         .stderr(Stdio::piped());
 283:     
 284:     cmd
 285: }
 286: 
 287: /// Lists all projects in the ~/.claude/projects directory
 288: #[tauri::command]
 289: pub async fn list_projects() -> Result<Vec<Project>, String> {
 290:     log::info!("Listing projects from ~/.claude/projects");
 291: 
 292:     let claude_dir = get_claude_dir().map_err(|e| e.to_string())?;
 293:     let projects_dir = claude_dir.join("projects");
 294: 
 295:     if !projects_dir.exists() {
 296:         log::warn!("Projects directory does not exist: {:?}", projects_dir);
 297:         return Ok(Vec::new());
 298:     }
 299: 
 300:     let mut projects = Vec::new();
 301: 
 302:     // Read all directories in the projects folder
 303:     let entries = fs::read_dir(&projects_dir)
 304:         .map_err(|e| format!("Failed to read projects directory: {}", e))?;
 305: 
 306:     for entry in entries {
 307:         let entry = entry.map_err(|e| format!("Failed to read directory entry: {}", e))?;
 308:         let path = entry.path();
 309: 
 310:         if path.is_dir() {
 311:             let dir_name = path
 312:                 .file_name()
 313:                 .and_then(|n| n.to_str())
 314:                 .ok_or_else(|| "Invalid directory name".to_string())?;
 315: 
 316:             // Get directory creation time
 317:             let metadata = fs::metadata(&path)
 318:                 .map_err(|e| format!("Failed to read directory metadata: {}", e))?;
 319: 
 320:             let created_at = metadata
 321:                 .created()
 322:                 .or_else(|_| metadata.modified())
 323:                 .unwrap_or(SystemTime::UNIX_EPOCH)
 324:                 .duration_since(SystemTime::UNIX_EPOCH)
 325:                 .unwrap_or_default()
 326:                 .as_secs();
 327: 
 328:             // Get the actual project path from JSONL files
 329:             let project_path = match get_project_path_from_sessions(&path) {
 330:                 Ok(path) => path,
 331:                 Err(e) => {
 332:                     log::warn!("Failed to get project path from sessions for {}: {}, falling back to decode", dir_name, e);
 333:                     decode_project_path(dir_name)
 334:                 }
 335:             };
 336: 
 337:             // List all JSONL files (sessions) in this project directory
 338:             let mut sessions = Vec::new();
 339:             if let Ok(session_entries) = fs::read_dir(&path) {
 340:                 for session_entry in session_entries.flatten() {
 341:                     let session_path = session_entry.path();
 342:                     if session_path.is_file()
 343:                         && session_path.extension().and_then(|s| s.to_str()) == Some("jsonl")
 344:                     {
 345:                         if let Some(session_id) = session_path.file_stem().and_then(|s| s.to_str())
 346:                         {
 347:                             sessions.push(session_id.to_string());
 348:                         }
 349:                     }
 350:                 }
 351:             }
 352: 
 353:             projects.push(Project {
 354:                 id: dir_name.to_string(),
 355:                 path: project_path,
 356:                 sessions,
 357:                 created_at,
 358:             });
 359:         }
 360:     }
 361: 
 362:     // Sort projects by creation time (newest first)
 363:     projects.sort_by(|a, b| b.created_at.cmp(&a.created_at));
 364: 
 365:     log::info!("Found {} projects", projects.len());
 366:     Ok(projects)
 367: }
 368: 
 369: /// Gets sessions for a specific project
 370: #[tauri::command]
 371: pub async fn get_project_sessions(project_id: String) -> Result<Vec<Session>, String> {
 372:     log::info!("Getting sessions for project: {}", project_id);
 373: 
 374:     let claude_dir = get_claude_dir().map_err(|e| e.to_string())?;
 375:     let project_dir = claude_dir.join("projects").join(&project_id);
 376:     let todos_dir = claude_dir.join("todos");
 377: 
 378:     if !project_dir.exists() {
 379:         return Err(format!("Project directory not found: {}", project_id));
 380:     }
 381: 
 382:     // Get the actual project path from JSONL files
 383:     let project_path = match get_project_path_from_sessions(&project_dir) {
 384:         Ok(path) => path,
 385:         Err(e) => {
 386:             log::warn!(
 387:                 "Failed to get project path from sessions for {}: {}, falling back to decode",
 388:                 project_id,
 389:                 e
 390:             );
 391:             decode_project_path(&project_id)
 392:         }
 393:     };
 394: 
 395:     let mut sessions = Vec::new();
 396: 
 397:     // Read all JSONL files in the project directory
 398:     let entries = fs::read_dir(&project_dir)
 399:         .map_err(|e| format!("Failed to read project directory: {}", e))?;
 400: 
 401:     for entry in entries {
 402:         let entry = entry.map_err(|e| format!("Failed to read directory entry: {}", e))?;
 403:         let path = entry.path();
 404: 
 405:         if path.is_file() && path.extension().and_then(|s| s.to_str()) == Some("jsonl") {
 406:             if let Some(session_id) = path.file_stem().and_then(|s| s.to_str()) {
 407:                 // Get file creation time
 408:                 let metadata = fs::metadata(&path)
 409:                     .map_err(|e| format!("Failed to read file metadata: {}", e))?;
 410: 
 411:                 let created_at = metadata
 412:                     .created()
 413:                     .or_else(|_| metadata.modified())
 414:                     .unwrap_or(SystemTime::UNIX_EPOCH)
 415:                     .duration_since(SystemTime::UNIX_EPOCH)
 416:                     .unwrap_or_default()
 417:                     .as_secs();
 418: 
 419:                 // Extract first user message and timestamp
 420:                 let (first_message, message_timestamp) = extract_first_user_message(&path);
 421: 
 422:                 // Try to load associated todo data
 423:                 let todo_path = todos_dir.join(format!("{}.json", session_id));
 424:                 let todo_data = if todo_path.exists() {
 425:                     fs::read_to_string(&todo_path)
 426:                         .ok()
 427:                         .and_then(|content| serde_json::from_str(&content).ok())
 428:                 } else {
 429:                     None
 430:                 };
 431: 
 432:                 sessions.push(Session {
 433:                     id: session_id.to_string(),
 434:                     project_id: project_id.clone(),
 435:                     project_path: project_path.clone(),
 436:                     todo_data,
 437:                     created_at,
 438:                     first_message,
 439:                     message_timestamp,
 440:                 });
 441:             }
 442:         }
 443:     }
 444: 
 445:     // Sort sessions by creation time (newest first)
 446:     sessions.sort_by(|a, b| b.created_at.cmp(&a.created_at));
 447: 
 448:     log::info!(
 449:         "Found {} sessions for project {}",
 450:         sessions.len(),
 451:         project_id
 452:     );
 453:     Ok(sessions)
 454: }
 455: 
 456: /// Reads the Claude settings file
 457: #[tauri::command]
 458: pub async fn get_claude_settings() -> Result<ClaudeSettings, String> {
 459:     log::info!("Reading Claude settings");
 460: 
 461:     let claude_dir = get_claude_dir().map_err(|e| e.to_string())?;
 462:     let settings_path = claude_dir.join("settings.json");
 463: 
 464:     if !settings_path.exists() {
 465:         log::warn!("Settings file not found, returning empty settings");
 466:         return Ok(ClaudeSettings {
 467:             data: serde_json::json!({}),
 468:         });
 469:     }
 470: 
 471:     let content = fs::read_to_string(&settings_path)
 472:         .map_err(|e| format!("Failed to read settings file: {}", e))?;
 473: 
 474:     let data: serde_json::Value = serde_json::from_str(&content)
 475:         .map_err(|e| format!("Failed to parse settings JSON: {}", e))?;
 476: 
 477:     Ok(ClaudeSettings { data })
 478: }
 479: 
 480: /// Opens a new Claude Code session by executing the claude command
 481: #[tauri::command]
 482: pub async fn open_new_session(app: AppHandle, path: Option<String>) -> Result<String, String> {
 483:     log::info!("Opening new Claude Code session at path: {:?}", path);
 484: 
 485:     #[cfg(not(debug_assertions))]
 486:     let _claude_path = find_claude_binary(&app)?;
 487: 
 488:     #[cfg(debug_assertions)]
 489:     let claude_path = find_claude_binary(&app)?;
 490: 
 491:     // In production, we can't use std::process::Command directly
 492:     // The user should launch Claude Code through other means or use the execute_claude_code command
 493:     #[cfg(not(debug_assertions))]
 494:     {
 495:         log::error!("Cannot spawn processes directly in production builds");
 496:         return Err("Direct process spawning is not available in production builds. Please use Claude Code directly or use the integrated execution commands.".to_string());
 497:     }
 498: 
 499:     #[cfg(debug_assertions)]
 500:     {
 501:         let mut cmd = std::process::Command::new(claude_path);
 502: 
 503:         // If a path is provided, use it; otherwise use current directory
 504:         if let Some(project_path) = path {
 505:             cmd.current_dir(&project_path);
 506:         }
 507: 
 508:         // Execute the command
 509:         match cmd.spawn() {
 510:             Ok(_) => {
 511:                 log::info!("Successfully launched Claude Code");
 512:                 Ok("Claude Code session started".to_string())
 513:             }
 514:             Err(e) => {
 515:                 log::error!("Failed to launch Claude Code: {}", e);
 516:                 Err(format!("Failed to launch Claude Code: {}", e))
 517:             }
 518:         }
 519:     }
 520: }
 521: 
 522: /// Reads the CLAUDE.md system prompt file
 523: #[tauri::command]
 524: pub async fn get_system_prompt() -> Result<String, String> {
 525:     log::info!("Reading CLAUDE.md system prompt");
 526: 
 527:     let claude_dir = get_claude_dir().map_err(|e| e.to_string())?;
 528:     let claude_md_path = claude_dir.join("CLAUDE.md");
 529: 
 530:     if !claude_md_path.exists() {
 531:         log::warn!("CLAUDE.md not found");
 532:         return Ok(String::new());
 533:     }
 534: 
 535:     fs::read_to_string(&claude_md_path).map_err(|e| format!("Failed to read CLAUDE.md: {}", e))
 536: }
 537: 
 538: /// Checks if Claude Code is installed and gets its version
 539: #[tauri::command]
 540: pub async fn check_claude_version(app: AppHandle) -> Result<ClaudeVersionStatus, String> {
 541:     log::info!("Checking Claude Code version");
 542: 
 543:     let claude_path = match find_claude_binary(&app) {
 544:         Ok(path) => path,
 545:         Err(e) => {
 546:             return Ok(ClaudeVersionStatus {
 547:                 is_installed: false,
 548:                 version: None,
 549:                 output: e,
 550:             });
 551:         }
 552:     };
 553: 
 554:     use log::debug;debug!("Claude path: {}", claude_path);
 555: 
 556:     // In production builds, we can't check the version directly
 557:     #[cfg(not(debug_assertions))]
 558:     {
 559:         log::warn!("Cannot check claude version in production build");
 560:         // If we found a path (either stored or in common locations), assume it's installed
 561:         if claude_path != "claude" && PathBuf::from(&claude_path).exists() {
 562:             return Ok(ClaudeVersionStatus {
 563:                 is_installed: true,
 564:                 version: None,
 565:                 output: "Claude binary found at: ".to_string() + &claude_path,
 566:             });
 567:         } else {
 568:             return Ok(ClaudeVersionStatus {
 569:                 is_installed: false,
 570:                 version: None,
 571:                 output: "Cannot verify Claude installation in production build. Please ensure Claude Code is installed.".to_string(),
 572:             });
 573:         }
 574:     }
 575: 
 576:     #[cfg(debug_assertions)]
 577:     {
 578:         let output = std::process::Command::new(claude_path)
 579:             .arg("--version")
 580:             .output();
 581: 
 582:         match output {
 583:             Ok(output) => {
 584:                 let stdout = String::from_utf8_lossy(&output.stdout).to_string();
 585:                 let stderr = String::from_utf8_lossy(&output.stderr).to_string();
 586:                 
 587:                 // Use regex to directly extract version pattern (e.g., "1.0.41")
 588:                 let version_regex = regex::Regex::new(r"(\d+\.\d+\.\d+(?:-[a-zA-Z0-9.-]+)?(?:\+[a-zA-Z0-9.-]+)?)").ok();
 589:                 
 590:                 let version = if let Some(regex) = version_regex {
 591:                     regex.captures(&stdout)
 592:                         .and_then(|captures| captures.get(1))
 593:                         .map(|m| m.as_str().to_string())
 594:                 } else {
 595:                     None
 596:                 };
 597:                 
 598:                 let full_output = if stderr.is_empty() {
 599:                     stdout.clone()
 600:                 } else {
 601:                     format!("{}\n{}", stdout, stderr)
 602:                 };
 603: 
 604:                 // Check if the output matches the expected format
 605:                 // Expected format: "1.0.17 (Claude Code)" or similar
 606:                 let is_valid = stdout.contains("(Claude Code)") || stdout.contains("Claude Code");
 607: 
 608:                 Ok(ClaudeVersionStatus {
 609:                     is_installed: is_valid && output.status.success(),
 610:                     version,
 611:                     output: full_output.trim().to_string(),
 612:                 })
 613:             }
 614:             Err(e) => {
 615:                 log::error!("Failed to run claude command: {}", e);
 616:                 Ok(ClaudeVersionStatus {
 617:                     is_installed: false,
 618:                     version: None,
 619:                     output: format!("Command not found: {}", e),
 620:                 })
 621:             }
 622:         }
 623:     }
 624: }
 625: 
 626: /// Saves the CLAUDE.md system prompt file
 627: #[tauri::command]
 628: pub async fn save_system_prompt(content: String) -> Result<String, String> {
 629:     log::info!("Saving CLAUDE.md system prompt");
 630: 
 631:     let claude_dir = get_claude_dir().map_err(|e| e.to_string())?;
 632:     let claude_md_path = claude_dir.join("CLAUDE.md");
 633: 
 634:     fs::write(&claude_md_path, content).map_err(|e| format!("Failed to write CLAUDE.md: {}", e))?;
 635: 
 636:     Ok("System prompt saved successfully".to_string())
 637: }
 638: 
 639: /// Saves the Claude settings file
 640: #[tauri::command]
 641: pub async fn save_claude_settings(settings: serde_json::Value) -> Result<String, String> {
 642:     log::info!("Saving Claude settings");
 643: 
 644:     let claude_dir = get_claude_dir().map_err(|e| e.to_string())?;
 645:     let settings_path = claude_dir.join("settings.json");
 646: 
 647:     // Pretty print the JSON with 2-space indentation
 648:     let json_string = serde_json::to_string_pretty(&settings)
 649:         .map_err(|e| format!("Failed to serialize settings: {}", e))?;
 650: 
 651:     fs::write(&settings_path, json_string)
 652:         .map_err(|e| format!("Failed to write settings file: {}", e))?;
 653: 
 654:     Ok("Settings saved successfully".to_string())
 655: }
 656: 
 657: /// Recursively finds all CLAUDE.md files in a project directory
 658: #[tauri::command]
 659: pub async fn find_claude_md_files(project_path: String) -> Result<Vec<ClaudeMdFile>, String> {
 660:     log::info!("Finding CLAUDE.md files in project: {}", project_path);
 661: 
 662:     let path = PathBuf::from(&project_path);
 663:     if !path.exists() {
 664:         return Err(format!("Project path does not exist: {}", project_path));
 665:     }
 666: 
 667:     let mut claude_files = Vec::new();
 668:     find_claude_md_recursive(&path, &path, &mut claude_files)?;
 669: 
 670:     // Sort by relative path
 671:     claude_files.sort_by(|a, b| a.relative_path.cmp(&b.relative_path));
 672: 
 673:     log::info!("Found {} CLAUDE.md files", claude_files.len());
 674:     Ok(claude_files)
 675: }
 676: 
 677: /// Helper function to recursively find CLAUDE.md files
 678: fn find_claude_md_recursive(
 679:     current_path: &PathBuf,
 680:     project_root: &PathBuf,
 681:     claude_files: &mut Vec<ClaudeMdFile>,
 682: ) -> Result<(), String> {
 683:     let entries = fs::read_dir(current_path)
 684:         .map_err(|e| format!("Failed to read directory {:?}: {}", current_path, e))?;
 685: 
 686:     for entry in entries {
 687:         let entry = entry.map_err(|e| format!("Failed to read directory entry: {}", e))?;
 688:         let path = entry.path();
 689: 
 690:         // Skip hidden files/directories
 691:         if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
 692:             if name.starts_with('.') {
 693:                 continue;
 694:             }
 695:         }
 696: 
 697:         if path.is_dir() {
 698:             // Skip common directories that shouldn't be searched
 699:             if let Some(dir_name) = path.file_name().and_then(|n| n.to_str()) {
 700:                 if matches!(
 701:                     dir_name,
 702:                     "node_modules" | "target" | ".git" | "dist" | "build" | ".next" | "__pycache__"
 703:                 ) {
 704:                     continue;
 705:                 }
 706:             }
 707: 
 708:             find_claude_md_recursive(&path, project_root, claude_files)?;
 709:         } else if path.is_file() {
 710:             // Check if it's a CLAUDE.md file (case insensitive)
 711:             if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
 712:                 if file_name.eq_ignore_ascii_case("CLAUDE.md") {
 713:                     let metadata = fs::metadata(&path)
 714:                         .map_err(|e| format!("Failed to read file metadata: {}", e))?;
 715: 
 716:                     let relative_path = path
 717:                         .strip_prefix(project_root)
 718:                         .map_err(|e| format!("Failed to get relative path: {}", e))?
 719:                         .to_string_lossy()
 720:                         .to_string();
 721: 
 722:                     let modified = metadata
 723:                         .modified()
 724:                         .unwrap_or(SystemTime::UNIX_EPOCH)
 725:                         .duration_since(SystemTime::UNIX_EPOCH)
 726:                         .unwrap_or_default()
 727:                         .as_secs();
 728: 
 729:                     claude_files.push(ClaudeMdFile {
 730:                         relative_path,
 731:                         absolute_path: path.to_string_lossy().to_string(),
 732:                         size: metadata.len(),
 733:                         modified,
 734:                     });
 735:                 }
 736:             }
 737:         }
 738:     }
 739: 
 740:     Ok(())
 741: }
 742: 
 743: /// Reads a specific CLAUDE.md file by its absolute path
 744: #[tauri::command]
 745: pub async fn read_claude_md_file(file_path: String) -> Result<String, String> {
 746:     log::info!("Reading CLAUDE.md file: {}", file_path);
 747: 
 748:     let path = PathBuf::from(&file_path);
 749:     if !path.exists() {
 750:         return Err(format!("File does not exist: {}", file_path));
 751:     }
 752: 
 753:     fs::read_to_string(&path).map_err(|e| format!("Failed to read file: {}", e))
 754: }
 755: 
 756: /// Saves a specific CLAUDE.md file by its absolute path
 757: #[tauri::command]
 758: pub async fn save_claude_md_file(file_path: String, content: String) -> Result<String, String> {
 759:     log::info!("Saving CLAUDE.md file: {}", file_path);
 760: 
 761:     let path = PathBuf::from(&file_path);
 762: 
 763:     // Ensure the parent directory exists
 764:     if let Some(parent) = path.parent() {
 765:         fs::create_dir_all(parent)
 766:             .map_err(|e| format!("Failed to create parent directory: {}", e))?;
 767:     }
 768: 
 769:     fs::write(&path, content).map_err(|e| format!("Failed to write file: {}", e))?;
 770: 
 771:     Ok("File saved successfully".to_string())
 772: }
 773: 
 774: /// Loads the JSONL history for a specific session
 775: #[tauri::command]
 776: pub async fn load_session_history(
 777:     session_id: String,
 778:     project_id: String,
 779: ) -> Result<Vec<serde_json::Value>, String> {
 780:     log::info!(
 781:         "Loading session history for session: {} in project: {}",
 782:         session_id,
 783:         project_id
 784:     );
 785: 
 786:     let claude_dir = get_claude_dir().map_err(|e| e.to_string())?;
 787:     let session_path = claude_dir
 788:         .join("projects")
 789:         .join(&project_id)
 790:         .join(format!("{}.jsonl", session_id));
 791: 
 792:     if !session_path.exists() {
 793:         return Err(format!("Session file not found: {}", session_id));
 794:     }
 795: 
 796:     let file =
 797:         fs::File::open(&session_path).map_err(|e| format!("Failed to open session file: {}", e))?;
 798: 
 799:     let reader = BufReader::new(file);
 800:     let mut messages = Vec::new();
 801: 
 802:     for line in reader.lines() {
 803:         if let Ok(line) = line {
 804:             if let Ok(json) = serde_json::from_str::<serde_json::Value>(&line) {
 805:                 messages.push(json);
 806:             }
 807:         }
 808:     }
 809: 
 810:     Ok(messages)
 811: }
 812: 
 813: 
 814: 
 815: /// Execute a new interactive Claude Code session with streaming output
 816: #[tauri::command]
 817: pub async fn execute_claude_code(
 818:     app: AppHandle,
 819:     project_path: String,
 820:     prompt: String,
 821:     model: String,
 822: ) -> Result<(), String> {
 823:     log::info!(
 824:         "Starting new Claude Code session in: {} with model: {}",
 825:         project_path,
 826:         model
 827:     );
 828: 
 829:     let claude_path = find_claude_binary(&app)?;
 830:     
 831:     let args = vec![
 832:         "-p".to_string(),
 833:         prompt.clone(),
 834:         "--model".to_string(),
 835:         model.clone(),
 836:         "--output-format".to_string(),
 837:         "stream-json".to_string(),
 838:         "--verbose".to_string(),
 839:         "--dangerously-skip-permissions".to_string(),
 840:     ];
 841: 
 842:     let cmd = create_system_command(&claude_path, args, &project_path);
 843:     spawn_claude_process(app, cmd, prompt, model, project_path).await
 844: }
 845: 
 846: /// Continue an existing Claude Code conversation with streaming output
 847: #[tauri::command]
 848: pub async fn continue_claude_code(
 849:     app: AppHandle,
 850:     project_path: String,
 851:     prompt: String,
 852:     model: String,
 853: ) -> Result<(), String> {
 854:     log::info!(
 855:         "Continuing Claude Code conversation in: {} with model: {}",
 856:         project_path,
 857:         model
 858:     );
 859: 
 860:     let claude_path = find_claude_binary(&app)?;
 861:     
 862:     let args = vec![
 863:         "-c".to_string(), // Continue flag
 864:         "-p".to_string(),
 865:         prompt.clone(),
 866:         "--model".to_string(),
 867:         model.clone(),
 868:         "--output-format".to_string(),
 869:         "stream-json".to_string(),
 870:         "--verbose".to_string(),
 871:         "--dangerously-skip-permissions".to_string(),
 872:     ];
 873: 
 874:     let cmd = create_system_command(&claude_path, args, &project_path);
 875:     spawn_claude_process(app, cmd, prompt, model, project_path).await
 876: }
 877: 
 878: /// Resume an existing Claude Code session by ID with streaming output
 879: #[tauri::command]
 880: pub async fn resume_claude_code(
 881:     app: AppHandle,
 882:     project_path: String,
 883:     session_id: String,
 884:     prompt: String,
 885:     model: String,
 886: ) -> Result<(), String> {
 887:     log::info!(
 888:         "Resuming Claude Code session: {} in: {} with model: {}",
 889:         session_id,
 890:         project_path,
 891:         model
 892:     );
 893: 
 894:     let claude_path = find_claude_binary(&app)?;
 895:     
 896:     let args = vec![
 897:         "--resume".to_string(),
 898:         session_id.clone(),
 899:         "-p".to_string(),
 900:         prompt.clone(),
 901:         "--model".to_string(),
 902:         model.clone(),
 903:         "--output-format".to_string(),
 904:         "stream-json".to_string(),
 905:         "--verbose".to_string(),
 906:         "--dangerously-skip-permissions".to_string(),
 907:     ];
 908: 
 909:     let cmd = create_system_command(&claude_path, args, &project_path);
 910:     spawn_claude_process(app, cmd, prompt, model, project_path).await
 911: }
 912: 
 913: /// Cancel the currently running Claude Code execution
 914: #[tauri::command]
 915: pub async fn cancel_claude_execution(
 916:     app: AppHandle,
 917:     session_id: Option<String>,
 918: ) -> Result<(), String> {
 919:     log::info!(
 920:         "Cancelling Claude Code execution for session: {:?}",
 921:         session_id
 922:     );
 923: 
 924:     let mut killed = false;
 925:     let mut attempted_methods = Vec::new();
 926: 
 927:     // Method 1: Try to find and kill via ProcessRegistry using session ID
 928:     if let Some(sid) = &session_id {
 929:         let registry = app.state::<crate::process::ProcessRegistryState>();
 930:         match registry.0.get_claude_session_by_id(sid) {
 931:             Ok(Some(process_info)) => {
 932:                 log::info!("Found process in registry for session {}: run_id={}, PID={}", 
 933:                     sid, process_info.run_id, process_info.pid);
 934:                 match registry.0.kill_process(process_info.run_id).await {
 935:                     Ok(success) => {
 936:                         if success {
 937:                             log::info!("Successfully killed process via registry");
 938:                             killed = true;
 939:                         } else {
 940:                             log::warn!("Registry kill returned false");
 941:                         }
 942:                     }
 943:                     Err(e) => {
 944:                         log::warn!("Failed to kill via registry: {}", e);
 945:                     }
 946:                 }
 947:                 attempted_methods.push("registry");
 948:             }
 949:             Ok(None) => {
 950:                 log::warn!("Session {} not found in ProcessRegistry", sid);
 951:             }
 952:             Err(e) => {
 953:                 log::error!("Error querying ProcessRegistry: {}", e);
 954:             }
 955:         }
 956:     }
 957: 
 958:     // Method 2: Try the legacy approach via ClaudeProcessState
 959:     if !killed {
 960:         let claude_state = app.state::<ClaudeProcessState>();
 961:         let mut current_process = claude_state.current_process.lock().await;
 962: 
 963:         if let Some(mut child) = current_process.take() {
 964:             // Try to get the PID before killing
 965:             let pid = child.id();
 966:             log::info!("Attempting to kill Claude process via ClaudeProcessState with PID: {:?}", pid);
 967: 
 968:             // Kill the process
 969:             match child.kill().await {
 970:                 Ok(_) => {
 971:                     log::info!("Successfully killed Claude process via ClaudeProcessState");
 972:                     killed = true;
 973:                 }
 974:                 Err(e) => {
 975:                     log::error!("Failed to kill Claude process via ClaudeProcessState: {}", e);
 976:                     
 977:                     // Method 3: If we have a PID, try system kill as last resort
 978:                     if let Some(pid) = pid {
 979:                         log::info!("Attempting system kill as last resort for PID: {}", pid);
 980:                         let kill_result = if cfg!(target_os = "windows") {
 981:                             std::process::Command::new("taskkill")
 982:                                 .args(["/F", "/PID", &pid.to_string()])
 983:                                 .output()
 984:                         } else {
 985:                             std::process::Command::new("kill")
 986:                                 .args(["-KILL", &pid.to_string()])
 987:                                 .output()
 988:                         };
 989:                         
 990:                         match kill_result {
 991:                             Ok(output) if output.status.success() => {
 992:                                 log::info!("Successfully killed process via system command");
 993:                                 killed = true;
 994:                             }
 995:                             Ok(output) => {
 996:                                 let stderr = String::from_utf8_lossy(&output.stderr);
 997:                                 log::error!("System kill failed: {}", stderr);
 998:                             }
 999:                             Err(e) => {
1000:                                 log::error!("Failed to execute system kill command: {}", e);
1001:                             }
1002:                         }
1003:                     }
1004:                 }
1005:             }
1006:             attempted_methods.push("claude_state");
1007:         } else {
1008:             log::warn!("No active Claude process in ClaudeProcessState");
1009:         }
1010:     }
1011: 
1012:     if !killed && attempted_methods.is_empty() {
1013:         log::warn!("No active Claude process found to cancel");
1014:     }
1015: 
1016:     // Always emit cancellation events for UI consistency
1017:     if let Some(sid) = session_id {
1018:         let _ = app.emit(&format!("claude-cancelled:{}", sid), true);
1019:         tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
1020:         let _ = app.emit(&format!("claude-complete:{}", sid), false);
1021:     }
1022:     
1023:     // Also emit generic events for backward compatibility
1024:     let _ = app.emit("claude-cancelled", true);
1025:     tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
1026:     let _ = app.emit("claude-complete", false);
1027:     
1028:     if killed {
1029:         log::info!("Claude process cancellation completed successfully");
1030:     } else if !attempted_methods.is_empty() {
1031:         log::warn!("Claude process cancellation attempted but process may have already exited. Attempted methods: {:?}", attempted_methods);
1032:     }
1033:     
1034:     Ok(())
1035: }
1036: 
1037: /// Get all running Claude sessions
1038: #[tauri::command]
1039: pub async fn list_running_claude_sessions(
1040:     registry: tauri::State<'_, crate::process::ProcessRegistryState>,
1041: ) -> Result<Vec<crate::process::ProcessInfo>, String> {
1042:     registry.0.get_running_claude_sessions()
1043: }
1044: 
1045: /// Get live output from a Claude session
1046: #[tauri::command]
1047: pub async fn get_claude_session_output(
1048:     registry: tauri::State<'_, crate::process::ProcessRegistryState>,
1049:     session_id: String,
1050: ) -> Result<String, String> {
1051:     // Find the process by session ID
1052:     if let Some(process_info) = registry.0.get_claude_session_by_id(&session_id)? {
1053:         registry.0.get_live_output(process_info.run_id)
1054:     } else {
1055:         Ok(String::new())
1056:     }
1057: }
1058: 
1059: /// Helper function to spawn Claude process and handle streaming
1060: async fn spawn_claude_process(app: AppHandle, mut cmd: Command, prompt: String, model: String, project_path: String) -> Result<(), String> {
1061:     use tokio::io::{AsyncBufReadExt, BufReader};
1062:     use std::sync::Mutex;
1063: 
1064:     // Spawn the process
1065:     let mut child = cmd
1066:         .spawn()
1067:         .map_err(|e| format!("Failed to spawn Claude: {}", e))?;
1068: 
1069:     // Get stdout and stderr
1070:     let stdout = child.stdout.take().ok_or("Failed to get stdout")?;
1071:     let stderr = child.stderr.take().ok_or("Failed to get stderr")?;
1072: 
1073:     // Get the child PID for logging
1074:     let pid = child.id().unwrap_or(0);
1075:     log::info!(
1076:         "Spawned Claude process with PID: {:?}",
1077:         pid
1078:     );
1079: 
1080:     // Create readers first (before moving child)
1081:     let stdout_reader = BufReader::new(stdout);
1082:     let stderr_reader = BufReader::new(stderr);
1083: 
1084:     // We'll extract the session ID from Claude's init message
1085:     let session_id_holder: Arc<Mutex<Option<String>>> = Arc::new(Mutex::new(None));
1086:     let run_id_holder: Arc<Mutex<Option<i64>>> = Arc::new(Mutex::new(None));
1087: 
1088:     // Store the child process in the global state (for backward compatibility)
1089:     let claude_state = app.state::<ClaudeProcessState>();
1090:     {
1091:         let mut current_process = claude_state.current_process.lock().await;
1092:         // If there's already a process running, kill it first
1093:         if let Some(mut existing_child) = current_process.take() {
1094:             log::warn!("Killing existing Claude process before starting new one");
1095:             let _ = existing_child.kill().await;
1096:         }
1097:         *current_process = Some(child);
1098:     }
1099: 
1100:     // Spawn tasks to read stdout and stderr
1101:     let app_handle = app.clone();
1102:     let session_id_holder_clone = session_id_holder.clone();
1103:     let run_id_holder_clone = run_id_holder.clone();
1104:     let registry = app.state::<crate::process::ProcessRegistryState>();
1105:     let registry_clone = registry.0.clone();
1106:     let project_path_clone = project_path.clone();
1107:     let prompt_clone = prompt.clone();
1108:     let model_clone = model.clone();
1109:     let stdout_task = tokio::spawn(async move {
1110:         let mut lines = stdout_reader.lines();
1111:         while let Ok(Some(line)) = lines.next_line().await {
1112:             log::debug!("Claude stdout: {}", line);
1113:             
1114:             // Parse the line to check for init message with session ID
1115:             if let Ok(msg) = serde_json::from_str::<serde_json::Value>(&line) {
1116:                 if msg["type"] == "system" && msg["subtype"] == "init" {
1117:                     if let Some(claude_session_id) = msg["session_id"].as_str() {
1118:                         let mut session_id_guard = session_id_holder_clone.lock().unwrap();
1119:                         if session_id_guard.is_none() {
1120:                             *session_id_guard = Some(claude_session_id.to_string());
1121:                             log::info!("Extracted Claude session ID: {}", claude_session_id);
1122:                             
1123:                             // Now register with ProcessRegistry using Claude's session ID
1124:                             match registry_clone.register_claude_session(
1125:                                 claude_session_id.to_string(),
1126:                                 pid,
1127:                                 project_path_clone.clone(),
1128:                                 prompt_clone.clone(),
1129:                                 model_clone.clone(),
1130:                             ) {
1131:                                 Ok(run_id) => {
1132:                                     log::info!("Registered Claude session with run_id: {}", run_id);
1133:                                     let mut run_id_guard = run_id_holder_clone.lock().unwrap();
1134:                                     *run_id_guard = Some(run_id);
1135:                                 }
1136:                                 Err(e) => {
1137:                                     log::error!("Failed to register Claude session: {}", e);
1138:                                 }
1139:                             }
1140:                         }
1141:                     }
1142:                 }
1143:             }
1144:             
1145:             // Store live output in registry if we have a run_id
1146:             if let Some(run_id) = *run_id_holder_clone.lock().unwrap() {
1147:                 let _ = registry_clone.append_live_output(run_id, &line);
1148:             }
1149:             
1150:             // Emit the line to the frontend with session isolation if we have session ID
1151:             if let Some(ref session_id) = *session_id_holder_clone.lock().unwrap() {
1152:                 let _ = app_handle.emit(&format!("claude-output:{}", session_id), &line);
1153:             }
1154:             // Also emit to the generic event for backward compatibility
1155:             let _ = app_handle.emit("claude-output", &line);
1156:         }
1157:     });
1158: 
1159:     let app_handle_stderr = app.clone();
1160:     let session_id_holder_clone2 = session_id_holder.clone();
1161:     let stderr_task = tokio::spawn(async move {
1162:         let mut lines = stderr_reader.lines();
1163:         while let Ok(Some(line)) = lines.next_line().await {
1164:             log::error!("Claude stderr: {}", line);
1165:             // Emit error lines to the frontend with session isolation if we have session ID
1166:             if let Some(ref session_id) = *session_id_holder_clone2.lock().unwrap() {
1167:                 let _ = app_handle_stderr.emit(&format!("claude-error:{}", session_id), &line);
1168:             }
1169:             // Also emit to the generic event for backward compatibility
1170:             let _ = app_handle_stderr.emit("claude-error", &line);
1171:         }
1172:     });
1173: 
1174:     // Wait for the process to complete
1175:     let app_handle_wait = app.clone();
1176:     let claude_state_wait = claude_state.current_process.clone();
1177:     let session_id_holder_clone3 = session_id_holder.clone();
1178:     let run_id_holder_clone2 = run_id_holder.clone();
1179:     let registry_clone2 = registry.0.clone();
1180:     tokio::spawn(async move {
1181:         let _ = stdout_task.await;
1182:         let _ = stderr_task.await;
1183: 
1184:         // Get the child from the state to wait on it
1185:         let mut current_process = claude_state_wait.lock().await;
1186:         if let Some(mut child) = current_process.take() {
1187:             match child.wait().await {
1188:                 Ok(status) => {
1189:                     log::info!("Claude process exited with status: {}", status);
1190:                     // Add a small delay to ensure all messages are processed
1191:                     tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
1192:                     if let Some(ref session_id) = *session_id_holder_clone3.lock().unwrap() {
1193:                         let _ = app_handle_wait.emit(
1194:                             &format!("claude-complete:{}", session_id),
1195:                             status.success(),
1196:                         );
1197:                     }
1198:                     // Also emit to the generic event for backward compatibility
1199:                     let _ = app_handle_wait.emit("claude-complete", status.success());
1200:                 }
1201:                 Err(e) => {
1202:                     log::error!("Failed to wait for Claude process: {}", e);
1203:                     // Add a small delay to ensure all messages are processed
1204:                     tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
1205:                     if let Some(ref session_id) = *session_id_holder_clone3.lock().unwrap() {
1206:                         let _ = app_handle_wait
1207:                             .emit(&format!("claude-complete:{}", session_id), false);
1208:                     }
1209:                     // Also emit to the generic event for backward compatibility
1210:                     let _ = app_handle_wait.emit("claude-complete", false);
1211:                 }
1212:             }
1213:         }
1214: 
1215:         // Unregister from ProcessRegistry if we have a run_id
1216:         if let Some(run_id) = *run_id_holder_clone2.lock().unwrap() {
1217:             let _ = registry_clone2.unregister_process(run_id);
1218:         }
1219: 
1220:         // Clear the process from state
1221:         *current_process = None;
1222:     });
1223: 
1224:     Ok(())
1225: }
1226: 
1227: 
1228: /// Lists files and directories in a given path
1229: #[tauri::command]
1230: pub async fn list_directory_contents(directory_path: String) -> Result<Vec<FileEntry>, String> {
1231:     log::info!("Listing directory contents: '{}'", directory_path);
1232: 
1233:     // Check if path is empty
1234:     if directory_path.trim().is_empty() {
1235:         log::error!("Directory path is empty or whitespace");
1236:         return Err("Directory path cannot be empty".to_string());
1237:     }
1238: 
1239:     let path = PathBuf::from(&directory_path);
1240:     log::debug!("Resolved path: {:?}", path);
1241: 
1242:     if !path.exists() {
1243:         log::error!("Path does not exist: {:?}", path);
1244:         return Err(format!("Path does not exist: {}", directory_path));
1245:     }
1246: 
1247:     if !path.is_dir() {
1248:         log::error!("Path is not a directory: {:?}", path);
1249:         return Err(format!("Path is not a directory: {}", directory_path));
1250:     }
1251: 
1252:     let mut entries = Vec::new();
1253: 
1254:     let dir_entries =
1255:         fs::read_dir(&path).map_err(|e| format!("Failed to read directory: {}", e))?;
1256: 
1257:     for entry in dir_entries {
1258:         let entry = entry.map_err(|e| format!("Failed to read entry: {}", e))?;
1259:         let entry_path = entry.path();
1260:         let metadata = entry
1261:             .metadata()
1262:             .map_err(|e| format!("Failed to read metadata: {}", e))?;
1263: 
1264:         // Skip hidden files/directories unless they are .claude directories
1265:         if let Some(name) = entry_path.file_name().and_then(|n| n.to_str()) {
1266:             if name.starts_with('.') && name != ".claude" {
1267:                 continue;
1268:             }
1269:         }
1270: 
1271:         let name = entry_path
1272:             .file_name()
1273:             .and_then(|n| n.to_str())
1274:             .unwrap_or("")
1275:             .to_string();
1276: 
1277:         let extension = if metadata.is_file() {
1278:             entry_path
1279:                 .extension()
1280:                 .and_then(|e| e.to_str())
1281:                 .map(|e| e.to_string())
1282:         } else {
1283:             None
1284:         };
1285: 
1286:         entries.push(FileEntry {
1287:             name,
1288:             path: entry_path.to_string_lossy().to_string(),
1289:             is_directory: metadata.is_dir(),
1290:             size: metadata.len(),
1291:             extension,
1292:         });
1293:     }
1294: 
1295:     // Sort: directories first, then files, alphabetically within each group
1296:     entries.sort_by(|a, b| match (a.is_directory, b.is_directory) {
1297:         (true, false) => std::cmp::Ordering::Less,
1298:         (false, true) => std::cmp::Ordering::Greater,
1299:         _ => a.name.to_lowercase().cmp(&b.name.to_lowercase()),
1300:     });
1301: 
1302:     Ok(entries)
1303: }
1304: 
1305: /// Search for files and directories matching a pattern
1306: #[tauri::command]
1307: pub async fn search_files(base_path: String, query: String) -> Result<Vec<FileEntry>, String> {
1308:     log::info!("Searching files in '{}' for: '{}'", base_path, query);
1309: 
1310:     // Check if path is empty
1311:     if base_path.trim().is_empty() {
1312:         log::error!("Base path is empty or whitespace");
1313:         return Err("Base path cannot be empty".to_string());
1314:     }
1315: 
1316:     // Check if query is empty
1317:     if query.trim().is_empty() {
1318:         log::warn!("Search query is empty, returning empty results");
1319:         return Ok(Vec::new());
1320:     }
1321: 
1322:     let path = PathBuf::from(&base_path);
1323:     log::debug!("Resolved search base path: {:?}", path);
1324: 
1325:     if !path.exists() {
1326:         log::error!("Base path does not exist: {:?}", path);
1327:         return Err(format!("Path does not exist: {}", base_path));
1328:     }
1329: 
1330:     let query_lower = query.to_lowercase();
1331:     let mut results = Vec::new();
1332: 
1333:     search_files_recursive(&path, &path, &query_lower, &mut results, 0)?;
1334: 
1335:     // Sort by relevance: exact matches first, then by name
1336:     results.sort_by(|a, b| {
1337:         let a_exact = a.name.to_lowercase() == query_lower;
1338:         let b_exact = b.name.to_lowercase() == query_lower;
1339: 
1340:         match (a_exact, b_exact) {
1341:             (true, false) => std::cmp::Ordering::Less,
1342:             (false, true) => std::cmp::Ordering::Greater,
1343:             _ => a.name.to_lowercase().cmp(&b.name.to_lowercase()),
1344:         }
1345:     });
1346: 
1347:     // Limit results to prevent overwhelming the UI
1348:     results.truncate(50);
1349: 
1350:     Ok(results)
1351: }
1352: 
1353: fn search_files_recursive(
1354:     current_path: &PathBuf,
1355:     base_path: &PathBuf,
1356:     query: &str,
1357:     results: &mut Vec<FileEntry>,
1358:     depth: usize,
1359: ) -> Result<(), String> {
1360:     // Limit recursion depth to prevent excessive searching
1361:     if depth > 5 || results.len() >= 50 {
1362:         return Ok(());
1363:     }
1364: 
1365:     let entries = fs::read_dir(current_path)
1366:         .map_err(|e| format!("Failed to read directory {:?}: {}", current_path, e))?;
1367: 
1368:     for entry in entries {
1369:         let entry = entry.map_err(|e| format!("Failed to read entry: {}", e))?;
1370:         let entry_path = entry.path();
1371: 
1372:         // Skip hidden files/directories
1373:         if let Some(name) = entry_path.file_name().and_then(|n| n.to_str()) {
1374:             if name.starts_with('.') {
1375:                 continue;
1376:             }
1377: 
1378:             // Check if name matches query
1379:             if name.to_lowercase().contains(query) {
1380:                 let metadata = entry
1381:                     .metadata()
1382:                     .map_err(|e| format!("Failed to read metadata: {}", e))?;
1383: 
1384:                 let extension = if metadata.is_file() {
1385:                     entry_path
1386:                         .extension()
1387:                         .and_then(|e| e.to_str())
1388:                         .map(|e| e.to_string())
1389:                 } else {
1390:                     None
1391:                 };
1392: 
1393:                 results.push(FileEntry {
1394:                     name: name.to_string(),
1395:                     path: entry_path.to_string_lossy().to_string(),
1396:                     is_directory: metadata.is_dir(),
1397:                     size: metadata.len(),
1398:                     extension,
1399:                 });
1400:             }
1401:         }
1402: 
1403:         // Recurse into directories
1404:         if entry_path.is_dir() {
1405:             // Skip common directories that shouldn't be searched
1406:             if let Some(dir_name) = entry_path.file_name().and_then(|n| n.to_str()) {
1407:                 if matches!(
1408:                     dir_name,
1409:                     "node_modules" | "target" | ".git" | "dist" | "build" | ".next" | "__pycache__"
1410:                 ) {
1411:                     continue;
1412:                 }
1413:             }
1414: 
1415:             search_files_recursive(&entry_path, base_path, query, results, depth + 1)?;
1416:         }
1417:     }
1418: 
1419:     Ok(())
1420: }
1421: 
1422: /// Creates a checkpoint for the current session state
1423: #[tauri::command]
1424: pub async fn create_checkpoint(
1425:     app: tauri::State<'_, crate::checkpoint::state::CheckpointState>,
1426:     session_id: String,
1427:     project_id: String,
1428:     project_path: String,
1429:     message_index: Option<usize>,
1430:     description: Option<String>,
1431: ) -> Result<crate::checkpoint::CheckpointResult, String> {
1432:     log::info!(
1433:         "Creating checkpoint for session: {} in project: {}",
1434:         session_id,
1435:         project_id
1436:     );
1437: 
1438:     let manager = app
1439:         .get_or_create_manager(
1440:             session_id.clone(),
1441:             project_id.clone(),
1442:             PathBuf::from(&project_path),
1443:         )
1444:         .await
1445:         .map_err(|e| format!("Failed to get checkpoint manager: {}", e))?;
1446: 
1447:     // Always load current session messages from the JSONL file
1448:     let session_path = get_claude_dir()
1449:         .map_err(|e| e.to_string())?
1450:         .join("projects")
1451:         .join(&project_id)
1452:         .join(format!("{}.jsonl", session_id));
1453: 
1454:     if session_path.exists() {
1455:         let file = fs::File::open(&session_path)
1456:             .map_err(|e| format!("Failed to open session file: {}", e))?;
1457:         let reader = BufReader::new(file);
1458: 
1459:         let mut line_count = 0;
1460:         for line in reader.lines() {
1461:             if let Some(index) = message_index {
1462:                 if line_count > index {
1463:                     break;
1464:                 }
1465:             }
1466:             if let Ok(line) = line {
1467:                 manager
1468:                     .track_message(line)
1469:                     .await
1470:                     .map_err(|e| format!("Failed to track message: {}", e))?;
1471:             }
1472:             line_count += 1;
1473:         }
1474:     }
1475: 
1476:     manager
1477:         .create_checkpoint(description, None)
1478:         .await
1479:         .map_err(|e| format!("Failed to create checkpoint: {}", e))
1480: }
1481: 
1482: /// Restores a session to a specific checkpoint
1483: #[tauri::command]
1484: pub async fn restore_checkpoint(
1485:     app: tauri::State<'_, crate::checkpoint::state::CheckpointState>,
1486:     checkpoint_id: String,
1487:     session_id: String,
1488:     project_id: String,
1489:     project_path: String,
1490: ) -> Result<crate::checkpoint::CheckpointResult, String> {
1491:     log::info!(
1492:         "Restoring checkpoint: {} for session: {}",
1493:         checkpoint_id,
1494:         session_id
1495:     );
1496: 
1497:     let manager = app
1498:         .get_or_create_manager(
1499:             session_id.clone(),
1500:             project_id.clone(),
1501:             PathBuf::from(&project_path),
1502:         )
1503:         .await
1504:         .map_err(|e| format!("Failed to get checkpoint manager: {}", e))?;
1505: 
1506:     let result = manager
1507:         .restore_checkpoint(&checkpoint_id)
1508:         .await
1509:         .map_err(|e| format!("Failed to restore checkpoint: {}", e))?;
1510: 
1511:     // Update the session JSONL file with restored messages
1512:     let claude_dir = get_claude_dir().map_err(|e| e.to_string())?;
1513:     let session_path = claude_dir
1514:         .join("projects")
1515:         .join(&result.checkpoint.project_id)
1516:         .join(format!("{}.jsonl", session_id));
1517: 
1518:     // The manager has already restored the messages internally,
1519:     // but we need to update the actual session file
1520:     let (_, _, messages) = manager
1521:         .storage
1522:         .load_checkpoint(&result.checkpoint.project_id, &session_id, &checkpoint_id)
1523:         .map_err(|e| format!("Failed to load checkpoint data: {}", e))?;
1524: 
1525:     fs::write(&session_path, messages)
1526:         .map_err(|e| format!("Failed to update session file: {}", e))?;
1527: 
1528:     Ok(result)
1529: }
1530: 
1531: /// Lists all checkpoints for a session
1532: #[tauri::command]
1533: pub async fn list_checkpoints(
1534:     app: tauri::State<'_, crate::checkpoint::state::CheckpointState>,
1535:     session_id: String,
1536:     project_id: String,
1537:     project_path: String,
1538: ) -> Result<Vec<crate::checkpoint::Checkpoint>, String> {
1539:     log::info!(
1540:         "Listing checkpoints for session: {} in project: {}",
1541:         session_id,
1542:         project_id
1543:     );
1544: 
1545:     let manager = app
1546:         .get_or_create_manager(session_id, project_id, PathBuf::from(&project_path))
1547:         .await
1548:         .map_err(|e| format!("Failed to get checkpoint manager: {}", e))?;
1549: 
1550:     Ok(manager.list_checkpoints().await)
1551: }
1552: 
1553: /// Forks a new timeline branch from a checkpoint
1554: #[tauri::command]
1555: pub async fn fork_from_checkpoint(
1556:     app: tauri::State<'_, crate::checkpoint::state::CheckpointState>,
1557:     checkpoint_id: String,
1558:     session_id: String,
1559:     project_id: String,
1560:     project_path: String,
1561:     new_session_id: String,
1562:     description: Option<String>,
1563: ) -> Result<crate::checkpoint::CheckpointResult, String> {
1564:     log::info!(
1565:         "Forking from checkpoint: {} to new session: {}",
1566:         checkpoint_id,
1567:         new_session_id
1568:     );
1569: 
1570:     let claude_dir = get_claude_dir().map_err(|e| e.to_string())?;
1571: 
1572:     // First, copy the session file to the new session
1573:     let source_session_path = claude_dir
1574:         .join("projects")
1575:         .join(&project_id)
1576:         .join(format!("{}.jsonl", session_id));
1577:     let new_session_path = claude_dir
1578:         .join("projects")
1579:         .join(&project_id)
1580:         .join(format!("{}.jsonl", new_session_id));
1581: 
1582:     if source_session_path.exists() {
1583:         fs::copy(&source_session_path, &new_session_path)
1584:             .map_err(|e| format!("Failed to copy session file: {}", e))?;
1585:     }
1586: 
1587:     // Create manager for the new session
1588:     let manager = app
1589:         .get_or_create_manager(
1590:             new_session_id.clone(),
1591:             project_id,
1592:             PathBuf::from(&project_path),
1593:         )
1594:         .await
1595:         .map_err(|e| format!("Failed to get checkpoint manager: {}", e))?;
1596: 
1597:     manager
1598:         .fork_from_checkpoint(&checkpoint_id, description)
1599:         .await
1600:         .map_err(|e| format!("Failed to fork checkpoint: {}", e))
1601: }
1602: 
1603: /// Gets the timeline for a session
1604: #[tauri::command]
1605: pub async fn get_session_timeline(
1606:     app: tauri::State<'_, crate::checkpoint::state::CheckpointState>,
1607:     session_id: String,
1608:     project_id: String,
1609:     project_path: String,
1610: ) -> Result<crate::checkpoint::SessionTimeline, String> {
1611:     log::info!(
1612:         "Getting timeline for session: {} in project: {}",
1613:         session_id,
1614:         project_id
1615:     );
1616: 
1617:     let manager = app
1618:         .get_or_create_manager(session_id, project_id, PathBuf::from(&project_path))
1619:         .await
1620:         .map_err(|e| format!("Failed to get checkpoint manager: {}", e))?;
1621: 
1622:     Ok(manager.get_timeline().await)
1623: }
1624: 
1625: /// Updates checkpoint settings for a session
1626: #[tauri::command]
1627: pub async fn update_checkpoint_settings(
1628:     app: tauri::State<'_, crate::checkpoint::state::CheckpointState>,
1629:     session_id: String,
1630:     project_id: String,
1631:     project_path: String,
1632:     auto_checkpoint_enabled: bool,
1633:     checkpoint_strategy: String,
1634: ) -> Result<(), String> {
1635:     use crate::checkpoint::CheckpointStrategy;
1636: 
1637:     log::info!("Updating checkpoint settings for session: {}", session_id);
1638: 
1639:     let strategy = match checkpoint_strategy.as_str() {
1640:         "manual" => CheckpointStrategy::Manual,
1641:         "per_prompt" => CheckpointStrategy::PerPrompt,
1642:         "per_tool_use" => CheckpointStrategy::PerToolUse,
1643:         "smart" => CheckpointStrategy::Smart,
1644:         _ => {
1645:             return Err(format!(
1646:                 "Invalid checkpoint strategy: {}",
1647:                 checkpoint_strategy
1648:             ))
1649:         }
1650:     };
1651: 
1652:     let manager = app
1653:         .get_or_create_manager(session_id, project_id, PathBuf::from(&project_path))
1654:         .await
1655:         .map_err(|e| format!("Failed to get checkpoint manager: {}", e))?;
1656: 
1657:     manager
1658:         .update_settings(auto_checkpoint_enabled, strategy)
1659:         .await
1660:         .map_err(|e| format!("Failed to update settings: {}", e))
1661: }
1662: 
1663: /// Gets diff between two checkpoints
1664: #[tauri::command]
1665: pub async fn get_checkpoint_diff(
1666:     from_checkpoint_id: String,
1667:     to_checkpoint_id: String,
1668:     session_id: String,
1669:     project_id: String,
1670: ) -> Result<crate::checkpoint::CheckpointDiff, String> {
1671:     use crate::checkpoint::storage::CheckpointStorage;
1672: 
1673:     log::info!(
1674:         "Getting diff between checkpoints: {} -> {}",
1675:         from_checkpoint_id,
1676:         to_checkpoint_id
1677:     );
1678: 
1679:     let claude_dir = get_claude_dir().map_err(|e| e.to_string())?;
1680:     let storage = CheckpointStorage::new(claude_dir);
1681: 
1682:     // Load both checkpoints
1683:     let (from_checkpoint, from_files, _) = storage
1684:         .load_checkpoint(&project_id, &session_id, &from_checkpoint_id)
1685:         .map_err(|e| format!("Failed to load source checkpoint: {}", e))?;
1686:     let (to_checkpoint, to_files, _) = storage
1687:         .load_checkpoint(&project_id, &session_id, &to_checkpoint_id)
1688:         .map_err(|e| format!("Failed to load target checkpoint: {}", e))?;
1689: 
1690:     // Build file maps
1691:     let mut from_map: std::collections::HashMap<PathBuf, &crate::checkpoint::FileSnapshot> =
1692:         std::collections::HashMap::new();
1693:     for file in &from_files {
1694:         from_map.insert(file.file_path.clone(), file);
1695:     }
1696: 
1697:     let mut to_map: std::collections::HashMap<PathBuf, &crate::checkpoint::FileSnapshot> =
1698:         std::collections::HashMap::new();
1699:     for file in &to_files {
1700:         to_map.insert(file.file_path.clone(), file);
1701:     }
1702: 
1703:     // Calculate differences
1704:     let mut modified_files = Vec::new();
1705:     let mut added_files = Vec::new();
1706:     let mut deleted_files = Vec::new();
1707: 
1708:     // Check for modified and deleted files
1709:     for (path, from_file) in &from_map {
1710:         if let Some(to_file) = to_map.get(path) {
1711:             if from_file.hash != to_file.hash {
1712:                 // File was modified
1713:                 let additions = to_file.content.lines().count();
1714:                 let deletions = from_file.content.lines().count();
1715: 
1716:                 modified_files.push(crate::checkpoint::FileDiff {
1717:                     path: path.clone(),
1718:                     additions,
1719:                     deletions,
1720:                     diff_content: None, // TODO: Generate actual diff
1721:                 });
1722:             }
1723:         } else {
1724:             // File was deleted
1725:             deleted_files.push(path.clone());
1726:         }
1727:     }
1728: 
1729:     // Check for added files
1730:     for (path, _) in &to_map {
1731:         if !from_map.contains_key(path) {
1732:             added_files.push(path.clone());
1733:         }
1734:     }
1735: 
1736:     // Calculate token delta
1737:     let token_delta = (to_checkpoint.metadata.total_tokens as i64)
1738:         - (from_checkpoint.metadata.total_tokens as i64);
1739: 
1740:     Ok(crate::checkpoint::CheckpointDiff {
1741:         from_checkpoint_id,
1742:         to_checkpoint_id,
1743:         modified_files,
1744:         added_files,
1745:         deleted_files,
1746:         token_delta,
1747:     })
1748: }
1749: 
1750: /// Tracks a message for checkpointing
1751: #[tauri::command]
1752: pub async fn track_checkpoint_message(
1753:     app: tauri::State<'_, crate::checkpoint::state::CheckpointState>,
1754:     session_id: String,
1755:     project_id: String,
1756:     project_path: String,
1757:     message: String,
1758: ) -> Result<(), String> {
1759:     log::info!("Tracking message for session: {}", session_id);
1760: 
1761:     let manager = app
1762:         .get_or_create_manager(session_id, project_id, PathBuf::from(project_path))
1763:         .await
1764:         .map_err(|e| format!("Failed to get checkpoint manager: {}", e))?;
1765: 
1766:     manager
1767:         .track_message(message)
1768:         .await
1769:         .map_err(|e| format!("Failed to track message: {}", e))
1770: }
1771: 
1772: /// Checks if auto-checkpoint should be triggered
1773: #[tauri::command]
1774: pub async fn check_auto_checkpoint(
1775:     app: tauri::State<'_, crate::checkpoint::state::CheckpointState>,
1776:     session_id: String,
1777:     project_id: String,
1778:     project_path: String,
1779:     message: String,
1780: ) -> Result<bool, String> {
1781:     log::info!("Checking auto-checkpoint for session: {}", session_id);
1782: 
1783:     let manager = app
1784:         .get_or_create_manager(session_id.clone(), project_id, PathBuf::from(project_path))
1785:         .await
1786:         .map_err(|e| format!("Failed to get checkpoint manager: {}", e))?;
1787: 
1788:     Ok(manager.should_auto_checkpoint(&message).await)
1789: }
1790: 
1791: /// Triggers cleanup of old checkpoints
1792: #[tauri::command]
1793: pub async fn cleanup_old_checkpoints(
1794:     app: tauri::State<'_, crate::checkpoint::state::CheckpointState>,
1795:     session_id: String,
1796:     project_id: String,
1797:     project_path: String,
1798:     keep_count: usize,
1799: ) -> Result<usize, String> {
1800:     log::info!(
1801:         "Cleaning up old checkpoints for session: {}, keeping {}",
1802:         session_id,
1803:         keep_count
1804:     );
1805: 
1806:     let manager = app
1807:         .get_or_create_manager(
1808:             session_id.clone(),
1809:             project_id.clone(),
1810:             PathBuf::from(project_path),
1811:         )
1812:         .await
1813:         .map_err(|e| format!("Failed to get checkpoint manager: {}", e))?;
1814: 
1815:     manager
1816:         .storage
1817:         .cleanup_old_checkpoints(&project_id, &session_id, keep_count)
1818:         .map_err(|e| format!("Failed to cleanup checkpoints: {}", e))
1819: }
1820: 
1821: /// Gets checkpoint settings for a session
1822: #[tauri::command]
1823: pub async fn get_checkpoint_settings(
1824:     app: tauri::State<'_, crate::checkpoint::state::CheckpointState>,
1825:     session_id: String,
1826:     project_id: String,
1827:     project_path: String,
1828: ) -> Result<serde_json::Value, String> {
1829:     log::info!("Getting checkpoint settings for session: {}", session_id);
1830: 
1831:     let manager = app
1832:         .get_or_create_manager(session_id, project_id, PathBuf::from(project_path))
1833:         .await
1834:         .map_err(|e| format!("Failed to get checkpoint manager: {}", e))?;
1835: 
1836:     let timeline = manager.get_timeline().await;
1837: 
1838:     Ok(serde_json::json!({
1839:         "auto_checkpoint_enabled": timeline.auto_checkpoint_enabled,
1840:         "checkpoint_strategy": timeline.checkpoint_strategy,
1841:         "total_checkpoints": timeline.total_checkpoints,
1842:         "current_checkpoint_id": timeline.current_checkpoint_id,
1843:     }))
1844: }
1845: 
1846: /// Clears checkpoint manager for a session (cleanup on session end)
1847: #[tauri::command]
1848: pub async fn clear_checkpoint_manager(
1849:     app: tauri::State<'_, crate::checkpoint::state::CheckpointState>,
1850:     session_id: String,
1851: ) -> Result<(), String> {
1852:     log::info!("Clearing checkpoint manager for session: {}", session_id);
1853: 
1854:     app.remove_manager(&session_id).await;
1855:     Ok(())
1856: }
1857: 
1858: /// Gets checkpoint state statistics (for debugging/monitoring)
1859: #[tauri::command]
1860: pub async fn get_checkpoint_state_stats(
1861:     app: tauri::State<'_, crate::checkpoint::state::CheckpointState>,
1862: ) -> Result<serde_json::Value, String> {
1863:     let active_count = app.active_count().await;
1864:     let active_sessions = app.list_active_sessions().await;
1865: 
1866:     Ok(serde_json::json!({
1867:         "active_managers": active_count,
1868:         "active_sessions": active_sessions,
1869:     }))
1870: }
1871: 
1872: /// Gets files modified in the last N minutes for a session
1873: #[tauri::command]
1874: pub async fn get_recently_modified_files(
1875:     app: tauri::State<'_, crate::checkpoint::state::CheckpointState>,
1876:     session_id: String,
1877:     project_id: String,
1878:     project_path: String,
1879:     minutes: i64,
1880: ) -> Result<Vec<String>, String> {
1881:     use chrono::{Duration, Utc};
1882: 
1883:     log::info!(
1884:         "Getting files modified in the last {} minutes for session: {}",
1885:         minutes,
1886:         session_id
1887:     );
1888: 
1889:     let manager = app
1890:         .get_or_create_manager(session_id, project_id, PathBuf::from(project_path))
1891:         .await
1892:         .map_err(|e| format!("Failed to get checkpoint manager: {}", e))?;
1893: 
1894:     let since = Utc::now() - Duration::minutes(minutes);
1895:     let modified_files = manager.get_files_modified_since(since).await;
1896: 
1897:     // Also log the last modification time
1898:     if let Some(last_mod) = manager.get_last_modification_time().await {
1899:         log::info!("Last file modification was at: {}", last_mod);
1900:     }
1901: 
1902:     Ok(modified_files
1903:         .into_iter()
1904:         .map(|p| p.to_string_lossy().to_string())
1905:         .collect())
1906: }
1907: 
1908: /// Track session messages from the frontend for checkpointing
1909: #[tauri::command]
1910: pub async fn track_session_messages(
1911:     state: tauri::State<'_, crate::checkpoint::state::CheckpointState>,
1912:     session_id: String,
1913:     project_id: String,
1914:     project_path: String,
1915:     messages: Vec<String>,
1916: ) -> Result<(), String> {
1917:     log::info!(
1918:         "Tracking {} messages for session {}",
1919:         messages.len(),
1920:         session_id
1921:     );
1922: 
1923:     let manager = state
1924:         .get_or_create_manager(
1925:             session_id.clone(),
1926:             project_id.clone(),
1927:             PathBuf::from(&project_path),
1928:         )
1929:         .await
1930:         .map_err(|e| format!("Failed to get checkpoint manager: {}", e))?;
1931: 
1932:     for message in messages {
1933:         manager
1934:             .track_message(message)
1935:             .await
1936:             .map_err(|e| format!("Failed to track message: {}", e))?;
1937:     }
1938: 
1939:     Ok(())
1940: }
1941: 
1942: /// Gets hooks configuration from settings at specified scope
1943: #[tauri::command]
1944: pub async fn get_hooks_config(scope: String, project_path: Option<String>) -> Result<serde_json::Value, String> {
1945:     log::info!("Getting hooks config for scope: {}, project: {:?}", scope, project_path);
1946: 
1947:     let settings_path = match scope.as_str() {
1948:         "user" => {
1949:             get_claude_dir()
1950:                 .map_err(|e| e.to_string())?
1951:                 .join("settings.json")
1952:         },
1953:         "project" => {
1954:             let path = project_path.ok_or("Project path required for project scope")?;
1955:             PathBuf::from(path).join(".claude").join("settings.json")
1956:         },
1957:         "local" => {
1958:             let path = project_path.ok_or("Project path required for local scope")?;
1959:             PathBuf::from(path).join(".claude").join("settings.local.json")
1960:         },
1961:         _ => return Err("Invalid scope".to_string())
1962:     };
1963: 
1964:     if !settings_path.exists() {
1965:         log::info!("Settings file does not exist at {:?}, returning empty hooks", settings_path);
1966:         return Ok(serde_json::json!({}));
1967:     }
1968: 
1969:     let content = fs::read_to_string(&settings_path)
1970:         .map_err(|e| format!("Failed to read settings: {}", e))?;
1971:     
1972:     let settings: serde_json::Value = serde_json::from_str(&content)
1973:         .map_err(|e| format!("Failed to parse settings: {}", e))?;
1974:     
1975:     Ok(settings.get("hooks").cloned().unwrap_or(serde_json::json!({})))
1976: }
1977: 
1978: /// Updates hooks configuration in settings at specified scope
1979: #[tauri::command]
1980: pub async fn update_hooks_config(
1981:     scope: String, 
1982:     hooks: serde_json::Value,
1983:     project_path: Option<String>
1984: ) -> Result<String, String> {
1985:     log::info!("Updating hooks config for scope: {}, project: {:?}", scope, project_path);
1986: 
1987:     let settings_path = match scope.as_str() {
1988:         "user" => {
1989:             get_claude_dir()
1990:                 .map_err(|e| e.to_string())?
1991:                 .join("settings.json")
1992:         },
1993:         "project" => {
1994:             let path = project_path.ok_or("Project path required for project scope")?;
1995:             let claude_dir = PathBuf::from(path).join(".claude");
1996:             fs::create_dir_all(&claude_dir)
1997:                 .map_err(|e| format!("Failed to create .claude directory: {}", e))?;
1998:             claude_dir.join("settings.json")
1999:         },
2000:         "local" => {
2001:             let path = project_path.ok_or("Project path required for local scope")?;
2002:             let claude_dir = PathBuf::from(path).join(".claude");
2003:             fs::create_dir_all(&claude_dir)
2004:                 .map_err(|e| format!("Failed to create .claude directory: {}", e))?;
2005:             claude_dir.join("settings.local.json")
2006:         },
2007:         _ => return Err("Invalid scope".to_string())
2008:     };
2009: 
2010:     // Read existing settings or create new
2011:     let mut settings = if settings_path.exists() {
2012:         let content = fs::read_to_string(&settings_path)
2013:             .map_err(|e| format!("Failed to read settings: {}", e))?;
2014:         serde_json::from_str(&content)
2015:             .map_err(|e| format!("Failed to parse settings: {}", e))?
2016:     } else {
2017:         serde_json::json!({})
2018:     };
2019: 
2020:     // Update hooks section
2021:     settings["hooks"] = hooks;
2022: 
2023:     // Write back with pretty formatting
2024:     let json_string = serde_json::to_string_pretty(&settings)
2025:         .map_err(|e| format!("Failed to serialize settings: {}", e))?;
2026:     
2027:     fs::write(&settings_path, json_string)
2028:         .map_err(|e| format!("Failed to write settings: {}", e))?;
2029: 
2030:     Ok("Hooks configuration updated successfully".to_string())
2031: }
2032: 
2033: /// Validates a hook command by dry-running it
2034: #[tauri::command]
2035: pub async fn validate_hook_command(command: String) -> Result<serde_json::Value, String> {
2036:     log::info!("Validating hook command syntax");
2037: 
2038:     // Validate syntax without executing
2039:     let mut cmd = std::process::Command::new("bash");
2040:     cmd.arg("-n") // Syntax check only
2041:        .arg("-c")
2042:        .arg(&command);
2043:     
2044:     match cmd.output() {
2045:         Ok(output) => {
2046:             if output.status.success() {
2047:                 Ok(serde_json::json!({
2048:                     "valid": true,
2049:                     "message": "Command syntax is valid"
2050:                 }))
2051:             } else {
2052:                 let stderr = String::from_utf8_lossy(&output.stderr);
2053:                 Ok(serde_json::json!({
2054:                     "valid": false,
2055:                     "message": format!("Syntax error: {}", stderr)
2056:                 }))
2057:             }
2058:         }
2059:         Err(e) => Err(format!("Failed to validate command: {}", e))
2060:     }
2061: }
````

## File: src-tauri/src/commands/mcp.rs
````rust
  1: use anyhow::{Context, Result};
  2: use dirs;
  3: use log::{error, info};
  4: use serde::{Deserialize, Serialize};
  5: use std::collections::HashMap;
  6: use std::fs;
  7: use std::path::PathBuf;
  8: use std::process::Command;
  9: use tauri::AppHandle;
 10: 
 11: /// Helper function to create a std::process::Command with proper environment variables
 12: /// This ensures commands like Claude can find Node.js and other dependencies
 13: fn create_command_with_env(program: &str) -> Command {
 14:     crate::claude_binary::create_command_with_env(program)
 15: }
 16: 
 17: /// Finds the full path to the claude binary
 18: /// This is necessary because macOS apps have a limited PATH environment
 19: fn find_claude_binary(app_handle: &AppHandle) -> Result<String> {
 20:     crate::claude_binary::find_claude_binary(app_handle).map_err(|e| anyhow::anyhow!(e))
 21: }
 22: 
 23: /// Represents an MCP server configuration
 24: #[derive(Debug, Clone, Serialize, Deserialize)]
 25: pub struct MCPServer {
 26:     /// Server name/identifier
 27:     pub name: String,
 28:     /// Transport type: "stdio" or "sse"
 29:     pub transport: String,
 30:     /// Command to execute (for stdio)
 31:     pub command: Option<String>,
 32:     /// Command arguments (for stdio)
 33:     pub args: Vec<String>,
 34:     /// Environment variables
 35:     pub env: HashMap<String, String>,
 36:     /// URL endpoint (for SSE)
 37:     pub url: Option<String>,
 38:     /// Configuration scope: "local", "project", or "user"
 39:     pub scope: String,
 40:     /// Whether the server is currently active
 41:     pub is_active: bool,
 42:     /// Server status
 43:     pub status: ServerStatus,
 44: }
 45: 
 46: /// Server status information
 47: #[derive(Debug, Clone, Serialize, Deserialize)]
 48: pub struct ServerStatus {
 49:     /// Whether the server is running
 50:     pub running: bool,
 51:     /// Last error message if any
 52:     pub error: Option<String>,
 53:     /// Last checked timestamp
 54:     pub last_checked: Option<u64>,
 55: }
 56: 
 57: /// MCP configuration for project scope (.mcp.json)
 58: #[derive(Debug, Clone, Serialize, Deserialize)]
 59: pub struct MCPProjectConfig {
 60:     #[serde(rename = "mcpServers")]
 61:     pub mcp_servers: HashMap<String, MCPServerConfig>,
 62: }
 63: 
 64: /// Individual server configuration in .mcp.json
 65: #[derive(Debug, Clone, Serialize, Deserialize)]
 66: pub struct MCPServerConfig {
 67:     pub command: String,
 68:     #[serde(default)]
 69:     pub args: Vec<String>,
 70:     #[serde(default)]
 71:     pub env: HashMap<String, String>,
 72: }
 73: 
 74: /// Result of adding a server
 75: #[derive(Debug, Clone, Serialize, Deserialize)]
 76: pub struct AddServerResult {
 77:     pub success: bool,
 78:     pub message: String,
 79:     pub server_name: Option<String>,
 80: }
 81: 
 82: /// Import result for multiple servers
 83: #[derive(Debug, Clone, Serialize, Deserialize)]
 84: pub struct ImportResult {
 85:     pub imported_count: u32,
 86:     pub failed_count: u32,
 87:     pub servers: Vec<ImportServerResult>,
 88: }
 89: 
 90: /// Result for individual server import
 91: #[derive(Debug, Clone, Serialize, Deserialize)]
 92: pub struct ImportServerResult {
 93:     pub name: String,
 94:     pub success: bool,
 95:     pub error: Option<String>,
 96: }
 97: 
 98: /// Executes a claude mcp command
 99: fn execute_claude_mcp_command(app_handle: &AppHandle, args: Vec<&str>) -> Result<String> {
100:     info!("Executing claude mcp command with args: {:?}", args);
101: 
102:     let claude_path = find_claude_binary(app_handle)?;
103:     let mut cmd = create_command_with_env(&claude_path);
104:     cmd.arg("mcp");
105:     for arg in args {
106:         cmd.arg(arg);
107:     }
108: 
109:     let output = cmd.output().context("Failed to execute claude command")?;
110: 
111:     if output.status.success() {
112:         Ok(String::from_utf8_lossy(&output.stdout).to_string())
113:     } else {
114:         let stderr = String::from_utf8_lossy(&output.stderr).to_string();
115:         Err(anyhow::anyhow!("Command failed: {}", stderr))
116:     }
117: }
118: 
119: /// Adds a new MCP server
120: #[tauri::command]
121: pub async fn mcp_add(
122:     app: AppHandle,
123:     name: String,
124:     transport: String,
125:     command: Option<String>,
126:     args: Vec<String>,
127:     env: HashMap<String, String>,
128:     url: Option<String>,
129:     scope: String,
130: ) -> Result<AddServerResult, String> {
131:     info!("Adding MCP server: {} with transport: {}", name, transport);
132: 
133:     // Prepare owned strings for environment variables
134:     let env_args: Vec<String> = env
135:         .iter()
136:         .map(|(key, value)| format!("{}={}", key, value))
137:         .collect();
138: 
139:     let mut cmd_args = vec!["add"];
140: 
141:     // Add scope flag
142:     cmd_args.push("-s");
143:     cmd_args.push(&scope);
144: 
145:     // Add transport flag for SSE
146:     if transport == "sse" {
147:         cmd_args.push("--transport");
148:         cmd_args.push("sse");
149:     }
150: 
151:     // Add environment variables
152:     for (i, _) in env.iter().enumerate() {
153:         cmd_args.push("-e");
154:         cmd_args.push(&env_args[i]);
155:     }
156: 
157:     // Add name
158:     cmd_args.push(&name);
159: 
160:     // Add command/URL based on transport
161:     if transport == "stdio" {
162:         if let Some(cmd) = &command {
163:             // Add "--" separator before command to prevent argument parsing issues
164:             if !args.is_empty() || cmd.contains('-') {
165:                 cmd_args.push("--");
166:             }
167:             cmd_args.push(cmd);
168:             // Add arguments
169:             for arg in &args {
170:                 cmd_args.push(arg);
171:             }
172:         } else {
173:             return Ok(AddServerResult {
174:                 success: false,
175:                 message: "Command is required for stdio transport".to_string(),
176:                 server_name: None,
177:             });
178:         }
179:     } else if transport == "sse" {
180:         if let Some(url_str) = &url {
181:             cmd_args.push(url_str);
182:         } else {
183:             return Ok(AddServerResult {
184:                 success: false,
185:                 message: "URL is required for SSE transport".to_string(),
186:                 server_name: None,
187:             });
188:         }
189:     }
190: 
191:     match execute_claude_mcp_command(&app, cmd_args) {
192:         Ok(output) => {
193:             info!("Successfully added MCP server: {}", name);
194:             Ok(AddServerResult {
195:                 success: true,
196:                 message: output.trim().to_string(),
197:                 server_name: Some(name),
198:             })
199:         }
200:         Err(e) => {
201:             error!("Failed to add MCP server: {}", e);
202:             Ok(AddServerResult {
203:                 success: false,
204:                 message: e.to_string(),
205:                 server_name: None,
206:             })
207:         }
208:     }
209: }
210: 
211: /// Lists all configured MCP servers
212: #[tauri::command]
213: pub async fn mcp_list(app: AppHandle) -> Result<Vec<MCPServer>, String> {
214:     info!("Listing MCP servers");
215: 
216:     match execute_claude_mcp_command(&app, vec!["list"]) {
217:         Ok(output) => {
218:             info!("Raw output from 'claude mcp list': {:?}", output);
219:             let trimmed = output.trim();
220:             info!("Trimmed output: {:?}", trimmed);
221: 
222:             // Check if no servers are configured
223:             if trimmed.contains("No MCP servers configured") || trimmed.is_empty() {
224:                 info!("No servers found - empty or 'No MCP servers' message");
225:                 return Ok(vec![]);
226:             }
227: 
228:             // Parse the text output, handling multi-line commands
229:             let mut servers = Vec::new();
230:             let lines: Vec<&str> = trimmed.lines().collect();
231:             info!("Total lines in output: {}", lines.len());
232:             for (idx, line) in lines.iter().enumerate() {
233:                 info!("Line {}: {:?}", idx, line);
234:             }
235: 
236:             let mut i = 0;
237: 
238:             while i < lines.len() {
239:                 let line = lines[i];
240:                 info!("Processing line {}: {:?}", i, line);
241: 
242:                 // Check if this line starts a new server entry
243:                 if let Some(colon_pos) = line.find(':') {
244:                     info!("Found colon at position {} in line: {:?}", colon_pos, line);
245:                     // Make sure this is a server name line (not part of a path)
246:                     // Server names typically don't contain '/' or '\'
247:                     let potential_name = line[..colon_pos].trim();
248:                     info!("Potential server name: {:?}", potential_name);
249: 
250:                     if !potential_name.contains('/') && !potential_name.contains('\\') {
251:                         info!("Valid server name detected: {:?}", potential_name);
252:                         let name = potential_name.to_string();
253:                         let mut command_parts = vec![line[colon_pos + 1..].trim().to_string()];
254:                         info!("Initial command part: {:?}", command_parts[0]);
255: 
256:                         // Check if command continues on next lines
257:                         i += 1;
258:                         while i < lines.len() {
259:                             let next_line = lines[i];
260:                             info!("Checking next line {} for continuation: {:?}", i, next_line);
261: 
262:                             // If the next line starts with a server name pattern, break
263:                             if next_line.contains(':') {
264:                                 let potential_next_name =
265:                                     next_line.split(':').next().unwrap_or("").trim();
266:                                 info!(
267:                                     "Found colon in next line, potential name: {:?}",
268:                                     potential_next_name
269:                                 );
270:                                 if !potential_next_name.is_empty()
271:                                     && !potential_next_name.contains('/')
272:                                     && !potential_next_name.contains('\\')
273:                                 {
274:                                     info!("Next line is a new server, breaking");
275:                                     break;
276:                                 }
277:                             }
278:                             // Otherwise, this line is a continuation of the command
279:                             info!("Line {} is a continuation", i);
280:                             command_parts.push(next_line.trim().to_string());
281:                             i += 1;
282:                         }
283: 
284:                         // Join all command parts
285:                         let full_command = command_parts.join(" ");
286:                         info!("Full command for server '{}': {:?}", name, full_command);
287: 
288:                         // For now, we'll create a basic server entry
289:                         servers.push(MCPServer {
290:                             name: name.clone(),
291:                             transport: "stdio".to_string(), // Default assumption
292:                             command: Some(full_command),
293:                             args: vec![],
294:                             env: HashMap::new(),
295:                             url: None,
296:                             scope: "local".to_string(), // Default assumption
297:                             is_active: false,
298:                             status: ServerStatus {
299:                                 running: false,
300:                                 error: None,
301:                                 last_checked: None,
302:                             },
303:                         });
304:                         info!("Added server: {:?}", name);
305: 
306:                         continue;
307:                     } else {
308:                         info!("Skipping line - name contains path separators");
309:                     }
310:                 } else {
311:                     info!("No colon found in line {}", i);
312:                 }
313: 
314:                 i += 1;
315:             }
316: 
317:             info!("Found {} MCP servers total", servers.len());
318:             for (idx, server) in servers.iter().enumerate() {
319:                 info!(
320:                     "Server {}: name='{}', command={:?}",
321:                     idx, server.name, server.command
322:                 );
323:             }
324:             Ok(servers)
325:         }
326:         Err(e) => {
327:             error!("Failed to list MCP servers: {}", e);
328:             Err(e.to_string())
329:         }
330:     }
331: }
332: 
333: /// Gets details for a specific MCP server
334: #[tauri::command]
335: pub async fn mcp_get(app: AppHandle, name: String) -> Result<MCPServer, String> {
336:     info!("Getting MCP server details for: {}", name);
337: 
338:     match execute_claude_mcp_command(&app, vec!["get", &name]) {
339:         Ok(output) => {
340:             // Parse the structured text output
341:             let mut scope = "local".to_string();
342:             let mut transport = "stdio".to_string();
343:             let mut command = None;
344:             let mut args = vec![];
345:             let env = HashMap::new();
346:             let mut url = None;
347: 
348:             for line in output.lines() {
349:                 let line = line.trim();
350: 
351:                 if line.starts_with("Scope:") {
352:                     let scope_part = line.replace("Scope:", "").trim().to_string();
353:                     if scope_part.to_lowercase().contains("local") {
354:                         scope = "local".to_string();
355:                     } else if scope_part.to_lowercase().contains("project") {
356:                         scope = "project".to_string();
357:                     } else if scope_part.to_lowercase().contains("user")
358:                         || scope_part.to_lowercase().contains("global")
359:                     {
360:                         scope = "user".to_string();
361:                     }
362:                 } else if line.starts_with("Type:") {
363:                     transport = line.replace("Type:", "").trim().to_string();
364:                 } else if line.starts_with("Command:") {
365:                     command = Some(line.replace("Command:", "").trim().to_string());
366:                 } else if line.starts_with("Args:") {
367:                     let args_str = line.replace("Args:", "").trim().to_string();
368:                     if !args_str.is_empty() {
369:                         args = args_str.split_whitespace().map(|s| s.to_string()).collect();
370:                     }
371:                 } else if line.starts_with("URL:") {
372:                     url = Some(line.replace("URL:", "").trim().to_string());
373:                 } else if line.starts_with("Environment:") {
374:                     // TODO: Parse environment variables if they're listed
375:                     // For now, we'll leave it empty
376:                 }
377:             }
378: 
379:             Ok(MCPServer {
380:                 name,
381:                 transport,
382:                 command,
383:                 args,
384:                 env,
385:                 url,
386:                 scope,
387:                 is_active: false,
388:                 status: ServerStatus {
389:                     running: false,
390:                     error: None,
391:                     last_checked: None,
392:                 },
393:             })
394:         }
395:         Err(e) => {
396:             error!("Failed to get MCP server: {}", e);
397:             Err(e.to_string())
398:         }
399:     }
400: }
401: 
402: /// Removes an MCP server
403: #[tauri::command]
404: pub async fn mcp_remove(app: AppHandle, name: String) -> Result<String, String> {
405:     info!("Removing MCP server: {}", name);
406: 
407:     match execute_claude_mcp_command(&app, vec!["remove", &name]) {
408:         Ok(output) => {
409:             info!("Successfully removed MCP server: {}", name);
410:             Ok(output.trim().to_string())
411:         }
412:         Err(e) => {
413:             error!("Failed to remove MCP server: {}", e);
414:             Err(e.to_string())
415:         }
416:     }
417: }
418: 
419: /// Adds an MCP server from JSON configuration
420: #[tauri::command]
421: pub async fn mcp_add_json(
422:     app: AppHandle,
423:     name: String,
424:     json_config: String,
425:     scope: String,
426: ) -> Result<AddServerResult, String> {
427:     info!(
428:         "Adding MCP server from JSON: {} with scope: {}",
429:         name, scope
430:     );
431: 
432:     // Build command args
433:     let mut cmd_args = vec!["add-json", &name, &json_config];
434: 
435:     // Add scope flag
436:     let scope_flag = "-s";
437:     cmd_args.push(scope_flag);
438:     cmd_args.push(&scope);
439: 
440:     match execute_claude_mcp_command(&app, cmd_args) {
441:         Ok(output) => {
442:             info!("Successfully added MCP server from JSON: {}", name);
443:             Ok(AddServerResult {
444:                 success: true,
445:                 message: output.trim().to_string(),
446:                 server_name: Some(name),
447:             })
448:         }
449:         Err(e) => {
450:             error!("Failed to add MCP server from JSON: {}", e);
451:             Ok(AddServerResult {
452:                 success: false,
453:                 message: e.to_string(),
454:                 server_name: None,
455:             })
456:         }
457:     }
458: }
459: 
460: /// Imports MCP servers from Claude Desktop
461: #[tauri::command]
462: pub async fn mcp_add_from_claude_desktop(
463:     app: AppHandle,
464:     scope: String,
465: ) -> Result<ImportResult, String> {
466:     info!(
467:         "Importing MCP servers from Claude Desktop with scope: {}",
468:         scope
469:     );
470: 
471:     // Get Claude Desktop config path based on platform
472:     let config_path = if cfg!(target_os = "macos") {
473:         dirs::home_dir()
474:             .ok_or_else(|| "Could not find home directory".to_string())?
475:             .join("Library")
476:             .join("Application Support")
477:             .join("Claude")
478:             .join("claude_desktop_config.json")
479:     } else if cfg!(target_os = "linux") {
480:         // For WSL/Linux, check common locations
481:         dirs::config_dir()
482:             .ok_or_else(|| "Could not find config directory".to_string())?
483:             .join("Claude")
484:             .join("claude_desktop_config.json")
485:     } else {
486:         return Err(
487:             "Import from Claude Desktop is only supported on macOS and Linux/WSL".to_string(),
488:         );
489:     };
490: 
491:     // Check if config file exists
492:     if !config_path.exists() {
493:         return Err(
494:             "Claude Desktop configuration not found. Make sure Claude Desktop is installed."
495:                 .to_string(),
496:         );
497:     }
498: 
499:     // Read and parse the config file
500:     let config_content = fs::read_to_string(&config_path)
501:         .map_err(|e| format!("Failed to read Claude Desktop config: {}", e))?;
502: 
503:     let config: serde_json::Value = serde_json::from_str(&config_content)
504:         .map_err(|e| format!("Failed to parse Claude Desktop config: {}", e))?;
505: 
506:     // Extract MCP servers
507:     let mcp_servers = config
508:         .get("mcpServers")
509:         .and_then(|v| v.as_object())
510:         .ok_or_else(|| "No MCP servers found in Claude Desktop config".to_string())?;
511: 
512:     let mut imported_count = 0;
513:     let mut failed_count = 0;
514:     let mut server_results = Vec::new();
515: 
516:     // Import each server using add-json
517:     for (name, server_config) in mcp_servers {
518:         info!("Importing server: {}", name);
519: 
520:         // Convert Claude Desktop format to add-json format
521:         let mut json_config = serde_json::Map::new();
522: 
523:         // All Claude Desktop servers are stdio type
524:         json_config.insert(
525:             "type".to_string(),
526:             serde_json::Value::String("stdio".to_string()),
527:         );
528: 
529:         // Add command
530:         if let Some(command) = server_config.get("command").and_then(|v| v.as_str()) {
531:             json_config.insert(
532:                 "command".to_string(),
533:                 serde_json::Value::String(command.to_string()),
534:             );
535:         } else {
536:             failed_count += 1;
537:             server_results.push(ImportServerResult {
538:                 name: name.clone(),
539:                 success: false,
540:                 error: Some("Missing command field".to_string()),
541:             });
542:             continue;
543:         }
544: 
545:         // Add args if present
546:         if let Some(args) = server_config.get("args").and_then(|v| v.as_array()) {
547:             json_config.insert("args".to_string(), args.clone().into());
548:         } else {
549:             json_config.insert("args".to_string(), serde_json::Value::Array(vec![]));
550:         }
551: 
552:         // Add env if present
553:         if let Some(env) = server_config.get("env").and_then(|v| v.as_object()) {
554:             json_config.insert("env".to_string(), env.clone().into());
555:         } else {
556:             json_config.insert(
557:                 "env".to_string(),
558:                 serde_json::Value::Object(serde_json::Map::new()),
559:             );
560:         }
561: 
562:         // Convert to JSON string
563:         let json_str = serde_json::to_string(&json_config)
564:             .map_err(|e| format!("Failed to serialize config for {}: {}", name, e))?;
565: 
566:         // Call add-json command
567:         match mcp_add_json(app.clone(), name.clone(), json_str, scope.clone()).await {
568:             Ok(result) => {
569:                 if result.success {
570:                     imported_count += 1;
571:                     server_results.push(ImportServerResult {
572:                         name: name.clone(),
573:                         success: true,
574:                         error: None,
575:                     });
576:                     info!("Successfully imported server: {}", name);
577:                 } else {
578:                     failed_count += 1;
579:                     let error_msg = result.message.clone();
580:                     server_results.push(ImportServerResult {
581:                         name: name.clone(),
582:                         success: false,
583:                         error: Some(result.message),
584:                     });
585:                     error!("Failed to import server {}: {}", name, error_msg);
586:                 }
587:             }
588:             Err(e) => {
589:                 failed_count += 1;
590:                 let error_msg = e.clone();
591:                 server_results.push(ImportServerResult {
592:                     name: name.clone(),
593:                     success: false,
594:                     error: Some(e),
595:                 });
596:                 error!("Error importing server {}: {}", name, error_msg);
597:             }
598:         }
599:     }
600: 
601:     info!(
602:         "Import complete: {} imported, {} failed",
603:         imported_count, failed_count
604:     );
605: 
606:     Ok(ImportResult {
607:         imported_count,
608:         failed_count,
609:         servers: server_results,
610:     })
611: }
612: 
613: /// Starts Claude Code as an MCP server
614: #[tauri::command]
615: pub async fn mcp_serve(app: AppHandle) -> Result<String, String> {
616:     info!("Starting Claude Code as MCP server");
617: 
618:     // Start the server in a separate process
619:     let claude_path = match find_claude_binary(&app) {
620:         Ok(path) => path,
621:         Err(e) => {
622:             error!("Failed to find claude binary: {}", e);
623:             return Err(e.to_string());
624:         }
625:     };
626: 
627:     let mut cmd = create_command_with_env(&claude_path);
628:     cmd.arg("mcp").arg("serve");
629: 
630:     match cmd.spawn() {
631:         Ok(_) => {
632:             info!("Successfully started Claude Code MCP server");
633:             Ok("Claude Code MCP server started".to_string())
634:         }
635:         Err(e) => {
636:             error!("Failed to start MCP server: {}", e);
637:             Err(e.to_string())
638:         }
639:     }
640: }
641: 
642: /// Tests connection to an MCP server
643: #[tauri::command]
644: pub async fn mcp_test_connection(app: AppHandle, name: String) -> Result<String, String> {
645:     info!("Testing connection to MCP server: {}", name);
646: 
647:     // For now, we'll use the get command to test if the server exists
648:     match execute_claude_mcp_command(&app, vec!["get", &name]) {
649:         Ok(_) => Ok(format!("Connection to {} successful", name)),
650:         Err(e) => Err(e.to_string()),
651:     }
652: }
653: 
654: /// Resets project-scoped server approval choices
655: #[tauri::command]
656: pub async fn mcp_reset_project_choices(app: AppHandle) -> Result<String, String> {
657:     info!("Resetting MCP project choices");
658: 
659:     match execute_claude_mcp_command(&app, vec!["reset-project-choices"]) {
660:         Ok(output) => {
661:             info!("Successfully reset MCP project choices");
662:             Ok(output.trim().to_string())
663:         }
664:         Err(e) => {
665:             error!("Failed to reset project choices: {}", e);
666:             Err(e.to_string())
667:         }
668:     }
669: }
670: 
671: /// Gets the status of MCP servers
672: #[tauri::command]
673: pub async fn mcp_get_server_status() -> Result<HashMap<String, ServerStatus>, String> {
674:     info!("Getting MCP server status");
675: 
676:     // TODO: Implement actual status checking
677:     // For now, return empty status
678:     Ok(HashMap::new())
679: }
680: 
681: /// Reads .mcp.json from the current project
682: #[tauri::command]
683: pub async fn mcp_read_project_config(project_path: String) -> Result<MCPProjectConfig, String> {
684:     info!("Reading .mcp.json from project: {}", project_path);
685: 
686:     let mcp_json_path = PathBuf::from(&project_path).join(".mcp.json");
687: 
688:     if !mcp_json_path.exists() {
689:         return Ok(MCPProjectConfig {
690:             mcp_servers: HashMap::new(),
691:         });
692:     }
693: 
694:     match fs::read_to_string(&mcp_json_path) {
695:         Ok(content) => match serde_json::from_str::<MCPProjectConfig>(&content) {
696:             Ok(config) => Ok(config),
697:             Err(e) => {
698:                 error!("Failed to parse .mcp.json: {}", e);
699:                 Err(format!("Failed to parse .mcp.json: {}", e))
700:             }
701:         },
702:         Err(e) => {
703:             error!("Failed to read .mcp.json: {}", e);
704:             Err(format!("Failed to read .mcp.json: {}", e))
705:         }
706:     }
707: }
708: 
709: /// Saves .mcp.json to the current project
710: #[tauri::command]
711: pub async fn mcp_save_project_config(
712:     project_path: String,
713:     config: MCPProjectConfig,
714: ) -> Result<String, String> {
715:     info!("Saving .mcp.json to project: {}", project_path);
716: 
717:     let mcp_json_path = PathBuf::from(&project_path).join(".mcp.json");
718: 
719:     let json_content = serde_json::to_string_pretty(&config)
720:         .map_err(|e| format!("Failed to serialize config: {}", e))?;
721: 
722:     fs::write(&mcp_json_path, json_content)
723:         .map_err(|e| format!("Failed to write .mcp.json: {}", e))?;
724: 
725:     Ok("Project MCP configuration saved".to_string())
726: }
````

## File: src-tauri/src/commands/mod.rs
````rust
1: pub mod agents;
2: pub mod claude;
3: pub mod mcp;
4: pub mod usage;
5: pub mod storage;
6: pub mod slash_commands;
7: pub mod proxy;
````

## File: src-tauri/src/commands/proxy.rs
````rust
  1: use serde::{Deserialize, Serialize};
  2: use tauri::State;
  3: use rusqlite::params;
  4: 
  5: use crate::commands::agents::AgentDb;
  6: 
  7: #[derive(Debug, Serialize, Deserialize, Clone)]
  8: pub struct ProxySettings {
  9:     pub http_proxy: Option<String>,
 10:     pub https_proxy: Option<String>,
 11:     pub no_proxy: Option<String>,
 12:     pub all_proxy: Option<String>,
 13:     pub enabled: bool,
 14: }
 15: 
 16: impl Default for ProxySettings {
 17:     fn default() -> Self {
 18:         Self {
 19:             http_proxy: None,
 20:             https_proxy: None,
 21:             no_proxy: None,
 22:             all_proxy: None,
 23:             enabled: false,
 24:         }
 25:     }
 26: }
 27: 
 28: /// Get proxy settings from the database
 29: #[tauri::command]
 30: pub async fn get_proxy_settings(db: State<'_, AgentDb>) -> Result<ProxySettings, String> {
 31:     let conn = db.0.lock().map_err(|e| e.to_string())?;
 32:     
 33:     let mut settings = ProxySettings::default();
 34:     
 35:     // Query each proxy setting
 36:     let keys = vec![
 37:         ("proxy_enabled", "enabled"),
 38:         ("proxy_http", "http_proxy"),
 39:         ("proxy_https", "https_proxy"),
 40:         ("proxy_no", "no_proxy"),
 41:         ("proxy_all", "all_proxy"),
 42:     ];
 43:     
 44:     for (db_key, field) in keys {
 45:         if let Ok(value) = conn.query_row(
 46:             "SELECT value FROM app_settings WHERE key = ?1",
 47:             params![db_key],
 48:             |row| row.get::<_, String>(0),
 49:         ) {
 50:             match field {
 51:                 "enabled" => settings.enabled = value == "true",
 52:                 "http_proxy" => settings.http_proxy = Some(value).filter(|s| !s.is_empty()),
 53:                 "https_proxy" => settings.https_proxy = Some(value).filter(|s| !s.is_empty()),
 54:                 "no_proxy" => settings.no_proxy = Some(value).filter(|s| !s.is_empty()),
 55:                 "all_proxy" => settings.all_proxy = Some(value).filter(|s| !s.is_empty()),
 56:                 _ => {}
 57:             }
 58:         }
 59:     }
 60:     
 61:     Ok(settings)
 62: }
 63: 
 64: /// Save proxy settings to the database
 65: #[tauri::command]
 66: pub async fn save_proxy_settings(
 67:     db: State<'_, AgentDb>,
 68:     settings: ProxySettings,
 69: ) -> Result<(), String> {
 70:     let conn = db.0.lock().map_err(|e| e.to_string())?;
 71:     
 72:     // Save each setting
 73:     let values = vec![
 74:         ("proxy_enabled", settings.enabled.to_string()),
 75:         ("proxy_http", settings.http_proxy.clone().unwrap_or_default()),
 76:         ("proxy_https", settings.https_proxy.clone().unwrap_or_default()),
 77:         ("proxy_no", settings.no_proxy.clone().unwrap_or_default()),
 78:         ("proxy_all", settings.all_proxy.clone().unwrap_or_default()),
 79:     ];
 80:     
 81:     for (key, value) in values {
 82:         conn.execute(
 83:             "INSERT OR REPLACE INTO app_settings (key, value) VALUES (?1, ?2)",
 84:             params![key, value],
 85:         ).map_err(|e| format!("Failed to save {}: {}", key, e))?;
 86:     }
 87:     
 88:     // Apply the proxy settings immediately to the current process
 89:     apply_proxy_settings(&settings);
 90:     
 91:     Ok(())
 92: }
 93: 
 94: /// Apply proxy settings as environment variables
 95: pub fn apply_proxy_settings(settings: &ProxySettings) {
 96:     log::info!("Applying proxy settings: enabled={}", settings.enabled);
 97:     
 98:     if !settings.enabled {
 99:         // Clear proxy environment variables if disabled
100:         log::info!("Clearing proxy environment variables");
101:         std::env::remove_var("HTTP_PROXY");
102:         std::env::remove_var("HTTPS_PROXY");
103:         std::env::remove_var("NO_PROXY");
104:         std::env::remove_var("ALL_PROXY");
105:         // Also clear lowercase versions
106:         std::env::remove_var("http_proxy");
107:         std::env::remove_var("https_proxy");
108:         std::env::remove_var("no_proxy");
109:         std::env::remove_var("all_proxy");
110:         return;
111:     }
112:     
113:     // Ensure NO_PROXY includes localhost by default
114:     let mut no_proxy_list = vec!["localhost", "127.0.0.1", "::1", "0.0.0.0"];
115:     if let Some(user_no_proxy) = &settings.no_proxy {
116:         if !user_no_proxy.is_empty() {
117:             no_proxy_list.push(user_no_proxy.as_str());
118:         }
119:     }
120:     let no_proxy_value = no_proxy_list.join(",");
121:     
122:     // Set proxy environment variables (uppercase is standard)
123:     if let Some(http_proxy) = &settings.http_proxy {
124:         if !http_proxy.is_empty() {
125:             log::info!("Setting HTTP_PROXY={}", http_proxy);
126:             std::env::set_var("HTTP_PROXY", http_proxy);
127:         }
128:     }
129:     
130:     if let Some(https_proxy) = &settings.https_proxy {
131:         if !https_proxy.is_empty() {
132:             log::info!("Setting HTTPS_PROXY={}", https_proxy);
133:             std::env::set_var("HTTPS_PROXY", https_proxy);
134:         }
135:     }
136:     
137:     // Always set NO_PROXY to include localhost
138:     log::info!("Setting NO_PROXY={}", no_proxy_value);
139:     std::env::set_var("NO_PROXY", &no_proxy_value);
140:     
141:     if let Some(all_proxy) = &settings.all_proxy {
142:         if !all_proxy.is_empty() {
143:             log::info!("Setting ALL_PROXY={}", all_proxy);
144:             std::env::set_var("ALL_PROXY", all_proxy);
145:         }
146:     }
147:     
148:     // Log current proxy environment variables for debugging
149:     log::info!("Current proxy environment variables:");
150:     for (key, value) in std::env::vars() {
151:         if key.contains("PROXY") || key.contains("proxy") {
152:             log::info!("  {}={}", key, value);
153:         }
154:     }
155: }
````

## File: src-tauri/src/commands/slash_commands.rs
````rust
  1: use anyhow::{Context, Result};
  2: use dirs;
  3: use log::{debug, error, info};
  4: use serde::{Deserialize, Serialize};
  5: use std::fs;
  6: use std::path::{Path, PathBuf};
  7: 
  8: /// Represents a custom slash command
  9: #[derive(Debug, Clone, Serialize, Deserialize)]
 10: pub struct SlashCommand {
 11:     /// Unique identifier for the command (derived from file path)
 12:     pub id: String,
 13:     /// Command name (without prefix)
 14:     pub name: String,
 15:     /// Full command with prefix (e.g., "/project:optimize")
 16:     pub full_command: String,
 17:     /// Command scope: "project" or "user"
 18:     pub scope: String,
 19:     /// Optional namespace (e.g., "frontend" in "/project:frontend:component")
 20:     pub namespace: Option<String>,
 21:     /// Path to the markdown file
 22:     pub file_path: String,
 23:     /// Command content (markdown body)
 24:     pub content: String,
 25:     /// Optional description from frontmatter
 26:     pub description: Option<String>,
 27:     /// Allowed tools from frontmatter
 28:     pub allowed_tools: Vec<String>,
 29:     /// Whether the command has bash commands (!)
 30:     pub has_bash_commands: bool,
 31:     /// Whether the command has file references (@)
 32:     pub has_file_references: bool,
 33:     /// Whether the command uses $ARGUMENTS placeholder
 34:     pub accepts_arguments: bool,
 35: }
 36: 
 37: /// YAML frontmatter structure
 38: #[derive(Debug, Deserialize)]
 39: struct CommandFrontmatter {
 40:     #[serde(rename = "allowed-tools")]
 41:     allowed_tools: Option<Vec<String>>,
 42:     description: Option<String>,
 43: }
 44: 
 45: /// Parse a markdown file with optional YAML frontmatter
 46: fn parse_markdown_with_frontmatter(content: &str) -> Result<(Option<CommandFrontmatter>, String)> {
 47:     let lines: Vec<&str> = content.lines().collect();
 48:     
 49:     // Check if the file starts with YAML frontmatter
 50:     if lines.is_empty() || lines[0] != "---" {
 51:         // No frontmatter
 52:         return Ok((None, content.to_string()));
 53:     }
 54:     
 55:     // Find the end of frontmatter
 56:     let mut frontmatter_end = None;
 57:     for (i, line) in lines.iter().enumerate().skip(1) {
 58:         if *line == "---" {
 59:             frontmatter_end = Some(i);
 60:             break;
 61:         }
 62:     }
 63:     
 64:     if let Some(end) = frontmatter_end {
 65:         // Extract frontmatter
 66:         let frontmatter_content = lines[1..end].join("\n");
 67:         let body_content = lines[(end + 1)..].join("\n");
 68:         
 69:         // Parse YAML
 70:         match serde_yaml::from_str::<CommandFrontmatter>(&frontmatter_content) {
 71:             Ok(frontmatter) => Ok((Some(frontmatter), body_content)),
 72:             Err(e) => {
 73:                 debug!("Failed to parse frontmatter: {}", e);
 74:                 // Return full content if frontmatter parsing fails
 75:                 Ok((None, content.to_string()))
 76:             }
 77:         }
 78:     } else {
 79:         // Malformed frontmatter, treat as regular content
 80:         Ok((None, content.to_string()))
 81:     }
 82: }
 83: 
 84: /// Extract command name and namespace from file path
 85: fn extract_command_info(file_path: &Path, base_path: &Path) -> Result<(String, Option<String>)> {
 86:     let relative_path = file_path
 87:         .strip_prefix(base_path)
 88:         .context("Failed to get relative path")?;
 89:     
 90:     // Remove .md extension
 91:     let path_without_ext = relative_path
 92:         .with_extension("")
 93:         .to_string_lossy()
 94:         .to_string();
 95:     
 96:     // Split into components
 97:     let components: Vec<&str> = path_without_ext.split('/').collect();
 98:     
 99:     if components.is_empty() {
100:         return Err(anyhow::anyhow!("Invalid command path"));
101:     }
102:     
103:     if components.len() == 1 {
104:         // No namespace
105:         Ok((components[0].to_string(), None))
106:     } else {
107:         // Last component is the command name, rest is namespace
108:         let command_name = components.last().unwrap().to_string();
109:         let namespace = components[..components.len() - 1].join(":");
110:         Ok((command_name, Some(namespace)))
111:     }
112: }
113: 
114: /// Load a single command from a markdown file
115: fn load_command_from_file(
116:     file_path: &Path,
117:     base_path: &Path,
118:     scope: &str,
119: ) -> Result<SlashCommand> {
120:     debug!("Loading command from: {:?}", file_path);
121:     
122:     // Read file content
123:     let content = fs::read_to_string(file_path)
124:         .context("Failed to read command file")?;
125:     
126:     // Parse frontmatter
127:     let (frontmatter, body) = parse_markdown_with_frontmatter(&content)?;
128:     
129:     // Extract command info
130:     let (name, namespace) = extract_command_info(file_path, base_path)?;
131:     
132:     // Build full command (no scope prefix, just /command or /namespace:command)
133:     let full_command = match &namespace {
134:         Some(ns) => format!("/{ns}:{name}"),
135:         None => format!("/{name}"),
136:     };
137:     
138:     // Generate unique ID
139:     let id = format!("{}-{}", scope, file_path.to_string_lossy().replace('/', "-"));
140:     
141:     // Check for special content
142:     let has_bash_commands = body.contains("!`");
143:     let has_file_references = body.contains('@');
144:     let accepts_arguments = body.contains("$ARGUMENTS");
145:     
146:     // Extract metadata from frontmatter
147:     let (description, allowed_tools) = if let Some(fm) = frontmatter {
148:         (fm.description, fm.allowed_tools.unwrap_or_default())
149:     } else {
150:         (None, Vec::new())
151:     };
152:     
153:     Ok(SlashCommand {
154:         id,
155:         name,
156:         full_command,
157:         scope: scope.to_string(),
158:         namespace,
159:         file_path: file_path.to_string_lossy().to_string(),
160:         content: body,
161:         description,
162:         allowed_tools,
163:         has_bash_commands,
164:         has_file_references,
165:         accepts_arguments,
166:     })
167: }
168: 
169: /// Recursively find all markdown files in a directory
170: fn find_markdown_files(dir: &Path, files: &mut Vec<PathBuf>) -> Result<()> {
171:     if !dir.exists() {
172:         return Ok(());
173:     }
174:     
175:     for entry in fs::read_dir(dir)? {
176:         let entry = entry?;
177:         let path = entry.path();
178:         
179:         // Skip hidden files/directories
180:         if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
181:             if name.starts_with('.') {
182:                 continue;
183:             }
184:         }
185:         
186:         if path.is_dir() {
187:             find_markdown_files(&path, files)?;
188:         } else if path.is_file() {
189:             if let Some(ext) = path.extension() {
190:                 if ext == "md" {
191:                     files.push(path);
192:                 }
193:             }
194:         }
195:     }
196:     
197:     Ok(())
198: }
199: 
200: /// Create default/built-in slash commands
201: fn create_default_commands() -> Vec<SlashCommand> {
202:     vec![
203:         SlashCommand {
204:             id: "default-add-dir".to_string(),
205:             name: "add-dir".to_string(),
206:             full_command: "/add-dir".to_string(),
207:             scope: "default".to_string(),
208:             namespace: None,
209:             file_path: "".to_string(),
210:             content: "Add additional working directories".to_string(),
211:             description: Some("Add additional working directories".to_string()),
212:             allowed_tools: vec![],
213:             has_bash_commands: false,
214:             has_file_references: false,
215:             accepts_arguments: false,
216:         },
217:         SlashCommand {
218:             id: "default-init".to_string(),
219:             name: "init".to_string(),
220:             full_command: "/init".to_string(),
221:             scope: "default".to_string(),
222:             namespace: None,
223:             file_path: "".to_string(),
224:             content: "Initialize project with CLAUDE.md guide".to_string(),
225:             description: Some("Initialize project with CLAUDE.md guide".to_string()),
226:             allowed_tools: vec![],
227:             has_bash_commands: false,
228:             has_file_references: false,
229:             accepts_arguments: false,
230:         },
231:         SlashCommand {
232:             id: "default-review".to_string(),
233:             name: "review".to_string(),
234:             full_command: "/review".to_string(),
235:             scope: "default".to_string(),
236:             namespace: None,
237:             file_path: "".to_string(),
238:             content: "Request code review".to_string(),
239:             description: Some("Request code review".to_string()),
240:             allowed_tools: vec![],
241:             has_bash_commands: false,
242:             has_file_references: false,
243:             accepts_arguments: false,
244:         },
245:     ]
246: }
247: 
248: /// Discover all custom slash commands
249: #[tauri::command]
250: pub async fn slash_commands_list(
251:     project_path: Option<String>,
252: ) -> Result<Vec<SlashCommand>, String> {
253:     info!("Discovering slash commands");
254:     let mut commands = Vec::new();
255:     
256:     // Add default commands
257:     commands.extend(create_default_commands());
258:     
259:     // Load project commands if project path is provided
260:     if let Some(proj_path) = project_path {
261:         let project_commands_dir = PathBuf::from(&proj_path).join(".claude").join("commands");
262:         if project_commands_dir.exists() {
263:             debug!("Scanning project commands at: {:?}", project_commands_dir);
264:             
265:             let mut md_files = Vec::new();
266:             if let Err(e) = find_markdown_files(&project_commands_dir, &mut md_files) {
267:                 error!("Failed to find project command files: {}", e);
268:             } else {
269:                 for file_path in md_files {
270:                     match load_command_from_file(&file_path, &project_commands_dir, "project") {
271:                         Ok(cmd) => {
272:                             debug!("Loaded project command: {}", cmd.full_command);
273:                             commands.push(cmd);
274:                         }
275:                         Err(e) => {
276:                             error!("Failed to load command from {:?}: {}", file_path, e);
277:                         }
278:                     }
279:                 }
280:             }
281:         }
282:     }
283:     
284:     // Load user commands
285:     if let Some(home_dir) = dirs::home_dir() {
286:         let user_commands_dir = home_dir.join(".claude").join("commands");
287:         if user_commands_dir.exists() {
288:             debug!("Scanning user commands at: {:?}", user_commands_dir);
289:             
290:             let mut md_files = Vec::new();
291:             if let Err(e) = find_markdown_files(&user_commands_dir, &mut md_files) {
292:                 error!("Failed to find user command files: {}", e);
293:             } else {
294:                 for file_path in md_files {
295:                     match load_command_from_file(&file_path, &user_commands_dir, "user") {
296:                         Ok(cmd) => {
297:                             debug!("Loaded user command: {}", cmd.full_command);
298:                             commands.push(cmd);
299:                         }
300:                         Err(e) => {
301:                             error!("Failed to load command from {:?}: {}", file_path, e);
302:                         }
303:                     }
304:                 }
305:             }
306:         }
307:     }
308:     
309:     info!("Found {} slash commands", commands.len());
310:     Ok(commands)
311: }
312: 
313: /// Get a single slash command by ID
314: #[tauri::command]
315: pub async fn slash_command_get(command_id: String) -> Result<SlashCommand, String> {
316:     debug!("Getting slash command: {}", command_id);
317:     
318:     // Parse the ID to determine scope and reconstruct file path
319:     let parts: Vec<&str> = command_id.split('-').collect();
320:     if parts.len() < 2 {
321:         return Err("Invalid command ID".to_string());
322:     }
323:     
324:     // The actual implementation would need to reconstruct the path and reload the command
325:     // For now, we'll list all commands and find the matching one
326:     let commands = slash_commands_list(None).await?;
327:     
328:     commands
329:         .into_iter()
330:         .find(|cmd| cmd.id == command_id)
331:         .ok_or_else(|| format!("Command not found: {}", command_id))
332: }
333: 
334: /// Create or update a slash command
335: #[tauri::command]
336: pub async fn slash_command_save(
337:     scope: String,
338:     name: String,
339:     namespace: Option<String>,
340:     content: String,
341:     description: Option<String>,
342:     allowed_tools: Vec<String>,
343:     project_path: Option<String>,
344: ) -> Result<SlashCommand, String> {
345:     info!("Saving slash command: {} in scope: {}", name, scope);
346:     
347:     // Validate inputs
348:     if name.is_empty() {
349:         return Err("Command name cannot be empty".to_string());
350:     }
351:     
352:     if !["project", "user"].contains(&scope.as_str()) {
353:         return Err("Invalid scope. Must be 'project' or 'user'".to_string());
354:     }
355:     
356:     // Determine base directory
357:     let base_dir = if scope == "project" {
358:         if let Some(proj_path) = project_path {
359:             PathBuf::from(proj_path).join(".claude").join("commands")
360:         } else {
361:             return Err("Project path required for project scope".to_string());
362:         }
363:     } else {
364:         dirs::home_dir()
365:             .ok_or_else(|| "Could not find home directory".to_string())?
366:             .join(".claude")
367:             .join("commands")
368:     };
369:     
370:     // Build file path
371:     let mut file_path = base_dir.clone();
372:     if let Some(ns) = &namespace {
373:         for component in ns.split(':') {
374:             file_path = file_path.join(component);
375:         }
376:     }
377:     
378:     // Create directories if needed
379:     fs::create_dir_all(&file_path)
380:         .map_err(|e| format!("Failed to create directories: {}", e))?;
381:     
382:     // Add filename
383:     file_path = file_path.join(format!("{}.md", name));
384:     
385:     // Build content with frontmatter
386:     let mut full_content = String::new();
387:     
388:     // Add frontmatter if we have metadata
389:     if description.is_some() || !allowed_tools.is_empty() {
390:         full_content.push_str("---\n");
391:         
392:         if let Some(desc) = &description {
393:             full_content.push_str(&format!("description: {}\n", desc));
394:         }
395:         
396:         if !allowed_tools.is_empty() {
397:             full_content.push_str("allowed-tools:\n");
398:             for tool in &allowed_tools {
399:                 full_content.push_str(&format!("  - {}\n", tool));
400:             }
401:         }
402:         
403:         full_content.push_str("---\n\n");
404:     }
405:     
406:     full_content.push_str(&content);
407:     
408:     // Write file
409:     fs::write(&file_path, &full_content)
410:         .map_err(|e| format!("Failed to write command file: {}", e))?;
411:     
412:     // Load and return the saved command
413:     load_command_from_file(&file_path, &base_dir, &scope)
414:         .map_err(|e| format!("Failed to load saved command: {}", e))
415: }
416: 
417: /// Delete a slash command
418: #[tauri::command]
419: pub async fn slash_command_delete(command_id: String, project_path: Option<String>) -> Result<String, String> {
420:     info!("Deleting slash command: {}", command_id);
421:     
422:     // First, we need to determine if this is a project command by parsing the ID
423:     let is_project_command = command_id.starts_with("project-");
424:     
425:     // If it's a project command and we don't have a project path, error out
426:     if is_project_command && project_path.is_none() {
427:         return Err("Project path required to delete project commands".to_string());
428:     }
429:     
430:     // List all commands (including project commands if applicable)
431:     let commands = slash_commands_list(project_path).await?;
432:     
433:     // Find the command by ID
434:     let command = commands
435:         .into_iter()
436:         .find(|cmd| cmd.id == command_id)
437:         .ok_or_else(|| format!("Command not found: {}", command_id))?;
438:     
439:     // Delete the file
440:     fs::remove_file(&command.file_path)
441:         .map_err(|e| format!("Failed to delete command file: {}", e))?;
442:     
443:     // Clean up empty directories
444:     if let Some(parent) = Path::new(&command.file_path).parent() {
445:         let _ = remove_empty_dirs(parent);
446:     }
447:     
448:     Ok(format!("Deleted command: {}", command.full_command))
449: }
450: 
451: /// Remove empty directories recursively
452: fn remove_empty_dirs(dir: &Path) -> Result<()> {
453:     if !dir.exists() {
454:         return Ok(());
455:     }
456:     
457:     // Check if directory is empty
458:     let is_empty = fs::read_dir(dir)?.next().is_none();
459:     
460:     if is_empty {
461:         fs::remove_dir(dir)?;
462:         
463:         // Try to remove parent if it's also empty
464:         if let Some(parent) = dir.parent() {
465:             let _ = remove_empty_dirs(parent);
466:         }
467:     }
468:     
469:     Ok(())
470: }
````

## File: src-tauri/src/commands/storage.rs
````rust
  1: use anyhow::Result;
  2: use rusqlite::{params, Connection, Result as SqliteResult, types::ValueRef};
  3: use serde::{Deserialize, Serialize};
  4: use serde_json::{Map, Value as JsonValue};
  5: use std::collections::HashMap;
  6: use tauri::{AppHandle, Manager, State};
  7: use super::agents::AgentDb;
  8: 
  9: /// Represents metadata about a database table
 10: #[derive(Debug, Serialize, Deserialize, Clone)]
 11: pub struct TableInfo {
 12:     pub name: String,
 13:     pub row_count: i64,
 14:     pub columns: Vec<ColumnInfo>,
 15: }
 16: 
 17: /// Represents metadata about a table column
 18: #[derive(Debug, Serialize, Deserialize, Clone)]
 19: pub struct ColumnInfo {
 20:     pub cid: i32,
 21:     pub name: String,
 22:     pub type_name: String,
 23:     pub notnull: bool,
 24:     pub dflt_value: Option<String>,
 25:     pub pk: bool,
 26: }
 27: 
 28: /// Represents a page of table data
 29: #[derive(Debug, Serialize, Deserialize, Clone)]
 30: pub struct TableData {
 31:     pub table_name: String,
 32:     pub columns: Vec<ColumnInfo>,
 33:     pub rows: Vec<Map<String, JsonValue>>,
 34:     pub total_rows: i64,
 35:     pub page: i64,
 36:     pub page_size: i64,
 37:     pub total_pages: i64,
 38: }
 39: 
 40: /// SQL query result
 41: #[derive(Debug, Serialize, Deserialize, Clone)]
 42: pub struct QueryResult {
 43:     pub columns: Vec<String>,
 44:     pub rows: Vec<Vec<JsonValue>>,
 45:     pub rows_affected: Option<i64>,
 46:     pub last_insert_rowid: Option<i64>,
 47: }
 48: 
 49: /// List all tables in the database
 50: #[tauri::command]
 51: pub async fn storage_list_tables(db: State<'_, AgentDb>) -> Result<Vec<TableInfo>, String> {
 52:     let conn = db.0.lock().map_err(|e| e.to_string())?;
 53:     
 54:     // Query for all tables
 55:     let mut stmt = conn
 56:         .prepare("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' ORDER BY name")
 57:         .map_err(|e| e.to_string())?;
 58:     
 59:     let table_names: Vec<String> = stmt
 60:         .query_map([], |row| row.get(0))
 61:         .map_err(|e| e.to_string())?
 62:         .collect::<SqliteResult<Vec<_>>>()
 63:         .map_err(|e| e.to_string())?;
 64:     
 65:     drop(stmt);
 66:     
 67:     let mut tables = Vec::new();
 68:     
 69:     for table_name in table_names {
 70:         // Get row count
 71:         let row_count: i64 = conn
 72:             .query_row(
 73:                 &format!("SELECT COUNT(*) FROM {}", table_name),
 74:                 [],
 75:                 |row| row.get(0),
 76:             )
 77:             .unwrap_or(0);
 78:         
 79:         // Get column information
 80:         let mut pragma_stmt = conn
 81:             .prepare(&format!("PRAGMA table_info({})", table_name))
 82:             .map_err(|e| e.to_string())?;
 83:         
 84:         let columns: Vec<ColumnInfo> = pragma_stmt
 85:             .query_map([], |row| {
 86:                 Ok(ColumnInfo {
 87:                     cid: row.get(0)?,
 88:                     name: row.get(1)?,
 89:                     type_name: row.get(2)?,
 90:                     notnull: row.get::<_, i32>(3)? != 0,
 91:                     dflt_value: row.get(4)?,
 92:                     pk: row.get::<_, i32>(5)? != 0,
 93:                 })
 94:             })
 95:             .map_err(|e| e.to_string())?
 96:             .collect::<SqliteResult<Vec<_>>>()
 97:             .map_err(|e| e.to_string())?;
 98:         
 99:         tables.push(TableInfo {
100:             name: table_name,
101:             row_count,
102:             columns,
103:         });
104:     }
105:     
106:     Ok(tables)
107: }
108: 
109: /// Read table data with pagination
110: #[tauri::command]
111: #[allow(non_snake_case)]
112: pub async fn storage_read_table(
113:     db: State<'_, AgentDb>,
114:     tableName: String,
115:     page: i64,
116:     pageSize: i64,
117:     searchQuery: Option<String>,
118: ) -> Result<TableData, String> {
119:     let conn = db.0.lock().map_err(|e| e.to_string())?;
120:     
121:     // Validate table name to prevent SQL injection
122:     if !is_valid_table_name(&conn, &tableName)? {
123:         return Err("Invalid table name".to_string());
124:     }
125:     
126:     // Get column information
127:     let mut pragma_stmt = conn
128:         .prepare(&format!("PRAGMA table_info({})", tableName))
129:         .map_err(|e| e.to_string())?;
130:     
131:     let columns: Vec<ColumnInfo> = pragma_stmt
132:         .query_map([], |row| {
133:             Ok(ColumnInfo {
134:                 cid: row.get(0)?,
135:                 name: row.get(1)?,
136:                 type_name: row.get(2)?,
137:                 notnull: row.get::<_, i32>(3)? != 0,
138:                 dflt_value: row.get(4)?,
139:                 pk: row.get::<_, i32>(5)? != 0,
140:             })
141:         })
142:         .map_err(|e| e.to_string())?
143:         .collect::<SqliteResult<Vec<_>>>()
144:         .map_err(|e| e.to_string())?;
145:     
146:     drop(pragma_stmt);
147:     
148:     // Build query with optional search
149:     let (query, count_query) = if let Some(search) = &searchQuery {
150:         // Create search conditions for all text columns
151:         let search_conditions: Vec<String> = columns
152:             .iter()
153:             .filter(|col| col.type_name.contains("TEXT") || col.type_name.contains("VARCHAR"))
154:             .map(|col| format!("{} LIKE '%{}%'", col.name, search.replace("'", "''")))
155:             .collect();
156:         
157:         if search_conditions.is_empty() {
158:             (
159:                 format!("SELECT * FROM {} LIMIT ? OFFSET ?", tableName),
160:                 format!("SELECT COUNT(*) FROM {}", tableName),
161:             )
162:         } else {
163:             let where_clause = search_conditions.join(" OR ");
164:             (
165:                 format!("SELECT * FROM {} WHERE {} LIMIT ? OFFSET ?", tableName, where_clause),
166:                 format!("SELECT COUNT(*) FROM {} WHERE {}", tableName, where_clause),
167:             )
168:         }
169:     } else {
170:         (
171:             format!("SELECT * FROM {} LIMIT ? OFFSET ?", tableName),
172:             format!("SELECT COUNT(*) FROM {}", tableName),
173:         )
174:     };
175:     
176:     // Get total row count
177:     let total_rows: i64 = conn
178:         .query_row(&count_query, [], |row| row.get(0))
179:         .unwrap_or(0);
180:     
181:     // Calculate pagination
182:     let offset = (page - 1) * pageSize;
183:     let total_pages = (total_rows as f64 / pageSize as f64).ceil() as i64;
184:     
185:     // Query data
186:     let mut data_stmt = conn
187:         .prepare(&query)
188:         .map_err(|e| e.to_string())?;
189:     
190:     let rows: Vec<Map<String, JsonValue>> = data_stmt
191:         .query_map(params![pageSize, offset], |row| {
192:             let mut row_map = Map::new();
193:             
194:             for (idx, col) in columns.iter().enumerate() {
195:                 let value = match row.get_ref(idx)? {
196:                     ValueRef::Null => JsonValue::Null,
197:                     ValueRef::Integer(i) => JsonValue::Number(serde_json::Number::from(i)),
198:                     ValueRef::Real(f) => {
199:                         if let Some(n) = serde_json::Number::from_f64(f) {
200:                             JsonValue::Number(n)
201:                         } else {
202:                             JsonValue::String(f.to_string())
203:                         }
204:                     }
205:                     ValueRef::Text(s) => JsonValue::String(String::from_utf8_lossy(s).to_string()),
206:                     ValueRef::Blob(b) => JsonValue::String(base64::Engine::encode(&base64::engine::general_purpose::STANDARD, b)),
207:                 };
208:                 row_map.insert(col.name.clone(), value);
209:             }
210:             
211:             Ok(row_map)
212:         })
213:         .map_err(|e| e.to_string())?
214:         .collect::<SqliteResult<Vec<_>>>()
215:         .map_err(|e| e.to_string())?;
216:     
217:     Ok(TableData {
218:         table_name: tableName,
219:         columns,
220:         rows,
221:         total_rows,
222:         page,
223:         page_size: pageSize,
224:         total_pages,
225:     })
226: }
227: 
228: /// Update a row in a table
229: #[tauri::command]
230: #[allow(non_snake_case)]
231: pub async fn storage_update_row(
232:     db: State<'_, AgentDb>,
233:     tableName: String,
234:     primaryKeyValues: HashMap<String, JsonValue>,
235:     updates: HashMap<String, JsonValue>,
236: ) -> Result<(), String> {
237:     let conn = db.0.lock().map_err(|e| e.to_string())?;
238:     
239:     // Validate table name
240:     if !is_valid_table_name(&conn, &tableName)? {
241:         return Err("Invalid table name".to_string());
242:     }
243:     
244:     // Build UPDATE query
245:     let set_clauses: Vec<String> = updates
246:         .keys()
247:         .enumerate()
248:         .map(|(idx, key)| format!("{} = ?{}", key, idx + 1))
249:         .collect();
250:     
251:     let where_clauses: Vec<String> = primaryKeyValues
252:         .keys()
253:         .enumerate()
254:         .map(|(idx, key)| format!("{} = ?{}", key, idx + updates.len() + 1))
255:         .collect();
256:     
257:     let query = format!(
258:         "UPDATE {} SET {} WHERE {}",
259:         tableName,
260:         set_clauses.join(", "),
261:         where_clauses.join(" AND ")
262:     );
263:     
264:     // Prepare parameters
265:     let mut params: Vec<Box<dyn rusqlite::ToSql>> = Vec::new();
266:     
267:     // Add update values
268:     for value in updates.values() {
269:         params.push(json_to_sql_value(value)?);
270:     }
271:     
272:     // Add where clause values
273:     for value in primaryKeyValues.values() {
274:         params.push(json_to_sql_value(value)?);
275:     }
276:     
277:     // Execute update
278:     conn.execute(&query, rusqlite::params_from_iter(params.iter().map(|p| p.as_ref())))
279:         .map_err(|e| format!("Failed to update row: {}", e))?;
280:     
281:     Ok(())
282: }
283: 
284: /// Delete a row from a table
285: #[tauri::command]
286: #[allow(non_snake_case)]
287: pub async fn storage_delete_row(
288:     db: State<'_, AgentDb>,
289:     tableName: String,
290:     primaryKeyValues: HashMap<String, JsonValue>,
291: ) -> Result<(), String> {
292:     let conn = db.0.lock().map_err(|e| e.to_string())?;
293:     
294:     // Validate table name
295:     if !is_valid_table_name(&conn, &tableName)? {
296:         return Err("Invalid table name".to_string());
297:     }
298:     
299:     // Build DELETE query
300:     let where_clauses: Vec<String> = primaryKeyValues
301:         .keys()
302:         .enumerate()
303:         .map(|(idx, key)| format!("{} = ?{}", key, idx + 1))
304:         .collect();
305:     
306:     let query = format!(
307:         "DELETE FROM {} WHERE {}",
308:         tableName,
309:         where_clauses.join(" AND ")
310:     );
311:     
312:     // Prepare parameters
313:     let params: Vec<Box<dyn rusqlite::ToSql>> = primaryKeyValues
314:         .values()
315:         .map(json_to_sql_value)
316:         .collect::<Result<Vec<_>, _>>()?;
317:     
318:     // Execute delete
319:     conn.execute(&query, rusqlite::params_from_iter(params.iter().map(|p| p.as_ref())))
320:         .map_err(|e| format!("Failed to delete row: {}", e))?;
321:     
322:     Ok(())
323: }
324: 
325: /// Insert a new row into a table
326: #[tauri::command]
327: #[allow(non_snake_case)]
328: pub async fn storage_insert_row(
329:     db: State<'_, AgentDb>,
330:     tableName: String,
331:     values: HashMap<String, JsonValue>,
332: ) -> Result<i64, String> {
333:     let conn = db.0.lock().map_err(|e| e.to_string())?;
334:     
335:     // Validate table name
336:     if !is_valid_table_name(&conn, &tableName)? {
337:         return Err("Invalid table name".to_string());
338:     }
339:     
340:     // Build INSERT query
341:     let columns: Vec<&String> = values.keys().collect();
342:     let placeholders: Vec<String> = (1..=columns.len())
343:         .map(|i| format!("?{}", i))
344:         .collect();
345:     
346:     let query = format!(
347:         "INSERT INTO {} ({}) VALUES ({})",
348:         tableName,
349:         columns.iter().map(|c| c.as_str()).collect::<Vec<_>>().join(", "),
350:         placeholders.join(", ")
351:     );
352:     
353:     // Prepare parameters
354:     let params: Vec<Box<dyn rusqlite::ToSql>> = values
355:         .values()
356:         .map(json_to_sql_value)
357:         .collect::<Result<Vec<_>, _>>()?;
358:     
359:     // Execute insert
360:     conn.execute(&query, rusqlite::params_from_iter(params.iter().map(|p| p.as_ref())))
361:         .map_err(|e| format!("Failed to insert row: {}", e))?;
362:     
363:     Ok(conn.last_insert_rowid())
364: }
365: 
366: /// Execute a raw SQL query
367: #[tauri::command]
368: pub async fn storage_execute_sql(
369:     db: State<'_, AgentDb>,
370:     query: String,
371: ) -> Result<QueryResult, String> {
372:     let conn = db.0.lock().map_err(|e| e.to_string())?;
373:     
374:     // Check if it's a SELECT query
375:     let is_select = query.trim().to_uppercase().starts_with("SELECT");
376:     
377:     if is_select {
378:         // Handle SELECT queries
379:         let mut stmt = conn.prepare(&query).map_err(|e| e.to_string())?;
380:         let column_count = stmt.column_count();
381:         
382:         // Get column names
383:         let columns: Vec<String> = (0..column_count)
384:             .map(|i| stmt.column_name(i).unwrap_or("").to_string())
385:             .collect();
386:         
387:         // Execute query and collect results
388:         let rows: Vec<Vec<JsonValue>> = stmt
389:             .query_map([], |row| {
390:                 let mut row_values = Vec::new();
391:                 for i in 0..column_count {
392:                     let value = match row.get_ref(i)? {
393:                         ValueRef::Null => JsonValue::Null,
394:                         ValueRef::Integer(n) => JsonValue::Number(serde_json::Number::from(n)),
395:                         ValueRef::Real(f) => {
396:                             if let Some(n) = serde_json::Number::from_f64(f) {
397:                                 JsonValue::Number(n)
398:                             } else {
399:                                 JsonValue::String(f.to_string())
400:                             }
401:                         }
402:                         ValueRef::Text(s) => JsonValue::String(String::from_utf8_lossy(s).to_string()),
403:                         ValueRef::Blob(b) => JsonValue::String(base64::Engine::encode(&base64::engine::general_purpose::STANDARD, b)),
404:                     };
405:                     row_values.push(value);
406:                 }
407:                 Ok(row_values)
408:             })
409:             .map_err(|e| e.to_string())?
410:             .collect::<SqliteResult<Vec<_>>>()
411:             .map_err(|e| e.to_string())?;
412:         
413:         Ok(QueryResult {
414:             columns,
415:             rows,
416:             rows_affected: None,
417:             last_insert_rowid: None,
418:         })
419:     } else {
420:         // Handle non-SELECT queries (INSERT, UPDATE, DELETE, etc.)
421:         let rows_affected = conn.execute(&query, []).map_err(|e| e.to_string())?;
422:         
423:         Ok(QueryResult {
424:             columns: vec![],
425:             rows: vec![],
426:             rows_affected: Some(rows_affected as i64),
427:             last_insert_rowid: Some(conn.last_insert_rowid()),
428:         })
429:     }
430: }
431: 
432: /// Reset the entire database (with confirmation)
433: #[tauri::command]
434: pub async fn storage_reset_database(app: AppHandle) -> Result<(), String> {
435:     {
436:         // Drop all existing tables within a scoped block
437:         let db_state = app.state::<AgentDb>();
438:         let conn = db_state.0.lock()
439:             .map_err(|e| e.to_string())?;
440:         
441:         // Disable foreign key constraints temporarily to allow dropping tables
442:         conn.execute("PRAGMA foreign_keys = OFF", [])
443:             .map_err(|e| format!("Failed to disable foreign keys: {}", e))?;
444:         
445:         // Drop tables - order doesn't matter with foreign keys disabled
446:         conn.execute("DROP TABLE IF EXISTS agent_runs", [])
447:             .map_err(|e| format!("Failed to drop agent_runs table: {}", e))?;
448:         conn.execute("DROP TABLE IF EXISTS agents", [])
449:             .map_err(|e| format!("Failed to drop agents table: {}", e))?;
450:         conn.execute("DROP TABLE IF EXISTS app_settings", [])
451:             .map_err(|e| format!("Failed to drop app_settings table: {}", e))?;
452:         
453:         // Re-enable foreign key constraints
454:         conn.execute("PRAGMA foreign_keys = ON", [])
455:             .map_err(|e| format!("Failed to re-enable foreign keys: {}", e))?;
456:         
457:         // Connection is automatically dropped at end of scope
458:     }
459:     
460:     // Re-initialize the database which will recreate all tables empty
461:     let new_conn = init_database(&app).map_err(|e| format!("Failed to reset database: {}", e))?;
462:     
463:     // Update the managed state with the new connection
464:     {
465:         let db_state = app.state::<AgentDb>();
466:         let mut conn_guard = db_state.0.lock()
467:             .map_err(|e| e.to_string())?;
468:         *conn_guard = new_conn;
469:     }
470:     
471:     // Run VACUUM to optimize the database
472:     {
473:         let db_state = app.state::<AgentDb>();
474:         let conn = db_state.0.lock()
475:             .map_err(|e| e.to_string())?;
476:         conn.execute("VACUUM", [])
477:             .map_err(|e| e.to_string())?;
478:     }
479:     
480:     Ok(())
481: }
482: 
483: /// Helper function to validate table name exists
484: fn is_valid_table_name(conn: &Connection, table_name: &str) -> Result<bool, String> {
485:     let count: i64 = conn
486:         .query_row(
487:             "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name=?",
488:             params![table_name],
489:             |row| row.get(0),
490:         )
491:         .map_err(|e| e.to_string())?;
492:     
493:     Ok(count > 0)
494: }
495: 
496: /// Helper function to convert JSON value to SQL value
497: fn json_to_sql_value(value: &JsonValue) -> Result<Box<dyn rusqlite::ToSql>, String> {
498:     match value {
499:         JsonValue::Null => Ok(Box::new(rusqlite::types::Null)),
500:         JsonValue::Bool(b) => Ok(Box::new(*b)),
501:         JsonValue::Number(n) => {
502:             if let Some(i) = n.as_i64() {
503:                 Ok(Box::new(i))
504:             } else if let Some(f) = n.as_f64() {
505:                 Ok(Box::new(f))
506:             } else {
507:                 Err("Invalid number value".to_string())
508:             }
509:         }
510:         JsonValue::String(s) => Ok(Box::new(s.clone())),
511:         _ => Err("Unsupported value type".to_string()),
512:     }
513: }
514: 
515: /// Initialize the agents database (re-exported from agents module)
516: use super::agents::init_database;
````

## File: src-tauri/src/commands/usage.rs
````rust
  1: use chrono::{DateTime, Local, NaiveDate};
  2: use serde::{Deserialize, Serialize};
  3: use serde_json;
  4: use std::collections::{HashMap, HashSet};
  5: use std::fs;
  6: use std::path::PathBuf;
  7: use tauri::command;
  8: 
  9: #[derive(Debug, Serialize, Deserialize, Clone)]
 10: pub struct UsageEntry {
 11:     timestamp: String,
 12:     model: String,
 13:     input_tokens: u64,
 14:     output_tokens: u64,
 15:     cache_creation_tokens: u64,
 16:     cache_read_tokens: u64,
 17:     cost: f64,
 18:     session_id: String,
 19:     project_path: String,
 20: }
 21: 
 22: #[derive(Debug, Serialize, Deserialize)]
 23: pub struct UsageStats {
 24:     total_cost: f64,
 25:     total_tokens: u64,
 26:     total_input_tokens: u64,
 27:     total_output_tokens: u64,
 28:     total_cache_creation_tokens: u64,
 29:     total_cache_read_tokens: u64,
 30:     total_sessions: u64,
 31:     by_model: Vec<ModelUsage>,
 32:     by_date: Vec<DailyUsage>,
 33:     by_project: Vec<ProjectUsage>,
 34: }
 35: 
 36: #[derive(Debug, Serialize, Deserialize)]
 37: pub struct ModelUsage {
 38:     model: String,
 39:     total_cost: f64,
 40:     total_tokens: u64,
 41:     input_tokens: u64,
 42:     output_tokens: u64,
 43:     cache_creation_tokens: u64,
 44:     cache_read_tokens: u64,
 45:     session_count: u64,
 46: }
 47: 
 48: #[derive(Debug, Serialize, Deserialize)]
 49: pub struct DailyUsage {
 50:     date: String,
 51:     total_cost: f64,
 52:     total_tokens: u64,
 53:     models_used: Vec<String>,
 54: }
 55: 
 56: #[derive(Debug, Serialize, Deserialize)]
 57: pub struct ProjectUsage {
 58:     project_path: String,
 59:     project_name: String,
 60:     total_cost: f64,
 61:     total_tokens: u64,
 62:     session_count: u64,
 63:     last_used: String,
 64: }
 65: 
 66: // Claude 4 pricing constants (per million tokens)
 67: const OPUS_4_INPUT_PRICE: f64 = 15.0;
 68: const OPUS_4_OUTPUT_PRICE: f64 = 75.0;
 69: const OPUS_4_CACHE_WRITE_PRICE: f64 = 18.75;
 70: const OPUS_4_CACHE_READ_PRICE: f64 = 1.50;
 71: 
 72: const SONNET_4_INPUT_PRICE: f64 = 3.0;
 73: const SONNET_4_OUTPUT_PRICE: f64 = 15.0;
 74: const SONNET_4_CACHE_WRITE_PRICE: f64 = 3.75;
 75: const SONNET_4_CACHE_READ_PRICE: f64 = 0.30;
 76: 
 77: #[derive(Debug, Deserialize)]
 78: struct JsonlEntry {
 79:     timestamp: String,
 80:     message: Option<MessageData>,
 81:     #[serde(rename = "sessionId")]
 82:     session_id: Option<String>,
 83:     #[serde(rename = "requestId")]
 84:     request_id: Option<String>,
 85:     #[serde(rename = "costUSD")]
 86:     cost_usd: Option<f64>,
 87: }
 88: 
 89: #[derive(Debug, Deserialize)]
 90: struct MessageData {
 91:     id: Option<String>,
 92:     model: Option<String>,
 93:     usage: Option<UsageData>,
 94: }
 95: 
 96: #[derive(Debug, Deserialize)]
 97: struct UsageData {
 98:     input_tokens: Option<u64>,
 99:     output_tokens: Option<u64>,
100:     cache_creation_input_tokens: Option<u64>,
101:     cache_read_input_tokens: Option<u64>,
102: }
103: 
104: fn calculate_cost(model: &str, usage: &UsageData) -> f64 {
105:     let input_tokens = usage.input_tokens.unwrap_or(0) as f64;
106:     let output_tokens = usage.output_tokens.unwrap_or(0) as f64;
107:     let cache_creation_tokens = usage.cache_creation_input_tokens.unwrap_or(0) as f64;
108:     let cache_read_tokens = usage.cache_read_input_tokens.unwrap_or(0) as f64;
109: 
110:     // Calculate cost based on model
111:     let (input_price, output_price, cache_write_price, cache_read_price) =
112:         if model.contains("opus-4") || model.contains("claude-opus-4") {
113:             (
114:                 OPUS_4_INPUT_PRICE,
115:                 OPUS_4_OUTPUT_PRICE,
116:                 OPUS_4_CACHE_WRITE_PRICE,
117:                 OPUS_4_CACHE_READ_PRICE,
118:             )
119:         } else if model.contains("sonnet-4") || model.contains("claude-sonnet-4") {
120:             (
121:                 SONNET_4_INPUT_PRICE,
122:                 SONNET_4_OUTPUT_PRICE,
123:                 SONNET_4_CACHE_WRITE_PRICE,
124:                 SONNET_4_CACHE_READ_PRICE,
125:             )
126:         } else {
127:             // Return 0 for unknown models to avoid incorrect cost estimations.
128:             (0.0, 0.0, 0.0, 0.0)
129:         };
130: 
131:     // Calculate cost (prices are per million tokens)
132:     let cost = (input_tokens * input_price / 1_000_000.0)
133:         + (output_tokens * output_price / 1_000_000.0)
134:         + (cache_creation_tokens * cache_write_price / 1_000_000.0)
135:         + (cache_read_tokens * cache_read_price / 1_000_000.0);
136: 
137:     cost
138: }
139: 
140: fn parse_jsonl_file(
141:     path: &PathBuf,
142:     encoded_project_name: &str,
143:     processed_hashes: &mut HashSet<String>,
144: ) -> Vec<UsageEntry> {
145:     let mut entries = Vec::new();
146:     let mut actual_project_path: Option<String> = None;
147: 
148:     if let Ok(content) = fs::read_to_string(path) {
149:         // Extract session ID from the file path
150:         let session_id = path
151:             .parent()
152:             .and_then(|p| p.file_name())
153:             .and_then(|n| n.to_str())
154:             .unwrap_or("unknown")
155:             .to_string();
156: 
157:         for line in content.lines() {
158:             if line.trim().is_empty() {
159:                 continue;
160:             }
161: 
162:             if let Ok(json_value) = serde_json::from_str::<serde_json::Value>(line) {
163:                 // Extract the actual project path from cwd if we haven't already
164:                 if actual_project_path.is_none() {
165:                     if let Some(cwd) = json_value.get("cwd").and_then(|v| v.as_str()) {
166:                         actual_project_path = Some(cwd.to_string());
167:                     }
168:                 }
169: 
170:                 // Try to parse as JsonlEntry for usage data
171:                 if let Ok(entry) = serde_json::from_value::<JsonlEntry>(json_value) {
172:                     if let Some(message) = &entry.message {
173:                         // Deduplication based on message ID and request ID
174:                         if let (Some(msg_id), Some(req_id)) = (&message.id, &entry.request_id) {
175:                             let unique_hash = format!("{}:{}", msg_id, req_id);
176:                             if processed_hashes.contains(&unique_hash) {
177:                                 continue; // Skip duplicate entry
178:                             }
179:                             processed_hashes.insert(unique_hash);
180:                         }
181: 
182:                         if let Some(usage) = &message.usage {
183:                             // Skip entries without meaningful token usage
184:                             if usage.input_tokens.unwrap_or(0) == 0
185:                                 && usage.output_tokens.unwrap_or(0) == 0
186:                                 && usage.cache_creation_input_tokens.unwrap_or(0) == 0
187:                                 && usage.cache_read_input_tokens.unwrap_or(0) == 0
188:                             {
189:                                 continue;
190:                             }
191: 
192:                             let cost = entry.cost_usd.unwrap_or_else(|| {
193:                                 if let Some(model_str) = &message.model {
194:                                     calculate_cost(model_str, usage)
195:                                 } else {
196:                                     0.0
197:                                 }
198:                             });
199: 
200:                             // Use actual project path if found, otherwise use encoded name
201:                             let project_path = actual_project_path
202:                                 .clone()
203:                                 .unwrap_or_else(|| encoded_project_name.to_string());
204: 
205:                             entries.push(UsageEntry {
206:                                 timestamp: entry.timestamp,
207:                                 model: message
208:                                     .model
209:                                     .clone()
210:                                     .unwrap_or_else(|| "unknown".to_string()),
211:                                 input_tokens: usage.input_tokens.unwrap_or(0),
212:                                 output_tokens: usage.output_tokens.unwrap_or(0),
213:                                 cache_creation_tokens: usage
214:                                     .cache_creation_input_tokens
215:                                     .unwrap_or(0),
216:                                 cache_read_tokens: usage.cache_read_input_tokens.unwrap_or(0),
217:                                 cost,
218:                                 session_id: entry.session_id.unwrap_or_else(|| session_id.clone()),
219:                                 project_path,
220:                             });
221:                         }
222:                     }
223:                 }
224:             }
225:         }
226:     }
227: 
228:     entries
229: }
230: 
231: fn get_earliest_timestamp(path: &PathBuf) -> Option<String> {
232:     if let Ok(content) = fs::read_to_string(path) {
233:         let mut earliest_timestamp: Option<String> = None;
234:         for line in content.lines() {
235:             if let Ok(json_value) = serde_json::from_str::<serde_json::Value>(line) {
236:                 if let Some(timestamp_str) = json_value.get("timestamp").and_then(|v| v.as_str()) {
237:                     if let Some(current_earliest) = &earliest_timestamp {
238:                         if timestamp_str < current_earliest.as_str() {
239:                             earliest_timestamp = Some(timestamp_str.to_string());
240:                         }
241:                     } else {
242:                         earliest_timestamp = Some(timestamp_str.to_string());
243:                     }
244:                 }
245:             }
246:         }
247:         return earliest_timestamp;
248:     }
249:     None
250: }
251: 
252: fn get_all_usage_entries(claude_path: &PathBuf) -> Vec<UsageEntry> {
253:     let mut all_entries = Vec::new();
254:     let mut processed_hashes = HashSet::new();
255:     let projects_dir = claude_path.join("projects");
256: 
257:     let mut files_to_process: Vec<(PathBuf, String)> = Vec::new();
258: 
259:     if let Ok(projects) = fs::read_dir(&projects_dir) {
260:         for project in projects.flatten() {
261:             if project.file_type().map(|t| t.is_dir()).unwrap_or(false) {
262:                 let project_name = project.file_name().to_string_lossy().to_string();
263:                 let project_path = project.path();
264: 
265:                 walkdir::WalkDir::new(&project_path)
266:                     .into_iter()
267:                     .filter_map(Result::ok)
268:                     .filter(|e| e.path().extension().and_then(|s| s.to_str()) == Some("jsonl"))
269:                     .for_each(|entry| {
270:                         files_to_process.push((entry.path().to_path_buf(), project_name.clone()));
271:                     });
272:             }
273:         }
274:     }
275: 
276:     // Sort files by their earliest timestamp to ensure chronological processing
277:     // and deterministic deduplication.
278:     files_to_process.sort_by_cached_key(|(path, _)| get_earliest_timestamp(path));
279: 
280:     for (path, project_name) in files_to_process {
281:         let entries = parse_jsonl_file(&path, &project_name, &mut processed_hashes);
282:         all_entries.extend(entries);
283:     }
284: 
285:     // Sort by timestamp
286:     all_entries.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));
287: 
288:     all_entries
289: }
290: 
291: #[command]
292: pub fn get_usage_stats(days: Option<u32>) -> Result<UsageStats, String> {
293:     let claude_path = dirs::home_dir()
294:         .ok_or("Failed to get home directory")?
295:         .join(".claude");
296: 
297:     let all_entries = get_all_usage_entries(&claude_path);
298: 
299:     if all_entries.is_empty() {
300:         return Ok(UsageStats {
301:             total_cost: 0.0,
302:             total_tokens: 0,
303:             total_input_tokens: 0,
304:             total_output_tokens: 0,
305:             total_cache_creation_tokens: 0,
306:             total_cache_read_tokens: 0,
307:             total_sessions: 0,
308:             by_model: vec![],
309:             by_date: vec![],
310:             by_project: vec![],
311:         });
312:     }
313: 
314:     // Filter by days if specified
315:     let filtered_entries = if let Some(days) = days {
316:         let cutoff = Local::now().naive_local().date() - chrono::Duration::days(days as i64);
317:         all_entries
318:             .into_iter()
319:             .filter(|e| {
320:                 if let Ok(dt) = DateTime::parse_from_rfc3339(&e.timestamp) {
321:                     dt.naive_local().date() >= cutoff
322:                 } else {
323:                     false
324:                 }
325:             })
326:             .collect()
327:     } else {
328:         all_entries
329:     };
330: 
331:     // Calculate aggregated stats
332:     let mut total_cost = 0.0;
333:     let mut total_input_tokens = 0u64;
334:     let mut total_output_tokens = 0u64;
335:     let mut total_cache_creation_tokens = 0u64;
336:     let mut total_cache_read_tokens = 0u64;
337: 
338:     let mut model_stats: HashMap<String, ModelUsage> = HashMap::new();
339:     let mut daily_stats: HashMap<String, DailyUsage> = HashMap::new();
340:     let mut project_stats: HashMap<String, ProjectUsage> = HashMap::new();
341: 
342:     for entry in &filtered_entries {
343:         // Update totals
344:         total_cost += entry.cost;
345:         total_input_tokens += entry.input_tokens;
346:         total_output_tokens += entry.output_tokens;
347:         total_cache_creation_tokens += entry.cache_creation_tokens;
348:         total_cache_read_tokens += entry.cache_read_tokens;
349: 
350:         // Update model stats
351:         let model_stat = model_stats
352:             .entry(entry.model.clone())
353:             .or_insert(ModelUsage {
354:                 model: entry.model.clone(),
355:                 total_cost: 0.0,
356:                 total_tokens: 0,
357:                 input_tokens: 0,
358:                 output_tokens: 0,
359:                 cache_creation_tokens: 0,
360:                 cache_read_tokens: 0,
361:                 session_count: 0,
362:             });
363:         model_stat.total_cost += entry.cost;
364:         model_stat.input_tokens += entry.input_tokens;
365:         model_stat.output_tokens += entry.output_tokens;
366:         model_stat.cache_creation_tokens += entry.cache_creation_tokens;
367:         model_stat.cache_read_tokens += entry.cache_read_tokens;
368:         model_stat.total_tokens = model_stat.input_tokens + model_stat.output_tokens;
369:         model_stat.session_count += 1;
370: 
371:         // Update daily stats
372:         let date = entry
373:             .timestamp
374:             .split('T')
375:             .next()
376:             .unwrap_or(&entry.timestamp)
377:             .to_string();
378:         let daily_stat = daily_stats.entry(date.clone()).or_insert(DailyUsage {
379:             date,
380:             total_cost: 0.0,
381:             total_tokens: 0,
382:             models_used: vec![],
383:         });
384:         daily_stat.total_cost += entry.cost;
385:         daily_stat.total_tokens += entry.input_tokens
386:             + entry.output_tokens
387:             + entry.cache_creation_tokens
388:             + entry.cache_read_tokens;
389:         if !daily_stat.models_used.contains(&entry.model) {
390:             daily_stat.models_used.push(entry.model.clone());
391:         }
392: 
393:         // Update project stats
394:         let project_stat =
395:             project_stats
396:                 .entry(entry.project_path.clone())
397:                 .or_insert(ProjectUsage {
398:                     project_path: entry.project_path.clone(),
399:                     project_name: entry
400:                         .project_path
401:                         .split('/')
402:                         .last()
403:                         .unwrap_or(&entry.project_path)
404:                         .to_string(),
405:                     total_cost: 0.0,
406:                     total_tokens: 0,
407:                     session_count: 0,
408:                     last_used: entry.timestamp.clone(),
409:                 });
410:         project_stat.total_cost += entry.cost;
411:         project_stat.total_tokens += entry.input_tokens
412:             + entry.output_tokens
413:             + entry.cache_creation_tokens
414:             + entry.cache_read_tokens;
415:         project_stat.session_count += 1;
416:         if entry.timestamp > project_stat.last_used {
417:             project_stat.last_used = entry.timestamp.clone();
418:         }
419:     }
420: 
421:     let total_tokens = total_input_tokens
422:         + total_output_tokens
423:         + total_cache_creation_tokens
424:         + total_cache_read_tokens;
425:     let total_sessions = filtered_entries.len() as u64;
426: 
427:     // Convert hashmaps to sorted vectors
428:     let mut by_model: Vec<ModelUsage> = model_stats.into_values().collect();
429:     by_model.sort_by(|a, b| b.total_cost.partial_cmp(&a.total_cost).unwrap());
430: 
431:     let mut by_date: Vec<DailyUsage> = daily_stats.into_values().collect();
432:     by_date.sort_by(|a, b| b.date.cmp(&a.date));
433: 
434:     let mut by_project: Vec<ProjectUsage> = project_stats.into_values().collect();
435:     by_project.sort_by(|a, b| b.total_cost.partial_cmp(&a.total_cost).unwrap());
436: 
437:     Ok(UsageStats {
438:         total_cost,
439:         total_tokens,
440:         total_input_tokens,
441:         total_output_tokens,
442:         total_cache_creation_tokens,
443:         total_cache_read_tokens,
444:         total_sessions,
445:         by_model,
446:         by_date,
447:         by_project,
448:     })
449: }
450: 
451: #[command]
452: pub fn get_usage_by_date_range(start_date: String, end_date: String) -> Result<UsageStats, String> {
453:     let claude_path = dirs::home_dir()
454:         .ok_or("Failed to get home directory")?
455:         .join(".claude");
456: 
457:     let all_entries = get_all_usage_entries(&claude_path);
458: 
459:     // Parse dates
460:     let start = NaiveDate::parse_from_str(&start_date, "%Y-%m-%d").or_else(|_| {
461:         // Try parsing ISO datetime format
462:         DateTime::parse_from_rfc3339(&start_date)
463:             .map(|dt| dt.naive_local().date())
464:             .map_err(|e| format!("Invalid start date: {}", e))
465:     })?;
466:     let end = NaiveDate::parse_from_str(&end_date, "%Y-%m-%d").or_else(|_| {
467:         // Try parsing ISO datetime format
468:         DateTime::parse_from_rfc3339(&end_date)
469:             .map(|dt| dt.naive_local().date())
470:             .map_err(|e| format!("Invalid end date: {}", e))
471:     })?;
472: 
473:     // Filter entries by date range
474:     let filtered_entries: Vec<_> = all_entries
475:         .into_iter()
476:         .filter(|e| {
477:             if let Ok(dt) = DateTime::parse_from_rfc3339(&e.timestamp) {
478:                 let date = dt.naive_local().date();
479:                 date >= start && date <= end
480:             } else {
481:                 false
482:             }
483:         })
484:         .collect();
485: 
486:     if filtered_entries.is_empty() {
487:         return Ok(UsageStats {
488:             total_cost: 0.0,
489:             total_tokens: 0,
490:             total_input_tokens: 0,
491:             total_output_tokens: 0,
492:             total_cache_creation_tokens: 0,
493:             total_cache_read_tokens: 0,
494:             total_sessions: 0,
495:             by_model: vec![],
496:             by_date: vec![],
497:             by_project: vec![],
498:         });
499:     }
500: 
501:     // Calculate aggregated stats (same logic as get_usage_stats)
502:     let mut total_cost = 0.0;
503:     let mut total_input_tokens = 0u64;
504:     let mut total_output_tokens = 0u64;
505:     let mut total_cache_creation_tokens = 0u64;
506:     let mut total_cache_read_tokens = 0u64;
507: 
508:     let mut model_stats: HashMap<String, ModelUsage> = HashMap::new();
509:     let mut daily_stats: HashMap<String, DailyUsage> = HashMap::new();
510:     let mut project_stats: HashMap<String, ProjectUsage> = HashMap::new();
511: 
512:     for entry in &filtered_entries {
513:         // Update totals
514:         total_cost += entry.cost;
515:         total_input_tokens += entry.input_tokens;
516:         total_output_tokens += entry.output_tokens;
517:         total_cache_creation_tokens += entry.cache_creation_tokens;
518:         total_cache_read_tokens += entry.cache_read_tokens;
519: 
520:         // Update model stats
521:         let model_stat = model_stats
522:             .entry(entry.model.clone())
523:             .or_insert(ModelUsage {
524:                 model: entry.model.clone(),
525:                 total_cost: 0.0,
526:                 total_tokens: 0,
527:                 input_tokens: 0,
528:                 output_tokens: 0,
529:                 cache_creation_tokens: 0,
530:                 cache_read_tokens: 0,
531:                 session_count: 0,
532:             });
533:         model_stat.total_cost += entry.cost;
534:         model_stat.input_tokens += entry.input_tokens;
535:         model_stat.output_tokens += entry.output_tokens;
536:         model_stat.cache_creation_tokens += entry.cache_creation_tokens;
537:         model_stat.cache_read_tokens += entry.cache_read_tokens;
538:         model_stat.total_tokens = model_stat.input_tokens + model_stat.output_tokens;
539:         model_stat.session_count += 1;
540: 
541:         // Update daily stats
542:         let date = entry
543:             .timestamp
544:             .split('T')
545:             .next()
546:             .unwrap_or(&entry.timestamp)
547:             .to_string();
548:         let daily_stat = daily_stats.entry(date.clone()).or_insert(DailyUsage {
549:             date,
550:             total_cost: 0.0,
551:             total_tokens: 0,
552:             models_used: vec![],
553:         });
554:         daily_stat.total_cost += entry.cost;
555:         daily_stat.total_tokens += entry.input_tokens
556:             + entry.output_tokens
557:             + entry.cache_creation_tokens
558:             + entry.cache_read_tokens;
559:         if !daily_stat.models_used.contains(&entry.model) {
560:             daily_stat.models_used.push(entry.model.clone());
561:         }
562: 
563:         // Update project stats
564:         let project_stat =
565:             project_stats
566:                 .entry(entry.project_path.clone())
567:                 .or_insert(ProjectUsage {
568:                     project_path: entry.project_path.clone(),
569:                     project_name: entry
570:                         .project_path
571:                         .split('/')
572:                         .last()
573:                         .unwrap_or(&entry.project_path)
574:                         .to_string(),
575:                     total_cost: 0.0,
576:                     total_tokens: 0,
577:                     session_count: 0,
578:                     last_used: entry.timestamp.clone(),
579:                 });
580:         project_stat.total_cost += entry.cost;
581:         project_stat.total_tokens += entry.input_tokens
582:             + entry.output_tokens
583:             + entry.cache_creation_tokens
584:             + entry.cache_read_tokens;
585:         project_stat.session_count += 1;
586:         if entry.timestamp > project_stat.last_used {
587:             project_stat.last_used = entry.timestamp.clone();
588:         }
589:     }
590: 
591:     let total_tokens = total_input_tokens
592:         + total_output_tokens
593:         + total_cache_creation_tokens
594:         + total_cache_read_tokens;
595:     let total_sessions = filtered_entries.len() as u64;
596: 
597:     // Convert hashmaps to sorted vectors
598:     let mut by_model: Vec<ModelUsage> = model_stats.into_values().collect();
599:     by_model.sort_by(|a, b| b.total_cost.partial_cmp(&a.total_cost).unwrap());
600: 
601:     let mut by_date: Vec<DailyUsage> = daily_stats.into_values().collect();
602:     by_date.sort_by(|a, b| b.date.cmp(&a.date));
603: 
604:     let mut by_project: Vec<ProjectUsage> = project_stats.into_values().collect();
605:     by_project.sort_by(|a, b| b.total_cost.partial_cmp(&a.total_cost).unwrap());
606: 
607:     Ok(UsageStats {
608:         total_cost,
609:         total_tokens,
610:         total_input_tokens,
611:         total_output_tokens,
612:         total_cache_creation_tokens,
613:         total_cache_read_tokens,
614:         total_sessions,
615:         by_model,
616:         by_date,
617:         by_project,
618:     })
619: }
620: 
621: #[command]
622: pub fn get_usage_details(
623:     project_path: Option<String>,
624:     date: Option<String>,
625: ) -> Result<Vec<UsageEntry>, String> {
626:     let claude_path = dirs::home_dir()
627:         .ok_or("Failed to get home directory")?
628:         .join(".claude");
629: 
630:     let mut all_entries = get_all_usage_entries(&claude_path);
631: 
632:     // Filter by project if specified
633:     if let Some(project) = project_path {
634:         all_entries.retain(|e| e.project_path == project);
635:     }
636: 
637:     // Filter by date if specified
638:     if let Some(date) = date {
639:         all_entries.retain(|e| e.timestamp.starts_with(&date));
640:     }
641: 
642:     Ok(all_entries)
643: }
644: 
645: #[command]
646: pub fn get_session_stats(
647:     since: Option<String>,
648:     until: Option<String>,
649:     order: Option<String>,
650: ) -> Result<Vec<ProjectUsage>, String> {
651:     let claude_path = dirs::home_dir()
652:         .ok_or("Failed to get home directory")?
653:         .join(".claude");
654: 
655:     let all_entries = get_all_usage_entries(&claude_path);
656: 
657:     let since_date = since.and_then(|s| NaiveDate::parse_from_str(&s, "%Y%m%d").ok());
658:     let until_date = until.and_then(|s| NaiveDate::parse_from_str(&s, "%Y%m%d").ok());
659: 
660:     let filtered_entries: Vec<_> = all_entries
661:         .into_iter()
662:         .filter(|e| {
663:             if let Ok(dt) = DateTime::parse_from_rfc3339(&e.timestamp) {
664:                 let date = dt.date_naive();
665:                 let is_after_since = since_date.map_or(true, |s| date >= s);
666:                 let is_before_until = until_date.map_or(true, |u| date <= u);
667:                 is_after_since && is_before_until
668:             } else {
669:                 false
670:             }
671:         })
672:         .collect();
673: 
674:     let mut session_stats: HashMap<String, ProjectUsage> = HashMap::new();
675:     for entry in &filtered_entries {
676:         let session_key = format!("{}/{}", entry.project_path, entry.session_id);
677:         let project_stat = session_stats
678:             .entry(session_key)
679:             .or_insert_with(|| ProjectUsage {
680:                 project_path: entry.project_path.clone(),
681:                 project_name: entry.session_id.clone(), // Using session_id as project_name for session view
682:                 total_cost: 0.0,
683:                 total_tokens: 0,
684:                 session_count: 0, // In this context, this will count entries per session
685:                 last_used: " ".to_string(),
686:             });
687: 
688:         project_stat.total_cost += entry.cost;
689:         project_stat.total_tokens += entry.input_tokens
690:             + entry.output_tokens
691:             + entry.cache_creation_tokens
692:             + entry.cache_read_tokens;
693:         project_stat.session_count += 1;
694:         if entry.timestamp > project_stat.last_used {
695:             project_stat.last_used = entry.timestamp.clone();
696:         }
697:     }
698: 
699:     let mut by_session: Vec<ProjectUsage> = session_stats.into_values().collect();
700: 
701:     // Sort by last_used date
702:     if let Some(order_str) = order {
703:         if order_str == "asc" {
704:             by_session.sort_by(|a, b| a.last_used.cmp(&b.last_used));
705:         } else {
706:             by_session.sort_by(|a, b| b.last_used.cmp(&a.last_used));
707:         }
708:     } else {
709:         // Default to descending
710:         by_session.sort_by(|a, b| b.last_used.cmp(&a.last_used));
711:     }
712: 
713:     Ok(by_session)
714: }
````

## File: src-tauri/src/process/mod.rs
````rust
1: pub mod registry;
2: 
3: pub use registry::*;
````

## File: src-tauri/src/process/registry.rs
````rust
  1: use chrono::{DateTime, Utc};
  2: use serde::{Deserialize, Serialize};
  3: use std::collections::HashMap;
  4: use std::sync::{Arc, Mutex};
  5: use tokio::process::Child;
  6: 
  7: /// Type of process being tracked
  8: #[derive(Debug, Clone, Serialize, Deserialize)]
  9: pub enum ProcessType {
 10:     AgentRun {
 11:         agent_id: i64,
 12:         agent_name: String,
 13:     },
 14:     ClaudeSession {
 15:         session_id: String,
 16:     },
 17: }
 18: 
 19: /// Information about a running agent process
 20: #[derive(Debug, Clone, Serialize, Deserialize)]
 21: pub struct ProcessInfo {
 22:     pub run_id: i64,
 23:     pub process_type: ProcessType,
 24:     pub pid: u32,
 25:     pub started_at: DateTime<Utc>,
 26:     pub project_path: String,
 27:     pub task: String,
 28:     pub model: String,
 29: }
 30: 
 31: /// Information about a running process with handle
 32: #[allow(dead_code)]
 33: pub struct ProcessHandle {
 34:     pub info: ProcessInfo,
 35:     pub child: Arc<Mutex<Option<Child>>>,
 36:     pub live_output: Arc<Mutex<String>>,
 37: }
 38: 
 39: /// Registry for tracking active agent processes
 40: pub struct ProcessRegistry {
 41:     processes: Arc<Mutex<HashMap<i64, ProcessHandle>>>, // run_id -> ProcessHandle
 42:     next_id: Arc<Mutex<i64>>, // Auto-incrementing ID for non-agent processes
 43: }
 44: 
 45: impl ProcessRegistry {
 46:     pub fn new() -> Self {
 47:         Self {
 48:             processes: Arc::new(Mutex::new(HashMap::new())),
 49:             next_id: Arc::new(Mutex::new(1000000)), // Start at high number to avoid conflicts
 50:         }
 51:     }
 52: 
 53:     /// Generate a unique ID for non-agent processes
 54:     pub fn generate_id(&self) -> Result<i64, String> {
 55:         let mut next_id = self.next_id.lock().map_err(|e| e.to_string())?;
 56:         let id = *next_id;
 57:         *next_id += 1;
 58:         Ok(id)
 59:     }
 60: 
 61:     /// Register a new running agent process
 62:     pub fn register_process(
 63:         &self,
 64:         run_id: i64,
 65:         agent_id: i64,
 66:         agent_name: String,
 67:         pid: u32,
 68:         project_path: String,
 69:         task: String,
 70:         model: String,
 71:         child: Child,
 72:     ) -> Result<(), String> {
 73:         let process_info = ProcessInfo {
 74:             run_id,
 75:             process_type: ProcessType::AgentRun { agent_id, agent_name },
 76:             pid,
 77:             started_at: Utc::now(),
 78:             project_path,
 79:             task,
 80:             model,
 81:         };
 82: 
 83:         self.register_process_internal(run_id, process_info, child)
 84:     }
 85: 
 86:     /// Register a new running agent process using sidecar (similar to register_process but for sidecar children)
 87:     pub fn register_sidecar_process(
 88:         &self,
 89:         run_id: i64,
 90:         agent_id: i64,
 91:         agent_name: String,
 92:         pid: u32,
 93:         project_path: String,
 94:         task: String,
 95:         model: String,
 96:     ) -> Result<(), String> {
 97:         let process_info = ProcessInfo {
 98:             run_id,
 99:             process_type: ProcessType::AgentRun { agent_id, agent_name },
100:             pid,
101:             started_at: Utc::now(),
102:             project_path,
103:             task,
104:             model,
105:         };
106: 
107:         // For sidecar processes, we register without the child handle since it's managed differently
108:         let mut processes = self.processes.lock().map_err(|e| e.to_string())?;
109:         
110:         let process_handle = ProcessHandle {
111:             info: process_info,
112:             child: Arc::new(Mutex::new(None)), // No tokio::process::Child handle for sidecar
113:             live_output: Arc::new(Mutex::new(String::new())),
114:         };
115: 
116:         processes.insert(run_id, process_handle);
117:         Ok(())
118:     }
119: 
120:     /// Register a new Claude session (without child process - handled separately)
121:     pub fn register_claude_session(
122:         &self,
123:         session_id: String,
124:         pid: u32,
125:         project_path: String,
126:         task: String,
127:         model: String,
128:     ) -> Result<i64, String> {
129:         let run_id = self.generate_id()?;
130:         
131:         let process_info = ProcessInfo {
132:             run_id,
133:             process_type: ProcessType::ClaudeSession { session_id },
134:             pid,
135:             started_at: Utc::now(),
136:             project_path,
137:             task,
138:             model,
139:         };
140: 
141:         // Register without child - Claude sessions use ClaudeProcessState for process management
142:         let mut processes = self.processes.lock().map_err(|e| e.to_string())?;
143:         
144:         let process_handle = ProcessHandle {
145:             info: process_info,
146:             child: Arc::new(Mutex::new(None)), // No child handle for Claude sessions
147:             live_output: Arc::new(Mutex::new(String::new())),
148:         };
149: 
150:         processes.insert(run_id, process_handle);
151:         Ok(run_id)
152:     }
153: 
154:     /// Internal method to register any process
155:     fn register_process_internal(
156:         &self,
157:         run_id: i64,
158:         process_info: ProcessInfo,
159:         child: Child,
160:     ) -> Result<(), String> {
161:         let mut processes = self.processes.lock().map_err(|e| e.to_string())?;
162: 
163:         let process_handle = ProcessHandle {
164:             info: process_info,
165:             child: Arc::new(Mutex::new(Some(child))),
166:             live_output: Arc::new(Mutex::new(String::new())),
167:         };
168: 
169:         processes.insert(run_id, process_handle);
170:         Ok(())
171:     }
172: 
173:     /// Get all running Claude sessions
174:     pub fn get_running_claude_sessions(&self) -> Result<Vec<ProcessInfo>, String> {
175:         let processes = self.processes.lock().map_err(|e| e.to_string())?;
176:         Ok(processes
177:             .values()
178:             .filter_map(|handle| {
179:                 match &handle.info.process_type {
180:                     ProcessType::ClaudeSession { .. } => Some(handle.info.clone()),
181:                     _ => None,
182:                 }
183:             })
184:             .collect())
185:     }
186: 
187:     /// Get a specific Claude session by session ID
188:     pub fn get_claude_session_by_id(&self, session_id: &str) -> Result<Option<ProcessInfo>, String> {
189:         let processes = self.processes.lock().map_err(|e| e.to_string())?;
190:         Ok(processes
191:             .values()
192:             .find(|handle| {
193:                 match &handle.info.process_type {
194:                     ProcessType::ClaudeSession { session_id: sid } => sid == session_id,
195:                     _ => false,
196:                 }
197:             })
198:             .map(|handle| handle.info.clone()))
199:     }
200: 
201:     /// Unregister a process (called when it completes)
202:     #[allow(dead_code)]
203:     pub fn unregister_process(&self, run_id: i64) -> Result<(), String> {
204:         let mut processes = self.processes.lock().map_err(|e| e.to_string())?;
205:         processes.remove(&run_id);
206:         Ok(())
207:     }
208: 
209:     /// Get all running processes
210:     #[allow(dead_code)]
211:     pub fn get_running_processes(&self) -> Result<Vec<ProcessInfo>, String> {
212:         let processes = self.processes.lock().map_err(|e| e.to_string())?;
213:         Ok(processes
214:             .values()
215:             .map(|handle| handle.info.clone())
216:             .collect())
217:     }
218: 
219:     /// Get all running agent processes
220:     pub fn get_running_agent_processes(&self) -> Result<Vec<ProcessInfo>, String> {
221:         let processes = self.processes.lock().map_err(|e| e.to_string())?;
222:         Ok(processes
223:             .values()
224:             .filter_map(|handle| {
225:                 match &handle.info.process_type {
226:                     ProcessType::AgentRun { .. } => Some(handle.info.clone()),
227:                     _ => None,
228:                 }
229:             })
230:             .collect())
231:     }
232: 
233:     /// Get a specific running process
234:     #[allow(dead_code)]
235:     pub fn get_process(&self, run_id: i64) -> Result<Option<ProcessInfo>, String> {
236:         let processes = self.processes.lock().map_err(|e| e.to_string())?;
237:         Ok(processes.get(&run_id).map(|handle| handle.info.clone()))
238:     }
239: 
240:     /// Kill a running process with proper cleanup
241:     pub async fn kill_process(&self, run_id: i64) -> Result<bool, String> {
242:         use log::{error, info, warn};
243: 
244:         // First check if the process exists and get its PID
245:         let (pid, child_arc) = {
246:             let processes = self.processes.lock().map_err(|e| e.to_string())?;
247:             if let Some(handle) = processes.get(&run_id) {
248:                 (handle.info.pid, handle.child.clone())
249:             } else {
250:                 warn!("Process {} not found in registry", run_id);
251:                 return Ok(false); // Process not found
252:             }
253:         };
254: 
255:         info!(
256:             "Attempting graceful shutdown of process {} (PID: {})",
257:             run_id, pid
258:         );
259: 
260:         // Send kill signal to the process
261:         let kill_sent = {
262:             let mut child_guard = child_arc.lock().map_err(|e| e.to_string())?;
263:             if let Some(child) = child_guard.as_mut() {
264:                 match child.start_kill() {
265:                     Ok(_) => {
266:                         info!("Successfully sent kill signal to process {}", run_id);
267:                         true
268:                     }
269:                     Err(e) => {
270:                         error!("Failed to send kill signal to process {}: {}", run_id, e);
271:                         // Don't return error here, try fallback method
272:                         false
273:                     }
274:                 }
275:             } else {
276:                 warn!("No child handle available for process {} (PID: {}), attempting system kill", run_id, pid);
277:                 false // Process handle not available, try fallback
278:             }
279:         };
280: 
281:         // If direct kill didn't work, try system command as fallback
282:         if !kill_sent {
283:             info!("Attempting fallback kill for process {} (PID: {})", run_id, pid);
284:             match self.kill_process_by_pid(run_id, pid) {
285:                 Ok(true) => return Ok(true),
286:                 Ok(false) => warn!("Fallback kill also failed for process {} (PID: {})", run_id, pid),
287:                 Err(e) => error!("Error during fallback kill: {}", e),
288:             }
289:             // Continue with the rest of the cleanup even if fallback failed
290:         }
291: 
292:         // Wait for the process to exit (with timeout)
293:         let wait_result = tokio::time::timeout(tokio::time::Duration::from_secs(5), async {
294:             loop {
295:                 // Check if process has exited
296:                 let status = {
297:                     let mut child_guard = child_arc.lock().map_err(|e| e.to_string())?;
298:                     if let Some(child) = child_guard.as_mut() {
299:                         match child.try_wait() {
300:                             Ok(Some(status)) => {
301:                                 info!("Process {} exited with status: {:?}", run_id, status);
302:                                 *child_guard = None; // Clear the child handle
303:                                 Some(Ok::<(), String>(()))
304:                             }
305:                             Ok(None) => {
306:                                 // Still running
307:                                 None
308:                             }
309:                             Err(e) => {
310:                                 error!("Error checking process status: {}", e);
311:                                 Some(Err(e.to_string()))
312:                             }
313:                         }
314:                     } else {
315:                         // Process already gone
316:                         Some(Ok(()))
317:                     }
318:                 };
319: 
320:                 match status {
321:                     Some(result) => return result,
322:                     None => {
323:                         // Still running, wait a bit
324:                         tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
325:                     }
326:                 }
327:             }
328:         })
329:         .await;
330: 
331:         match wait_result {
332:             Ok(Ok(_)) => {
333:                 info!("Process {} exited gracefully", run_id);
334:             }
335:             Ok(Err(e)) => {
336:                 error!("Error waiting for process {}: {}", run_id, e);
337:             }
338:             Err(_) => {
339:                 warn!("Process {} didn't exit within 5 seconds after kill", run_id);
340:                 // Force clear the handle
341:                 if let Ok(mut child_guard) = child_arc.lock() {
342:                     *child_guard = None;
343:                 }
344:                 // One more attempt with system kill
345:                 let _ = self.kill_process_by_pid(run_id, pid);
346:             }
347:         }
348: 
349:         // Remove from registry after killing
350:         self.unregister_process(run_id)?;
351: 
352:         Ok(true)
353:     }
354: 
355:     /// Kill a process by PID using system commands (fallback method)
356:     pub fn kill_process_by_pid(&self, run_id: i64, pid: u32) -> Result<bool, String> {
357:         use log::{error, info, warn};
358: 
359:         info!("Attempting to kill process {} by PID {}", run_id, pid);
360: 
361:         let kill_result = if cfg!(target_os = "windows") {
362:             std::process::Command::new("taskkill")
363:                 .args(["/F", "/PID", &pid.to_string()])
364:                 .output()
365:         } else {
366:             // First try SIGTERM
367:             let term_result = std::process::Command::new("kill")
368:                 .args(["-TERM", &pid.to_string()])
369:                 .output();
370: 
371:             match &term_result {
372:                 Ok(output) if output.status.success() => {
373:                     info!("Sent SIGTERM to PID {}", pid);
374:                     // Give it 2 seconds to exit gracefully
375:                     std::thread::sleep(std::time::Duration::from_secs(2));
376: 
377:                     // Check if still running
378:                     let check_result = std::process::Command::new("kill")
379:                         .args(["-0", &pid.to_string()])
380:                         .output();
381: 
382:                     if let Ok(output) = check_result {
383:                         if output.status.success() {
384:                             // Still running, send SIGKILL
385:                             warn!(
386:                                 "Process {} still running after SIGTERM, sending SIGKILL",
387:                                 pid
388:                             );
389:                             std::process::Command::new("kill")
390:                                 .args(["-KILL", &pid.to_string()])
391:                                 .output()
392:                         } else {
393:                             term_result
394:                         }
395:                     } else {
396:                         term_result
397:                     }
398:                 }
399:                 _ => {
400:                     // SIGTERM failed, try SIGKILL directly
401:                     warn!("SIGTERM failed for PID {}, trying SIGKILL", pid);
402:                     std::process::Command::new("kill")
403:                         .args(["-KILL", &pid.to_string()])
404:                         .output()
405:                 }
406:             }
407:         };
408: 
409:         match kill_result {
410:             Ok(output) => {
411:                 if output.status.success() {
412:                     info!("Successfully killed process with PID {}", pid);
413:                     // Remove from registry
414:                     self.unregister_process(run_id)?;
415:                     Ok(true)
416:                 } else {
417:                     let error_msg = String::from_utf8_lossy(&output.stderr);
418:                     warn!("Failed to kill PID {}: {}", pid, error_msg);
419:                     Ok(false)
420:                 }
421:             }
422:             Err(e) => {
423:                 error!("Failed to execute kill command for PID {}: {}", pid, e);
424:                 Err(format!("Failed to execute kill command: {}", e))
425:             }
426:         }
427:     }
428: 
429:     /// Check if a process is still running by trying to get its status
430:     #[allow(dead_code)]
431:     pub async fn is_process_running(&self, run_id: i64) -> Result<bool, String> {
432:         let processes = self.processes.lock().map_err(|e| e.to_string())?;
433: 
434:         if let Some(handle) = processes.get(&run_id) {
435:             let child_arc = handle.child.clone();
436:             drop(processes); // Release the lock before async operation
437: 
438:             let mut child_guard = child_arc.lock().map_err(|e| e.to_string())?;
439:             if let Some(ref mut child) = child_guard.as_mut() {
440:                 match child.try_wait() {
441:                     Ok(Some(_)) => {
442:                         // Process has exited
443:                         *child_guard = None;
444:                         Ok(false)
445:                     }
446:                     Ok(None) => {
447:                         // Process is still running
448:                         Ok(true)
449:                     }
450:                     Err(_) => {
451:                         // Error checking status, assume not running
452:                         *child_guard = None;
453:                         Ok(false)
454:                     }
455:                 }
456:             } else {
457:                 Ok(false) // No child handle
458:             }
459:         } else {
460:             Ok(false) // Process not found in registry
461:         }
462:     }
463: 
464:     /// Append to live output for a process
465:     pub fn append_live_output(&self, run_id: i64, output: &str) -> Result<(), String> {
466:         let processes = self.processes.lock().map_err(|e| e.to_string())?;
467:         if let Some(handle) = processes.get(&run_id) {
468:             let mut live_output = handle.live_output.lock().map_err(|e| e.to_string())?;
469:             live_output.push_str(output);
470:             live_output.push('\n');
471:         }
472:         Ok(())
473:     }
474: 
475:     /// Get live output for a process
476:     pub fn get_live_output(&self, run_id: i64) -> Result<String, String> {
477:         let processes = self.processes.lock().map_err(|e| e.to_string())?;
478:         if let Some(handle) = processes.get(&run_id) {
479:             let live_output = handle.live_output.lock().map_err(|e| e.to_string())?;
480:             Ok(live_output.clone())
481:         } else {
482:             Ok(String::new())
483:         }
484:     }
485: 
486:     /// Cleanup finished processes
487:     #[allow(dead_code)]
488:     pub async fn cleanup_finished_processes(&self) -> Result<Vec<i64>, String> {
489:         let mut finished_runs = Vec::new();
490:         let processes_lock = self.processes.clone();
491: 
492:         // First, identify finished processes
493:         {
494:             let processes = processes_lock.lock().map_err(|e| e.to_string())?;
495:             let run_ids: Vec<i64> = processes.keys().cloned().collect();
496:             drop(processes);
497: 
498:             for run_id in run_ids {
499:                 if !self.is_process_running(run_id).await? {
500:                     finished_runs.push(run_id);
501:                 }
502:             }
503:         }
504: 
505:         // Then remove them from the registry
506:         {
507:             let mut processes = processes_lock.lock().map_err(|e| e.to_string())?;
508:             for run_id in &finished_runs {
509:                 processes.remove(run_id);
510:             }
511:         }
512: 
513:         Ok(finished_runs)
514:     }
515: }
516: 
517: impl Default for ProcessRegistry {
518:     fn default() -> Self {
519:         Self::new()
520:     }
521: }
522: 
523: /// Global process registry state
524: pub struct ProcessRegistryState(pub Arc<ProcessRegistry>);
525: 
526: impl Default for ProcessRegistryState {
527:     fn default() -> Self {
528:         Self(Arc::new(ProcessRegistry::new()))
529:     }
530: }
````

## File: src-tauri/src/claude_binary.rs
````rust
  1: use anyhow::Result;
  2: use log::{debug, error, info, warn};
  3: use serde::{Deserialize, Serialize};
  4: use std::cmp::Ordering;
  5: /// Shared module for detecting Claude Code binary installations
  6: /// Supports NVM installations, aliased paths, and version-based selection
  7: use std::path::PathBuf;
  8: use std::process::Command;
  9: use tauri::Manager;
 10: 
 11: /// Type of Claude installation
 12: #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
 13: pub enum InstallationType {
 14:     /// System-installed binary
 15:     System,
 16:     /// Custom path specified by user
 17:     Custom,
 18: }
 19: 
 20: /// Represents a Claude installation with metadata
 21: #[derive(Debug, Clone, Serialize, Deserialize)]
 22: pub struct ClaudeInstallation {
 23:     /// Full path to the Claude binary
 24:     pub path: String,
 25:     /// Version string if available
 26:     pub version: Option<String>,
 27:     /// Source of discovery (e.g., "nvm", "system", "homebrew", "which")
 28:     pub source: String,
 29:     /// Type of installation
 30:     pub installation_type: InstallationType,
 31: }
 32: 
 33: /// Main function to find the Claude binary
 34: /// Checks database first for stored path and preference, then prioritizes accordingly
 35: pub fn find_claude_binary(app_handle: &tauri::AppHandle) -> Result<String, String> {
 36:     info!("Searching for claude binary...");
 37: 
 38:     // First check if we have a stored path and preference in the database
 39:     if let Ok(app_data_dir) = app_handle.path().app_data_dir() {
 40:         let db_path = app_data_dir.join("agents.db");
 41:         if db_path.exists() {
 42:             if let Ok(conn) = rusqlite::Connection::open(&db_path) {
 43:                 // Check for stored path first
 44:                 if let Ok(stored_path) = conn.query_row(
 45:                     "SELECT value FROM app_settings WHERE key = 'claude_binary_path'",
 46:                     [],
 47:                     |row| row.get::<_, String>(0),
 48:                 ) {
 49:                     info!("Found stored claude path in database: {}", stored_path);
 50:                     
 51:                     // Check if the path still exists
 52:                     let path_buf = PathBuf::from(&stored_path);
 53:                     if path_buf.exists() && path_buf.is_file() {
 54:                         return Ok(stored_path);
 55:                     } else {
 56:                         warn!("Stored claude path no longer exists: {}", stored_path);
 57:                     }
 58:                 }
 59:                 
 60:                 // Check user preference
 61:                 let preference = conn.query_row(
 62:                     "SELECT value FROM app_settings WHERE key = 'claude_installation_preference'",
 63:                     [],
 64:                     |row| row.get::<_, String>(0),
 65:                 ).unwrap_or_else(|_| "system".to_string());
 66:                 
 67:                 info!("User preference for Claude installation: {}", preference);
 68:             }
 69:         }
 70:     }
 71: 
 72:     // Discover all available system installations
 73:     let installations = discover_system_installations();
 74: 
 75:     if installations.is_empty() {
 76:         error!("Could not find claude binary in any location");
 77:         return Err("Claude Code not found. Please ensure it's installed in one of these locations: PATH, /usr/local/bin, /opt/homebrew/bin, ~/.nvm/versions/node/*/bin, ~/.claude/local, ~/.local/bin".to_string());
 78:     }
 79: 
 80:     // Log all found installations
 81:     for installation in &installations {
 82:         info!("Found Claude installation: {:?}", installation);
 83:     }
 84: 
 85:     // Select the best installation (highest version)
 86:     if let Some(best) = select_best_installation(installations) {
 87:         info!(
 88:             "Selected Claude installation: path={}, version={:?}, source={}",
 89:             best.path, best.version, best.source
 90:         );
 91:         Ok(best.path)
 92:     } else {
 93:         Err("No valid Claude installation found".to_string())
 94:     }
 95: }
 96: 
 97: /// Discovers all available Claude installations and returns them for selection
 98: /// This allows UI to show a version selector
 99: pub fn discover_claude_installations() -> Vec<ClaudeInstallation> {
100:     info!("Discovering all Claude installations...");
101: 
102:     let mut installations = discover_system_installations();
103: 
104:     // Sort by version (highest first), then by source preference
105:     installations.sort_by(|a, b| {
106:         match (&a.version, &b.version) {
107:             (Some(v1), Some(v2)) => {
108:                 // Compare versions in descending order (newest first)
109:                 match compare_versions(v2, v1) {
110:                     Ordering::Equal => {
111:                         // If versions are equal, prefer by source
112:                         source_preference(a).cmp(&source_preference(b))
113:                     }
114:                     other => other,
115:                 }
116:             }
117:             (Some(_), None) => Ordering::Less, // Version comes before no version
118:             (None, Some(_)) => Ordering::Greater,
119:             (None, None) => source_preference(a).cmp(&source_preference(b)),
120:         }
121:     });
122: 
123:     installations
124: }
125: 
126: /// Returns a preference score for installation sources (lower is better)
127: fn source_preference(installation: &ClaudeInstallation) -> u8 {
128:     match installation.source.as_str() {
129:         "which" => 1,
130:         "homebrew" => 2,
131:         "system" => 3,
132:         source if source.starts_with("nvm") => 4,
133:         "local-bin" => 5,
134:         "claude-local" => 6,
135:         "npm-global" => 7,
136:         "yarn" | "yarn-global" => 8,
137:         "bun" => 9,
138:         "node-modules" => 10,
139:         "home-bin" => 11,
140:         "PATH" => 12,
141:         _ => 13,
142:     }
143: }
144: 
145: /// Discovers all Claude installations on the system
146: fn discover_system_installations() -> Vec<ClaudeInstallation> {
147:     let mut installations = Vec::new();
148: 
149:     // 1. Try 'which' command first (now works in production)
150:     if let Some(installation) = try_which_command() {
151:         installations.push(installation);
152:     }
153: 
154:     // 2. Check NVM paths
155:     installations.extend(find_nvm_installations());
156: 
157:     // 3. Check standard paths
158:     installations.extend(find_standard_installations());
159: 
160:     // Remove duplicates by path
161:     let mut unique_paths = std::collections::HashSet::new();
162:     installations.retain(|install| unique_paths.insert(install.path.clone()));
163: 
164:     installations
165: }
166: 
167: /// Try using the 'which' command to find Claude
168: fn try_which_command() -> Option<ClaudeInstallation> {
169:     debug!("Trying 'which claude' to find binary...");
170: 
171:     match Command::new("which").arg("claude").output() {
172:         Ok(output) if output.status.success() => {
173:             let output_str = String::from_utf8_lossy(&output.stdout).trim().to_string();
174: 
175:             if output_str.is_empty() {
176:                 return None;
177:             }
178: 
179:             // Parse aliased output: "claude: aliased to /path/to/claude"
180:             let path = if output_str.starts_with("claude:") && output_str.contains("aliased to") {
181:                 output_str
182:                     .split("aliased to")
183:                     .nth(1)
184:                     .map(|s| s.trim().to_string())
185:             } else {
186:                 Some(output_str)
187:             }?;
188: 
189:             debug!("'which' found claude at: {}", path);
190: 
191:             // Verify the path exists
192:             if !PathBuf::from(&path).exists() {
193:                 warn!("Path from 'which' does not exist: {}", path);
194:                 return None;
195:             }
196: 
197:             // Get version
198:             let version = get_claude_version(&path).ok().flatten();
199: 
200:             Some(ClaudeInstallation {
201:                 path,
202:                 version,
203:                 source: "which".to_string(),
204:                 installation_type: InstallationType::System,
205:             })
206:         }
207:         _ => None,
208:     }
209: }
210: 
211: /// Find Claude installations in NVM directories
212: fn find_nvm_installations() -> Vec<ClaudeInstallation> {
213:     let mut installations = Vec::new();
214: 
215:     if let Ok(home) = std::env::var("HOME") {
216:         let nvm_dir = PathBuf::from(&home)
217:             .join(".nvm")
218:             .join("versions")
219:             .join("node");
220: 
221:         debug!("Checking NVM directory: {:?}", nvm_dir);
222: 
223:         if let Ok(entries) = std::fs::read_dir(&nvm_dir) {
224:             for entry in entries.flatten() {
225:                 if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {
226:                     let claude_path = entry.path().join("bin").join("claude");
227: 
228:                     if claude_path.exists() && claude_path.is_file() {
229:                         let path_str = claude_path.to_string_lossy().to_string();
230:                         let node_version = entry.file_name().to_string_lossy().to_string();
231: 
232:                         debug!("Found Claude in NVM node {}: {}", node_version, path_str);
233: 
234:                         // Get Claude version
235:                         let version = get_claude_version(&path_str).ok().flatten();
236: 
237:                         installations.push(ClaudeInstallation {
238:                             path: path_str,
239:                             version,
240:                             source: format!("nvm ({})", node_version),
241:                             installation_type: InstallationType::System,
242:                         });
243:                     }
244:                 }
245:             }
246:         }
247:     }
248: 
249:     installations
250: }
251: 
252: /// Check standard installation paths
253: fn find_standard_installations() -> Vec<ClaudeInstallation> {
254:     let mut installations = Vec::new();
255: 
256:     // Common installation paths for claude
257:     let mut paths_to_check: Vec<(String, String)> = vec![
258:         ("/usr/local/bin/claude".to_string(), "system".to_string()),
259:         (
260:             "/opt/homebrew/bin/claude".to_string(),
261:             "homebrew".to_string(),
262:         ),
263:         ("/usr/bin/claude".to_string(), "system".to_string()),
264:         ("/bin/claude".to_string(), "system".to_string()),
265:     ];
266: 
267:     // Also check user-specific paths
268:     if let Ok(home) = std::env::var("HOME") {
269:         paths_to_check.extend(vec![
270:             (
271:                 format!("{}/.claude/local/claude", home),
272:                 "claude-local".to_string(),
273:             ),
274:             (
275:                 format!("{}/.local/bin/claude", home),
276:                 "local-bin".to_string(),
277:             ),
278:             (
279:                 format!("{}/.npm-global/bin/claude", home),
280:                 "npm-global".to_string(),
281:             ),
282:             (format!("{}/.yarn/bin/claude", home), "yarn".to_string()),
283:             (format!("{}/.bun/bin/claude", home), "bun".to_string()),
284:             (format!("{}/bin/claude", home), "home-bin".to_string()),
285:             // Check common node_modules locations
286:             (
287:                 format!("{}/node_modules/.bin/claude", home),
288:                 "node-modules".to_string(),
289:             ),
290:             (
291:                 format!("{}/.config/yarn/global/node_modules/.bin/claude", home),
292:                 "yarn-global".to_string(),
293:             ),
294:         ]);
295:     }
296: 
297:     // Check each path
298:     for (path, source) in paths_to_check {
299:         let path_buf = PathBuf::from(&path);
300:         if path_buf.exists() && path_buf.is_file() {
301:             debug!("Found claude at standard path: {} ({})", path, source);
302: 
303:             // Get version
304:             let version = get_claude_version(&path).ok().flatten();
305: 
306:             installations.push(ClaudeInstallation {
307:                 path,
308:                 version,
309:                 source,
310:                 installation_type: InstallationType::System,
311:             });
312:         }
313:     }
314: 
315:     // Also check if claude is available in PATH (without full path)
316:     if let Ok(output) = Command::new("claude").arg("--version").output() {
317:         if output.status.success() {
318:             debug!("claude is available in PATH");
319:             let version = extract_version_from_output(&output.stdout);
320: 
321:             installations.push(ClaudeInstallation {
322:                 path: "claude".to_string(),
323:                 version,
324:                 source: "PATH".to_string(),
325:                 installation_type: InstallationType::System,
326:             });
327:         }
328:     }
329: 
330:     installations
331: }
332: 
333: /// Get Claude version by running --version command
334: fn get_claude_version(path: &str) -> Result<Option<String>, String> {
335:     match Command::new(path).arg("--version").output() {
336:         Ok(output) => {
337:             if output.status.success() {
338:                 Ok(extract_version_from_output(&output.stdout))
339:             } else {
340:                 Ok(None)
341:             }
342:         }
343:         Err(e) => {
344:             warn!("Failed to get version for {}: {}", path, e);
345:             Ok(None)
346:         }
347:     }
348: }
349: 
350: /// Extract version string from command output
351: fn extract_version_from_output(stdout: &[u8]) -> Option<String> {
352:     let output_str = String::from_utf8_lossy(stdout);
353:     
354:     // Debug log the raw output
355:     debug!("Raw version output: {:?}", output_str);
356:     
357:     // Use regex to directly extract version pattern (e.g., "1.0.41")
358:     // This pattern matches:
359:     // - One or more digits, followed by
360:     // - A dot, followed by
361:     // - One or more digits, followed by
362:     // - A dot, followed by
363:     // - One or more digits
364:     // - Optionally followed by pre-release/build metadata
365:     let version_regex = regex::Regex::new(r"(\d+\.\d+\.\d+(?:-[a-zA-Z0-9.-]+)?(?:\+[a-zA-Z0-9.-]+)?)").ok()?;
366:     
367:     if let Some(captures) = version_regex.captures(&output_str) {
368:         if let Some(version_match) = captures.get(1) {
369:             let version = version_match.as_str().to_string();
370:             debug!("Extracted version: {:?}", version);
371:             return Some(version);
372:         }
373:     }
374:     
375:     debug!("No version found in output");
376:     None
377: }
378: 
379: /// Select the best installation based on version
380: fn select_best_installation(installations: Vec<ClaudeInstallation>) -> Option<ClaudeInstallation> {
381:     // In production builds, version information may not be retrievable because
382:     // spawning external processes can be restricted. We therefore no longer
383:     // discard installations that lack a detected version – the mere presence
384:     // of a readable binary on disk is enough to consider it valid. We still
385:     // prefer binaries with version information when it is available so that
386:     // in development builds we keep the previous behaviour of picking the
387:     // most recent version.
388:     installations.into_iter().max_by(|a, b| {
389:         match (&a.version, &b.version) {
390:             // If both have versions, compare them semantically.
391:             (Some(v1), Some(v2)) => compare_versions(v1, v2),
392:             // Prefer the entry that actually has version information.
393:             (Some(_), None) => Ordering::Greater,
394:             (None, Some(_)) => Ordering::Less,
395:             // Neither have version info: prefer the one that is not just
396:             // the bare "claude" lookup from PATH, because that may fail
397:             // at runtime if PATH is modified.
398:             (None, None) => {
399:                 if a.path == "claude" && b.path != "claude" {
400:                     Ordering::Less
401:                 } else if a.path != "claude" && b.path == "claude" {
402:                     Ordering::Greater
403:                 } else {
404:                     Ordering::Equal
405:                 }
406:             }
407:         }
408:     })
409: }
410: 
411: /// Compare two version strings
412: fn compare_versions(a: &str, b: &str) -> Ordering {
413:     // Simple semantic version comparison
414:     let a_parts: Vec<u32> = a
415:         .split('.')
416:         .filter_map(|s| {
417:             // Handle versions like "1.0.17-beta" by taking only numeric part
418:             s.chars()
419:                 .take_while(|c| c.is_numeric())
420:                 .collect::<String>()
421:                 .parse()
422:                 .ok()
423:         })
424:         .collect();
425: 
426:     let b_parts: Vec<u32> = b
427:         .split('.')
428:         .filter_map(|s| {
429:             s.chars()
430:                 .take_while(|c| c.is_numeric())
431:                 .collect::<String>()
432:                 .parse()
433:                 .ok()
434:         })
435:         .collect();
436: 
437:     // Compare each part
438:     for i in 0..std::cmp::max(a_parts.len(), b_parts.len()) {
439:         let a_val = a_parts.get(i).unwrap_or(&0);
440:         let b_val = b_parts.get(i).unwrap_or(&0);
441:         match a_val.cmp(b_val) {
442:             Ordering::Equal => continue,
443:             other => return other,
444:         }
445:     }
446: 
447:     Ordering::Equal
448: }
449: 
450: /// Helper function to create a Command with proper environment variables
451: /// This ensures commands like Claude can find Node.js and other dependencies
452: pub fn create_command_with_env(program: &str) -> Command {
453:     let mut cmd = Command::new(program);
454:     
455:     info!("Creating command for: {}", program);
456: 
457:     // Inherit essential environment variables from parent process
458:     for (key, value) in std::env::vars() {
459:         // Pass through PATH and other essential environment variables
460:         if key == "PATH"
461:             || key == "HOME"
462:             || key == "USER"
463:             || key == "SHELL"
464:             || key == "LANG"
465:             || key == "LC_ALL"
466:             || key.starts_with("LC_")
467:             || key == "NODE_PATH"
468:             || key == "NVM_DIR"
469:             || key == "NVM_BIN"
470:             || key == "HOMEBREW_PREFIX"
471:             || key == "HOMEBREW_CELLAR"
472:             // Add proxy environment variables (only uppercase)
473:             || key == "HTTP_PROXY"
474:             || key == "HTTPS_PROXY"
475:             || key == "NO_PROXY"
476:             || key == "ALL_PROXY"
477:         {
478:             debug!("Inheriting env var: {}={}", key, value);
479:             cmd.env(&key, &value);
480:         }
481:     }
482:     
483:     // Log proxy-related environment variables for debugging
484:     info!("Command will use proxy settings:");
485:     if let Ok(http_proxy) = std::env::var("HTTP_PROXY") {
486:         info!("  HTTP_PROXY={}", http_proxy);
487:     }
488:     if let Ok(https_proxy) = std::env::var("HTTPS_PROXY") {
489:         info!("  HTTPS_PROXY={}", https_proxy);
490:     }
491: 
492:     // Add NVM support if the program is in an NVM directory
493:     if program.contains("/.nvm/versions/node/") {
494:         if let Some(node_bin_dir) = std::path::Path::new(program).parent() {
495:             // Ensure the Node.js bin directory is in PATH
496:             let current_path = std::env::var("PATH").unwrap_or_default();
497:             let node_bin_str = node_bin_dir.to_string_lossy();
498:             if !current_path.contains(&node_bin_str.as_ref()) {
499:                 let new_path = format!("{}:{}", node_bin_str, current_path);
500:                 debug!("Adding NVM bin directory to PATH: {}", node_bin_str);
501:                 cmd.env("PATH", new_path);
502:             }
503:         }
504:     }
505: 
506:     cmd
507: }
````

## File: src-tauri/src/lib.rs
````rust
 1: // Learn more about Tauri commands at https://tauri.app/develop/calling-rust/
 2: 
 3: // Declare modules
 4: pub mod checkpoint;
 5: pub mod claude_binary;
 6: pub mod commands;
 7: pub mod process;
 8: 
 9: #[cfg_attr(mobile, tauri::mobile_entry_point)]
10: pub fn run() {
11:     tauri::Builder::default()
12:         .run(tauri::generate_context!())
13:         .expect("error while running tauri application");
14: }
````

## File: src-tauri/src/main.rs
````rust
  1: // Prevents additional console window on Windows in release, DO NOT REMOVE!!
  2: #![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]
  3: 
  4: mod checkpoint;
  5: mod claude_binary;
  6: mod commands;
  7: mod process;
  8: 
  9: use checkpoint::state::CheckpointState;
 10: use commands::agents::{
 11:     cleanup_finished_processes, create_agent, delete_agent, execute_agent, export_agent,
 12:     export_agent_to_file, fetch_github_agent_content, fetch_github_agents, get_agent,
 13:     get_agent_run, get_agent_run_with_real_time_metrics, get_claude_binary_path,
 14:     get_live_session_output, get_session_output, get_session_status, import_agent,
 15:     import_agent_from_file, import_agent_from_github, init_database, kill_agent_session,
 16:     list_agent_runs, list_agent_runs_with_metrics, list_agents, list_claude_installations,
 17:     list_running_sessions, load_agent_session_history, set_claude_binary_path, stream_session_output, update_agent, AgentDb,
 18: };
 19: use commands::claude::{
 20:     cancel_claude_execution, check_auto_checkpoint, check_claude_version, cleanup_old_checkpoints,
 21:     clear_checkpoint_manager, continue_claude_code, create_checkpoint, execute_claude_code,
 22:     find_claude_md_files, fork_from_checkpoint, get_checkpoint_diff, get_checkpoint_settings,
 23:     get_checkpoint_state_stats, get_claude_session_output, get_claude_settings, get_project_sessions,
 24:     get_recently_modified_files, get_session_timeline, get_system_prompt, list_checkpoints,
 25:     list_directory_contents, list_projects, list_running_claude_sessions, load_session_history,
 26:     open_new_session, read_claude_md_file, restore_checkpoint, resume_claude_code,
 27:     save_claude_md_file, save_claude_settings, save_system_prompt, search_files,
 28:     track_checkpoint_message, track_session_messages, update_checkpoint_settings,
 29:     get_hooks_config, update_hooks_config, validate_hook_command,
 30:     ClaudeProcessState,
 31: };
 32: use commands::mcp::{
 33:     mcp_add, mcp_add_from_claude_desktop, mcp_add_json, mcp_get, mcp_get_server_status, mcp_list,
 34:     mcp_read_project_config, mcp_remove, mcp_reset_project_choices, mcp_save_project_config,
 35:     mcp_serve, mcp_test_connection,
 36: };
 37: 
 38: use commands::usage::{
 39:     get_session_stats, get_usage_by_date_range, get_usage_details, get_usage_stats,
 40: };
 41: use commands::storage::{
 42:     storage_list_tables, storage_read_table, storage_update_row, storage_delete_row,
 43:     storage_insert_row, storage_execute_sql, storage_reset_database,
 44: };
 45: use commands::proxy::{get_proxy_settings, save_proxy_settings, apply_proxy_settings};
 46: use process::ProcessRegistryState;
 47: use std::sync::Mutex;
 48: use tauri::Manager;
 49: 
 50: fn main() {
 51:     // Initialize logger
 52:     env_logger::init();
 53: 
 54: 
 55:     tauri::Builder::default()
 56:         .plugin(tauri_plugin_dialog::init())
 57:         .plugin(tauri_plugin_shell::init())
 58:         .setup(|app| {
 59:             // Initialize agents database
 60:             let conn = init_database(&app.handle()).expect("Failed to initialize agents database");
 61:             
 62:             // Load and apply proxy settings from the database
 63:             {
 64:                 let db = AgentDb(Mutex::new(conn));
 65:                 let proxy_settings = match db.0.lock() {
 66:                     Ok(conn) => {
 67:                         // Directly query proxy settings from the database
 68:                         let mut settings = commands::proxy::ProxySettings::default();
 69:                         
 70:                         let keys = vec![
 71:                             ("proxy_enabled", "enabled"),
 72:                             ("proxy_http", "http_proxy"),
 73:                             ("proxy_https", "https_proxy"),
 74:                             ("proxy_no", "no_proxy"),
 75:                             ("proxy_all", "all_proxy"),
 76:                         ];
 77:                         
 78:                         for (db_key, field) in keys {
 79:                             if let Ok(value) = conn.query_row(
 80:                                 "SELECT value FROM app_settings WHERE key = ?1",
 81:                                 rusqlite::params![db_key],
 82:                                 |row| row.get::<_, String>(0),
 83:                             ) {
 84:                                 match field {
 85:                                     "enabled" => settings.enabled = value == "true",
 86:                                     "http_proxy" => settings.http_proxy = Some(value).filter(|s| !s.is_empty()),
 87:                                     "https_proxy" => settings.https_proxy = Some(value).filter(|s| !s.is_empty()),
 88:                                     "no_proxy" => settings.no_proxy = Some(value).filter(|s| !s.is_empty()),
 89:                                     "all_proxy" => settings.all_proxy = Some(value).filter(|s| !s.is_empty()),
 90:                                     _ => {}
 91:                                 }
 92:                             }
 93:                         }
 94:                         
 95:                         log::info!("Loaded proxy settings: enabled={}", settings.enabled);
 96:                         settings
 97:                     }
 98:                     Err(e) => {
 99:                         log::warn!("Failed to lock database for proxy settings: {}", e);
100:                         commands::proxy::ProxySettings::default()
101:                     }
102:                 };
103:                 
104:                 // Apply the proxy settings
105:                 apply_proxy_settings(&proxy_settings);
106:             }
107:             
108:             // Re-open the connection for the app to manage
109:             let conn = init_database(&app.handle()).expect("Failed to initialize agents database");
110:             app.manage(AgentDb(Mutex::new(conn)));
111: 
112:             // Initialize checkpoint state
113:             let checkpoint_state = CheckpointState::new();
114: 
115:             // Set the Claude directory path
116:             if let Ok(claude_dir) = dirs::home_dir()
117:                 .ok_or_else(|| "Could not find home directory")
118:                 .and_then(|home| {
119:                     let claude_path = home.join(".claude");
120:                     claude_path
121:                         .canonicalize()
122:                         .map_err(|_| "Could not find ~/.claude directory")
123:                 })
124:             {
125:                 let state_clone = checkpoint_state.clone();
126:                 tauri::async_runtime::spawn(async move {
127:                     state_clone.set_claude_dir(claude_dir).await;
128:                 });
129:             }
130: 
131:             app.manage(checkpoint_state);
132: 
133:             // Initialize process registry
134:             app.manage(ProcessRegistryState::default());
135: 
136:             // Initialize Claude process state
137:             app.manage(ClaudeProcessState::default());
138: 
139:             Ok(())
140:         })
141:         .invoke_handler(tauri::generate_handler![
142:             // Claude & Project Management
143:             list_projects,
144:             get_project_sessions,
145:             get_claude_settings,
146:             open_new_session,
147:             get_system_prompt,
148:             check_claude_version,
149:             save_system_prompt,
150:             save_claude_settings,
151:             find_claude_md_files,
152:             read_claude_md_file,
153:             save_claude_md_file,
154:             load_session_history,
155:             execute_claude_code,
156:             continue_claude_code,
157:             resume_claude_code,
158:             cancel_claude_execution,
159:             list_running_claude_sessions,
160:             get_claude_session_output,
161:             list_directory_contents,
162:             search_files,
163:             get_recently_modified_files,
164:             get_hooks_config,
165:             update_hooks_config,
166:             validate_hook_command,
167:             
168:             // Checkpoint Management
169:             create_checkpoint,
170:             restore_checkpoint,
171:             list_checkpoints,
172:             fork_from_checkpoint,
173:             get_session_timeline,
174:             update_checkpoint_settings,
175:             get_checkpoint_diff,
176:             track_checkpoint_message,
177:             track_session_messages,
178:             check_auto_checkpoint,
179:             cleanup_old_checkpoints,
180:             get_checkpoint_settings,
181:             clear_checkpoint_manager,
182:             get_checkpoint_state_stats,
183:             
184:             // Agent Management
185:             list_agents,
186:             create_agent,
187:             update_agent,
188:             delete_agent,
189:             get_agent,
190:             execute_agent,
191:             list_agent_runs,
192:             get_agent_run,
193:             list_agent_runs_with_metrics,
194:             get_agent_run_with_real_time_metrics,
195:             list_running_sessions,
196:             kill_agent_session,
197:             get_session_status,
198:             cleanup_finished_processes,
199:             get_session_output,
200:             get_live_session_output,
201:             stream_session_output,
202:             load_agent_session_history,
203:             get_claude_binary_path,
204:             set_claude_binary_path,
205:             list_claude_installations,
206:             export_agent,
207:             export_agent_to_file,
208:             import_agent,
209:             import_agent_from_file,
210:             fetch_github_agents,
211:             fetch_github_agent_content,
212:             import_agent_from_github,
213:             
214:             // Usage & Analytics
215:             get_usage_stats,
216:             get_usage_by_date_range,
217:             get_usage_details,
218:             get_session_stats,
219:             
220:             // MCP (Model Context Protocol)
221:             mcp_add,
222:             mcp_list,
223:             mcp_get,
224:             mcp_remove,
225:             mcp_add_json,
226:             mcp_add_from_claude_desktop,
227:             mcp_serve,
228:             mcp_test_connection,
229:             mcp_reset_project_choices,
230:             mcp_get_server_status,
231:             mcp_read_project_config,
232:             mcp_save_project_config,
233:             
234:             // Storage Management
235:             storage_list_tables,
236:             storage_read_table,
237:             storage_update_row,
238:             storage_delete_row,
239:             storage_insert_row,
240:             storage_execute_sql,
241:             storage_reset_database,
242:             
243:             // Slash Commands
244:             commands::slash_commands::slash_commands_list,
245:             commands::slash_commands::slash_command_get,
246:             commands::slash_commands::slash_command_save,
247:             commands::slash_commands::slash_command_delete,
248:             
249:             // Proxy Settings
250:             get_proxy_settings,
251:             save_proxy_settings,
252:         ])
253:         .run(tauri::generate_context!())
254:         .expect("error while running tauri application");
255: }
````

## File: src-tauri/tests/TESTS_COMPLETE.md
````markdown
 1: # Test Suite - Complete with Real Claude ✅
 2: 
 3: ## Final Status: All Tests Passing with Real Claude Commands
 4: 
 5: ### Key Changes from Original Task:
 6: 
 7: 1. **Replaced MockClaude with Real Claude Execution** ✅
 8:    - Removed all mock Claude implementations
 9:    - Tests now execute actual `claude` command with `--dangerously-skip-permissions`
10:    - Added proper timeout handling for macOS/Linux compatibility
11: 
12: 2. **Real Claude Test Implementation** ✅
13:    - Created `claude_real.rs` with helper functions for executing real Claude
14:    - Tests use actual Claude CLI with test prompts
15:    - Proper handling of stdout/stderr/exit codes
16: 
17: 3. **Test Suite Results:**
18: ```
19: test result: ok. 58 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
20: ```
21: 
22: ### Implementation Details:
23: 
24: #### Real Claude Execution:
25: - `execute_claude_task()` - Executes Claude with specified task and captures output
26: - Supports timeout handling (gtimeout on macOS, timeout on Linux)
27: - Returns structured output with stdout, stderr, exit code, and duration
28: - Helper methods for checking operation results
29: 
30: #### Test Tasks:
31: - Simple, focused prompts that execute quickly
32: - Example: "Read the file ./test.txt in the current directory and show its contents"
33: - 20-second timeout to allow Claude sufficient time to respond
34: 
35: #### Key Test Updates:
36: 1. **Agent Tests**:
37:    - Test agent execution with various permission configurations
38:    - Test agent execution in different project contexts
39:    - Control tests for baseline behavior
40: 
41: 2. **Claude Tests**:
42:    - Test Claude execution with default settings
43:    - Test Claude execution with custom configurations
44: 
45: ### Benefits of Real Claude Testing:
46: - **Authenticity**: Tests validate actual Claude behavior, not mocked responses
47: - **Integration**: Ensures the system works with real Claude execution
48: - **End-to-End**: Complete validation from command invocation to output parsing
49: - **No External Dependencies**: Uses `--dangerously-skip-permissions` flag
50: 
51: ### Notes:
52: - All tests use real Claude CLI commands
53: - No ignored tests
54: - No TODOs in test code
55: - Clean compilation with no warnings
56: - Platform-aware expectations for different operating systems
57: 
58: The test suite now provides comprehensive end-to-end validation with actual Claude execution.
````

## File: src-tauri/.gitignore
````
1: # Generated by Cargo
2: # will have compiled files and executables
3: /target/
4: 
5: # Generated by Tauri
6: # will have schema files for capabilities auto-completion
7: /gen/schemas
````

## File: src-tauri/build.rs
````rust
1: fn main() {
2:     tauri_build::build()
3: }
````

## File: src-tauri/Cargo.toml
````toml
 1: [package]
 2: name = "claudia"
 3: version = "0.1.0"
 4: description = "GUI app and Toolkit for Claude Code"
 5: authors = ["mufeedvh", "123vviekr"]
 6: license = "AGPL-3.0"
 7: edition = "2021"
 8: 
 9: # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
10: 
11: [[bin]]
12: name = "claudia"
13: path = "src/main.rs"
14: 
15: [lib]
16: name = "claudia_lib"
17: crate-type = ["lib", "cdylib", "staticlib"]
18: 
19: [build-dependencies]
20: tauri-build = { version = "2", features = [] }
21: 
22: [dependencies]
23: tauri = { version = "2", features = ["protocol-asset", "tray-icon", "image-png"] }
24: tauri-plugin-shell = "2"
25: tauri-plugin-dialog = "2"
26: tauri-plugin-fs = "2"
27: tauri-plugin-process = "2"
28: tauri-plugin-updater = "2"
29: tauri-plugin-notification = "2"
30: tauri-plugin-clipboard-manager = "2"
31: tauri-plugin-global-shortcut = "2"
32: tauri-plugin-http = "2"
33: serde = { version = "1", features = ["derive"] }
34: serde_json = "1"
35: tokio = { version = "1", features = ["full"] }
36: rusqlite = { version = "0.32", features = ["bundled"] }
37: dirs = "5"
38: chrono = { version = "0.4", features = ["serde"] }
39: anyhow = "1"
40: log = "0.4"
41: env_logger = "0.11"
42: regex = "1"
43: glob = "0.3"
44: base64 = "0.22"
45: libc = "0.2"
46: reqwest = { version = "0.12", features = ["json", "native-tls-vendored"] }
47: futures = "0.3"
48: async-trait = "0.1"
49: tempfile = "3"
50: which = "7"
51: sha2 = "0.10"
52: zstd = "0.13"
53: uuid = { version = "1.6", features = ["v4", "serde"] }
54: walkdir = "2"
55: serde_yaml = "0.9"
56: 
57: 
58: [target.'cfg(target_os = "macos")'.dependencies]
59: cocoa = "0.26"
60: objc = "0.2"
61: 
62: [features]
63: # This feature is used for production builds or when a dev server is not specified, DO NOT REMOVE!!
64: custom-protocol = ["tauri/custom-protocol"]
65: 
66: [profile.release]
67: strip = true
68: opt-level = "z"
69: lto = true
70: codegen-units = 1
````

## File: src-tauri/entitlements.plist
````
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 3: <plist version="1.0">
 4: <dict>
 5:     <!-- Allow app to be run from Homebrew installation -->
 6:     <key>com.apple.security.app-sandbox</key>
 7:     <false/>
 8:     
 9:     <!-- Network access for Claude API and other services -->
10:     <key>com.apple.security.network.client</key>
11:     <true/>
12:     <key>com.apple.security.network.server</key>
13:     <true/>
14:     
15:     <!-- File system access -->
16:     <key>com.apple.security.files.user-selected.read-write</key>
17:     <true/>
18:     <key>com.apple.security.files.downloads.read-write</key>
19:     <true/>
20:     
21:     <!-- Allow spawning subprocesses (needed for shell commands) -->
22:     <key>com.apple.security.inherit</key>
23:     <true/>
24:     
25:     <!-- Allow automation for Apple Events -->
26:     <key>com.apple.security.automation.apple-events</key>
27:     <true/>
28:     
29:     <!-- Camera and microphone if needed -->
30:     <key>com.apple.security.device.camera</key>
31:     <true/>
32:     <key>com.apple.security.device.microphone</key>
33:     <true/>
34:     
35:     <!-- Printing -->
36:     <key>com.apple.security.print</key>
37:     <true/>
38:     
39:     <!-- Required for Hardened Runtime -->
40:     <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
41:     <true/>
42:     <key>com.apple.security.cs.allow-jit</key>
43:     <true/>
44:     <key>com.apple.security.cs.disable-library-validation</key>
45:     <true/>
46:     <key>com.apple.security.cs.disable-executable-page-protection</key>
47:     <true/>
48: </dict>
49: </plist>
````

## File: src-tauri/Info.plist
````
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 3: <plist version="1.0">
 4: <dict>
 5:   <key>NSRequiresAquaSystemAppearance</key>
 6:   <false/>
 7:   <key>LSMinimumSystemVersion</key>
 8:   <string>10.15</string>
 9:   <key>CFBundleShortVersionString</key>
10:   <string>0.1.0</string>
11:   <key>CFBundleName</key>
12:   <string>Claudia</string>
13:   <key>CFBundleDisplayName</key>
14:   <string>Claudia</string>
15:   <key>CFBundleIdentifier</key>
16:   <string>claudia.asterisk.so</string>
17:   <key>CFBundleDocumentTypes</key>
18:   <array>
19:     <dict>
20:       <key>CFBundleTypeName</key>
21:       <string>Claudia Agent</string>
22:       <key>CFBundleTypeRole</key>
23:       <string>Editor</string>
24:       <key>CFBundleTypeExtensions</key>
25:       <array>
26:         <string>claudia.json</string>
27:       </array>
28:       <key>CFBundleTypeIconFile</key>
29:       <string>icon.icns</string>
30:       <key>LSHandlerRank</key>
31:       <string>Owner</string>
32:     </dict>
33:   </array>
34:   <key>NSAppleEventsUsageDescription</key>
35:   <string>Claudia needs to send Apple Events to other applications.</string>
36:   <key>NSAppleScriptEnabled</key>
37:   <true/>
38:   <key>NSCameraUsageDescription</key>
39:   <string>Claudia needs camera access for capturing images for AI processing.</string>
40:   <key>NSMicrophoneUsageDescription</key>
41:   <string>Claudia needs microphone access for voice input features.</string>
42: </dict>
43: </plist>
````

## File: src-tauri/tauri.conf.json
````json
 1: {
 2:   "$schema": "https://schema.tauri.app/config/2",
 3:   "productName": "Claudia",
 4:   "version": "0.1.0",
 5:   "identifier": "claudia.asterisk.so",
 6:   "build": {
 7:     "beforeDevCommand": "bun run dev",
 8:     "devUrl": "http://localhost:1420",
 9:     "beforeBuildCommand": "bun run build",
10:     "frontendDist": "../dist"
11:   },
12:   "app": {
13:     "windows": [
14:       {
15:         "title": "Claudia",
16:         "width": 800,
17:         "height": 600
18:       }
19:     ],
20:     "security": {
21:       "csp": "default-src 'self'; img-src 'self' asset: https://asset.localhost blob: data:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-eval' https://app.posthog.com https://*.posthog.com https://*.i.posthog.com https://*.assets.i.posthog.com; connect-src 'self' ipc: https://ipc.localhost https://app.posthog.com https://*.posthog.com https://*.i.posthog.com",
22:       "assetProtocol": {
23:         "enable": true,
24:         "scope": [
25:           "**"
26:         ]
27:       }
28:     }
29:   },
30:   "plugins": {
31:     "fs": {
32:       "scope": [
33:         "$HOME/**"
34:       ],
35:       "allow": [
36:         "readFile",
37:         "writeFile",
38:         "readDir",
39:         "copyFile",
40:         "createDir",
41:         "removeDir",
42:         "removeFile",
43:         "renameFile",
44:         "exists"
45:       ]
46:     },
47:     "shell": {
48:       "open": true
49:     }
50:   },
51:   "bundle": {
52:     "active": true,
53:     "targets": [
54:       "deb",
55:       "rpm",
56:       "appimage",
57:       "app",
58:       "dmg"
59:     ],
60:     "icon": [
61:       "icons/32x32.png",
62:       "icons/128x128.png",
63:       "icons/128x128@2x.png",
64:       "icons/icon.icns"
65:     ],
66:     "resources": [],
67:     "externalBin": [],
68:     "copyright": "© 2025 Asterisk. All rights reserved.",
69:     "category": "DeveloperTool",
70:     "shortDescription": "GUI app and Toolkit for Claude Code",
71:     "longDescription": "Claudia is a comprehensive GUI application and toolkit for working with Claude Code, providing an intuitive interface for AI-assisted development.",
72:     "linux": {
73:       "appimage": {
74:         "bundleMediaFramework": true
75:       },
76:       "deb": {
77:         "depends": ["libwebkit2gtk-4.1-0", "libgtk-3-0"]
78:       }
79:     },
80:     "macOS": {
81:       "frameworks": [],
82:       "minimumSystemVersion": "10.15",
83:       "exceptionDomain": "",
84:       "signingIdentity": null,
85:       "providerShortName": null,
86:       "entitlements": "entitlements.plist"
87:     }
88:   }
89: }
````

## File: .gitignore
````
 1: # Logs
 2: logs
 3: *.log
 4: npm-debug.log*
 5: yarn-debug.log*
 6: yarn-error.log*
 7: pnpm-debug.log*
 8: lerna-debug.log*
 9: 
10: node_modules
11: dist
12: dist-ssr
13: *.local
14: *.bun-build
15: 
16: # Tauri binaries (built executables)
17: src-tauri/binaries/
18: 
19: # Editor directories and files
20: .vscode/*
21: !.vscode/extensions.json
22: .idea
23: .DS_Store
24: *.suo
25: *.ntvs*
26: *.njsproj
27: *.sln
28: *.sw?
29: temp_lib/
30: 
31: .cursor/
32: AGENTS.md
33: CLAUDE.md
34: *_TASK.md
35: 
36: # Claude project-specific files
37: .claude/
38: 
39: .env
````

## File: CONTRIBUTING.md
````markdown
 1: # Welcome Contributors
 2: 
 3: We welcome contributions to enhance Claudia's capabilities and improve its performance. To report bugs, create a [GitHub issue](https://github.com/getAsterisk/claudia/issues).
 4: 
 5: > Before contributing, read through the existing issues and pull requests to see if someone else is already working on something similar. That way you can avoid duplicating efforts.
 6: 
 7: To contribute, please follow these steps:
 8: 
 9: 1. Fork the Claudia repository on GitHub.
10: 2. Create a new branch for your feature or bug fix.
11: 3. Make your changes and ensure that the code passes all tests.
12: 4. Submit a pull request describing your changes and their benefits.
13: 
14: ## Pull Request Guidelines
15: 
16: When submitting a pull request, please follow these guidelines:
17: 
18: 1. **Title**: Please include following prefixes:
19:    - `Feature:` for new features
20:    - `Fix:` for bug fixes
21:    - `Docs:` for documentation changes
22:    - `Refactor:` for code refactoring
23:    - `Improve:` for performance improvements
24:    - `Other:` for other changes
25: 
26:    For example:
27:    - `Feature: added custom agent timeout configuration`
28:    - `Fix: resolved session list scrolling issue`
29: 
30: 2. **Description**: Provide a clear and detailed description of your changes in the pull request. Explain the problem you are solving, the approach you took, and any potential side effects or limitations of your changes.
31: 
32: 3. **Documentation**: Update the relevant documentation to reflect your changes. This includes the README file, code comments, and any other relevant documentation.
33: 
34: 4. **Dependencies**: If your changes require new dependencies, ensure that they are properly documented and added to the `package.json` or `Cargo.toml` files.
35: 
36: 5. If the pull request does not meet the above guidelines, it may be closed without merging.
37: 
38: **Note**: Please ensure that you have the latest version of the code before creating a pull request. If you have an existing fork, just sync your fork with the latest version of the Claudia repository.
39: 
40: ## Coding Standards
41: 
42: ### Frontend (React/TypeScript)
43: - Use TypeScript for all new code
44: - Follow functional components with hooks
45: - Use Tailwind CSS for styling
46: - Add JSDoc comments for exported functions and components
47: 
48: ### Backend (Rust)
49: - Follow Rust standard conventions
50: - Use `cargo fmt` for formatting
51: - Use `cargo clippy` for linting
52: - Handle all `Result` types explicitly
53: - Add comprehensive documentation with `///` comments
54: 
55: ### Security Requirements
56: - Validate all inputs from the frontend
57: - Use prepared statements for database operations
58: - Never log sensitive data (tokens, passwords, etc.)
59: - Use secure defaults for all configurations
60: 
61: ## Testing
62: - Add tests for new functionality
63: - Ensure all existing tests pass
64: - Run `cargo test` for Rust code
65: - Test the application manually before submitting
66: 
67: Please adhere to the coding conventions, maintain clear documentation, and provide thorough testing for your contributions.
````

## File: index.html
````html
 1: <!doctype html>
 2: <html lang="en" class="dark">
 3:   <head>
 4:     <meta charset="UTF-8" />
 5:     <link rel="icon" type="image/svg+xml" href="/vite.svg" />
 6:     <meta name="viewport" content="width=device-width, initial-scale=1.0" />
 7:     <meta name="color-scheme" content="dark" />
 8:     <title>Claudia - Claude Code Session Browser</title>
 9:   </head>
10: 
11:   <body>
12:     <div id="root"></div>
13:     <script type="module" src="/src/main.tsx"></script>
14:   </body>
15: </html>
````

## File: LICENSE
````
  1: GNU AFFERO GENERAL PUBLIC LICENSE
  2:                        Version 3, 19 November 2007
  3: 
  4:  Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
  5:  Everyone is permitted to copy and distribute verbatim copies
  6:  of this license document, but changing it is not allowed.
  7: 
  8:                             Preamble
  9: 
 10:   The GNU Affero General Public License is a free, copyleft license for
 11: software and other kinds of works, specifically designed to ensure
 12: cooperation with the community in the case of network server software.
 13: 
 14:   The licenses for most software and other practical works are designed
 15: to take away your freedom to share and change the works.  By contrast,
 16: our General Public Licenses are intended to guarantee your freedom to
 17: share and change all versions of a program--to make sure it remains free
 18: software for all its users.
 19: 
 20:   When we speak of free software, we are referring to freedom, not
 21: price.  Our General Public Licenses are designed to make sure that you
 22: have the freedom to distribute copies of free software (and charge for
 23: them if you wish), that you receive source code or can get it if you
 24: want it, that you can change the software or use pieces of it in new
 25: free programs, and that you know you can do these things.
 26: 
 27:   Developers that use our General Public Licenses protect your rights
 28: with two steps: (1) assert copyright on the software, and (2) offer
 29: you this License which gives you legal permission to copy, distribute
 30: and/or modify the software.
 31: 
 32:   A secondary benefit of defending all users' freedom is that
 33: improvements made in alternate versions of the program, if they
 34: receive widespread use, become available for other developers to
 35: incorporate.  Many developers of free software are heartened and
 36: encouraged by the resulting cooperation.  However, in the case of
 37: software used on network servers, this result may fail to come about.
 38: The GNU General Public License permits making a modified version and
 39: letting the public access it on a server without ever releasing its
 40: source code to the public.
 41: 
 42:   The GNU Affero General Public License is designed specifically to
 43: ensure that, in such cases, the modified source code becomes available
 44: to the community.  It requires the operator of a network server to
 45: provide the source code of the modified version running there to the
 46: users of that server.  Therefore, public use of a modified version, on
 47: a publicly accessible server, gives the public access to the source
 48: code of the modified version.
 49: 
 50:   An older license, called the Affero General Public License and
 51: published by Affero, was designed to accomplish similar goals.  This is
 52: a different license, not a version of the Affero GPL, but Affero has
 53: released a new version of the Affero GPL which permits relicensing under
 54: this license.
 55: 
 56:   The precise terms and conditions for copying, distribution and
 57: modification follow.
 58: 
 59:                        TERMS AND CONDITIONS
 60: 
 61:   0. Definitions.
 62: 
 63:   "This License" refers to version 3 of the GNU Affero General Public License.
 64: 
 65:   "Copyright" also means copyright-like laws that apply to other kinds of
 66: works, such as semiconductor masks.
 67: 
 68:   "The Program" refers to any copyrightable work licensed under this
 69: License.  Each licensee is addressed as "you".  "Licensees" and
 70: "recipients" may be individuals or organizations.
 71: 
 72:   To "modify" a work means to copy from or adapt all or part of the work
 73: in a fashion requiring copyright permission, other than the making of an
 74: exact copy.  The resulting work is called a "modified version" of the
 75: earlier work or a work "based on" the earlier work.
 76: 
 77:   A "covered work" means either the unmodified Program or a work based
 78: on the Program.
 79: 
 80:   To "propagate" a work means to do anything with it that, without
 81: permission, would make you directly or secondarily liable for
 82: infringement under applicable copyright law, except executing it on a
 83: computer or modifying a private copy.  Propagation includes copying,
 84: distribution (with or without modification), making available to the
 85: public, and in some countries other activities as well.
 86: 
 87:   To "convey" a work means any kind of propagation that enables other
 88: parties to make or receive copies.  Mere interaction with a user through
 89: a computer network, with no transfer of a copy, is not conveying.
 90: 
 91:   An interactive user interface displays "Appropriate Legal Notices"
 92: to the extent that it includes a convenient and prominently visible
 93: feature that (1) displays an appropriate copyright notice, and (2)
 94: tells the user that there is no warranty for the work (except to the
 95: extent that warranties are provided), that licensees may convey the
 96: work under this License, and how to view a copy of this License.  If
 97: the interface presents a list of user commands or options, such as a
 98: menu, a prominent item in the list meets this criterion.
 99: 
100:   1. Source Code.
101: 
102:   The "source code" for a work means the preferred form of the work
103: for making modifications to it.  "Object code" means any non-source
104: form of a work.
105: 
106:   A "Standard Interface" means an interface that either is an official
107: standard defined by a recognized standards body, or, in the case of
108: interfaces specified for a particular programming language, one that
109: is widely used among developers working in that language.
110: 
111:   The "System Libraries" of an executable work include anything, other
112: than the work as a whole, that (a) is included in the normal form of
113: packaging a Major Component, but which is not part of that Major
114: Component, and (b) serves only to enable use of the work with that
115: Major Component, or to implement a Standard Interface for which an
116: implementation is available to the public in source code form.  A
117: "Major Component", in this context, means a major essential component
118: (kernel, window system, and so on) of the specific operating system
119: (if any) on which the executable work runs, or a compiler used to
120: produce the work, or an object code interpreter used to run it.
121: 
122:   The "Corresponding Source" for a work in object code form means all
123: the source code needed to generate, install, and (for an executable
124: work) run the object code and to modify the work, including scripts to
125: control those activities.  However, it does not include the work's
126: System Libraries, or general-purpose tools or generally available free
127: programs which are used unmodified in performing those activities but
128: which are not part of the work.  For example, Corresponding Source
129: includes interface definition files associated with source files for
130: the work, and the source code for shared libraries and dynamically
131: linked subprograms that the work is specifically designed to require,
132: such as by intimate data communication or control flow between those
133: subprograms and other parts of the work.
134: 
135:   The Corresponding Source need not include anything that users
136: can regenerate automatically from other parts of the Corresponding
137: Source.
138: 
139:   The Corresponding Source for a work in source code form is that
140: same work.
141: 
142:   2. Basic Permissions.
143: 
144:   All rights granted under this License are granted for the term of
145: copyright on the Program, and are irrevocable provided the stated
146: conditions are met.  This License explicitly affirms your unlimited
147: permission to run the unmodified Program.  The output from running a
148: covered work is covered by this License only if the output, given its
149: content, constitutes a covered work.  This License acknowledges your
150: rights of fair use or other equivalent, as provided by copyright law.
151: 
152:   You may make, run and propagate covered works that you do not
153: convey, without conditions so long as your license otherwise remains
154: in force.  You may convey covered works to others for the sole purpose
155: of having them make modifications exclusively for you, or provide you
156: with facilities for running those works, provided that you comply with
157: the terms of this License in conveying all material for which you do
158: not control copyright.  Those thus making or running the covered works
159: for you must do so exclusively on your behalf, under your direction
160: and control, on terms that prohibit them from making any copies of
161: your copyrighted material outside their relationship with you.
162: 
163:   Conveying under any other circumstances is permitted solely under
164: the conditions stated below.  Sublicensing is not allowed; section 10
165: makes it unnecessary.
166: 
167:   3. Protecting Users' Legal Rights From Anti-Circumvention Law.
168: 
169:   No covered work shall be deemed part of an effective technological
170: measure under any applicable law fulfilling obligations under article
171: 11 of the WIPO copyright treaty adopted on 20 December 1996, or
172: similar laws prohibiting or restricting circumvention of such
173: measures.
174: 
175:   When you convey a covered work, you waive any legal power to forbid
176: circumvention of technological measures to the extent such circumvention
177: is effected by exercising rights under this License with respect to
178: the covered work, and you disclaim any intention to limit operation or
179: modification of the work as a means of enforcing, against the work's
180: users, your or third parties' legal rights to forbid circumvention of
181: technological measures.
182: 
183:   4. Conveying Verbatim Copies.
184: 
185:   You may convey verbatim copies of the Program's source code as you
186: receive it, in any medium, provided that you conspicuously and
187: appropriately publish on each copy an appropriate copyright notice;
188: keep intact all notices stating that this License and any
189: non-permissive terms added in accord with section 7 apply to the code;
190: keep intact all notices of the absence of any warranty; and give all
191: recipients a copy of this License along with the Program.
192: 
193:   You may charge any price or no price for each copy that you convey,
194: and you may offer support or warranty protection for a fee.
195: 
196:   5. Conveying Modified Source Versions.
197: 
198:   You may convey a work based on the Program, or the modifications to
199: produce it from the Program, in the form of source code under the
200: terms of section 4, provided that you also meet all of these conditions:
201: 
202:     a) The work must carry prominent notices stating that you modified
203:     it, and giving a relevant date.
204: 
205:     b) The work must carry prominent notices stating that it is
206:     released under this License and any conditions added under section
207:     7.  This requirement modifies the requirement in section 4 to
208:     "keep intact all notices".
209: 
210:     c) You must license the entire work, as a whole, under this
211:     License to anyone who comes into possession of a copy.  This
212:     License will therefore apply, along with any applicable section 7
213:     additional terms, to the whole of the work, and all its parts,
214:     regardless of how they are packaged.  This License gives no
215:     permission to license the work in any other way, but it does not
216:     invalidate such permission if you have separately received it.
217: 
218:     d) If the work has interactive user interfaces, each must display
219:     Appropriate Legal Notices; however, if the Program has interactive
220:     interfaces that do not display Appropriate Legal Notices, your
221:     work need not make them do so.
222: 
223:   A compilation of a covered work with other separate and independent
224: works, which are not by their nature extensions of the covered work,
225: and which are not combined with it such as to form a larger program,
226: in or on a volume of a storage or distribution medium, is called an
227: "aggregate" if the compilation and its resulting copyright are not
228: used to limit the access or legal rights of the compilation's users
229: beyond what the individual works permit.  Inclusion of a covered work
230: in an aggregate does not cause this License to apply to the other
231: parts of the aggregate.
232: 
233:   6. Conveying Non-Source Forms.
234: 
235:   You may convey a covered work in object code form under the terms
236: of sections 4 and 5, provided that you also convey the
237: machine-readable Corresponding Source under the terms of this License,
238: in one of these ways:
239: 
240:     a) Convey the object code in, or embodied in, a physical product
241:     (including a physical distribution medium), accompanied by the
242:     Corresponding Source fixed on a durable physical medium
243:     customarily used for software interchange.
244: 
245:     b) Convey the object code in, or embodied in, a physical product
246:     (including a physical distribution medium), accompanied by a
247:     written offer, valid for at least three years and valid for as
248:     long as you offer spare parts or customer support for that product
249:     model, to give anyone who possesses the object code either (1) a
250:     copy of the Corresponding Source for all the software in the
251:     product that is covered by this License, on a durable physical
252:     medium customarily used for software interchange, for a price no
253:     more than your reasonable cost of physically performing this
254:     conveying of source, or (2) access to copy the
255:     Corresponding Source from a network server at no charge.
256: 
257:     c) Convey individual copies of the object code with a copy of the
258:     written offer to provide the Corresponding Source.  This
259:     alternative is allowed only occasionally and noncommercially, and
260:     only if you received the object code with such an offer, in accord
261:     with subsection 6b.
262: 
263:     d) Convey the object code by offering access from a designated
264:     place (gratis or for a charge), and offer equivalent access to the
265:     Corresponding Source in the same way through the same place at no
266:     further charge.  You need not require recipients to copy the
267:     Corresponding Source along with the object code.  If the place to
268:     copy the object code is a network server, the Corresponding Source
269:     may be on a different server (operated by you or a third party)
270:     that supports equivalent copying facilities, provided you maintain
271:     clear directions next to the object code saying where to find the
272:     Corresponding Source.  Regardless of what server hosts the
273:     Corresponding Source, you remain obligated to ensure that it is
274:     available for as long as needed to satisfy these requirements.
275: 
276:     e) Convey the object code using peer-to-peer transmission, provided
277:     you inform other peers where the object code and Corresponding
278:     Source of the work are being offered to the general public at no
279:     charge under subsection 6d.
280: 
281:   A separable portion of the object code, whose source code is excluded
282: from the Corresponding Source as a System Library, need not be
283: included in conveying the object code work.
284: 
285:   A "User Product" is either (1) a "consumer product", which means any
286: tangible personal property which is normally used for personal, family,
287: or household purposes, or (2) anything designed or sold for incorporation
288: into a dwelling.  In determining whether a product is a consumer product,
289: doubtful cases shall be resolved in favor of coverage.  For a particular
290: product received by a particular user, "normally used" refers to a
291: typical or common use of that class of product, regardless of the status
292: of the particular user or of the way in which the particular user
293: actually uses, or expects or is expected to use, the product.  A product
294: is a consumer product regardless of whether the product has substantial
295: commercial, industrial or non-consumer uses, unless such uses represent
296: the only significant mode of use of the product.
297: 
298:   "Installation Information" for a User Product means any methods,
299: procedures, authorization keys, or other information required to install
300: and execute modified versions of a covered work in that User Product from
301: a modified version of its Corresponding Source.  The information must
302: suffice to ensure that the continued functioning of the modified object
303: code is in no case prevented or interfered with solely because
304: modification has been made.
305: 
306:   If you convey an object code work under this section in, or with, or
307: specifically for use in, a User Product, and the conveying occurs as
308: part of a transaction in which the right of possession and use of the
309: User Product is transferred to the recipient in perpetuity or for a
310: fixed term (regardless of how the transaction is characterized), the
311: Corresponding Source conveyed under this section must be accompanied
312: by the Installation Information.  But this requirement does not apply
313: if neither you nor any third party retains the ability to install
314: modified object code on the User Product (for example, the work has
315: been installed in ROM).
316: 
317:   The requirement to provide Installation Information does not include a
318: requirement to continue to provide support service, warranty, or updates
319: for a work that has been modified or installed by the recipient, or for
320: the User Product in which it has been modified or installed.  Access to a
321: network may be denied when the modification itself materially and
322: adversely affects the operation of the network or violates the rules and
323: protocols for communication across the network.
324: 
325:   Corresponding Source conveyed, and Installation Information provided,
326: in accord with this section must be in a format that is publicly
327: documented (and with an implementation available to the public in
328: source code form), and must require no special password or key for
329: unpacking, reading or copying.
330: 
331:   7. Additional Terms.
332: 
333:   "Additional permissions" are terms that supplement the terms of this
334: License by making exceptions from one or more of its conditions.
335: Additional permissions that are applicable to the entire Program shall
336: be treated as though they were included in this License, to the extent
337: that they are valid under applicable law.  If additional permissions
338: apply only to part of the Program, that part may be used separately
339: under those permissions, but the entire Program remains governed by
340: this License without regard to the additional permissions.
341: 
342:   When you convey a copy of a covered work, you may at your option
343: remove any additional permissions from that copy, or from any part of
344: it.  (Additional permissions may be written to require their own
345: removal in certain cases when you modify the work.)  You may place
346: additional permissions on material, added by you to a covered work,
347: for which you have or can give appropriate copyright permission.
348: 
349:   Notwithstanding any other provision of this License, for material you
350: add to a covered work, you may (if authorized by the copyright holders of
351: that material) supplement the terms of this License with terms:
352: 
353:     a) Disclaiming warranty or limiting liability differently from the
354:     terms of sections 15 and 16 of this License; or
355: 
356:     b) Requiring preservation of specified reasonable legal notices or
357:     author attributions in that material or in the Appropriate Legal
358:     Notices displayed by works containing it; or
359: 
360:     c) Prohibiting misrepresentation of the origin of that material, or
361:     requiring that modified versions of such material be marked in
362:     reasonable ways as different from the original version; or
363: 
364:     d) Limiting the use for publicity purposes of names of licensors or
365:     authors of the material; or
366: 
367:     e) Declining to grant rights under trademark law for use of some
368:     trade names, trademarks, or service marks; or
369: 
370:     f) Requiring indemnification of licensors and authors of that
371:     material by anyone who conveys the material (or modified versions of
372:     it) with contractual assumptions of liability to the recipient, for
373:     any liability that these contractual assumptions directly impose on
374:     those licensors and authors.
375: 
376:   All other non-permissive additional terms are considered "further
377: restrictions" within the meaning of section 10.  If the Program as you
378: received it, or any part of it, contains a notice stating that it is
379: governed by this License along with a term that is a further
380: restriction, you may remove that term.  If a license document contains
381: a further restriction but permits relicensing or conveying under this
382: License, you may add to a covered work material governed by the terms
383: of that license document, provided that the further restriction does
384: not survive such relicensing or conveying.
385: 
386:   If you add terms to a covered work in accord with this section, you
387: must place, in the relevant source files, a statement of the
388: additional terms that apply to those files, or a notice indicating
389: where to find the applicable terms.
390: 
391:   Additional terms, permissive or non-permissive, may be stated in the
392: form of a separately written license, or stated as exceptions;
393: the above requirements apply either way.
394: 
395:   8. Termination.
396: 
397:   You may not propagate or modify a covered work except as expressly
398: provided under this License.  Any attempt otherwise to propagate or
399: modify it is void, and will automatically terminate your rights under
400: this License (including any patent licenses granted under the third
401: paragraph of section 11).
402: 
403:   However, if you cease all violation of this License, then your
404: license from a particular copyright holder is reinstated (a)
405: provisionally, unless and until the copyright holder explicitly and
406: finally terminates your license, and (b) permanently, if the copyright
407: holder fails to notify you of the violation by some reasonable means
408: prior to 60 days after the cessation.
409: 
410:   Moreover, your license from a particular copyright holder is
411: reinstated permanently if the copyright holder notifies you of the
412: violation by some reasonable means, this is the first time you have
413: received notice of violation of this License (for any work) from that
414: copyright holder, and you cure the violation prior to 30 days after
415: your receipt of the notice.
416: 
417:   Termination of your rights under this section does not terminate the
418: licenses of parties who have received copies or rights from you under
419: this License.  If your rights have been terminated and not permanently
420: reinstated, you do not qualify to receive new licenses for the same
421: material under section 10.
422: 
423:   9. Acceptance Not Required for Having Copies.
424: 
425:   You are not required to accept this License in order to receive or
426: run a copy of the Program.  Ancillary propagation of a covered work
427: occurring solely as a consequence of using peer-to-peer transmission
428: to receive a copy likewise does not require acceptance.  However,
429: nothing other than this License grants you permission to propagate or
430: modify any covered work.  These actions infringe copyright if you do
431: not accept this License.  Therefore, by modifying or propagating a
432: covered work, you indicate your acceptance of this License to do so.
433: 
434:   10. Automatic Licensing of Downstream Recipients.
435: 
436:   Each time you convey a covered work, the recipient automatically
437: receives a license from the original licensors, to run, modify and
438: propagate that work, subject to this License.  You are not responsible
439: for enforcing compliance by third parties with this License.
440: 
441:   An "entity transaction" is a transaction transferring control of an
442: organization, or substantially all assets of one, or subdividing an
443: organization, or merging organizations.  If propagation of a covered
444: work results from an entity transaction, each party to that
445: transaction who receives a copy of the work also receives whatever
446: licenses to the work the party's predecessor in interest had or could
447: give under the previous paragraph, plus a right to possession of the
448: Corresponding Source of the work from the predecessor in interest, if
449: the predecessor has it or can get it with reasonable efforts.
450: 
451:   You may not impose any further restrictions on the exercise of the
452: rights granted or affirmed under this License.  For example, you may
453: not impose a license fee, royalty, or other charge for exercise of
454: rights granted under this License, and you may not initiate litigation
455: (including a cross-claim or counterclaim in a lawsuit) alleging that
456: any patent claim is infringed by making, using, selling, offering for
457: sale, or importing the Program or any portion of it.
458: 
459:   11. Patents.
460: 
461:   A "contributor" is a copyright holder who authorizes use under this
462: License of the Program or a work on which the Program is based.  The
463: work thus licensed is called the contributor's "contributor version".
464: 
465:   A contributor's "essential patent claims" are all patent claims
466: owned or controlled by the contributor, whether already acquired or
467: hereafter acquired, that would be infringed by some manner, permitted
468: by this License, of making, using, or selling its contributor version,
469: but do not include claims that would be infringed only as a
470: consequence of further modification of the contributor version.  For
471: purposes of this definition, "control" includes the right to grant
472: patent sublicenses in a manner consistent with the requirements of
473: this License.
474: 
475:   Each contributor grants you a non-exclusive, worldwide, royalty-free
476: patent license under the contributor's essential patent claims, to
477: make, use, sell, offer for sale, import and otherwise run, modify and
478: propagate the contents of its contributor version.
479: 
480:   In the following three paragraphs, a "patent license" is any express
481: agreement or commitment, however denominated, not to enforce a patent
482: (such as an express permission to practice a patent or covenant not to
483: sue for patent infringement).  To "grant" such a patent license to a
484: party means to make such an agreement or commitment not to enforce a
485: patent against the party.
486: 
487:   If you convey a covered work, knowingly relying on a patent license,
488: and the Corresponding Source of the work is not available for anyone
489: to copy, free of charge and under the terms of this License, through a
490: publicly available network server or other readily accessible means,
491: then you must either (1) cause the Corresponding Source to be so
492: available, or (2) arrange to deprive yourself of the benefit of the
493: patent license for this particular work, or (3) arrange, in a manner
494: consistent with the requirements of this License, to extend the patent
495: license to downstream recipients.  "Knowingly relying" means you have
496: actual knowledge that, but for the patent license, your conveying the
497: covered work in a country, or your recipient's use of the covered work
498: in a country, would infringe one or more identifiable patents in that
499: country that you have reason to believe are valid.
500: 
501:   If, pursuant to or in connection with a single transaction or
502: arrangement, you convey, or propagate by procuring conveyance of, a
503: covered work, and grant a patent license to some of the parties
504: receiving the covered work authorizing them to use, propagate, modify
505: or convey a specific copy of the covered work, then the patent license
506: you grant is automatically extended to all recipients of the covered
507: work and works based on it.
508: 
509:   A patent license is "discriminatory" if it does not include within
510: the scope of its coverage, prohibits the exercise of, or is
511: conditioned on the non-exercise of one or more of the rights that are
512: specifically granted under this License.  You may not convey a covered
513: work if you are a party to an arrangement with a third party that is
514: in the business of distributing software, under which you make payment
515: to the third party based on the extent of your activity of conveying
516: the work, and under which the third party grants, to any of the
517: parties who would receive the covered work from you, a discriminatory
518: patent license (a) in connection with copies of the covered work
519: conveyed by you (or copies made from those copies), or (b) primarily
520: for and in connection with specific products or compilations that
521: contain the covered work, unless you entered into that arrangement,
522: or that patent license was granted, prior to 28 March 2007.
523: 
524:   Nothing in this License shall be construed as excluding or limiting
525: any implied license or other defenses to infringement that may
526: otherwise be available to you under applicable patent law.
527: 
528:   12. No Surrender of Others' Freedom.
529: 
530:   If conditions are imposed on you (whether by court order, agreement or
531: otherwise) that contradict the conditions of this License, they do not
532: excuse you from the conditions of this License.  If you cannot convey a
533: covered work so as to satisfy simultaneously your obligations under this
534: License and any other pertinent obligations, then as a consequence you may
535: not convey it at all.  For example, if you agree to terms that obligate you
536: to collect a royalty for further conveying from those to whom you convey
537: the Program, the only way you could satisfy both those terms and this
538: License would be to refrain entirely from conveying the Program.
539: 
540:   13. Remote Network Interaction; Use with the GNU General Public License.
541: 
542:   Notwithstanding any other provision of this License, if you modify the
543: Program, your modified version must prominently offer all users
544: interacting with it remotely through a computer network (if your version
545: supports such interaction) an opportunity to receive the Corresponding
546: Source of your version by providing access to the Corresponding Source
547: from a network server at no charge, through some standard or customary
548: means of facilitating copying of software.  This Corresponding Source
549: shall include the Corresponding Source for any work covered by version 3
550: of the GNU General Public License that is incorporated pursuant to the
551: following paragraph.
552: 
553:   Notwithstanding any other provision of this License, you have
554: permission to link or combine any covered work with a work licensed
555: under version 3 of the GNU General Public License into a single
556: combined work, and to convey the resulting work.  The terms of this
557: License will continue to apply to the part which is the covered work,
558: but the work with which it is combined will remain governed by version
559: 3 of the GNU General Public License.
560: 
561:   14. Revised Versions of this License.
562: 
563:   The Free Software Foundation may publish revised and/or new versions of
564: the GNU Affero General Public License from time to time.  Such new versions
565: will be similar in spirit to the present version, but may differ in detail to
566: address new problems or concerns.
567: 
568:   Each version is given a distinguishing version number.  If the
569: Program specifies that a certain numbered version of the GNU Affero General
570: Public License "or any later version" applies to it, you have the
571: option of following the terms and conditions either of that numbered
572: version or of any later version published by the Free Software
573: Foundation.  If the Program does not specify a version number of the
574: GNU Affero General Public License, you may choose any version ever published
575: by the Free Software Foundation.
576: 
577:   If the Program specifies that a proxy can decide which future
578: versions of the GNU Affero General Public License can be used, that proxy's
579: public statement of acceptance of a version permanently authorizes you
580: to choose that version for the Program.
581: 
582:   Later license versions may give you additional or different
583: permissions.  However, no additional obligations are imposed on any
584: author or copyright holder as a result of your choosing to follow a
585: later version.
586: 
587:   15. Disclaimer of Warranty.
588: 
589:   THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
590: APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
591: HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
592: OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
593: THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
594: PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
595: IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
596: ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
597: 
598:   16. Limitation of Liability.
599: 
600:   IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
601: WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
602: THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
603: GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
604: USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
605: DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
606: PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
607: EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
608: SUCH DAMAGES.
609: 
610:   17. Interpretation of Sections 15 and 16.
611: 
612:   If the disclaimer of warranty and limitation of liability provided
613: above cannot be given local legal effect according to their terms,
614: reviewing courts shall apply local law that most closely approximates
615: an absolute waiver of all civil liability in connection with the
616: Program, unless a warranty or assumption of liability accompanies a
617: copy of the Program in return for a fee.
618: 
619:                      END OF TERMS AND CONDITIONS
620: 
621:             How to Apply These Terms to Your New Programs
622: 
623:   If you develop a new program, and you want it to be of the greatest
624: possible use to the public, the best way to achieve this is to make it
625: free software which everyone can redistribute and change under these terms.
626: 
627:   To do so, attach the following notices to the program.  It is safest
628: to attach them to the start of each source file to most effectively
629: state the exclusion of warranty; and each file should have at least
630: the "copyright" line and a pointer to where the full notice is found.
631: 
632:     <one line to give the program's name and a brief idea of what it does.>
633:     Copyright (C) <year>  <name of author>
634: 
635:     This program is free software: you can redistribute it and/or modify
636:     it under the terms of the GNU Affero General Public License as published
637:     by the Free Software Foundation, either version 3 of the License, or
638:     (at your option) any later version.
639: 
640:     This program is distributed in the hope that it will be useful,
641:     but WITHOUT ANY WARRANTY; without even the implied warranty of
642:     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
643:     GNU Affero General Public License for more details.
644: 
645:     You should have received a copy of the GNU Affero General Public License
646:     along with this program.  If not, see <https://www.gnu.org/licenses/>.
647: 
648: Also add information on how to contact you by electronic and paper mail.
649: 
650:   If your software can interact with users remotely through a computer
651: network, you should also make sure that it provides a way for users to
652: get its source.  For example, if your program is a web application, its
653: interface could display a "Source" link that leads users to an archive
654: of the code.  There are many ways you could offer source, and different
655: solutions will be better for different programs; see section 13 for the
656: specific requirements.
657: 
658:   You should also get your employer (if you work as a programmer) or school,
659: if any, to sign a "copyright disclaimer" for the program, if necessary.
660: For more information on this, and how to apply and follow the GNU AGPL, see
661: <https://www.gnu.org/licenses/>.
````

## File: package.json
````json
 1: {
 2:   "name": "claudia",
 3:   "private": true,
 4:   "version": "0.1.0",
 5:   "license": "AGPL-3.0",
 6:   "type": "module",
 7:   "scripts": {
 8:     "dev": "vite",
 9:     "build": "tsc && vite build",
10:     "preview": "vite preview",
11:     "tauri": "tauri",
12:     "check": "tsc --noEmit && cd src-tauri && cargo check"
13:   },
14:   "dependencies": {
15:     "@hookform/resolvers": "^3.9.1",
16:     "@radix-ui/react-dialog": "^1.1.4",
17:     "@radix-ui/react-dropdown-menu": "^2.1.15",
18:     "@radix-ui/react-label": "^2.1.1",
19:     "@radix-ui/react-popover": "^1.1.4",
20:     "@radix-ui/react-radio-group": "^1.3.7",
21:     "@radix-ui/react-select": "^2.1.3",
22:     "@radix-ui/react-switch": "^1.1.3",
23:     "@radix-ui/react-tabs": "^1.1.3",
24:     "@radix-ui/react-toast": "^1.2.3",
25:     "@radix-ui/react-tooltip": "^1.1.5",
26:     "@tailwindcss/cli": "^4.1.8",
27:     "@tailwindcss/vite": "^4.1.8",
28:     "@tanstack/react-virtual": "^3.13.10",
29:     "@tauri-apps/api": "^2.1.1",
30:     "@tauri-apps/plugin-dialog": "^2.0.2",
31:     "@tauri-apps/plugin-global-shortcut": "^2.0.0",
32:     "@tauri-apps/plugin-opener": "^2",
33:     "@tauri-apps/plugin-shell": "^2.0.1",
34:     "@types/diff": "^8.0.0",
35:     "@types/react-syntax-highlighter": "^15.5.13",
36:     "@uiw/react-md-editor": "^4.0.7",
37:     "ansi-to-html": "^0.7.2",
38:     "class-variance-authority": "^0.7.1",
39:     "clsx": "^2.1.1",
40:     "date-fns": "^3.6.0",
41:     "diff": "^8.0.2",
42:     "framer-motion": "^12.0.0-alpha.1",
43:     "html2canvas": "^1.4.1",
44:     "lucide-react": "^0.468.0",
45:     "posthog-js": "^1.258.3",
46:     "react": "^18.3.1",
47:     "react-dom": "^18.3.1",
48:     "react-hook-form": "^7.54.2",
49:     "react-markdown": "^9.0.3",
50:     "react-syntax-highlighter": "^15.6.1",
51:     "recharts": "^2.14.1",
52:     "remark-gfm": "^4.0.0",
53:     "tailwind-merge": "^2.6.0",
54:     "tailwindcss": "^4.1.8",
55:     "zod": "^3.24.1",
56:     "zustand": "^5.0.6"
57:   },
58:   "devDependencies": {
59:     "@tauri-apps/cli": "^2.7.1",
60:     "@types/node": "^22.15.30",
61:     "@types/react": "^18.3.1",
62:     "@types/react-dom": "^18.3.1",
63:     "@types/sharp": "^0.32.0",
64:     "@vitejs/plugin-react": "^4.3.4",
65:     "sharp": "^0.34.2",
66:     "typescript": "~5.6.2",
67:     "vite": "^6.0.3"
68:   },
69:   "trustedDependencies": [
70:     "@parcel/watcher",
71:     "@tailwindcss/oxide"
72:   ]
73: }
````

## File: README.md
````markdown
  1: <div align="center">
  2:   <img src="https://github.com/user-attachments/assets/92fd93ed-e71b-4b94-b270-50684323dd00" alt="Claudia Logo" width="120" height="120">
  3: 
  4:   <a href="https://claudiacode.com"><h1>Claudia</h1></a>
  5:   
  6:   <p>
  7:     <strong>A powerful GUI app and Toolkit for Claude Code</strong>
  8:   </p>
  9:   <p>
 10:     <strong>Create custom agents, manage interactive Claude Code sessions, run secure background agents, and more.</strong>
 11:   </p>
 12:   
 13:   <p>
 14:     <a href="#features"><img src="https://img.shields.io/badge/Features-✨-blue?style=for-the-badge" alt="Features"></a>
 15:     <a href="#installation"><img src="https://img.shields.io/badge/Install-🚀-green?style=for-the-badge" alt="Installation"></a>
 16:     <a href="#usage"><img src="https://img.shields.io/badge/Usage-📖-purple?style=for-the-badge" alt="Usage"></a>
 17:     <a href="#development"><img src="https://img.shields.io/badge/Develop-🛠️-orange?style=for-the-badge" alt="Development"></a>
 18:   </p>
 19: </div>
 20: 
 21: ![457013521-6133a738-d0cb-4d3e-8746-c6768c82672c](https://github.com/user-attachments/assets/a028de9e-d881-44d8-bae5-7326ab3558b9)
 22: 
 23: https://github.com/user-attachments/assets/bf0bdf9d-ba91-45af-9ac4-7274f57075cf
 24: 
 25: > [!TIP]
 26: > **⭐ Star the repo and follow [@getAsterisk](https://x.com/getAsterisk) on X for early access to `asteria-swe-v0`**.
 27: 
 28: ## 🌟 Overview
 29: 
 30: **Claudia** is a powerful desktop application that transforms how you interact with Claude Code. Built with Tauri 2, it provides a beautiful GUI for managing your Claude Code sessions, creating custom agents, tracking usage, and much more.
 31: 
 32: Think of Claudia as your command center for Claude Code - bridging the gap between the command-line tool and a visual experience that makes AI-assisted development more intuitive and productive.
 33: 
 34: ## 📋 Table of Contents
 35: 
 36: - [🌟 Overview](#-overview)
 37: - [✨ Features](#-features)
 38:   - [🗂️ Project & Session Management](#️-project--session-management)
 39:   - [🤖 CC Agents](#-cc-agents)
 40:   
 41:   - [📊 Usage Analytics Dashboard](#-usage-analytics-dashboard)
 42:   - [🔌 MCP Server Management](#-mcp-server-management)
 43:   - [⏰ Timeline & Checkpoints](#-timeline--checkpoints)
 44:   - [📝 CLAUDE.md Management](#-claudemd-management)
 45: - [📖 Usage](#-usage)
 46:   - [Getting Started](#getting-started)
 47:   - [Managing Projects](#managing-projects)
 48:   - [Creating Agents](#creating-agents)
 49:   - [Tracking Usage](#tracking-usage)
 50:   - [Working with MCP Servers](#working-with-mcp-servers)
 51: - [🚀 Installation](#-installation)
 52: - [🔨 Build from Source](#-build-from-source)
 53: - [🛠️ Development](#️-development)
 54: - [🔒 Security](#-security)
 55: - [🤝 Contributing](#-contributing)
 56: - [📄 License](#-license)
 57: - [🙏 Acknowledgments](#-acknowledgments)
 58: 
 59: ## ✨ Features
 60: 
 61: ### 🗂️ **Project & Session Management**
 62: - **Visual Project Browser**: Navigate through all your Claude Code projects in `~/.claude/projects/`
 63: - **Session History**: View and resume past coding sessions with full context
 64: - **Smart Search**: Find projects and sessions quickly with built-in search
 65: - **Session Insights**: See first messages, timestamps, and session metadata at a glance
 66: 
 67: ### 🤖 **CC Agents**
 68: - **Custom AI Agents**: Create specialized agents with custom system prompts and behaviors
 69: - **Agent Library**: Build a collection of purpose-built agents for different tasks
 70: - **Background Execution**: Run agents in separate processes for non-blocking operations
 71: - **Execution History**: Track all agent runs with detailed logs and performance metrics
 72: 
 73: 
 74: 
 75: ### 📊 **Usage Analytics Dashboard**
 76: - **Cost Tracking**: Monitor your Claude API usage and costs in real-time
 77: - **Token Analytics**: Detailed breakdown by model, project, and time period
 78: - **Visual Charts**: Beautiful charts showing usage trends and patterns
 79: - **Export Data**: Export usage data for accounting and analysis
 80: 
 81: ### 🔌 **MCP Server Management**
 82: - **Server Registry**: Manage Model Context Protocol servers from a central UI
 83: - **Easy Configuration**: Add servers via UI or import from existing configs
 84: - **Connection Testing**: Verify server connectivity before use
 85: - **Claude Desktop Import**: Import server configurations from Claude Desktop
 86: 
 87: ### ⏰ **Timeline & Checkpoints**
 88: - **Session Versioning**: Create checkpoints at any point in your coding session
 89: - **Visual Timeline**: Navigate through your session history with a branching timeline
 90: - **Instant Restore**: Jump back to any checkpoint with one click
 91: - **Fork Sessions**: Create new branches from existing checkpoints
 92: - **Diff Viewer**: See exactly what changed between checkpoints
 93: 
 94: ### 📝 **CLAUDE.md Management**
 95: - **Built-in Editor**: Edit CLAUDE.md files directly within the app
 96: - **Live Preview**: See your markdown rendered in real-time
 97: - **Project Scanner**: Find all CLAUDE.md files in your projects
 98: - **Syntax Highlighting**: Full markdown support with syntax highlighting
 99: 
100: ## 📖 Usage
101: 
102: ### Getting Started
103: 
104: 1. **Launch Claudia**: Open the application after installation
105: 2. **Welcome Screen**: Choose between CC Agents or CC Projects
106: 3. **First Time Setup**: Claudia will automatically detect your `~/.claude` directory
107: 
108: ### Managing Projects
109: 
110: ```
111: CC Projects → Select Project → View Sessions → Resume or Start New
112: ```
113: 
114: - Click on any project to view its sessions
115: - Each session shows the first message and timestamp
116: - Resume sessions directly or start new ones
117: 
118: ### Creating Agents
119: 
120: ```
121: CC Agents → Create Agent → Configure → Execute
122: ```
123: 
124: 1. **Design Your Agent**: Set name, icon, and system prompt
125: 2. **Configure Model**: Choose between available Claude models
126: 3. **Set Permissions**: Configure file read/write and network access
127: 4. **Execute Tasks**: Run your agent on any project
128: 
129: ### Tracking Usage
130: 
131: ```
132: Menu → Usage Dashboard → View Analytics
133: ```
134: 
135: - Monitor costs by model, project, and date
136: - Export data for reports
137: - Set up usage alerts (coming soon)
138: 
139: ### Working with MCP Servers
140: 
141: ```
142: Menu → MCP Manager → Add Server → Configure
143: ```
144: 
145: - Add servers manually or via JSON
146: - Import from Claude Desktop configuration
147: - Test connections before using
148: 
149: ## 🚀 Installation
150: 
151: ### Prerequisites
152: 
153: - **Claude Code CLI**: Install from [Claude's official site](https://claude.ai/code)
154: 
155: ### Release Executables Will Be Published Soon
156: 
157: ## 🔨 Build from Source
158: 
159: ### Prerequisites
160: 
161: Before building Claudia from source, ensure you have the following installed:
162: 
163: #### System Requirements
164: 
165: - **Operating System**: Windows 10/11, macOS 11+, or Linux (Ubuntu 20.04+)
166: - **RAM**: Minimum 4GB (8GB recommended)
167: - **Storage**: At least 1GB free space
168: 
169: #### Required Tools
170: 
171: 1. **Rust** (1.70.0 or later)
172:    ```bash
173:    # Install via rustup
174:    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
175:    ```
176: 
177: 2. **Bun** (latest version)
178:    ```bash
179:    # Install bun
180:    curl -fsSL https://bun.sh/install | bash
181:    ```
182: 
183: 3. **Git**
184:    ```bash
185:    # Usually pre-installed, but if not:
186:    # Ubuntu/Debian: sudo apt install git
187:    # macOS: brew install git
188:    # Windows: Download from https://git-scm.com
189:    ```
190: 
191: 4. **Claude Code CLI**
192:    - Download and install from [Claude's official site](https://claude.ai/code)
193:    - Ensure `claude` is available in your PATH
194: 
195: #### Platform-Specific Dependencies
196: 
197: **Linux (Ubuntu/Debian)**
198: ```bash
199: # Install system dependencies
200: sudo apt update
201: sudo apt install -y \
202:   libwebkit2gtk-4.1-dev \
203:   libgtk-3-dev \
204:   libayatana-appindicator3-dev \
205:   librsvg2-dev \
206:   patchelf \
207:   build-essential \
208:   curl \
209:   wget \
210:   file \
211:   libssl-dev \
212:   libxdo-dev \
213:   libsoup-3.0-dev \
214:   libjavascriptcoregtk-4.1-dev
215: ```
216: 
217: **macOS**
218: ```bash
219: # Install Xcode Command Line Tools
220: xcode-select --install
221: 
222: # Install additional dependencies via Homebrew (optional)
223: brew install pkg-config
224: ```
225: 
226: **Windows**
227: - Install [Microsoft C++ Build Tools](https://visualstudio.microsoft.com/visual-cpp-build-tools/)
228: - Install [WebView2](https://developer.microsoft.com/microsoft-edge/webview2/) (usually pre-installed on Windows 11)
229: 
230: ### Build Steps
231: 
232: 1. **Clone the Repository**
233:    ```bash
234:    git clone https://github.com/getAsterisk/claudia.git
235:    cd claudia
236:    ```
237: 
238: 2. **Install Frontend Dependencies**
239:    ```bash
240:    bun install
241:    ```
242: 
243: 3. **Build the Application**
244:    
245:    **For Development (with hot reload)**
246:    ```bash
247:    bun run tauri dev
248:    ```
249:    
250:    **For Production Build**
251:    ```bash
252:    # Build the application
253:    bun run tauri build
254:    
255:    # The built executable will be in:
256:    # - Linux: src-tauri/target/release/
257:    # - macOS: src-tauri/target/release/
258:    # - Windows: src-tauri/target/release/
259:    ```
260: 
261: 4. **Platform-Specific Build Options**
262:    
263:    **Debug Build (faster compilation, larger binary)**
264:    ```bash
265:    bun run tauri build --debug
266:    ```
267:    
268:    **Universal Binary for macOS (Intel + Apple Silicon)**
269:    ```bash
270:    bun run tauri build --target universal-apple-darwin
271:    ```
272: 
273: ### Troubleshooting
274: 
275: #### Common Issues
276: 
277: 1. **"cargo not found" error**
278:    - Ensure Rust is installed and `~/.cargo/bin` is in your PATH
279:    - Run `source ~/.cargo/env` or restart your terminal
280: 
281: 2. **Linux: "webkit2gtk not found" error**
282:    - Install the webkit2gtk development packages listed above
283:    - On newer Ubuntu versions, you might need `libwebkit2gtk-4.0-dev`
284: 
285: 3. **Windows: "MSVC not found" error**
286:    - Install Visual Studio Build Tools with C++ support
287:    - Restart your terminal after installation
288: 
289: 4. **"claude command not found" error**
290:    - Ensure Claude Code CLI is installed and in your PATH
291:    - Test with `claude --version`
292: 
293: 5. **Build fails with "out of memory"**
294:    - Try building with fewer parallel jobs: `cargo build -j 2`
295:    - Close other applications to free up RAM
296: 
297: #### Verify Your Build
298: 
299: After building, you can verify the application works:
300: 
301: ```bash
302: # Run the built executable directly
303: # Linux/macOS
304: ./src-tauri/target/release/claudia
305: 
306: # Windows
307: ./src-tauri/target/release/claudia.exe
308: ```
309: 
310: ### Build Artifacts
311: 
312: The build process creates several artifacts:
313: 
314: - **Executable**: The main Claudia application
315: - **Installers** (when using `tauri build`):
316:   - `.deb` package (Linux)
317:   - `.AppImage` (Linux)
318:   - `.dmg` installer (macOS)
319:   - `.msi` installer (Windows)
320:   - `.exe` installer (Windows)
321: 
322: All artifacts are located in `src-tauri/target/release/`.
323: 
324: ## 🛠️ Development
325: 
326: ### Tech Stack
327: 
328: - **Frontend**: React 18 + TypeScript + Vite 6
329: - **Backend**: Rust with Tauri 2
330: - **UI Framework**: Tailwind CSS v4 + shadcn/ui
331: - **Database**: SQLite (via rusqlite)
332: - **Package Manager**: Bun
333: 
334: ### Project Structure
335: 
336: ```
337: claudia/
338: ├── src/                   # React frontend
339: │   ├── components/        # UI components
340: │   ├── lib/               # API client & utilities
341: │   └── assets/            # Static assets
342: ├── src-tauri/             # Rust backend
343: │   ├── src/
344: │   │   ├── commands/      # Tauri command handlers
345: │   │   ├── checkpoint/    # Timeline management
346: │   │   └── process/       # Process management
347: │   └── tests/             # Rust test suite
348: └── public/                # Public assets
349: ```
350: 
351: ### Development Commands
352: 
353: ```bash
354: # Start development server
355: bun run tauri dev
356: 
357: # Run frontend only
358: bun run dev
359: 
360: # Type checking
361: bunx tsc --noEmit
362: 
363: # Run Rust tests
364: cd src-tauri && cargo test
365: 
366: # Format code
367: cd src-tauri && cargo fmt
368: ```
369: 
370: ## 🔒 Security
371: 
372: Claudia prioritizes your privacy and security:
373: 
374: 1. **Process Isolation**: Agents run in separate processes
375: 2. **Permission Control**: Configure file and network access per agent
376: 3. **Local Storage**: All data stays on your machine
377: 4. **No Telemetry**: No data collection or tracking
378: 5. **Open Source**: Full transparency through open source code
379: 
380: ## 🤝 Contributing
381: 
382: We welcome contributions! Please see our [Contributing Guide](CONTRIBUTING.md) for details.
383: 
384: ### Areas for Contribution
385: 
386: - 🐛 Bug fixes and improvements
387: - ✨ New features and enhancements
388: - 📚 Documentation improvements
389: - 🎨 UI/UX enhancements
390: - 🧪 Test coverage
391: - 🌐 Internationalization
392: 
393: ## 📄 License
394: 
395: This project is licensed under the AGPL License - see the [LICENSE](LICENSE) file for details.
396: 
397: ## 🙏 Acknowledgments
398: 
399: - Built with [Tauri](https://tauri.app/) - The secure framework for building desktop apps
400: - [Claude](https://claude.ai) by Anthropic
401: 
402: ---
403: 
404: <div align="center">
405:   <p>
406:     <strong>Made with ❤️ by the <a href="https://asterisk.so/">Asterisk</a></strong>
407:   </p>
408:   <p>
409:     <a href="https://github.com/getAsterisk/claudia/issues">Report Bug</a>
410:     ·
411:     <a href="https://github.com/getAsterisk/claudia/issues">Request Feature</a>
412:   </p>
413: </div>
414: 
415: 
416: ## Star History
417: 
418: [![Star History Chart](https://api.star-history.com/svg?repos=getAsterisk/claudia&type=Date)](https://www.star-history.com/#getAsterisk/claudia&Date)
````

## File: tsconfig.json
````json
 1: {
 2:   "compilerOptions": {
 3:     "target": "ES2020",
 4:     "useDefineForClassFields": true,
 5:     "lib": ["ES2020", "DOM", "DOM.Iterable"],
 6:     "module": "ESNext",
 7:     "skipLibCheck": true,
 8: 
 9:     /* Bundler mode */
10:     "moduleResolution": "bundler",
11:     "allowImportingTsExtensions": true,
12:     "resolveJsonModule": true,
13:     "isolatedModules": true,
14:     "noEmit": true,
15:     "jsx": "react-jsx",
16: 
17:     /* Linting */
18:     "strict": true,
19:     "noUnusedLocals": true,
20:     "noUnusedParameters": true,
21:     "noFallthroughCasesInSwitch": true,
22: 
23:     /* Path aliases */
24:     "baseUrl": ".",
25:     "paths": {
26:       "@/*": ["./src/*"]
27:     }
28:   },
29:   "include": ["src"],
30:   "references": [{ "path": "./tsconfig.node.json" }]
31: }
````

## File: tsconfig.node.json
````json
 1: {
 2:   "compilerOptions": {
 3:     "composite": true,
 4:     "skipLibCheck": true,
 5:     "module": "ESNext",
 6:     "moduleResolution": "bundler",
 7:     "allowSyntheticDefaultImports": true
 8:   },
 9:   "include": ["vite.config.ts"]
10: }
````

## File: vite.config.ts
````typescript
 1: import { defineConfig } from "vite";
 2: import react from "@vitejs/plugin-react";
 3: import tailwindcss from "@tailwindcss/vite";
 4: import { fileURLToPath, URL } from "node:url";
 5: 
 6: const host = process.env.TAURI_DEV_HOST;
 7: 
 8: // https://vitejs.dev/config/
 9: export default defineConfig(async () => ({
10:   plugins: [react(), tailwindcss()],
11: 
12:   // Path resolution
13:   resolve: {
14:     alias: {
15:       "@": fileURLToPath(new URL("./src", import.meta.url)),
16:     },
17:   },
18: 
19:   // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build`
20:   //
21:   // 1. prevent vite from obscuring rust errors
22:   clearScreen: false,
23:   // 2. tauri expects a fixed port, fail if that port is not available
24:   server: {
25:     port: 1420,
26:     strictPort: true,
27:     host: host || false,
28:     hmr: host
29:       ? {
30:           protocol: "ws",
31:           host,
32:           port: 1421,
33:         }
34:       : undefined,
35:     watch: {
36:       // 3. tell vite to ignore watching `src-tauri`
37:       ignored: ["**/src-tauri/**"],
38:     },
39:   },
40: 
41:   // Build configuration for code splitting
42:   build: {
43:     // Increase chunk size warning limit to 2000 KB
44:     chunkSizeWarningLimit: 2000,
45:     
46:     rollupOptions: {
47:       output: {
48:         // Manual chunks for better code splitting
49:         manualChunks: {
50:           // Vendor chunks
51:           'react-vendor': ['react', 'react-dom'],
52:           'ui-vendor': ['@radix-ui/react-dialog', '@radix-ui/react-dropdown-menu', '@radix-ui/react-select', '@radix-ui/react-tabs', '@radix-ui/react-tooltip', '@radix-ui/react-switch', '@radix-ui/react-popover'],
53:           'editor-vendor': ['@uiw/react-md-editor'],
54:           'syntax-vendor': ['react-syntax-highlighter'],
55:           // Tauri and other utilities
56:           'tauri': ['@tauri-apps/api', '@tauri-apps/plugin-dialog', '@tauri-apps/plugin-shell'],
57:           'utils': ['date-fns', 'clsx', 'tailwind-merge'],
58:         },
59:       },
60:     },
61:   },
62: }));
````
